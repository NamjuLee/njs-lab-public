{"version":3,"file":"static/js/6376.4abb916a.chunk.js","mappings":"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","sources":["njslab/Tools/Clustering/ClusteringCollisionBasedGraph/lib/index.ts","njslab/Tools/Clustering/ClusteringCollisionBasedGraph/Core/PointCluster.ts","njslab/Tools/Clustering/ClusteringCollisionBasedGraph/Core/Renderer.ts","njslab/Tools/Clustering/ClusteringCollisionBasedGraph/Core/GraphClustering.ts","njslab/Tools/Clustering/ClusteringCollisionBasedGraph/index.ts","njslab/Tools/Clustering/MapboxGLWrapper/index.ts","njslab/Tools/Clustering/index.ts"],"sourcesContent":["\nexport const AABBintersect2D = (v0: NVector3[], v1: NVector3[]): boolean => {\n    const v0minX = v0[0].x;\n    const v0maxX = v0[1].x;\n    const v1minX = v1[0].x;\n    const v1maxX = v1[1].x;\n    const v0minY = v0[0].y;\n    const v0maxY = v0[1].y;\n    const v1minY = v1[0].y;\n    const v1maxY = v1[1].y;\n    // const v0minZ = 0;\n    // const v0maxZ = 0;\n    // const v1minZ = 0;\n    // const v1maxZ = 0;\n    return (v0minX <= v1maxX && v0maxX >= v1minX) &&\n        (v0minY <= v1maxY && v0maxY >= v1minY); // &&\n    // (v0minZ <= v1maxZ && v0maxZ >= v1minZ);\n};\nexport const distance = (v0: NVector3, v1: NVector3): number => {\n    return Math.sqrt((v0.x - v1.x) * (v0.x - v1.x) + (v0.y - v1.y) * (v0.y - v1.y) + (v0.z - v1.z) * (v0.z - v1.z));\n    // return NWebassemblyController.ctrller.Distance(v0.x, v0.y, v0.z, v1.x, v1.y, v1.z);\n}\n\nexport class NVector3 {\n    public x: number = 0;\n    public y: number = 0;\n    public z: number = 0;\n    public lon: number = 0;\n    public lat: number = 0;\n    public elevation: number = 0;\n\n    public d: boolean = true;\n    public isRenderable: boolean = true;\n\n    constructor(x: number = 0, y: number = 0, z: number = 0) {\n        this.x = x;\n        this.y = y;\n        this.z = z;\n    }\n}\n\n\nexport class CPoint {\n    public vec: NVector3;\n    public id: string = '';\n    public numVisit: number = 0;\n\n    public isCollapse: boolean = false;\n\n    public isHidden: boolean = false;\n    public isRenderable: boolean = true;\n\n    public isSelected: boolean = false;\n    public isHover: boolean = false;\n    public collision: Collision;\n    constructor(x: number, y: number) {\n        this.vec = new NVector3(x, y, 0);\n        this.collision = new Collision(this);\n    }\n}\nexport class Collision {\n    base: CPoint;\n    isCollided: boolean = false;\n\n    neighborShapes: CPoint[] = [];\n\n    minVec: NVector3;\n    maxVec: NVector3;\n\n    isVisited: boolean = false;\n    numOrder: number = -1;\n\n    constructor(base: CPoint) {\n        this.base = base;\n        const r = 5;\n        this.minVec = new NVector3(this.base.vec.x - r, this.base.vec.y - r, 0);\n        this.maxVec = new NVector3(this.base.vec.x + r, this.base.vec.y + r, 0);\n    }\n    public Reset(){\n        this.neighborShapes = [];\n        this.numOrder = -1;\n        this.base.numVisit = 0;\n        this.base.isCollapse = false;\n        this.isCollided = false;\n        this.isVisited = false;\n    }\n}","\r\n// import { GeometryBase } from '../../../DrawingEngine/Geometry/Base';\r\n// import { GTYPE } from '../../../../../../../lib/Enumeration';\r\nimport { distance, NVector3, CPoint} from '../lib';\r\n// import { NVector3 } from '../../../../../../../lib/NVector3';\r\nimport { Renderer } from './Renderer';\r\n\r\nexport class PointCluster {\r\n    renderer: Renderer;\r\n    points: CPoint[];\r\n    r0: number = 32 * 0.5;\r\n    r1: number = 48 * 0.5;\r\n    isHover: boolean = false;\r\n    isVisited: boolean = false;\r\n    boundingBoxMin: NVector3 = new NVector3(Number.MAX_SAFE_INTEGER, Number.MAX_SAFE_INTEGER, Number.MAX_SAFE_INTEGER);\r\n    boundingBoxMax: NVector3 = new NVector3(Number.MIN_SAFE_INTEGER, Number.MIN_SAFE_INTEGER, Number.MIN_SAFE_INTEGER);\r\n    minVec: NVector3;\r\n    maxVec: NVector3;\r\n    vec = new NVector3(0, 0, 0);\r\n    private t: number = 1.0;\r\n    private GridResolution = 85;\r\n    private tempVecGridList: NVector3[] = [];\r\n    private tempGeoGridList: CPoint[][][] = [];\r\n\r\n    constructor(renderer: Renderer, geometries: CPoint[]) {\r\n        this.renderer = renderer;\r\n        this.points = geometries;\r\n        for(let i = 0; i < this.points.length; ++i) {\r\n            this.vec.x += this.points[i].vec.x;\r\n            this.vec.y += this.points[i].vec.y;\r\n            this.UpdateBoundingBox(this.points[i].vec);\r\n        }\r\n        this.vec.x /= this.points.length;\r\n        this.vec.y /= this.points.length;\r\n        this.minVec = new NVector3(this.vec.x - this.r1, this.vec.y - this.r1, 0);\r\n        this.maxVec = new NVector3(this.vec.x + this.r1, this.vec.y + this.r1, 0);\r\n        // for(let i = 0; i < this.geometries.length; ++i) {\r\n        // this.geometries[i].isAniEasing = true;\r\n        // this.geometries[i].tVec = this.vec;\r\n        // }\r\n    }\r\n    public IsInside(m: NVector3) {\r\n        if(distance(this.vec, m ) < this.r1) {\r\n            this.isHover = true;\r\n            // this.points[0].scene.annotationInstance.activeCommandController.activeMouseCursor.SetActiveCursorHovering();\r\n            // this.points[0].scene.annotationInstance.renderer.needFocus = true;\r\n            // this.points[0].scene.annotationInstance.activeCommandController.acProperties.hasHovering = true;\r\n            return true;\r\n        } else {\r\n            this.isHover = false;\r\n            return false;\r\n        }\r\n    }\r\n    public AddPost(geo: CPoint) {\r\n        // @ts-ignore\r\n        if(this.points.includes(geo)) { return; }\r\n        this.points.push(geo);\r\n        this.vec = new NVector3(0, 0, 0);\r\n        for(let i = 0; i < this.points.length; ++i) {\r\n        this.vec.x += this.points[i].vec.x;\r\n        this.vec.y += this.points[i].vec.y;\r\n        this.UpdateBoundingBox(this.points[i].vec);\r\n        }\r\n        this.vec.x /= this.points.length;\r\n        this.vec.y /= this.points.length;\r\n        this.minVec = new NVector3(this.vec.x - this.r1, this.vec.y - this.r1, 0);\r\n        this.maxVec = new NVector3(this.vec.x + this.r1, this.vec.y + this.r1, 0);\r\n    }\r\n    public NeedDecompose() {\r\n        if (this.boundingBoxMax.x - this.boundingBoxMin.x > this.GridResolution) { return true; }\r\n        if (this.boundingBoxMax.y - this.boundingBoxMin.y > this.GridResolution) { return true; }\r\n        return false;\r\n    }\r\n    public Split() {\r\n        this.DeepRemove();\r\n        const xNum = (this.boundingBoxMax.x - this.boundingBoxMin.x) / this.GridResolution < 1 ? 1: (this.boundingBoxMax.x - this.boundingBoxMin.x) / this.GridResolution;\r\n        const yNum = (this.boundingBoxMax.y - this.boundingBoxMin.y) / this.GridResolution < 1 ? 1: (this.boundingBoxMax.y - this.boundingBoxMin.y) / this.GridResolution;\r\n        const grid = this.buildGrid(xNum, yNum);\r\n        this.BuildSubCluster(grid, xNum, yNum);\r\n    }\r\n    public Merge(other: PointCluster){\r\n        this.points.concat(other.points);\r\n        this.vec = new NVector3(0, 0, 0);\r\n        for(let i = 0; i < this.points.length; ++i) {\r\n            this.vec.x += this.points[i].vec.x;\r\n            this.vec.y += this.points[i].vec.y;\r\n            this.UpdateBoundingBox(this.points[i].vec);\r\n        }\r\n        this.vec.x /= this.points.length;\r\n        this.vec.y /= this.points.length;\r\n        this.minVec = new NVector3(this.vec.x - this.r1, this.vec.y - this.r1, 0);\r\n        this.maxVec = new NVector3(this.vec.x + this.r1, this.vec.y + this.r1, 0);\r\n        other.DeepRemove();\r\n    }\r\n    public DeepRemove(){\r\n        this.renderer.RemoveCluster(this);\r\n    }\r\n    public buildGrid(xNum: number, yNum: number) {\r\n        this.tempGeoGridList = []\r\n        let gridList = [];;\r\n        for(let y = 0; y < yNum; ++y) {\r\n            const theY = this.boundingBoxMin.y + y * this.GridResolution;\r\n            const geoMat: CPoint[][] = [];\r\n            for(let x = 0; x < xNum; ++x) {\r\n                const theX = this.boundingBoxMin.x + x * this.GridResolution;\r\n                gridList.push(new NVector3(theX, theY));\r\n                const geoList: CPoint[]= [];\r\n                geoMat.push(geoList);\r\n            }\r\n            this.tempGeoGridList.push(geoMat);\r\n        }\r\n        this.tempVecGridList = gridList;\r\n        return gridList;\r\n    }\r\n    public BuildSubCluster(vs: NVector3[], xNum: number, yNum: number){\r\n        for(let i = 0 ; i < this.points.length; ++i) {\r\n            this.GetCellAtPoint(this.points[i].vec, xNum, yNum).push(this.points[i]);\r\n        }\r\n        for(let y = 0; y < this.tempGeoGridList.length; ++y) {\r\n            for(let x = 0; x < this.tempGeoGridList[y].length; ++x) {\r\n            if(this.tempGeoGridList[y][x]) {\r\n                if (this.tempGeoGridList[y][x].length === 1) {\r\n                    this.tempGeoGridList[y][x][0].collision.Reset();\r\n                } else if(this.tempGeoGridList[y][x].length > 1) {\r\n                    this.renderer.clustersRPoint.push(new PointCluster(this.renderer, this.tempGeoGridList[y][x]));\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    private GetCellAtPoint(tv: NVector3, xNum: number, yNum: number) {\r\n        let dp: NVector3 = new NVector3(tv.x - this.boundingBoxMin.x, tv.y - this.boundingBoxMin.y);\r\n        // let dp: NVector3 = new NVector3(this.boundingBoxMin.x - tv.x, this.boundingBoxMin.y - tv.y);\r\n        let i: number = Math.round(dp.x / this.GridResolution);\r\n        let j: number = Math.round(dp.y / this.GridResolution);\r\n        if (i >= xNum) { i = xNum - 1; }\r\n        if (j >= yNum) { j = yNum - 1; }\r\n        if (i < 0) { i = 0; }\r\n        if (j < 0) { j = 0; }\r\n        i = Math.round(i);\r\n        j = Math.round(j);\r\n        // console.log(j, i);\r\n        // console.log(this.tempGeoGridList)\r\n        return this.tempGeoGridList[j][i];\r\n    }\r\n    public Draw(ctx: CanvasRenderingContext2D, renderer: Renderer, isPanning: boolean, toScreen: (x: number, y: number) => number[]) {\r\n        this.UpdateTimeer();\r\n\r\n        if (isPanning) {\r\n            this.vec = new NVector3(0, 0, 0);\r\n            this.boundingBoxMin = new NVector3(Number.MAX_SAFE_INTEGER, Number.MAX_SAFE_INTEGER, Number.MAX_SAFE_INTEGER);\r\n            this.boundingBoxMax = new NVector3(Number.MIN_SAFE_INTEGER, Number.MIN_SAFE_INTEGER, Number.MIN_SAFE_INTEGER);\r\n            for(let i = 0; i < this.points.length; ++i) {\r\n                this.vec.x += this.points[i].vec.x;\r\n                this.vec.y += this.points[i].vec.y;\r\n                this.UpdateBoundingBox(this.points[i].vec);\r\n            }\r\n            this.vec.x /= this.points.length;\r\n            this.vec.y /= this.points.length;\r\n            this.minVec = new NVector3(this.vec.x - this.r1, this.vec.y - this.r1, 0);\r\n            this.maxVec = new NVector3(this.vec.x + this.r1, this.vec.y + this.r1, 0);\r\n            // this.vec.y -= this.r * 0.5 // offset the ghost center along y\r\n        }\r\n\r\n        drawingPresetClustering(ctx, this.points, this.vec, this.r0, this.r1, this.isHover, this.t);\r\n        \r\n        if(renderer.optimizer.inspection) {\r\n            ctx.beginPath();\r\n            ctx.rect(this.minVec.x, this.minVec.y, this.maxVec.x - this.minVec.x, this.maxVec.y - this.minVec.y)\r\n            ctx.closePath();\r\n            ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';\r\n            ctx.fill();\r\n            ctx.lineWidth = 0.5;\r\n            ctx.beginPath();\r\n            ctx.rect(this.boundingBoxMin.x, this.boundingBoxMin.y, this.boundingBoxMax.x - this.boundingBoxMin.x, this.boundingBoxMax.y - this.boundingBoxMin.y)\r\n            ctx.closePath();\r\n            ctx.stroke();\r\n            if (this.tempVecGridList.length > 0) {\r\n                for(let i = 0 ; i < this.tempVecGridList.length; ++i) {\r\n                    ctx.beginPath();\r\n                    ctx.rect(this.tempVecGridList[i].x, this.tempVecGridList[i].y, this.GridResolution, this.GridResolution);\r\n                    ctx.closePath();\r\n                    ctx.stroke();\r\n                }\r\n            }\r\n\r\n        }\r\n    }\r\n    private UpdateTimeer(){\r\n        if (true ) {\r\n            this.t -= 0.1; // this.points[0].scene.annotationInstance.customization.themeCurrent.properties.timeTransitionA;\r\n            this.t = this.t < 0.4 ? 0.4 : this.t;\r\n        } else {\r\n            this.t += 0.1; // this.points[0].scene.annotationInstance.customization.themeCurrent.properties.timeTransitionB;\r\n            this.t = this.t > 1 ? 1 : this.t;\r\n        }\r\n    }\r\n    private UpdateBoundingBox(vec: NVector3){\r\n        this.boundingBoxMin.x = vec.x < this.boundingBoxMin.x ? vec.x : this.boundingBoxMin.x;\r\n        this.boundingBoxMin.y = vec.y < this.boundingBoxMin.y ? vec.y : this.boundingBoxMin.y;\r\n        this.boundingBoxMax.x = vec.x > this.boundingBoxMax.x ? vec.x : this.boundingBoxMax.x;\r\n        this.boundingBoxMax.y = vec.y > this.boundingBoxMax.y ? vec.y : this.boundingBoxMax.y;\r\n    }\r\n}\r\n\r\n\r\nconst drawingPresetClustering = (\r\n    ctx: CanvasRenderingContext2D,\r\n    geometries: CPoint[],\r\n    vec: NVector3,\r\n    r0: number,\r\n    r1: number,\r\n    isHover: boolean,\r\n    t = 1\r\n  ) => {\r\n\r\n    const colorFillHover = '#f00'; \r\n    const fillColor = '#0f0'; //`rgba(${geometries[0].styleComponent.renderStyle.colorInterpolatedString})`\r\n\r\n    // if (renderer.optimizer.optimizer.optimizer.renderer.annotationInstance.implementations.app.INSPECTION) {\r\n    if (isHover) {\r\n      for (let i = 0; i < geometries.length; ++i) {\r\n        ctx.lineWidth = 0.6;\r\n        ctx.strokeStyle = '#f00' // geometries[0].styleComponent.renderStyle.colorFill;\r\n        ctx.beginPath();\r\n        ctx.moveTo(vec.x, vec.y);\r\n        ctx.lineTo(geometries[i].vec.x, geometries[i].vec.y);\r\n        ctx.closePath();\r\n        ctx.stroke();\r\n\r\n        // sub points\r\n        ctx.lineWidth = 1;\r\n        ctx.strokeStyle = 'rgba(255, 255, 255, 1)';\r\n        ctx.fillStyle = '#f00' //geometries[0].styleComponent.renderStyle.colorFill;\r\n        ctx.beginPath();\r\n        ctx.arc(geometries[i].vec.x, geometries[i].vec.y, 4, 0, Math.PI * 2);\r\n        ctx.closePath();\r\n        ctx.fill();\r\n        ctx.stroke();\r\n      }\r\n    }\r\n\r\n    // center point\r\n    if (isHover) {\r\n      ctx.fillStyle = '#f00' // geometries[0].styleComponent.renderStyle.colorFill;\r\n      ctx.beginPath();\r\n      ctx.arc(vec.x, vec.y, 1.5, 0, Math.PI * 2);\r\n      ctx.closePath();\r\n      ctx.fill();\r\n    } else {\r\n      // if(this.type === GTYPE.POINT_NUMBERED) {\r\n      //   ctx.fillStyle = 'rgba(0, 255, 0, 0.5)';\r\n      // } else if(this.type === GTYPE.POINT_REGULAR) {\r\n      //   ctx.fillStyle = 'rgba(255, 0, 0, 0.5)';\r\n      // }\r\n      ctx.beginPath();\r\n      ctx.arc(vec.x, vec.y, r1, 0, Math.PI * 2);\r\n      ctx.closePath();\r\n      ctx.fillStyle = colorFillHover;\r\n      ctx.fill();\r\n      ctx.beginPath();\r\n      ctx.arc(vec.x, vec.y, r0, 0, Math.PI * 2);\r\n      ctx.closePath();\r\n      ctx.fillStyle = fillColor;\r\n      ctx.fill();\r\n\r\n      ctx.fillStyle = `rgba(255, 255, 255, 1)`;\r\n      ctx.font = 'bold 11px Arial';\r\n      // ctx.font='bold 9px NotoSerif-Bold';\r\n      ctx.textAlign = 'center';\r\n      ctx.fillText(`${geometries.length}`, vec.x, vec.y + 4);\r\n    }\r\n  };","import { PointCluster } from './PointCluster';\r\nimport { CPoint } from '../lib';\r\nimport { ClusteringCollisionBasedGraph } from '../';\r\n\r\nexport class Renderer {\r\n\r\n    clustersRPoint: PointCluster[] = [];\r\n    optimizer: ClusteringCollisionBasedGraph;\r\n    constructor(optimizer: ClusteringCollisionBasedGraph) {\r\n        this.optimizer = optimizer;\r\n    }\r\n    public InitGeometry(){\r\n        this.clustersRPoint = [];\r\n    }\r\n    public addClusterByGeometries(geo: CPoint[][] ) {\r\n        for(let i = 0; i < geo.length; ++i) {\r\n            this.clustersRPoint.push(new PointCluster(this, geo[i]));\r\n        }\r\n    }\r\n    public RemoveCluster(cluster: PointCluster ){\r\n        this.clustersRPoint.splice(this.clustersRPoint.indexOf(cluster), 1);\r\n\r\n    }\r\n    public Render(ctx: CanvasRenderingContext2D, isStationary: boolean, toScreen: (x: number, y: number) => number[]): void {\r\n    //     console.log(this.clustersRPoint.length);\r\n        if (this.clustersRPoint.length > 0) {\r\n            for(let i = 0 ; i < this.clustersRPoint.length; ++i) {\r\n                this.clustersRPoint[i].Draw(ctx, this, isStationary, toScreen);\r\n            }\r\n        }\r\n\r\n    }\r\n}","\r\n// import { GeometryBase } from '../../../DrawingEngine/Geometry/Base/GeometryBase';\r\nimport { PointCluster } from './PointCluster';\r\nimport { ClusteringCollisionBasedGraph } from '..';\r\n\r\nimport { distance, AABBintersect2D, CPoint } from '../lib';\r\n\r\nexport class GraphClustering {\r\n\r\n    optimizer: ClusteringCollisionBasedGraph;\r\n    pointList: CPoint[] = []\r\n    // listNPoint: CPoint[] = []\r\n\r\n    constructor(optimizer: ClusteringCollisionBasedGraph) {\r\n        this.optimizer = optimizer;\r\n    }\r\n\r\n    public update(): void {\r\n        this.updatePoints();\r\n\r\n        // 1: build connectivity based on collision\r\n        // this.listNPoint = this.BuildConnectivity(this.listNPoint);\r\n        this.pointList = this.BuildConnectivity(this.pointList);\r\n        this.initGeometry();\r\n        // 2: construct clusters graph based on the connectivity\r\n        const geoList = this.buildGraph(this.pointList);\r\n\r\n        if (geoList !== undefined){\r\n            this.addClusterByGeometries(geoList);\r\n            // // 3: recursive checking for the collision while repositioning clusters\r\n            this.PostUpdateCollisionBasedonGraph();\r\n\r\n            const graphs = this.NeedDecompose();\r\n            if (graphs.length > 0) {\r\n                // 4: tessellate big clusters based on a resolution\r\n                this.SplitClusters(graphs);\r\n                // 5: post-process for merging based on a tolerance\r\n                this.PostMergeCluster();\r\n            }\r\n        }\r\n    }\r\n    public initGeometry(){\r\n        this.optimizer.renderer.InitGeometry();\r\n    }\r\n    public addClusterByGeometries(outGraphList: CPoint[][] ){\r\n        this.optimizer.renderer.addClusterByGeometries(outGraphList);\r\n    }\r\n    private updatePoints() {\r\n        this.pointList = [];\r\n\r\n        for(let i = 0; i < this.optimizer.points.length; ++i) {\r\n            if(this.optimizer.points[i].isHidden ||\r\n                !this.optimizer.points[i].isRenderable ){\r\n                continue\r\n            } else {\r\n                const pt = this.optimizer.points[i];\r\n                pt.collision.Reset();\r\n                this.pointList.push(pt)\r\n            }\r\n        }\r\n\r\n    }\r\n    private BuildConnectivity(listPoints: CPoint[]) {\r\n        for(let i = 0; i < listPoints.length; ++i) {\r\n            const pt = listPoints[i];\r\n            for(let j = i + 1 ; j < listPoints.length; ++j) {\r\n                const other = listPoints[j];\r\n                if (!other.isCollapse && other !== pt && AABBintersect2D([pt.collision.minVec, pt.collision.maxVec], [other.collision.minVec, other.collision.maxVec])) {\r\n                    pt.collision.isCollided = true;\r\n                    pt.isCollapse = true;\r\n                    pt.numVisit = 0;\r\n                    pt.collision.neighborShapes.push(other);\r\n                    other.collision.isCollided = true;\r\n                    other.isCollapse = true;\r\n                    other.numVisit = 0;\r\n                    other.collision.neighborShapes.push(pt);\r\n                    // other.collision.neighborShapes.push(pt);\r\n                    // pt.collision.numOrder = numOrder++;\r\n                    // break;\r\n                }\r\n            }\r\n        }\r\n        return listPoints;\r\n    }\r\n    private buildGraph(listPoints: CPoint[]) {\r\n        let outList: CPoint[][] = [];\r\n        for(let i = 0; i < listPoints.length; ++i) {\r\n            let ptList: CPoint[] = [];\r\n            let queue = [listPoints[i]];\r\n            queue[0].collision.isVisited = true;\r\n            ptList.push(queue[0]);\r\n            let safeguard = 0;\r\n            let current = undefined;\r\n            while( (current = queue.shift()) !== undefined ) {\r\n                for(let i = 0; i < current.collision.neighborShapes.length; ++i) {\r\n                    if(!current.collision.neighborShapes[i].collision.isVisited) {\r\n                        current.collision.neighborShapes[i].collision.isVisited = true;\r\n                        queue.push(current.collision.neighborShapes[i] as CPoint);\r\n                        ptList.push(current.collision.neighborShapes[i] as CPoint);\r\n                    }\r\n                }\r\n                if(safeguard++ > 1000) { console.debug('fail to optimize'); return; }\r\n            }\r\n            if (ptList.length > 1) {\r\n                outList.push(ptList);\r\n            }\r\n        }\r\n        return outList;\r\n    }\r\n    public PostUpdateCollisionBasedonGraph() {\r\n        // for(let i = 0; i < this.optimizer.renderer.clustersNPoint.length; ++i) {\r\n        //     this.UpdateByQueue(this.optimizer.renderer.clustersNPoint[i], this.listNPoint);\r\n        // }\r\n        for(let i = 0; i < this.optimizer.renderer.clustersRPoint.length; ++i) {\r\n            this.UpdateByQueue(this.optimizer.renderer.clustersRPoint[i], this.pointList);\r\n        }\r\n    }\r\n    private UpdateByQueue(cluster: PointCluster, geometries: CPoint[]) {\r\n        let remain = 0;\r\n        const queue = [...geometries]\r\n        while(queue.length) {\r\n            const geo = queue.shift();\r\n\r\n            if (geo) {\r\n                // console.log(queue.length);\r\n                // safeguard and performance optimization\r\n                if (geo.numVisit > 100) { geo.numVisit = 0; break; }\r\n                if (queue.length === 0) {\r\n                    if(geometries.length < remain++ ) { break; }\r\n                }\r\n                // end safeguard and performance optimization\r\n                if (!geo.collision.isCollided) {\r\n                    if(AABBintersect2D([geo.collision.minVec, geo.collision.maxVec], [cluster.minVec, cluster.maxVec]) ) {\r\n                        geo.collision.isCollided = true;\r\n                        geo.isCollapse = true;\r\n                        geo.numVisit = 0;\r\n                        cluster.AddPost(geo);\r\n                    } else {\r\n                        geo.numVisit++;\r\n                        queue.push(geo);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    private NeedDecompose(){\r\n        const clusterGraph = [];\r\n\r\n        for(let i = 0; i < this.optimizer.renderer.clustersRPoint.length; ++i) {\r\n            if(this.optimizer.renderer.clustersRPoint[i].NeedDecompose()) {\r\n                clusterGraph.push(this.optimizer.renderer.clustersRPoint[i]);\r\n            }\r\n        }\r\n        return clusterGraph;\r\n    }\r\n    private SplitClusters(clusters: PointCluster[]) {\r\n        for(let i = 0; i < clusters.length; ++i) {\r\n            clusters[i].Split();\r\n        }\r\n    }\r\n    private PostMergeCluster(){\r\n        this.PostMergeClusterCompute(this.optimizer.renderer.clustersRPoint);\r\n    }\r\n    private PostMergeClusterCompute(clusters: PointCluster[]){\r\n        for(let i = 0; i < clusters.length - 1; ++i) {\r\n            const cluster = clusters[i];\r\n            for(let j = i + 1; j < clusters.length; ++j) {\r\n                const other = clusters[j]\r\n                if(!other.isVisited) {\r\n                    if(distance(cluster.vec, other.vec ) < cluster.r1 + 20) {\r\n                        other.isVisited = true;\r\n                        cluster.Merge(other);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n}","import { NVector3, CPoint } from './lib';\r\n\r\nimport { Renderer } from './Core/Renderer';\r\nimport { GraphClustering } from './Core/GraphClustering';\r\n\r\nexport class ClusteringCollisionBasedGraph {\r\n\r\n    graphClustering: GraphClustering;\r\n    renderer: Renderer;\r\n\r\n    mv: NVector3 = new NVector3(0, 0);\r\n\r\n    inspection: boolean = true;\r\n\r\n    points: CPoint[] = [];\r\n\r\n    constructor() {\r\n        this.graphClustering = new GraphClustering(this);\r\n        this.renderer = new Renderer(this);\r\n    }\r\n    public push(x: number, y: number) {\r\n        this.points.push(new CPoint(x, y));\r\n        this.update();\r\n    }\r\n    public mouseInteraction(x: number, y: number){\r\n        // this.mv = this.optimizer.getCellAtPoint(new NVector3(x, y)).vec;\r\n    }\r\n    public update(): void {\r\n        this.graphClustering.update();\r\n        // console.log(this.optimizer.optimizer.optimizer.renderer.annotationInstance.activeCommandController.acProperties.isZooming);\r\n        // if (this.optimizer.optimizer.optimizer.renderer.annotationInstance.activeCommandController.acProperties.isZooming) {\r\n        // this.initGrid(width, height);\r\n        // }\r\n    //     console.log(this);\r\n    }\r\n    public getCellAtPoint(dp: NVector3) {\r\n\r\n    }\r\n    public render(ctx: CanvasRenderingContext2D, isStationary: boolean, toScreen: (x: number, y: number) => number[] ) {\r\n        this.renderer.Render(ctx, isStationary, toScreen)\r\n    }\r\n}","import mapboxgl from \"mapbox-gl\";\r\n\r\nexport class MapboxGLWrapper {\r\n    public map: mapboxgl.Map\r\n    constructor(id: string) {\r\n\r\n        this.initMap(id);\r\n    }\r\n    private initMap(id: string) {\r\n        // https://account.mapbox.com\r\n        mapboxgl.accessToken = process.env.REACT_APP_MAPBOX;\r\n        this.map = new mapboxgl.Map({\r\n            container: id,\r\n            zoom: 15,\r\n            // minZoom: 10,\r\n            center: [-71.093161, 42.358871],\r\n            style: 'mapbox://styles/mapbox/dark-v10' // 'mapbox://styles/mapbox/streets-v11'\r\n        });\r\n        this.map.dragRotate.disable();\r\n\r\n        // https://docs.mapbox.com/mapbox-gl-js/api/events/#mapmouseevent#type\r\n        this.map.on('mousemove', (e) => { this.mouseMove(e); });\r\n        this.map.on('click', (e) => { this.mouseClick(e); });\r\n        this.map.on('mousedown', (e) => { this.mouseDown(e); });\r\n        this.map.on('dblclick', (e) => { this.mouseDClick(e); });\r\n        this.map.on('mouseup', (e) => { this.mouseUp(e); });\r\n\r\n        let div = document.getElementsByClassName('mapboxgl-canvas')[0] as HTMLDivElement;\r\n        div.style.position = 'absolute';\r\n        \r\n        div = document.getElementsByClassName('mapboxgl-control-container')[0] as HTMLDivElement;\r\n        div.style.display = 'none';\r\n\r\n    }\r\n    public center = (lng: number = -99.292649, lat: number = 39.043903) => {\r\n        // const v = new mapboxgl.LngLat(lon, lat);\r\n        // console.log(v);\r\n        this.map.setCenter({ lat, lng })\r\n    }\r\n    public toMap = (x: number, y: number) => {\r\n        const p = this.map.unproject({x, y} as any)\r\n        return [p.lng, p.lat];\r\n    }\r\n    public toScreen = (lon: number, lat: number) => {\r\n        const p = this.map.project([lon, lat])\r\n        return [p.x, p.y];\r\n    }\r\n    public mouseDown = (e) => {\r\n        // console.log(this.toScreen(-71.093161, 42.358871))\r\n        // console.log(JSON.stringify(e.point), e.lngLat.wrap())\r\n    }\r\n    public mouseUp = (e) => {\r\n        // console.log(JSON.stringify(e.point), e.lngLat.wrap())\r\n    }\r\n    public mouseMove = (e) => {\r\n        // console.log(JSON.stringify(e.point), e.lngLat.wrap())\r\n    }\r\n    public mouseClick = (e) => {\r\n        // console.log(e)\r\n        \r\n        // console.log(this.toMap(100, 100));\r\n        // console.log(e.point)\r\n        // this.center()\r\n        // this.map.zoomTo(0)\r\n        // console.log(JSON.stringify(e.point), e.lngLat.wrap())\r\n    }\r\n    public mouseDClick = (e) => {\r\n        // console.log(JSON.stringify(e.point), e.lngLat.wrap())\r\n    }\r\n}\r\n\r\n\r\n","// import { RendererCanvas } from '../../../lib'\r\nimport { ClusteringCollisionBasedGraph } from './ClusteringCollisionBasedGraph';\r\n\r\nimport { MapboxGLWrapper } from './MapboxGLWrapper';\r\nimport { RendererCanvas } from '../../../lib'\r\n\r\nexport class Solution {\r\n    public divHost: HTMLDivElement;\r\n    public mapboxWrapper: MapboxGLWrapper;\r\n    public renderer: Renderer;\r\n    constructor(div: HTMLDivElement) {\r\n        this.divHost = div;\r\n        this.divHost.style.position = 'relative';\r\n\r\n        this.mapboxWrapper = new MapboxGLWrapper(this.divHost.id);\r\n        this.mapboxWrapper.mouseDown = this.mouseDown\r\n        this.mapboxWrapper.mouseUp = this.mouseUp\r\n        this.mapboxWrapper.mouseClick = this.mouseClick\r\n        this.mapboxWrapper.mouseMove = this.mouseMove\r\n\r\n        setTimeout(() => {\r\n            this.renderer = new Renderer(this.divHost, this);\r\n        }, 100);\r\n\r\n    }\r\n    public mouseDown = (e) => {\r\n        // TODO\r\n    }\r\n    public mouseUp = (e) => {\r\n        // TODO\r\n    }\r\n    public mouseDrag = (e) => {\r\n        // TODO\r\n    }\r\n    public mouseClick = (e) => {\r\n        // TODO\r\n        // console.log(e);\r\n        // console.log(e['lngLat']);\r\n        this.renderer.pts.push([e['lngLat']['lng'], e['lngLat']['lat']])\r\n        \r\n        const p = this.mapboxWrapper.toScreen(e['lngLat']['lng'], e['lngLat']['lat']);\r\n        this.renderer.mouseClick(p[0], p[1]);\r\n        // console.log(p)\r\n        // this.renderer.clustering.push(p)\r\n\r\n    }\r\n    public mouseMove = (e)  =>{\r\n        // TODO\r\n    }\r\n    public keyDown(k: KeyboardEvent) {\r\n        // TODO\r\n    }\r\n    public destroy() {\r\n        this.renderer.destroy();\r\n        while (this.divHost.lastElementChild) {\r\n            this.divHost.removeChild(this.divHost.lastElementChild);\r\n        }\r\n    }\r\n}\r\nexport class Renderer extends RendererCanvas {\r\n    public app: Solution\r\n    public time: number = 0.0;\r\n    public pts: number[][] = [];\r\n\r\n    clustering: ClusteringCollisionBasedGraph;\r\n\r\n    constructor(div: any, app: Solution) {\r\n        super(div);\r\n        this.app = app;\r\n        this.canvas.id = 'mapboxCustom'\r\n        this.canvas.style.position = 'absolute';\r\n        this.canvas.style.width = '100%';\r\n        this.canvas.style.height = '100%';\r\n        this.canvas.style.pointerEvents = 'none';\r\n\r\n        // TODO\r\n        // You code goes here for one time operation\r\n        this.pts.push([-71.093161, 42.358871]);\r\n\r\n        this.clustering = new ClusteringCollisionBasedGraph()\r\n        // const p = this.app.mapboxWrapper.toScreen(-71.093161, 42.358871);\r\n        // this.clustering.push(p)\r\n        this.start();\r\n    }\r\n    public mouseClick = (x: number, y: number): void => {\r\n        console.log(x, y);\r\n\r\n        this.clustering.push(x, y);\r\n    }\r\n    public mouseUp = (x: number, y: number): void => {\r\n\r\n    }\r\n    public mouseDrag = (x: number, y: number): void => {\r\n\r\n    }\r\n    public render(ctx: CanvasRenderingContext2D): void {\r\n        this.time += 0.1;\r\n\r\n      \r\n\r\n        // for(let i = 0 ; i < this.pts.length; ++i) {\r\n        //     const pt = this.pts[i];\r\n        //     const p = this.app.mapboxWrapper.toScreen(pt[0], pt[1]);\r\n        //     // const p = this.app.mapboxWrapper.map.unproject({x: 10, y: 10})\r\n    \r\n        //     ctx.beginPath();\r\n        //     ctx.arc(p[0], p[1], 10, 0, Math.PI * 2);\r\n        //     ctx.closePath();\r\n        //     ctx.fillStyle = '#0f0';\r\n        //     ctx.fill();\r\n        // }\r\n\r\n        this.clustering.render(ctx, false, this.app.mapboxWrapper.toScreen);\r\n\r\n    }\r\n}"],"names":["AABBintersect2D","v0","v1","v0minX","x","v0maxX","v1minX","v1maxX","v0minY","y","v0maxY","v1minY","v1maxY","distance","Math","sqrt","z","NVector3","constructor","lon","lat","elevation","d","isRenderable","this","CPoint","vec","id","numVisit","isCollapse","isHidden","isSelected","isHover","collision","Collision","base","isCollided","neighborShapes","minVec","maxVec","isVisited","numOrder","Reset","PointCluster","renderer","geometries","points","r0","r1","boundingBoxMin","Number","MAX_SAFE_INTEGER","boundingBoxMax","MIN_SAFE_INTEGER","t","GridResolution","tempVecGridList","tempGeoGridList","i","length","UpdateBoundingBox","IsInside","m","AddPost","geo","includes","push","NeedDecompose","Split","DeepRemove","xNum","yNum","grid","buildGrid","BuildSubCluster","Merge","other","concat","RemoveCluster","gridList","theY","geoMat","theX","geoList","vs","GetCellAtPoint","clustersRPoint","tv","dp","round","j","Draw","ctx","isPanning","toScreen","UpdateTimeer","drawingPresetClustering","optimizer","inspection","beginPath","rect","closePath","fillStyle","fill","lineWidth","stroke","strokeStyle","moveTo","lineTo","arc","PI","font","textAlign","fillText","Renderer","InitGeometry","addClusterByGeometries","cluster","splice","indexOf","Render","isStationary","GraphClustering","pointList","update","updatePoints","BuildConnectivity","initGeometry","buildGraph","undefined","PostUpdateCollisionBasedonGraph","graphs","SplitClusters","PostMergeCluster","outGraphList","pt","listPoints","outList","ptList","queue","current","safeguard","shift","console","debug","UpdateByQueue","remain","clusterGraph","clusters","PostMergeClusterCompute","ClusteringCollisionBasedGraph","graphClustering","mv","mouseInteraction","getCellAtPoint","render","MapboxGLWrapper","map","center","lng","setCenter","toMap","p","unproject","project","mouseDown","e","mouseUp","mouseMove","mouseClick","mouseDClick","initMap","mapboxgl","process","container","zoom","style","dragRotate","disable","on","div","document","getElementsByClassName","position","display","Solution","divHost","mapboxWrapper","mouseDrag","pts","setTimeout","keyDown","k","destroy","lastElementChild","removeChild","RendererCanvas","app","super","time","clustering","log","canvas","width","height","pointerEvents","start"],"sourceRoot":""}