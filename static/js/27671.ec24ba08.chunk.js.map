{"version":3,"file":"static/js/27671.ec24ba08.chunk.js","mappings":"iIACO,MAAMA,EAETC,YAAYC,GAAc,KAD1BA,SAAG,EAECC,KAAKD,IAAMA,EAEXC,KAAKC,MACT,CACA,aA6CI,MAAMC,QAAgBC,UAAUC,IAAIC,iBAE9BC,QAAeJ,EAAQK,cAAc,CAAC,GAG5C,MAAMH,EADUI,SAASC,cAAc,UACjBC,WAAW,cAEjC,IAAIC,EAAS,qvBAkBbC,QAAQC,IAAIP,EAAQF,EAAKO,GAEzB,IAAIG,EAAUV,EAAIW,cAAcJ,GAC5BK,EAAiBF,EAAQG,iBAAiB,eAC1CC,EAAmBJ,EAAQG,iBAAiB,iBAChDL,QAAQC,IAAIG,EAAgBE,GA8D5BN,QAAQC,IAAI,cAChB,ECjJG,MAAMM,EAGT,YAAmBC,GACf,IAAID,EAAOC,EACf,CACAtB,YAAYsB,GAAa,KALzBC,UAAI,OACJC,aAAO,EAKH,MAAMA,EAAUd,SAASe,eAAeH,GACpCE,IAAWtB,KAAKsB,QAAUA,GAC9BtB,KAAKqB,KAAO,IAAIxB,EAAWG,KAC/B,E","sources":["njslab/app-legacy/Implementation/Demos/Demo13WebGPU/Core/index.ts","njslab/app-legacy/Implementation/Demos/Demo13WebGPU/index.ts"],"sourcesContent":["import { WebGPU } from '..';\r\nexport class WebGPUCore {\r\n    app: WebGPU;\r\n    constructor(app: WebGPU) {\r\n        this.app = app;\r\n\r\n        this.Init();\r\n    }\r\n    public async Init() {\r\n\r\n        // @ts-ignore\r\n        // const adapter = await navigator.gpu.requestAdapter();\r\n        // // @ts-ignore\r\n        // const device = await adapter.requestDevice({});\r\n\r\n        // let newCanvas = document.createElement('canvas');\r\n        // const webgpuContext = newCanvas.getContext('gpupresent');\r\n\r\n        // const format = 'bgra8unorm';\r\n\r\n        // // console.log(device, format);\r\n        // // @ts-ignore\r\n        // const swapChain = webgpuContext.configureSwapChain({device, format});\r\n        // console.log(swapChain);\r\n\r\n        // const vertexShader = `#version 450\r\n        //     const vec2 pos[3] = vec2[3]{\r\n        //         vec2(0.25f, 0.5f),\r\n        //         vec2(-0.5f, -0.5f),\r\n        //         vec2(0.5f, -0.5f),\r\n        //     };\r\n        //     void main() {\r\n        //         gl_position = vec4(pos[gl_VertexIndex], 0.0, 1.0);\r\n        //     };\r\n\r\n        // `;\r\n        // const fragmentShader = `#version 450\r\n        //     layout(location = 0) out vec4 outColor;\r\n        //     void main() {\r\n        //         outColor = vec4(0.0, 0.0, 0.0, 0.1);\r\n        //     }\r\n        // `;\r\n\r\n        // console.log(vertexShader, fragmentShader);\r\n\r\n        // @ts-ignore\r\n        // const vertexModule = device.createShaderModule(code: utils.compileShader('v', vertexShader));\r\n        // const vertexModule = device.createShaderModule(\r\n        //     // @ts-ignore\r\n        //     code : utils.compileShader('v', vertexShader)\r\n        // );\r\n\r\n        // @ts-ignore\r\n        const adapter = await navigator.gpu.requestAdapter();\r\n        // @ts-ignore\r\n        const device = await adapter.requestDevice({});\r\n\r\n        let newCanvas = document.createElement('canvas');\r\n        const gpu = newCanvas.getContext('gpupresent');\r\n\r\n        let shaderSrc = `using namespace metal;\r\n        // Rec 709 LUMA values for grayscale image conversion\r\n        constant float3 kRec709Luma = float3(0.2126, 0.7152, 0.0722);\r\n        struct Vertex {\r\n            float4 position [[position]];\r\n            float4 color;\r\n        };\r\n        vertex Vertex vertex_main(constant Vertex *vertices [[buffer(0)]],\r\n                                uint vid [[vertex_id]]) {\r\n            return vertices[vid];\r\n        }\r\n        fragment float4 fragment_main(Vertex vert [[stage_in]]) {\r\n            float3 inColor = float3(vert.color.x, vert.color.y, vert.color.z);\r\n            half gray = dot(kRec709Luma, inColor);\r\n            float4 outColor = float4(gray, gray, gray, 1);\r\n            return outColor;\r\n        }\r\n        `;\r\n        console.log(device, gpu, shaderSrc);\r\n        // @ts-ignore\r\n        let library = gpu.createLibrary(shaderSrc);\r\n        let vertexFunction = library.functionWithName('vertex_main');\r\n        let fragmentFunction = library.functionWithName('fragment_main');\r\n        console.log(vertexFunction, fragmentFunction);\r\n\r\n        // // @ts-ignore\r\n        // let pipelineDescriptor = new WebGPURenderPipelineDescriptor();\r\n        // pipelineDescriptor.vertexFunction = vertexFunction;\r\n        // pipelineDescriptor.fragmentFunction = fragmentFunction;\r\n\r\n        // // @ts-ignore\r\n        // pipelineDescriptor.colorAttachments[0].pixelFormat = gpu.PixelFormatBGRA8Unorm;\r\n\r\n        // // @ts-ignore\r\n        // let pipelineState = gpu.createRenderPipelineState(pipelineDescriptor);\r\n\r\n        // let vertexData = new Float32Array([\r\n        //     // x y z 1 r g b 1\r\n        //     0, 0.75, 0, 1, 1, 0, 0, 1,\r\n        //     -0.75, -0.75, 0, 1, 0, 1, 0, 1,\r\n        //     0.75, -0.75, 0, 1, 0, 0, 1, 1\r\n        // ]);\r\n\r\n        // // @ts-ignore\r\n        // let vertexBuffer = gpu.createBuffer(vertexData);\r\n\r\n        // // @ts-ignore\r\n        // let drawable = gpu.nextDrawable();\r\n\r\n        // // @ts-ignore\r\n        // let passDescriptor = new WebGPURenderPassDescriptor();\r\n        // // @ts-ignore\r\n        // passDescriptor.colorAttachments[0].loadAction = gpu.LoadActionClear;\r\n        // // @ts-ignore\r\n        // passDescriptor.colorAttachments[0].storeAction = gpu.StoreActionStore;\r\n        // passDescriptor.colorAttachments[0].clearColor = [0.2, 0.8, 0.8, 1.0];\r\n        // passDescriptor.colorAttachments[0].texture = drawable.texture;\r\n\r\n        // // @ts-ignore\r\n        // let commandQueue = gpu.createCommandQueue();\r\n        // let commandBuffer = commandQueue.createCommandBuffer();\r\n\r\n        // // Use the descriptor we created above.\r\n        // let commandEncoder = commandBuffer.createRenderCommandEncoderWithDescriptor(\r\n        //     passDescriptor);\r\n\r\n        // // Tell the encoder which state to use (i.e. shaders).\r\n        // commandEncoder.setRenderPipelineState(pipelineState);\r\n\r\n        // // And, lastly, the encoder needs to know which buffer\r\n        // // to use for the geometry.\r\n        // commandEncoder.setVertexBuffer(vertexBuffer, 0, 0);\r\n\r\n        // // We know our buffer has three vertices. We want to draw them\r\n        // // with filled triangles.\r\n        // // @ts-ignore\r\n        // commandEncoder.drawPrimitives(gpu.PrimitiveTypeTriangle, 0, 3);\r\n        // commandEncoder.endEncoding();\r\n\r\n        // // All drawing commands have been submitted. Tell WebGPU to\r\n        // // show/present the results in the canvas once the queue has\r\n        // // been processed.\r\n        // commandBuffer.presentDrawable(drawable);\r\n        // commandBuffer.commit();\r\n\r\n        console.log('webGPU init');\r\n    }\r\n\r\n}","import { WebGPUCore } from './Core';\r\nexport class WebGPU {\r\n    core: WebGPUCore;\r\n    divHost: HTMLElement;\r\n    public static Init(id: string) {\r\n        new WebGPU(id);\r\n    }\r\n    constructor(id: string) {\r\n        const divHost = document.getElementById(id);\r\n        if (divHost) { this.divHost = divHost; }\r\n        this.core = new WebGPUCore(this);\r\n    }\r\n}"],"names":["WebGPUCore","constructor","app","this","Init","adapter","navigator","gpu","requestAdapter","device","requestDevice","document","createElement","getContext","shaderSrc","console","log","library","createLibrary","vertexFunction","functionWithName","fragmentFunction","WebGPU","id","core","divHost","getElementById"],"sourceRoot":""}