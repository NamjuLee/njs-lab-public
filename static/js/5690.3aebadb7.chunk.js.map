{"version":3,"file":"static/js/5690.3aebadb7.chunk.js","mappings":"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","sources":["njslab/Tools/A-Star-Graph/index.ts"],"sourcesContent":["import { PARAM } from 'App';\r\nimport { RendererCanvas } from '../../../lib'\r\n\r\nexport class Solution {\r\n    public divHost: HTMLElement;\r\n    public renderer: Renderer;\r\n\r\n    constructor(divHost: any) {\r\n        this.divHost = divHost;\r\n\r\n        // Center align\r\n        this.divHost.style.display = 'flex';\r\n        this.divHost.style.alignItems = 'center';\r\n\r\n        const div = document.createElement('div');\r\n        div.style.marginLeft = 'auto';\r\n        div.style.marginRight = 'auto';\r\n        div.style.backgroundColor = '#555';\r\n        div.style.width = '1000px';\r\n        div.style.height = '600px';\r\n        this.divHost.appendChild(div);\r\n\r\n        // if (PARAM.demo) {\r\n            this.renderer = new Renderer(div);\r\n\r\n            let btn = document.createElement('div');\r\n            div.appendChild(btn);\r\n            btn.textContent = 'Reset';\r\n            btn.onclick = () => {\r\n                this.renderer.Build();\r\n            };\r\n            const cBox = getCheckBox('Connectivity');\r\n            div.appendChild(cBox.div);\r\n            cBox.checkBox.checked = false;\r\n            cBox.checkBox.onchange = () => {\r\n                console.log(cBox.checkBox.checked)\r\n                if (cBox.checkBox.checked === true) {\r\n                    this.renderer.connectionDiagonal = true;\r\n                } else {\r\n                    this.renderer.connectionDiagonal = false;\r\n                }\r\n            }\r\n\r\n            btn = document.createElement('div');\r\n            div.appendChild(btn);\r\n            btn.textContent = 'Play and Stop toggle';\r\n            btn.onclick = () => {\r\n                this.renderer.playToggle = !this.renderer.playToggle;\r\n            };\r\n\r\n            const sl2 = getSlider('Heuristic intensity', 0, 1000);\r\n            div.appendChild(sl2.div);\r\n            sl2.slider.oninput = () => {\r\n                const val = 1 / +sl2.slider.value - 0.001;\r\n                this.renderer.graph.heuristicConst = val;\r\n            };\r\n\r\n\r\n        // }\r\n    }\r\n    public destroy() {\r\n        this.renderer.destroy();\r\n        while (this.divHost.lastElementChild) {\r\n            this.divHost.removeChild(this.divHost.lastElementChild);\r\n        }\r\n    }\r\n}\r\n\r\nconst renderCell = (ctx: CanvasRenderingContext2D, node: Node, col: string, cellSize: number) => {\r\n    ctx.fillStyle = col;\r\n    ctx.beginPath();\r\n    ctx.rect(node.x * cellSize, node.y * cellSize, cellSize - 1, cellSize - 1);\r\n    ctx.closePath();\r\n    ctx.fill();\r\n};\r\n\r\nexport class Renderer extends RendererCanvas {\r\n    w: number = 0;\r\n    h: number = 0;\r\n    cols: number = 0;\r\n    rows: number = 0;\r\n    cellSize: number = 20;\r\n    gridWidth: number = 0;\r\n    gridHeight: number = 0;\r\n    chanceOfWalls: number = 0.35;\r\n    connectionDiagonal = false\r\n\r\n    graph: PixelMap;\r\n\r\n    playToggle = true;\r\n\r\n    frame = 0;\r\n    public divTextIteration: HTMLDivElement;\r\n\r\n    constructor(div: any) {\r\n        super(div);\r\n        this.canvas.style.position = 'relative';\r\n        this.canvas.style.width = '100%';\r\n        this.canvas.style.height = '100%';\r\n\r\n        // TODO\r\n        // You code goes here for one time operation\r\n        this.divTextIteration = document.createElement('div');\r\n        div.appendChild(this.divTextIteration);\r\n\r\n        this.Build();\r\n        this.start();\r\n    }\r\n    public render(ctx: CanvasRenderingContext2D): void {\r\n        if (this.playToggle) {\r\n            const result = this.graph.propagation();\r\n            this.divTextIteration.textContent = `${this.frame++} iterations`;\r\n        }\r\n        // const result = this.graph.gePath();\r\n        if (this.graph.doneComputation) { this.Build(); }\r\n        // console.log(result)\r\n\r\n        for (let i = 0; i < this.cols; i++) {\r\n            for (let j = 0; j < this.rows; j++) {\r\n                const node = this.graph.grid[i][j];\r\n                let color = 'rgb(190, 190, 190)';\r\n\r\n                if (node.blocked) { color = `rgba(0, 0, 0, 0.9)`; }\r\n                if (node === this.graph.endNode) { color = `rgba(255, 0, 255, 0.9)`; }\r\n\r\n                renderCell(ctx, node, color, this.cellSize);\r\n\r\n            }\r\n        }\r\n\r\n        for (let i = 0; i < this.graph.openNodes.length; i++) { // render open nodes\r\n            const node = this.graph.openNodes[i];\r\n            const color = 'rgb(0, 0, 255)';\r\n            renderCell(ctx, node, color, this.cellSize);\r\n        }\r\n\r\n        for (let i = 0; i < this.graph.closedNodes.length; i++) { // visited nodes\r\n            const node = this.graph.closedNodes[i];\r\n            const color = 'rgb(255, 0, 0)';\r\n            renderCell(ctx, node, color, this.cellSize);\r\n        }\r\n\r\n        for (let i = 0; i < this.graph.path.length; i++) { // path\r\n            const node = this.graph.path[i];\r\n            const color = 'rgb(0, 255, 0)';\r\n            renderCell(ctx, node, color, this.cellSize);\r\n        }\r\n\r\n        for (let i = 0; i < this.cols; i++) { // connection\r\n            for (let j = 0; j < this.rows; j++) {\r\n                const node = this.graph.grid[i][j];\r\n                if (node.blocked) { continue; }\r\n                for (let k = 0; k < node.neighbors.length; ++k) {\r\n                    ctx.strokeStyle = '#fff';\r\n                    ctx.lineWidth = 0.58;\r\n                    ctx.beginPath();\r\n                    ctx.moveTo(this.cellSize * node.x + this.cellSize * 0.5, this.cellSize * node.y + this.cellSize * 0.5);\r\n                    ctx.lineTo(this.cellSize * node.neighbors[k].x + this.cellSize * 0.5, this.cellSize * node.neighbors[k].y + this.cellSize * 0.5);\r\n                    ctx.stroke();\r\n                }\r\n\r\n            }\r\n        }\r\n    }\r\n    public Build() {\r\n        this.frame = 0;\r\n        this.w = this.canvas.width;\r\n        this.h = this.canvas.height;\r\n        this.cols = Math.floor(this.w / this.cellSize);\r\n        this.rows = Math.floor(this.h / this.cellSize);\r\n        this.gridWidth = this.w;\r\n        this.gridHeight = this.h;\r\n\r\n\r\n        this.graph = new PixelMap();\r\n        this.graph.connectionDiagonal = this.connectionDiagonal;\r\n\r\n        //Build navigation grid\r\n        for (let i = 0; i < this.cols; i++) {\r\n            for (let j = 0; j < this.rows; j++) {\r\n                if (this.graph.grid[i] === undefined)\r\n                    this.graph.grid[i] = [];\r\n\r\n                const node = new Node(i, j);\r\n                if (Math.random() < this.chanceOfWalls) { node.blocked = true; }\r\n                this.graph.grid[i][j] = node;\r\n            }\r\n        }\r\n\r\n        this.graph.startNode = this.getRandomCell();\r\n        this.graph.startNode.blocked = false;\r\n\r\n        this.graph.endNode = this.getRandomCell();\r\n        this.graph.endNode.blocked = false;\r\n\r\n        //find neighbors\r\n        for (let i = 0; i < this.cols; i++) {\r\n            for (let j = 0; j < this.rows; j++) {\r\n                this.graph.buildConnection(this.graph.grid[i][j], this.cols, this.rows);\r\n            }\r\n        }\r\n\r\n        this.graph.openNodes.push(this.graph.startNode);\r\n\r\n    }\r\n    getRandomCell() {\r\n        return this.graph.grid[Math.floor(Math.random() * this.cols)][Math.floor(Math.random() * this.rows)];\r\n    }\r\n}\r\n\r\nclass PixelMap {\r\n    public grid: Node[][] = [];\r\n    public openNodes: Node[] = [];\r\n    public closedNodes: Node[] = [];\r\n    public startNode: Node;\r\n    public endNode: Node;\r\n    public path: Node[] = [];\r\n    public heuristicConst = 1;\r\n    public doneComputation: boolean = false;\r\n    public connectionDiagonal = false;\r\n    // constructor() {\r\n    //     // TODO\r\n    // }\r\n    public buildConnection = (node: Node, cols: number, rows: number) => {\r\n        if (node.blocked) { return; }\r\n\r\n        let x = node.x;\r\n        let y = node.y;\r\n\r\n        if (x < cols - 1) {\r\n            if (!this.grid[x + 1][y].blocked) {\r\n                node.neighbors.push(this.grid[x + 1][y]);\r\n            } // right\r\n        }\r\n\r\n        if (y < rows - 1) {\r\n            if (!this.grid[x][y + 1].blocked) {\r\n                node.neighbors.push(this.grid[x][y + 1]);\r\n            } // bottom\r\n        }\r\n\r\n        if (x > 0) {\r\n            if (!this.grid[x - 1][y].blocked) {\r\n                node.neighbors.push(this.grid[x - 1][y]);\r\n            } // left\r\n        }\r\n\r\n        if (y > 0) {\r\n            if (!this.grid[x][y - 1].blocked) {\r\n                node.neighbors.push(this.grid[x][y - 1]);\r\n            } // top\r\n        }\r\n        if (this.connectionDiagonal) {\r\n            console.log(this.connectionDiagonal);\r\n            if (x > 0 && y > 0) {\r\n                if (!this.grid[x - 1][y - 1].blocked) {\r\n                    node.neighbors.push(this.grid[x - 1][y - 1]);\r\n                }\r\n            } // left up\r\n            if (x < cols - 1 && y < rows - 1) {\r\n                if (!this.grid[x + 1][y + 1].blocked) {\r\n                    node.neighbors.push(this.grid[x + 1][y + 1]);\r\n                }\r\n            } // right bottom\r\n            if (x > 0 && y < rows - 1) {\r\n                if (!this.grid[x - 1][y + 1].blocked) {\r\n                    node.neighbors.push(this.grid[x - 1][y + 1]);\r\n                }\r\n            } // left bottom\r\n            if (x < cols - 1 && y > 0) {\r\n                if (!this.grid[x + 1][y - 1].blocked) {\r\n                    node.neighbors.push(this.grid[x + 1][y - 1]);\r\n                }\r\n            } // right top\r\n        }\r\n    }\r\n    public gePath() {\r\n        let result = undefined;\r\n        let count = this.grid[0].length * this.grid.length\r\n        while (count--) {\r\n            result = this.propagation();\r\n            if (result !== undefined && result.length) {\r\n                return result;\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n    public propagation() {\r\n        // console.log('-----');\r\n        if (this.openNodes.length > 0) {\r\n            //find the lowest f in open nodes\r\n            let lowestF = 0;\r\n            for (let i = 0; i < this.openNodes.length; i++) {\r\n                if (this.openNodes[i].f < this.openNodes[lowestF].f) {\r\n                    lowestF = i;\r\n                }\r\n\r\n                if (this.openNodes[i].f === this.openNodes[lowestF].f) {\r\n                    if (this.openNodes[i].g > this.openNodes[lowestF].g) {\r\n                        lowestF = i;\r\n                    }\r\n                }\r\n            }\r\n            let current: Node = this.openNodes[lowestF];\r\n\r\n            if (current === this.endNode) {\r\n                //reached the end node so wait a sec and restart\r\n                this.doneComputation = true;\r\n                return this.path;\r\n            }\r\n\r\n            //calculate path\r\n            this.path = [];\r\n            let temp = current;\r\n            while (temp.previous) {\r\n                this.path.push(temp.previous);\r\n                temp = temp.previous;\r\n            }\r\n            // console.log(this.path.length);\r\n\r\n            this.openNodes.splice(this.openNodes.indexOf(current), 1);\r\n            this.closedNodes.push(current);\r\n\r\n            let neighbors = current.neighbors;\r\n            for (let i = 0; i < neighbors.length; i++) {\r\n                let neighbor = neighbors[i];\r\n\r\n                if (!this.closedNodes.includes(neighbor) && !neighbor.blocked) {\r\n                    let tempG = current.g + heuristic(neighbor, current) * this.heuristicConst;\r\n\r\n                    if (!this.openNodes.includes(neighbor)) {\r\n                        this.openNodes.push(neighbor);\r\n                    }\r\n                    else {\r\n                        continue;\r\n                    }\r\n\r\n                    neighbor.g = tempG;\r\n                    neighbor.h = heuristic(neighbor, this.endNode);\r\n                    neighbor.f = neighbor.g + neighbor.h;\r\n                    neighbor.previous = current\r\n                }\r\n            }\r\n            return undefined;\r\n        } else {\r\n            this.doneComputation = true;\r\n            return this.path;\r\n        }\r\n    }\r\n}\r\nclass Node {\r\n    public f = 0;\r\n    public h = 0;\r\n    public g = 0;\r\n\r\n    public x = 0;\r\n    public y = 0;\r\n    public z = 0;\r\n    public neighbors: Node[] = [];\r\n    public previous = undefined;\r\n    public blocked = false;\r\n    constructor(x: number, y: number) {\r\n        this.f = 0;\r\n        this.h = 0;\r\n        this.g = 0;\r\n        this.x = x;\r\n        this.y = y;\r\n        this.neighbors = [];\r\n        this.blocked = false;\r\n    }\r\n}\r\nconst heuristic = (a: Node, b: Node) => {\r\n    let d = 0;\r\n    // d = distanceManhattan(a.x, a.y, a.z, b.x, b.y, b.z); // find the Manhattan distance (best for grids)\r\n    d = distanceEuclidean(a.x, a.y, a.z, b.x, b.y, b.z); // euclidean - find the direct distance\r\n    return d;\r\n}\r\nconst distanceManhattan = (x0: number, y0: number, z0: number, x1: number, y1: number, z1: number) => {\r\n    return Math.abs(x0 - x1) + Math.abs(y0 - y1) + Math.abs(z0 - z1);\r\n}\r\nconst distanceEuclidean = (x0: number, y0: number, z0: number, x1: number, y1: number, z1: number) => {\r\n    return Math.sqrt((x0 - x1) * (x0 - x1) + (y0 - y1) * (y0 - y1) + (z0 - z1) * (z0 - z1));\r\n}\r\n\r\n\r\n\r\n// ..................................\r\n\r\nconst getSlider = (title: string, min: number, max: number) => {\r\n    // <input type=\"range\" min=\"1\" max=\"100\" value=\"50\" class=\"slider\" id=\"myRange\">\r\n    const div = document.createElement('div');\r\n    div.style.display = 'flex';\r\n\r\n    const slider = document.createElement('input');\r\n    slider.type = 'range';\r\n    slider.min = `${min}`;\r\n    slider.max = `${max}`;\r\n\r\n    const text = document.createElement('div');\r\n    text.textContent = title;\r\n    text.style.color = '#aaa';\r\n    div.appendChild(slider);\r\n    div.appendChild(text);\r\n\r\n    return {\r\n        div, slider\r\n    }\r\n};\r\nconst getCheckBox = (title: string) => {\r\n    const div = document.createElement('div');\r\n    div.style.display = 'flex';\r\n\r\n    const checkBox = document.createElement('input');\r\n    checkBox.type = 'checkbox';\r\n    checkBox.defaultChecked = false;\r\n    const text = document.createElement('div');\r\n    text.textContent = title;\r\n    text.style.color = '#aaa';\r\n    div.appendChild(checkBox);\r\n    div.appendChild(text);\r\n\r\n    return {\r\n        div, checkBox\r\n    }\r\n};"],"names":["Solution","constructor","divHost","renderer","this","style","display","alignItems","div","document","createElement","marginLeft","marginRight","backgroundColor","width","height","appendChild","Renderer","btn","textContent","onclick","Build","cBox","getCheckBox","checkBox","checked","onchange","console","log","connectionDiagonal","playToggle","sl2","getSlider","slider","oninput","val","value","graph","heuristicConst","destroy","lastElementChild","removeChild","renderCell","ctx","node","col","cellSize","fillStyle","beginPath","rect","x","y","closePath","fill","RendererCanvas","super","w","h","cols","rows","gridWidth","gridHeight","chanceOfWalls","frame","divTextIteration","canvas","position","start","render","propagation","doneComputation","i","j","grid","color","blocked","endNode","openNodes","length","closedNodes","path","k","neighbors","strokeStyle","lineWidth","moveTo","lineTo","stroke","Math","floor","PixelMap","undefined","Node","random","startNode","getRandomCell","buildConnection","push","gePath","result","count","lowestF","f","g","current","temp","previous","splice","indexOf","neighbor","includes","tempG","heuristic","z","a","b","d","distanceEuclidean","x0","y0","z0","x1","y1","z1","sqrt","title","min","max","type","text","defaultChecked"],"sourceRoot":""}