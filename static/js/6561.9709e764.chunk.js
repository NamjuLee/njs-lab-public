"use strict";(self.webpackChunkNJS_Lab=self.webpackChunkNJS_Lab||[]).push([[6561],{66561:function(r,t,o){o.r(t),o.d(t,{Solution:function(){return d}});var e=o(1250),n=o(5483),i=o.n(n),a=(o(43161),o(72791));class s{constructor(){let r=arguments.length>0&&void 0!==arguments[0]?arguments[0]:"custom",t=arguments.length>1?arguments[1]:void 0;this.type="custom",this.id=void 0,this.vertexSource="\n    precision highp float;\n    uniform mat4 u_matrix;\n    uniform float u_size;\n    attribute vec2 aPos;\n\n    varying vec2 position;\n    \n    void main() {\n        gl_Position = u_matrix * vec4(aPos, 0.0, 1.0);\n        gl_PointSize = u_size; \n        position = vec2(aPos.xy);\n    }",this.fragmentSource="\n    precision mediump float;\n\n    uniform vec4 u_color;\n    uniform vec4 u_stroke;\n\n    varying vec2 position;\n\n    void main() {\n        \n\n        float aRadius = 2.0;\n        float dist = distance(position, gl_FragCoord.xy);\n\n        // https://stackoverflow.com/questions/7237086/opengl-es-2-0-equivalent-for-es-1-0-circles-using-gl-point-smooth\n        float len = length(gl_PointCoord - vec2(0.5)) * 1.0;\n        float radius = 0.3;\n        float strokeWidth = 0.2;\n\n        if (len < radius) {\n            gl_FragColor = u_color;\n        } else if (len < radius + strokeWidth) {\n            gl_FragColor = u_stroke;\n        } else {\n            discard;\n        }\n    }",this.program=void 0,this.buffer=void 0,this.aPos=void 0,this.data=void 0,this.map=void 0,this.id=r,this.data=t}onAdd(r,t){this.map=r;const o=t.createShader(t.VERTEX_SHADER);t.shaderSource(o,this.vertexSource),t.compileShader(o);const e=t.createShader(t.FRAGMENT_SHADER);t.shaderSource(e,this.fragmentSource),t.compileShader(e),this.program=t.createProgram(),t.attachShader(this.program,o),t.attachShader(this.program,e),t.linkProgram(this.program),this.aPos=t.getAttribLocation(this.program,"aPos"),this.buffer=t.createBuffer(),t.bindBuffer(t.ARRAY_BUFFER,this.buffer),t.bufferData(t.ARRAY_BUFFER,this.data,t.STATIC_DRAW)}render(r,t){r.useProgram(this.program),console.log(Math.pow(2,this.map.transform.zoom)),r.uniform1f(r.getUniformLocation(this.program,"u_size"),5*Math.pow(2,this.map.transform.zoom)),r.uniform4fv(r.getUniformLocation(this.program,"u_color"),[1,1,0,1]),r.uniform4fv(r.getUniformLocation(this.program,"u_stroke"),[1,0,0,1]),r.uniformMatrix4fv(r.getUniformLocation(this.program,"u_matrix"),!1,t),r.bindBuffer(r.ARRAY_BUFFER,this.buffer),r.enableVertexAttribArray(this.aPos),r.vertexAttribPointer(this.aPos,2,r.FLOAT,!1,0,0),r.enable(r.BLEND),r.blendFunc(r.SRC_ALPHA,r.ONE_MINUS_SRC_ALPHA),r.drawArrays(r.POINTS,0,.5*this.data.length)}}class c{constructor(){let r=arguments.length>0&&void 0!==arguments[0]?arguments[0]:"custom";this.type="custom",this.id=void 0,this.vertexSource="\n    uniform mat4 u_matrix;\n    attribute vec2 aPos;\n    \n    uniform vec4 u_color;\n    // out vec4 vertexColor;\n\n    void main() {\n        gl_Position = u_matrix * vec4(aPos, 0.0, 1.0);\n        gl_PointSize = 5.0; \n    }",this.fragmentSource="\n    \n    // uniform vec4 u_color;\n\n    void main() {\n        gl_FragColor = vec4(1.0, 1.0, 0.0, 0.25);\n    }",this.program=void 0,this.buffer=void 0,this.aPos=void 0,this.id=r}onAdd(r,t){const o=t.createShader(t.VERTEX_SHADER);t.shaderSource(o,this.vertexSource),t.compileShader(o);const e=t.createShader(t.FRAGMENT_SHADER);t.shaderSource(e,this.fragmentSource),t.compileShader(e),this.program=t.createProgram(),t.attachShader(this.program,o),t.attachShader(this.program,e),t.linkProgram(this.program),this.aPos=t.getAttribLocation(this.program,"aPos");const n=i().MercatorCoordinate.fromLngLat({lng:25.004,lat:60.239}),a=i().MercatorCoordinate.fromLngLat({lng:13.403,lat:52.562}),s=i().MercatorCoordinate.fromLngLat({lng:30.498,lat:50.541});this.buffer=t.createBuffer(),t.bindBuffer(t.ARRAY_BUFFER,this.buffer),t.bufferData(t.ARRAY_BUFFER,new Float32Array([n.x,n.y,a.x,a.y,s.x,s.y]),t.STATIC_DRAW)}render(r,t){r.useProgram(this.program),r.uniformMatrix4fv(r.getUniformLocation(this.program,"u_matrix"),!1,t),r.uniform4fv(r.getUniformLocation(this.program,"u_color"),[1,0,0,1]),r.bindBuffer(r.ARRAY_BUFFER,this.buffer),r.enableVertexAttribArray(this.aPos),r.vertexAttribPointer(this.aPos,2,r.FLOAT,!1,0,0),r.enable(r.BLEND),r.blendFunc(r.SRC_ALPHA,r.ONE_MINUS_SRC_ALPHA),r.drawArrays(r.TRIANGLES,0,3)}}class u{constructor(r){this.map=void 0,this.map=r}init(){this.map.addLayer(new c("custom-01"),"building");const r=this.toMercators([25.004,60.239,0,0,1,1,2,2,3,3]);this.map.addLayer(new s("custom-02",r),"building"),this.map.on("click",(r=>{console.log(r);var t=this.map.queryRenderedFeatures(r.point,{layers:["custom-01"]});if(console.log(t),t.length>0){var o=t[0];console.log(o.properties)}}))}dispose(){}toMercator(r,t){return i().MercatorCoordinate.fromLngLat({lng:r,lat:t})}toMercators(r){const t=new Float32Array(r.length);for(let o=0;o<r.length;o+=2){const e=this.toMercator(r[o],r[o+1]);t[o]=e.x,t[o+1]=e.y}return t}}var h="style_mapContainer__BkMw2",l=o(80184),m=()=>{const r=(0,a.useRef)(null),t=(0,a.useRef)(null),o=(0,a.useRef)(null);return(0,a.useEffect)((()=>(t.current||(i().accessToken="pk.eyJ1IjoiZGVzaWduanUiLCJhIjoiY2xhNGU0YWo4MDlhYzNwdHBwenVvang4eiJ9.P3sX4l_3KjdPeRRbVS1VVg",t.current=new(i().Map)({container:r.current,style:"mapbox://styles/mapbox/dark-v11",center:[0,38],projection:"mercator",zoom:2,attributionControl:!1}),o.current=new u(t.current),t.current.on("load",(()=>{o.current.init()})),t.current.on("move",(()=>{}))),()=>{o.current.dispose()})),[]),(0,l.jsx)("div",{ref:r,className:h})};class d{constructor(r){const t=document.createElement("div");t.style.height="100%",r.appendChild(t);e.createRoot(t).render(a.createElement(m,{}))}destroy(){}}},43161:function(){}}]);
//# sourceMappingURL=6561.9709e764.chunk.js.map