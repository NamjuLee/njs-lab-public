"use strict";(self.webpackChunkNJS_Lab=self.webpackChunkNJS_Lab||[]).push([[4931],{64931:function(e,t,n){n.r(t),n.d(t,{Renderer:function(){return L},Solution:function(){return E}});var i=n(72791),o=n(67028);var s="undefined"!==typeof window?i.useLayoutEffect:i.useEffect;function r(e,t){for(;e;){if(e===t)return!0;e=Object.getPrototypeOf(e)}return!1}var a=n(50735),c=n(79966);const l={position:"absolute",zIndex:-1};function d(e,t){if("function"===typeof e)return e(t);if(Array.isArray(e))return e.map((e=>d(e,t)));if(u(e)){if(function(e){var t;return null===(t=e.props)||void 0===t?void 0:t.mapStyle}(e))return t.style=l,(0,i.cloneElement)(e,t);if(function(e){const t=e.type;return t&&t.deckGLViewProps}(e))return(0,i.cloneElement)(e,t)}return e}function u(e){return e&&"object"===typeof e&&"type"in e||!1}function g(e){if("function"===typeof e)return(0,i.createElement)(a.Z,{},e);if(Array.isArray(e))return e.map(g);if(u(e)){if(e.type===i.Fragment)return g(e.props.children);if(r(e.type,a.Z))return e}return e}const p={mixBlendMode:null};function h(e){e.redrawReason&&(e.deck._drawLayers(e.redrawReason),e.redrawReason=null)}const v=(0,i.forwardRef)(((e,t)=>{const[n,l]=(0,i.useState)(0),v=(0,i.useRef)({control:null,version:n,forceUpdate:()=>l((e=>e+1))}).current,f=(0,i.useRef)(null),m=(0,i.useRef)(null),x=(0,i.useMemo)((()=>function(e){let{children:t,layers:n=[],views:o=null}=e;const s=[],l=[],d={};return i.Children.forEach(g(t),(e=>{if(u(e)){const t=e.type;if(r(t,c.Z)){const n=function(e,t){const n={},i=e.defaultProps||{};for(const o in t)i[o]!==t[o]&&(n[o]=t[o]);return new e(n)}(t,e.props);l.push(n)}else s.push(e);if(r(t,a.Z)&&t!==a.Z&&e.props.id){const n=new t(e.props);d[n.id]=n}}else e&&s.push(e)})),Object.keys(d).length>0&&(Array.isArray(o)?o.forEach((e=>{d[e.id]=e})):o&&(d[o.id]=o),o=Object.values(d)),n=l.length>0?[...l,...n]:n,{layers:n,children:s,views:o}}(e)),[e.layers,e.views,e.children]);let w=!0;const y=t=>{var n;return w&&e.viewState?(v.viewStateUpdateRequested=t,null):(v.viewStateUpdateRequested=null,null===(n=e.onViewStateChange)||void 0===n?void 0:n.call(e,t))},P=t=>{var n;w?v.interactionStateUpdateRequested=t:(v.interactionStateUpdateRequested=null,null===(n=e.onInteractionStateChange)||void 0===n||n.call(e,t))},S=(0,i.useMemo)((()=>{const t={...e,style:null,width:"100%",height:"100%",parent:f.current,canvas:m.current,layers:x.layers,views:x.views,onViewStateChange:y,onInteractionStateChange:P};return delete t._customRender,v.deck&&v.deck.setProps(t),t}),[e]);(0,i.useEffect)((()=>{const t=e.Deck||o.Z;return v.deck=function(e,t,n){const i=new t({...n,_customRender:t=>{e.redrawReason=t;const n=i.getViewports();e.lastRenderedViewports!==n?e.forceUpdate():h(e)}});return i}(v,t,{...S,parent:f.current,canvas:m.current}),()=>{var e;return null===(e=v.deck)||void 0===e?void 0:e.finalize()}}),[]),s((()=>{h(v);const{viewStateUpdateRequested:e,interactionStateUpdateRequested:t}=v;e&&y(e),t&&P(t)})),(0,i.useImperativeHandle)(t,(()=>function(e){return{get deck(){return e.deck},pickObject:t=>e.deck.pickObject(t),pickMultipleObjects:t=>e.deck.pickMultipleObjects(t),pickObjects:t=>e.deck.pickObjects(t)}}(v)),[]);const _=v.deck&&v.deck.isInitialized?v.deck.getViewports():void 0,{ContextProvider:R,width:C,height:b,id:k,style:E}=e,{containerStyle:L,canvasStyle:T}=(0,i.useMemo)((()=>function(e){let{width:t,height:n,style:i}=e;const o={position:"absolute",zIndex:0,left:0,top:0,width:t,height:n},s={left:0,top:0};if(i)for(const r in i)r in p?s[r]=i[r]:o[r]=i[r];return{containerStyle:o,canvasStyle:s}}({width:C,height:b,style:E})),[C,b,E]);if(!v.viewStateUpdateRequested&&v.lastRenderedViewports===_||v.version!==n){v.lastRenderedViewports=_,v.version=n;const e=function(e){let{children:t,deck:n,ContextProvider:o}=e;const{viewManager:s}=n||{};if(!s||!s.views.length)return[];const c={},l=s.views[0].id;for(const i of t){let e=l,t=i;u(i)&&r(i.type,a.Z)&&(e=i.props.id||l,t=i.props.children);const n=s.getViewport(e),o=s.getViewState(e);if(n){o.padding=n.padding;const{x:i,y:s,width:r,height:a}=n;t=d(t,{x:i,y:s,width:r,height:a,viewport:n,viewState:o}),c[e]||(c[e]={viewport:n,children:[]}),c[e].children.push(t)}}return Object.keys(c).map((e=>{const{viewport:t,children:s}=c[e],{x:r,y:a,width:l,height:d}=t,u={position:"absolute",left:r,top:a,width:l,height:d},g="view-".concat(e),p=(0,i.createElement)("div",{key:g,id:g,style:u},...s);if(o){const s={viewport:t,container:n.canvas.offsetParent,eventManager:n.eventManager,onViewStateChange:t=>{t.viewId=e,n._onViewStateChange(t)}};return(0,i.createElement)(o,{key:g,value:s},p)}return p}))}({children:x.children,deck:v.deck,ContextProvider:R}),t=(0,i.createElement)("canvas",{key:"canvas",id:k||"deckgl-overlay",ref:m,style:T});v.control=(0,i.createElement)("div",{id:"".concat(k||"deckgl","-wrapper"),ref:f,style:L},[t,e])}return w=!1,v.control}));v.defaultProps=o.Z.defaultProps;var f=v,m=n(64572),x=n(38378),w=n(69323),y=n(56128),P=n(76501),S=n(90643);const _=[0,0,0,255],R={getSourcePosition:{type:"accessor",value:e=>e.sourcePosition},getTargetPosition:{type:"accessor",value:e=>e.targetPosition},getSourceColor:{type:"accessor",value:_},getTargetColor:{type:"accessor",value:_},getWidth:{type:"accessor",value:1},getHeight:{type:"accessor",value:1},getTilt:{type:"accessor",value:0},greatCircle:!1,widthUnits:"pixels",widthScale:{type:"number",value:1,min:0},widthMinPixels:{type:"number",value:0,min:0},widthMaxPixels:{type:"number",value:Number.MAX_SAFE_INTEGER,min:0}};class C extends c.Z{constructor(){super(...arguments),(0,m.Z)(this,"state",void 0)}getBounds(){var e;return null===(e=this.getAttributeManager())||void 0===e?void 0:e.getBounds(["instanceSourcePositions","instanceTargetPositions"])}getShaders(){return super.getShaders({vs:"#define SHADER_NAME arc-layer-vertex-shader\n\nattribute vec3 positions;\nattribute vec4 instanceSourceColors;\nattribute vec4 instanceTargetColors;\nattribute vec3 instanceSourcePositions;\nattribute vec3 instanceSourcePositions64Low;\nattribute vec3 instanceTargetPositions;\nattribute vec3 instanceTargetPositions64Low;\nattribute vec3 instancePickingColors;\nattribute float instanceWidths;\nattribute float instanceHeights;\nattribute float instanceTilts;\n\nuniform bool greatCircle;\nuniform bool useShortestPath;\nuniform float numSegments;\nuniform float opacity;\nuniform float widthScale;\nuniform float widthMinPixels;\nuniform float widthMaxPixels;\nuniform int widthUnits;\n\nvarying vec4 vColor;\nvarying vec2 uv;\nvarying float isValid;\n\nfloat paraboloid(float distance, float sourceZ, float targetZ, float ratio) {\n\n  float deltaZ = targetZ - sourceZ;\n  float dh = distance * instanceHeights;\n  if (dh == 0.0) {\n    return sourceZ + deltaZ * ratio;\n  }\n  float unitZ = deltaZ / dh;\n  float p2 = unitZ * unitZ + 1.0;\n  float dir = step(deltaZ, 0.0);\n  float z0 = mix(sourceZ, targetZ, dir);\n  float r = mix(ratio, 1.0 - ratio, dir);\n  return sqrt(r * (p2 - r)) * dh + z0;\n}\nvec2 getExtrusionOffset(vec2 line_clipspace, float offset_direction, float width) {\n  vec2 dir_screenspace = normalize(line_clipspace * project_uViewportSize);\n  dir_screenspace = vec2(-dir_screenspace.y, dir_screenspace.x);\n\n  return dir_screenspace * offset_direction * width / 2.0;\n}\n\nfloat getSegmentRatio(float index) {\n  return smoothstep(0.0, 1.0, index / (numSegments - 1.0));\n}\n\nvec3 interpolateFlat(vec3 source, vec3 target, float segmentRatio) {\n  float distance = length(source.xy - target.xy);\n  float z = paraboloid(distance, source.z, target.z, segmentRatio);\n\n  float tiltAngle = radians(instanceTilts);\n  vec2 tiltDirection = normalize(target.xy - source.xy);\n  vec2 tilt = vec2(-tiltDirection.y, tiltDirection.x) * z * sin(tiltAngle);\n\n  return vec3(\n    mix(source.xy, target.xy, segmentRatio) + tilt,\n    z * cos(tiltAngle)\n  );\n}\nfloat getAngularDist (vec2 source, vec2 target) {\n  vec2 sourceRadians = radians(source);\n  vec2 targetRadians = radians(target);\n  vec2 sin_half_delta = sin((sourceRadians - targetRadians) / 2.0);\n  vec2 shd_sq = sin_half_delta * sin_half_delta;\n\n  float a = shd_sq.y + cos(sourceRadians.y) * cos(targetRadians.y) * shd_sq.x;\n  return 2.0 * asin(sqrt(a));\n}\n\nvec3 interpolateGreatCircle(vec3 source, vec3 target, vec3 source3D, vec3 target3D, float angularDist, float t) {\n  vec2 lngLat;\n  if(abs(angularDist - PI) < 0.001) {\n    lngLat = (1.0 - t) * source.xy + t * target.xy;\n  } else {\n    float a = sin((1.0 - t) * angularDist);\n    float b = sin(t * angularDist);\n    vec3 p = source3D.yxz * a + target3D.yxz * b;\n    lngLat = degrees(vec2(atan(p.y, -p.x), atan(p.z, length(p.xy))));\n  }\n\n  float z = paraboloid(angularDist * EARTH_RADIUS, source.z, target.z, t);\n\n  return vec3(lngLat, z);\n}\n\nvoid main(void) {\n  geometry.worldPosition = instanceSourcePositions;\n  geometry.worldPositionAlt = instanceTargetPositions;\n\n  float segmentIndex = positions.x;\n  float segmentRatio = getSegmentRatio(segmentIndex);\n  float prevSegmentRatio = getSegmentRatio(max(0.0, segmentIndex - 1.0));\n  float nextSegmentRatio = getSegmentRatio(min(numSegments - 1.0, segmentIndex + 1.0));\n  float indexDir = mix(-1.0, 1.0, step(segmentIndex, 0.0));\n  isValid = 1.0;\n\n  uv = vec2(segmentRatio, positions.y);\n  geometry.uv = uv;\n  geometry.pickingColor = instancePickingColors;\n\n  vec4 curr;\n  vec4 next;\n  vec3 source;\n  vec3 target;\n\n  if ((greatCircle || project_uProjectionMode == PROJECTION_MODE_GLOBE) && project_uCoordinateSystem == COORDINATE_SYSTEM_LNGLAT) {\n    source = project_globe_(vec3(instanceSourcePositions.xy, 0.0));\n    target = project_globe_(vec3(instanceTargetPositions.xy, 0.0));\n    float angularDist = getAngularDist(instanceSourcePositions.xy, instanceTargetPositions.xy);\n\n    vec3 prevPos = interpolateGreatCircle(instanceSourcePositions, instanceTargetPositions, source, target, angularDist, prevSegmentRatio);\n    vec3 currPos = interpolateGreatCircle(instanceSourcePositions, instanceTargetPositions, source, target, angularDist, segmentRatio);\n    vec3 nextPos = interpolateGreatCircle(instanceSourcePositions, instanceTargetPositions, source, target, angularDist, nextSegmentRatio);\n\n    if (abs(currPos.x - prevPos.x) > 180.0) {\n      indexDir = -1.0;\n      isValid = 0.0;\n    } else if (abs(currPos.x - nextPos.x) > 180.0) {\n      indexDir = 1.0;\n      isValid = 0.0;\n    }\n    nextPos = indexDir < 0.0 ? prevPos : nextPos;\n    nextSegmentRatio = indexDir < 0.0 ? prevSegmentRatio : nextSegmentRatio;\n\n    if (isValid == 0.0) {\n      nextPos.x += nextPos.x > 0.0 ? -360.0 : 360.0;\n      float t = ((currPos.x > 0.0 ? 180.0 : -180.0) - currPos.x) / (nextPos.x - currPos.x);\n      currPos = mix(currPos, nextPos, t);\n      segmentRatio = mix(segmentRatio, nextSegmentRatio, t);\n    }\n\n    vec3 currPos64Low = mix(instanceSourcePositions64Low, instanceTargetPositions64Low, segmentRatio);\n    vec3 nextPos64Low = mix(instanceSourcePositions64Low, instanceTargetPositions64Low, nextSegmentRatio);\n  \n    curr = project_position_to_clipspace(currPos, currPos64Low, vec3(0.0), geometry.position);\n    next = project_position_to_clipspace(nextPos, nextPos64Low, vec3(0.0));\n  \n  } else {\n    vec3 source_world = instanceSourcePositions;\n    vec3 target_world = instanceTargetPositions;\n    if (useShortestPath) {\n      source_world.x = mod(source_world.x + 180., 360.0) - 180.;\n      target_world.x = mod(target_world.x + 180., 360.0) - 180.;\n\n      float deltaLng = target_world.x - source_world.x;\n      if (deltaLng > 180.) target_world.x -= 360.;\n      if (deltaLng < -180.) source_world.x -= 360.;\n    }\n    source = project_position(source_world, instanceSourcePositions64Low);\n    target = project_position(target_world, instanceTargetPositions64Low);\n    float antiMeridianX = 0.0;\n\n    if (useShortestPath) {\n      if (project_uProjectionMode == PROJECTION_MODE_WEB_MERCATOR_AUTO_OFFSET) {\n        antiMeridianX = -(project_uCoordinateOrigin.x + 180.) / 360. * TILE_SIZE;\n      }\n      float thresholdRatio = (antiMeridianX - source.x) / (target.x - source.x);\n\n      if (prevSegmentRatio <= thresholdRatio && nextSegmentRatio > thresholdRatio) {\n        isValid = 0.0;\n        indexDir = sign(segmentRatio - thresholdRatio);\n        segmentRatio = thresholdRatio;\n      }\n    }\n\n    nextSegmentRatio = indexDir < 0.0 ? prevSegmentRatio : nextSegmentRatio;\n    vec3 currPos = interpolateFlat(source, target, segmentRatio);\n    vec3 nextPos = interpolateFlat(source, target, nextSegmentRatio);\n\n    if (useShortestPath) {\n      if (nextPos.x < antiMeridianX) {\n        currPos.x += TILE_SIZE;\n        nextPos.x += TILE_SIZE;\n      }\n    }\n\n    curr = project_common_position_to_clipspace(vec4(currPos, 1.0));\n    next = project_common_position_to_clipspace(vec4(nextPos, 1.0));\n    geometry.position = vec4(currPos, 1.0);\n  }\n  float widthPixels = clamp(\n    project_size_to_pixel(instanceWidths * widthScale, widthUnits),\n    widthMinPixels, widthMaxPixels\n  );\n  vec3 offset = vec3(\n    getExtrusionOffset((next.xy - curr.xy) * indexDir, positions.y, widthPixels),\n    0.0);\n  DECKGL_FILTER_SIZE(offset, geometry);\n  DECKGL_FILTER_GL_POSITION(curr, geometry);\n  gl_Position = curr + vec4(project_pixel_size_to_clipspace(offset.xy), 0.0, 0.0);\n\n  vec4 color = mix(instanceSourceColors, instanceTargetColors, segmentRatio);\n  vColor = vec4(color.rgb, color.a * opacity);\n  DECKGL_FILTER_COLOR(vColor, geometry);\n}\n",fs:"#define SHADER_NAME arc-layer-fragment-shader\n\nprecision highp float;\n\nvarying vec4 vColor;\nvarying vec2 uv;\nvarying float isValid;\n\nvoid main(void) {\n  if (isValid == 0.0) {\n    discard;\n  }\n\n  gl_FragColor = vColor;\n  geometry.uv = uv;\n\n  DECKGL_FILTER_COLOR(gl_FragColor, geometry);\n}\n",modules:[x.Z,w.Z]})}get wrapLongitude(){return!1}initializeState(){this.getAttributeManager().addInstanced({instanceSourcePositions:{size:3,type:5130,fp64:this.use64bitPositions(),transition:!0,accessor:"getSourcePosition"},instanceTargetPositions:{size:3,type:5130,fp64:this.use64bitPositions(),transition:!0,accessor:"getTargetPosition"},instanceSourceColors:{size:this.props.colorFormat.length,type:5121,normalized:!0,transition:!0,accessor:"getSourceColor",defaultValue:_},instanceTargetColors:{size:this.props.colorFormat.length,type:5121,normalized:!0,transition:!0,accessor:"getTargetColor",defaultValue:_},instanceWidths:{size:1,transition:!0,accessor:"getWidth",defaultValue:1},instanceHeights:{size:1,transition:!0,accessor:"getHeight",defaultValue:1},instanceTilts:{size:1,transition:!0,accessor:"getTilt",defaultValue:0}})}updateState(e){if(super.updateState(e),e.changeFlags.extensionsChanged){var t;const{gl:e}=this.context;null===(t=this.state.model)||void 0===t||t.delete(),this.state.model=this._getModel(e),this.getAttributeManager().invalidateAll()}}draw(e){let{uniforms:t}=e;const{widthUnits:n,widthScale:i,widthMinPixels:o,widthMaxPixels:s,greatCircle:r,wrapLongitude:a}=this.props;this.state.model.setUniforms(t).setUniforms({greatCircle:r,widthUnits:y.iI[n],widthScale:i,widthMinPixels:o,widthMaxPixels:s,useShortestPath:a}).draw()}_getModel(e){let t=[];for(let i=0;i<50;i++)t=t.concat([i,1,0,i,-1,0]);const n=new P.Z(e,{...this.getShaders(),id:this.props.id,geometry:new S.Z({drawMode:5,attributes:{positions:new Float32Array(t)}}),isInstanced:!0});return n.setUniforms({numSegments:50}),n}}(0,m.Z)(C,"layerName","ArcLayer"),(0,m.Z)(C,"defaultProps",R);class b{constructor(e){this.map=void 0,this.deckLayer=void 0,this.downloadImage=()=>{const e=this.map.getCanvas();console.log(e),console.log(this.deckLayer.deck.canvas);let t=document.createElement("canvas");t.width=e.width,t.height=e.height,t.getContext("2d").drawImage(this.deckLayer.deck.canvas,0,0);var n=document.createElement("a");n.download="filename.jpg",n.href=t.toDataURL(),n.click()},this.center=function(){},this.toMap=(e,t)=>{},this.toScreen=(e,t)=>{},this.mouseDown=e=>{},this.mouseUp=e=>{},this.mouseMove=e=>{},this.mouseClick=e=>{},this.mouseDClick=e=>{this.downloadImage()},this.initMap(e)}initMap(e){document.getElementById(e);const t=new f({container:"id",mapboxApiAccessToken:"pk.eyJ1IjoiZGVzaWduanUiLCJhIjoiY2xhNGU0YWo4MDlhYzNwdHBwenVvang4eiJ9.P3sX4l_3KjdPeRRbVS1VVg",mapStyle:"mapbox://styles/mapbox/dark-v9",longitude:-122.45,latitude:37.8,zoom:11,pitch:30,layers:[new C({data:[{pickup:[-122.42,37.8],dropoff:[-122.48,37.76]},{pickup:[-122.43,37.8],dropoff:[-122.42,37.75]}],getSourcePosition:e=>e.pickup,getTargetPosition:e=>e.dropoff,getSourceColor:e=>[255,128,0],getTargetColor:e=>[0,128,255],strokeWidth:5})],onClick:console.log});console.log(t)}}var k=n(55913);class E{constructor(e){this.divHost=void 0,this.mapboxWrapper=void 0,this.renderer=void 0,this.mouseDown=e=>{},this.mouseUp=e=>{},this.mouseDrag=e=>{},this.mouseClick=e=>{console.log(e),console.log(e.lngLat)},this.mouseMove=e=>{},this.divHost=e,this.divHost.style.position="relative",this.mapboxWrapper=new b(this.divHost.id)}keyDown(e){}destroy(){for(this.renderer.destroy();this.divHost.lastElementChild;)this.divHost.removeChild(this.divHost.lastElementChild)}}class L extends k.bb{constructor(e,t){super(e),this.app=void 0,this.time=0,this.pts=[],this.mouseDown=(e,t)=>{},this.mouseUp=(e,t)=>{},this.mouseDrag=(e,t)=>{},this.app=t,this.canvas.id="mapboxCustom",this.canvas.style.position="absolute",this.canvas.style.width="100%",this.canvas.style.height="100%",this.canvas.style.pointerEvents="none",this.pts.push([-71.093161,42.358871]),this.start()}render(e){}}}}]);
//# sourceMappingURL=4931.e5e54169.chunk.js.map