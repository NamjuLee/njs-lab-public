{"version":3,"file":"static/js/6759.1678dd13.chunk.js","mappings":"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","sources":["njslab/Project/Project_03_SlowZone/01_JSAPI/Tint/FilterGLViewDarkForDarken.ts","njslab/Project/Project_03_SlowZone/PolygonInteraction/index.ts"],"sourcesContent":["import { NVector3, GLShaderCommon } from '../../../../../lib/NJSCore';\n\n// import { Mat3 } from '../../AppCore/GLUtility/Mat3';\n\nexport class FilterGLViewDarkForDarken {\n\n    gl: WebGLRenderingContext;\n    program: WebGLProgram;\n    fragmentShader: WebGLShader;\n    vertexShader: WebGLShader;\n    matrixLocation: WebGLProgram;\n    posBuffer: WebGLBuffer;\n    colBuffer: WebGLBuffer;\n    vertexs: Float32Array;\n\n    posLocAtt: number;\n    colLocAtt: number;\n    matLoc: WebGLUniformLocation;\n    colLoc: WebGLUniformLocation;\n    cVecLoc: WebGLUniformLocation;\n    mouseLoc: WebGLUniformLocation;\n    timeGL: WebGLUniformLocation;\n    // startTime: number;\n    // randomSeed: number;\n\n    vShader: WebGLShader;\n    fShader: WebGLShader;\n\n    v = `\n    attribute vec2 a_position;\n    attribute vec4 a_color;\n    \n    varying vec4 f_color;\n\n    void main() {\n\n        vec2 mouse_distance = vec2(0,0) - (a_position.xy /vec2(2,2));\n        float red = 1.0 - length(mouse_distance);\n        f_color = vec4(a_position, 0, 1.0);\n    \n        // float dis = distance(vec2(a_position.xy), vec2(0,0));\n\n        // f_color = vec4(dis * 0.6, 0,0,1);\n        gl_Position = vec4( a_position, 0, 1);\n    }\n    `;\n\n    f = `\n    precision highp float;\n\n    varying vec4 f_color;\n    \n    void main() {\n        vec2 mouse_distance = vec2(0,0) - (f_color.xy /vec2(5,5));\n\n        float col =  length(mouse_distance*5.);\n        float val = 1.0 - length(mouse_distance*8.);\n        \n        gl_FragColor = vec4(0.19,0.19,0.19, col);\n\n    }\n    `;\n\n    positionAttribLocation: WebGLProgram;\n    colorAttribLocation: WebGLProgram;\n    translation: NVector3;\n    color: number[];\n    colArray: Float32Array;\n\n    constructor(gl: WebGLRenderingContext, xt: number = 100, yt: number = 100, zt: number = 0, xs: number = 1, ys: number = 1, zs: number = 1) {\n        this.gl = gl;\n        // this.translation = new NVector3(xt, yt, zt);\n        // this.angleInRadians = 0;\n        // this.scale = new NVector3(xs, ys, zs);\n        this.color = [Math.random(), Math.random(), Math.random(), 1];\n        this.InitShader();\n    }\n    InitShader() {\n        // let vShader = GLUtility.CreateShaderFromPath(this.gl, this.gl.VERTEX_SHADER,'/shader/vsCanvas.glsl');\n        // let fShader = GLUtility.CreateShaderFromPath(this.gl, this.gl.FRAGMENT_SHADER, '/shader/fsColor.glsl');\n\n        let vShader = GLShaderCommon.CreateShader(this.gl, this.gl.VERTEX_SHADER, this.v); // '/shader/vsCanvas.glsl');\n        let fShader = GLShaderCommon.CreateShader(this.gl, this.gl.FRAGMENT_SHADER, this.f); // '/shader/fsColor.glsl');\n\n        if (vShader && fShader) {\n            this.vShader = vShader;\n            this.fShader = fShader;\n            let program = GLShaderCommon.CreateProgram(this.gl, vShader, fShader);\n            if (program) { this.program = program; }\n        }\n\n        // this.InitVerext();\n    }\n    Render(gl: WebGLRenderingContext) {\n\n        let col = [0.1, 0, 0, 1];\n\n        this.vertexs = new Float32Array([\n            // left column\n            -1, -1, 1, 1, 1, 1,\n            - 1, 1, col[0], col[1], col[2], col[3],\n            1, -1, col[0], col[1], col[2], col[3],\n\n            -1, 1, 1, 1, 1, 1,\n            1, -1, col[0], col[1], col[2], col[3],\n            1, 1, col[0], col[1], col[2], col[3],\n\n        ]);\n\n        this.posBuffer = this.gl.createBuffer() as WebGLBuffer;\n        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.posBuffer);\n        this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(this.vertexs), gl.STATIC_DRAW);\n\n        this.posLocAtt = this.gl.getAttribLocation(this.program, 'a_position');\n        // Tell the attribute how to get data out of posBuffer (ARRAY_BUFFER)\n        let size = 2;          // 2 components per iteration\n        let type = gl.FLOAT;   // the data is 32bit floats\n        let normalize = false; // don't normalize the data\n        let stride = 6 * Float32Array.BYTES_PER_ELEMENT; // 0 = move forward size * sizeof(type) each iteration to get the next position\n        let offset = 0;        // start at the beginning of the buffer\n        gl.vertexAttribPointer(this.posLocAtt, size, type, normalize, stride, offset);\n        gl.enableVertexAttribArray(this.posLocAtt);\n\n        // this.colLocAtt = this.gl.getAttribLocation(this.program, 'a_color');\n        // size = 4;          // 2 components per iteration\n        // type = gl.FLOAT;   // the data is 32bit floats\n        // normalize = false; // don't normalize the data\n        // stride = 6 * Float32Array.BYTES_PER_ELEMENT; // 0 = move forward size * sizeof(type) each iteration to get the next position\n        // offset = 2 * Float32Array.BYTES_PER_ELEMENT;        // start at the beginning of the buffer\n        // gl.vertexAttribPointer(this.colLocAtt, size, type, normalize, stride, offset);\n        // gl.enableVertexAttribArray(this.colLocAtt);\n\n        gl.useProgram(this.program);\n        let primitiveType = gl.TRIANGLES; // LINE_LOOP; // gl.TRIANGLE_STRIP;\n        offset = 0;\n        let count = 6; // this.vertexs.length * 0.5;\n        gl.drawArrays(primitiveType, offset, count);\n\n    }\n}","import * as THREE from 'three';\r\nimport { RendererThree, MercatorProjection, } from '../../../../lib';\r\nimport { getJSONFromURL, } from 'njscore';\r\n\r\nimport { FilterGLViewDarkForDarken } from '../01_JSAPI/Tint/FilterGLViewDarkForDarken';\r\n\r\nexport class Solution extends RendererThree {\r\n\r\n    streetOSM: any = [];\r\n    routesTreated: any = [];\r\n    routesControl: any = [];\r\n    zones30: any = [];\r\n\r\n    constructor(id: string = 'main') {\r\n        super(id)\r\n\r\n        const light = new THREE.PointLight(0xffffff, 0.8);\r\n        this.camera.add(light);\r\n        this.scene.add(light);\r\n\r\n        const canvasGL = document.createElement('canvas');\r\n        canvasGL.style.position = 'absolute';\r\n        canvasGL.style.pointerEvents = 'none';\r\n        canvasGL.style.mixBlendMode = 'darken';\r\n        canvasGL.width = this.hostDiv.clientWidth;\r\n        canvasGL.height = this.hostDiv.clientHeight;\r\n        this.hostDiv.appendChild(canvasGL);\r\n        const glCtx = canvasGL.getContext('webgl');\r\n        const d = new FilterGLViewDarkForDarken(glCtx, 0.5, 5)\r\n        d.Render(glCtx);\r\n\r\n\r\n        this.camera.position.set(0, 40, 48);\r\n\r\n        const path = '/static/research/slow-zone/';\r\n        getJSONFromURL(process.env.PUBLIC_URL + path + 'street_osm.geojson').then((data) => {\r\n            for (let i = 0; i < data['features'].length; ++i) {\r\n                this.streetOSM.push(data['features'][i]['geometry']['coordinates']);\r\n            }\r\n            renderLines(this.scene, this.streetOSM, [0, 1, 1]);\r\n            renderPoints(this.scene, this.streetOSM, [0, 1, 1]);\r\n\r\n\r\n            getJSONFromURL(process.env.PUBLIC_URL + path + 'treated-st.geojson').then((data) => {\r\n                for (let i = 0; i < data['features'].length; ++i) {\r\n                    this.routesTreated.push(data['features'][i]['geometry']['coordinates']);\r\n                }\r\n                renderLines(this.scene, this.routesTreated, [1, 0, 0]);\r\n            });\r\n\r\n            getJSONFromURL(process.env.PUBLIC_URL + path + 'control-st.geojson').then((data) => {\r\n                for (let i = 0; i < data['features'].length; ++i) {\r\n                    this.routesControl.push(data['features'][i]['geometry']['coordinates']);\r\n                }\r\n                renderLines(this.scene, this.routesControl, [0, 1, 0]);\r\n            });\r\n\r\n            getJSONFromURL(process.env.PUBLIC_URL + path + 'zones-30.geojson').then((data) => {\r\n                for (let i = 0; i < data['features'].length; ++i) {\r\n                    this.zones30.push(data['features'][i]['geometry']['coordinates']);\r\n                }\r\n                renderMultiPolygon(this.scene, this.zones30, [0, 1, 0]);\r\n\r\n            });\r\n\r\n\r\n            this.start();\r\n        });\r\n    }\r\n\r\n    public update(scene: THREE.Scene) {\r\n        // console.log('dddd');\r\n\r\n    }\r\n\r\n}\r\n\r\nconst renderMultiPolygon = (scene: THREE.Scene, paths: any, colorArray: number[]) => {\r\n    // if (multiPolygons === undefined) return;\r\n\r\n    const xOFf = -15478803.88731685;\r\n    const yOFf = -4766681.448690384;\r\n    const scale = 0.01;\r\n\r\n    // const geometry = new THREE.BufferGeometry();\r\n    // const material = new THREE.MeshBasicMaterial( { vertexColors: true } );\r\n\r\n    const positions = [];\r\n\r\n\r\n    for (let multi = 0; multi < paths.length; ++multi) {\r\n        const multiPolygon = paths[multi];\r\n\r\n        for (let polyI = 0; polyI < multiPolygon.length; ++polyI) {\r\n            const polygon = multiPolygon[polyI];\r\n\r\n\r\n\r\n            if (polygon.length === 1) {\r\n                const thePolygon = polygon[0];\r\n\r\n                const shape = [];\r\n\r\n                for (let i = 0; i < thePolygon.length; ++i) {\r\n\r\n                    const [xPro, yPro] = MercatorProjection(thePolygon[i][0], thePolygon[i][1]);\r\n\r\n                    const x = (xPro + xOFf) * scale\r\n                    const y = (yPro + yOFf) * scale\r\n                    // console.log(x, y)\r\n                    positions.push(x, 0, y)\r\n\r\n                    shape.push(new THREE.Vector2(x, y));\r\n                }\r\n\r\n\r\n                let geometry = new THREE.ShapeGeometry(new THREE.Shape(shape));\r\n                let mat = new THREE.MeshBasicMaterial({\r\n                    side: THREE.DoubleSide, color: 0x00ff00,\r\n                    transparent: true,\r\n                    opacity: 0.3\r\n                });\r\n                let mesh = new THREE.Mesh(geometry, mat);\r\n                scene.add(mesh);\r\n                mesh.rotateOnAxis(new THREE.Vector3(1, 0, 0), Math.PI * 0.5);\r\n\r\n\r\n            }\r\n        }\r\n    }\r\n\r\n\r\n};\r\n\r\n\r\nconst renderPoints = (scene: THREE.Scene, paths: any, color: number[]) => {\r\n    const geometry = new THREE.BufferGeometry();\r\n    const material = new THREE.PointsMaterial({ vertexColors: true, size: 0.5 });\r\n\r\n    const positions = [];\r\n    const colors = [];\r\n\r\n\r\n    const xOFf = -15478803.88731685;\r\n    const yOFf = -4766681.448690384;\r\n    const scale = 0.01;\r\n\r\n\r\n    for (let i = 0; i < paths.length; ++i) {\r\n        const route = paths[i]\r\n\r\n        for (let j = 0; j < route.length; ++j) {\r\n            for (let k = 0; k < route[j].length; ++k) {\r\n\r\n                const [xPro, yPro] = MercatorProjection(route[j][k][0], route[j][k][1]);\r\n\r\n                const x = (xPro + xOFf) * scale\r\n                const y = (yPro + yOFf) * scale\r\n\r\n                positions.push(x, 0, y)\r\n\r\n                colors.push(color[0], color[1], color[2]);\r\n\r\n\r\n            }\r\n        }\r\n    }\r\n\r\n    geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));\r\n    geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));\r\n    // generateMorphTargets( geometry );\r\n\r\n    geometry.computeBoundingSphere();\r\n\r\n    const line = new THREE.Points(geometry, material);\r\n    scene.add(line);\r\n\r\n\r\n}\r\n\r\nconst renderLines = (scene: THREE.Scene, paths: any, color: number[]) => {\r\n\r\n    const geometry = new THREE.BufferGeometry();\r\n    // const material = new THREE.PointsMaterial( { vertexColors: true, size: 0.1 } );\r\n    const material = new THREE.LineBasicMaterial({ vertexColors: true });\r\n\r\n    const positions = [];\r\n    const colors = [];\r\n    const indices = [];\r\n\r\n    const xOFf = -15478803.88731685;\r\n    const yOFf = -4766681.448690384;\r\n    const scale = 0.01;\r\n\r\n\r\n    let xC = 0\r\n    let yC = 0\r\n    let Count = 0\r\n\r\n    for (let i = 0; i < paths.length; ++i) {\r\n        const route = paths[i]\r\n\r\n        for (let j = 0; j < route.length; ++j) {\r\n            for (let k = 0; k < route[j].length; ++k) {\r\n\r\n                const [xPro, yPro] = MercatorProjection(route[j][k][0], route[j][k][1]);\r\n                xC += xPro;\r\n                yC += yPro;\r\n                Count += 1;\r\n\r\n                const x = (xPro + xOFf) * scale\r\n                const y = (yPro + yOFf) * scale\r\n                // console.log(x, y)\r\n                positions.push(x, 0, y)\r\n\r\n                colors.push(color[0], color[1], color[2]);\r\n\r\n                if (k < route[j].length - 1) {\r\n                    indices.push(Math.floor(positions.length / 3) - 1, Math.floor(positions.length / 3));\r\n                }\r\n            }\r\n        }\r\n    }\r\n    console.log(xC / Count, yC / Count, Count)\r\n    geometry.setIndex(indices);\r\n    geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));\r\n    geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));\r\n    // generateMorphTargets( geometry );\r\n\r\n    geometry.computeBoundingSphere();\r\n\r\n    const line = new THREE.LineSegments(geometry, material);\r\n    scene.add(line);\r\n};"],"names":["FilterGLViewDarkForDarken","gl","program","fragmentShader","vertexShader","matrixLocation","posBuffer","colBuffer","vertexs","posLocAtt","colLocAtt","matLoc","colLoc","cVecLoc","mouseLoc","timeGL","vShader","fShader","v","f","positionAttribLocation","colorAttribLocation","translation","color","colArray","this","Math","random","InitShader","GLShaderCommon","VERTEX_SHADER","FRAGMENT_SHADER","col","Float32Array","createBuffer","bindBuffer","ARRAY_BUFFER","bufferData","STATIC_DRAW","getAttribLocation","type","FLOAT","stride","BYTES_PER_ELEMENT","offset","vertexAttribPointer","enableVertexAttribArray","useProgram","primitiveType","TRIANGLES","drawArrays","Solution","id","streetOSM","routesTreated","routesControl","zones30","light","THREE","camera","add","scene","canvasGL","document","createElement","style","position","pointerEvents","mixBlendMode","width","hostDiv","clientWidth","height","clientHeight","appendChild","glCtx","getContext","d","Render","set","path","getJSONFromURL","process","then","data","i","length","push","renderLines","renderPoints","renderMultiPolygon","start","RendererThree","paths","colorArray","positions","multi","multiPolygon","polyI","polygon","thePolygon","shape","MercatorProjection","x","y","geometry","mat","side","transparent","opacity","mesh","rotateOnAxis","PI","material","vertexColors","size","colors","route","j","k","setAttribute","computeBoundingSphere","line","indices","xC","yC","Count","xPro","yPro","floor","console","log","setIndex"],"sourceRoot":""}