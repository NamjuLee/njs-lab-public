{"version":3,"file":"static/js/382.06f0140f.chunk.js","mappings":"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DAGQF,EAAqB,0BACZ,IAA5BC,EAA6B,qbAiB/BC,EAAa,gCACwB,IAA5BD,EAA6B,2bAetCC,EAAa,gCACwB,IAA5BD,EAA6B,sfAetCC,EAAa,0CAvHD,WAyHO,oBAG7B,ECnDK,MC8ED+9B,GAAgC,CACpCv5B,GACAE,GACAE,GACAG,GACAK,GACAO,GACAS,GACAI,GACA2B,GACAG,GACAG,GACAG,GACAG,GACAG,GACAG,GACAkC,GACAM,GACAU,GACAI,GACAE,GACAW,GACAqB,GACAY,GACAG,GACAW,GACAK,GACAG,GACAnV,GACA2V,GACAgC,GACAqC,GACAS,GACAE,GACAE,GACAE,GACAE,GACAG,GACAG,GACAsB,GACAmB,GACAE,GACAE,GACAS,GACAQ,GACAK,GACAE,GACAG,GACAI,GACAE,GACAgB,GACAE,GACAG,GACAE,GACAE,GACAE,GACAG,GACAc,GACAG,GACAG,GACAG,GACAE,GACAI,GACAc,GACAK,GACAK,GACAe,GACAG,GACAE,GACAlnB,GACAmnB,GACArQ,GACAwQ,GACAG,GACAE,GACAlnB,GACAqnB,GACAE,GACAC,GACAE,GACAE,GACAG,GACAG,GACAG,GACAU,GACAI,GACAO,GACAG,GACAC,GACAG,GACAI,GACAK,GACAK,GACAK,GACAO,GACAG,GACAQ,GACAG,GACAqB,GACAzqB,GACAgrB,GACAE,GACAU,GACAK,GACAjb,GACA4b,GACAK,GACAG,GACAS,GACAG,GACAhxB,GACAkxB,GACAC,GACAS,GACAO,GACAO,GACAze,GACAyY,GACAmG,GACAG,GACAG,GACA/vB,GACA4wB,GACAe,GACAK,GACAG,GACAa,GACAM,GACAO,GACAG,GACAW,GACAQ,GACAS,GACAG,GACAG,GACAC,GACAE,GACAG,GACApnB,GACA+a,GACAwM,GACAE,GACAQ,GACAI,GACAI,GACAK,GACAE,GACAK,GACAM,GACAE,GACAI,GACAC,GACAM,GACAe,GACAG,GACAI,GACAvR,GACA9mB,GACAw4B,GACAG,GACAK,GACAO,GACAsB,GACAz6B,GACA46B,GACAE,GDnPoD,CACpDhiC,WAAYyiC,EAAAA,mBACZxiC,YAAa,QACbC,WArFI,SAA6Bl1B,GAKjC,MAAM,OAACxR,EAAM,QAAEyR,EAAO,MAAE0B,GAAS3B,GAC3B,EAAC3Z,EAAC,WAAE8xB,GAAc3pB,GAClB,YAAC6oE,GAAe11D,EAEhByI,EAAQ/jB,EAAExN,MAAMkE,OAEhB8rD,EAAY,GAElB,IAAIzqB,EAAO,EACX,MAAM40B,EAAchtD,EAAAA,aAAAA,mBAAgC,CAACo4B,GAAOhU,GAC5D,IAAI21B,EAAY15C,EACG,MAAf2sD,IACFjT,EAAY/D,GAAU,CAACxtC,OAAQ,CAACnI,KAAI4Z,UAAS0B,MAAO,CAACwI,KAAM6oC,KAC3DnK,EAAUpiD,KAAKs5C,GACf3hB,EAAOp4B,EAAAA,aAAAA,iBAA8B,EAAGokB,GAAO,IAGjD,MAAMxiB,EAAW5B,EAAAA,aAAAA,aAAAA,gBACb+5C,EAAUlnD,MAAOulC,EAAMi5C,GACrBtpE,EAAShV,EAAAA,KAAAA,cAAmB,CAACgnD,EAAUlnD,MAAMulC,KAC7C4hB,EACFvsB,GAAQ,CAACjlB,OAAQ,CAACnI,EAAG05C,GAAY9/B,UAAS0B,MAAO,CAAC9oB,MAAO,EAAE,EAAGkV,MAClE86C,EAAUpiD,KAAKu5C,GAEf,MAAM03B,GAAc97B,EAAAA,EAAAA,YAAWv1C,EAAElD,OAE3Bw0E,EACF,CAACtxE,EAAe+wE,EAAiCj/C,EAChDh1B,EAAiBk0E,KAChB,MAAMp7C,EAAY51B,EAAExN,MAAM,GACpBkV,EAAS1H,EAAExN,MAAM,GACjBygD,EACFtzC,EAAAA,aAAAA,aAAAA,8BACI+H,EAAQspE,GAEVz5E,EAAU,IAAIs5E,GADF,CAAC59B,aAAYvrC,SAAQkuB,YAAWo7C,eACFD,GAC1C1zE,EAASuc,EAAQmuB,cAAcxwC,EAAS,CAACyI,EAAG8xB,GAAah1B,GAG/D,GAFA0lD,EAAUpiD,KAAK/C,GAEXA,EAAO7K,MAAM,KAAOw+E,EACtB,OAAO3zE,EAET,MAAMk0E,EAAYtP,GAAM,CACtBroD,UACA0B,MAAO,CAAC8G,MAAO,EAAGC,KAAM2uD,EAAa1uD,KAAM,EAAGxlB,MAAO,aAEjD00E,EAAWjD,GAAK,CACpBpmE,OAAQ,CAACnI,EAAGuxE,GACZ33D,UACA0B,MAAO,CAACob,KAAM,CAAChvB,EAASurC,MAG1BuP,EAAUpiD,KAAKmxE,GACf/uB,EAAUpiD,KAAKoxE,GAIf,OADIF,EAAaj0E,EAAQ0zE,EAAWS,EAAU10E,EAAOk0E,EACxC,EAMb11B,EACFluB,GAAQ,CAACjlB,OAAQ,CAACnI,EAJFsxE,EAChB33B,EAAK,qBAAsB7nB,EAAYu/C,EAAaL,IAGjBp3D,UAAS0B,MAAO,CAAC9oB,MAAO+O,KAE/D,IAAI6Q,EAASkpC,EACb,GAAmB,MAAfqR,EAAqB,CACvBnK,EAAUpiD,KAAKk7C,GACf,MAAMx3B,EAAOnkB,EAAAA,aAAAA,uBAAoCgtD,GACjDv6C,EAASujC,GAAU,CAACxtC,OAAQ,CAACnI,EAAGoS,GAASwH,UAAS0B,MAAO,CAACwI,UAI5D,OADA0+B,EAAU5lD,SAAQC,GAAK+c,EAAQ6B,8BAA8B5e,KACtDuV,CACT,GCuPEmtD,IAGF,IAAK,MAAMkS,MAAgBN,IACzBO,EAAAA,EAAAA,gBAAeD","sources":["../../tfjs-backend-webgl/src/canvas_util.ts","../../tfjs-backend-webgl/src/tex_util.ts","../../tfjs-backend-webgl/src/webgl_util.ts","../../tfjs-backend-webgl/src/flags_webgl.ts","../../tfjs-backend-webgl/src/glsl_version.ts","../../tfjs-backend-webgl/src/shader_compiler_util.ts","../../tfjs-backend-webgl/src/shader_compiler.ts","../../tfjs-backend-webgl/src/gpgpu_math.ts","../../tfjs-backend-webgl/src/decode_matrix_gpu.ts","../../tfjs-backend-webgl/src/decode_matrix_packed_gpu.ts","../../tfjs-backend-webgl/src/encode_float_gpu.ts","../../tfjs-backend-webgl/src/encode_float_packed_gpu.ts","../../tfjs-backend-webgl/src/encode_matrix_gpu.ts","../../tfjs-backend-webgl/src/encode_matrix_packed_gpu.ts","../../tfjs-backend-webgl/src/gpgpu_util.ts","../../tfjs-backend-webgl/src/gpgpu_context.ts","../node_modules/@tensorflow/tfjs-backend-cpu/src/cpu_util.ts","../node_modules/@tensorflow/tfjs-backend-cpu/src/kernels/Abs.ts","../node_modules/@tensorflow/tfjs-backend-cpu/src/utils/binary_impl.ts","../node_modules/@tensorflow/tfjs-backend-cpu/src/kernels/Complex.ts","../node_modules/@tensorflow/tfjs-backend-cpu/src/utils/zeros_impl.ts","../node_modules/@tensorflow/tfjs-backend-cpu/src/kernels/Identity.ts","../node_modules/@tensorflow/tfjs-backend-cpu/src/kernels/Real.ts","../node_modules/@tensorflow/tfjs-backend-cpu/src/kernels/Cast.ts","../node_modules/@tensorflow/tfjs-backend-cpu/src/utils/binary_utils.ts","../node_modules/@tensorflow/tfjs-backend-cpu/src/kernels/Add.ts","../node_modules/@tensorflow/tfjs-backend-cpu/src/kernels/Bincount_impl.ts","../node_modules/@tensorflow/tfjs-backend-cpu/src/utils/unary_impl.ts","../node_modules/@tensorflow/tfjs-backend-cpu/src/utils/unary_utils.ts","../node_modules/@tensorflow/tfjs-backend-cpu/src/kernels/Ceil.ts","../node_modules/@tensorflow/tfjs-backend-cpu/src/kernels/Concat_impl.ts","../node_modules/@tensorflow/tfjs-backend-cpu/src/kernels/Equal.ts","../node_modules/@tensorflow/tfjs-backend-cpu/src/kernels/Exp.ts","../node_modules/@tensorflow/tfjs-backend-cpu/src/kernels/Expm1.ts","../node_modules/@tensorflow/tfjs-backend-cpu/src/kernels/Floor.ts","../node_modules/@tensorflow/tfjs-backend-cpu/src/kernels/GatherNd_Impl.ts","../node_modules/@tensorflow/tfjs-backend-cpu/src/kernels/GatherV2_impl.ts","../node_modules/@tensorflow/tfjs-backend-cpu/src/kernels/Greater.ts","../node_modules/@tensorflow/tfjs-backend-cpu/src/kernels/GreaterEqual.ts","../node_modules/@tensorflow/tfjs-backend-cpu/src/kernels/Less.ts","../node_modules/@tensorflow/tfjs-backend-cpu/src/kernels/LessEqual.ts","../node_modules/@tensorflow/tfjs-backend-cpu/src/kernels/LinSpace_impl.ts","../node_modules/@tensorflow/tfjs-backend-cpu/src/kernels/Log.ts","../node_modules/@tensorflow/tfjs-backend-cpu/src/kernels/Max_impl.ts","../node_modules/@tensorflow/tfjs-backend-cpu/src/kernels/Maximum.ts","../node_modules/@tensorflow/tfjs-backend-cpu/src/kernels/Minimum.ts","../node_modules/@tensorflow/tfjs-backend-cpu/src/kernels/Multiply.ts","../node_modules/@tensorflow/tfjs-backend-cpu/src/kernels/Neg.ts","../node_modules/@tensorflow/tfjs-backend-cpu/src/kernels/NotEqual.ts","../node_modules/@tensorflow/tfjs-backend-cpu/src/kernels/Transpose_impl.ts","../node_modules/@tensorflow/tfjs-backend-cpu/src/kernels/Transpose.ts","../node_modules/@tensorflow/tfjs-backend-cpu/src/kernels/Prod.ts","../node_modules/@tensorflow/tfjs-backend-cpu/src/kernels/RaggedGather_impl.ts","../node_modules/@tensorflow/tfjs-backend-cpu/src/kernels/RaggedRange_impl.ts","../node_modules/@tensorflow/tfjs-backend-cpu/src/kernels/RaggedTensorToTensor_impl.ts","../node_modules/@tensorflow/tfjs-backend-cpu/src/kernels/Range_impl.ts","../node_modules/@tensorflow/tfjs-backend-cpu/src/kernels/Rsqrt.ts","../node_modules/@tensorflow/tfjs-backend-cpu/src/kernels/Scatter_impl.ts","../node_modules/@tensorflow/tfjs-backend-cpu/src/kernels/Sigmoid.ts","../node_modules/@tensorflow/tfjs-backend-cpu/src/kernels/Slice.ts","../node_modules/@tensorflow/tfjs-backend-cpu/src/kernels/SparseFillEmptyRows_impl.ts","../node_modules/@tensorflow/tfjs-backend-cpu/src/kernels/SparseReshape_impl.ts","../node_modules/@tensorflow/tfjs-backend-cpu/src/kernels/SparseSegmentReduction_impl.ts","../node_modules/@tensorflow/tfjs-backend-cpu/src/kernels/Sqrt.ts","../node_modules/@tensorflow/tfjs-backend-cpu/src/kernels/SquaredDifference.ts","../node_modules/@tensorflow/tfjs-backend-cpu/src/kernels/StridedSlice_impl.ts","../node_modules/@tensorflow/tfjs-backend-cpu/src/kernels/StringNGrams_impl.ts","../node_modules/@tensorflow/tfjs-backend-cpu/src/kernels/StringSplit_impl.ts","../node_modules/@tensorflow/tfjs-backend-cpu/src/kernels/StringToHashBucketFast_impl.ts","../node_modules/@tensorflow/tfjs-backend-cpu/src/kernels/Sub.ts","../node_modules/@tensorflow/tfjs-backend-cpu/src/kernels/Tile_impl.ts","../node_modules/@tensorflow/tfjs-backend-cpu/src/kernels/TopK_impl.ts","../node_modules/@tensorflow/tfjs-backend-cpu/src/kernels/Unique_impl.ts","../../tfjs-backend-webgl/src/kernel_utils/shared.ts","../../tfjs-backend-webgl/src/packing_util.ts","../../tfjs-backend-webgl/src/pack_gpu.ts","../../tfjs-backend-webgl/src/reshape_packed_gpu.ts","../../tfjs-backend-webgl/src/texture_manager.ts","../../tfjs-backend-webgl/src/unaryop_gpu.ts","../../tfjs-backend-webgl/src/unaryop_packed_gpu.ts","../../tfjs-backend-webgl/src/unpack_gpu.ts","../../tfjs-backend-webgl/src/backend_webgl.ts","../../tfjs-backend-webgl/src/base.ts","../../tfjs-backend-webgl/src/binaryop_gpu.ts","../../tfjs-backend-webgl/src/binaryop_packed_gpu.ts","../../tfjs-backend-webgl/src/kernels/Identity.ts","../../tfjs-backend-webgl/src/kernels/Complex.ts","../../tfjs-backend-webgl/src/kernels/LeakyRelu.ts","../../tfjs-backend-webgl/src/kernels/Prelu.ts","../../tfjs-backend-webgl/src/kernel_utils/kernel_funcs_utils.ts","../../tfjs-backend-webgl/src/mulmat_packed_gpu.ts","../../tfjs-backend-webgl/src/binaryop_complex_gpu.ts","../../tfjs-backend-webgl/src/kernels/Multiply.ts","../../tfjs-backend-webgl/src/kernels/Reshape.ts","../../tfjs-backend-webgl/src/kernel_utils/reshape.ts","../../tfjs-backend-webgl/src/mean_gpu.ts","../../tfjs-backend-webgl/src/reduce_gpu.ts","../../tfjs-backend-webgl/src/kernel_utils/reduce.ts","../../tfjs-backend-webgl/src/transpose_gpu.ts","../../tfjs-backend-webgl/src/transpose_packed_gpu.ts","../../tfjs-backend-webgl/src/kernels/Transpose_impl.ts","../../tfjs-backend-webgl/src/kernels/Sum.ts","../../tfjs-backend-webgl/src/kernels/Sum_impl.ts","../../tfjs-backend-webgl/src/kernels/Transpose.ts","../../tfjs-backend-webgl/src/kernels/BatchMatMul_impl.ts","../../tfjs-backend-webgl/src/kernels/_FusedMatMul.ts","../../tfjs-backend-webgl/src/kernels/Abs.ts","../../tfjs-backend-webgl/src/kernels/Acos.ts","../../tfjs-backend-webgl/src/kernels/Acosh.ts","../../tfjs-backend-webgl/src/kernels/Add.ts","../../tfjs-backend-webgl/src/addn_gpu.ts","../../tfjs-backend-webgl/src/addn_packed_gpu.ts","../../tfjs-backend-webgl/src/kernels/AddN.ts","../../tfjs-backend-webgl/src/kernels/All.ts","../../tfjs-backend-webgl/src/kernels/Any.ts","../../tfjs-backend-webgl/src/argminmax_gpu.ts","../../tfjs-backend-webgl/src/argminmax_packed_gpu.ts","../../tfjs-backend-webgl/src/kernel_utils/arg_min_max.ts","../../tfjs-backend-webgl/src/kernels/ArgMax.ts","../../tfjs-backend-webgl/src/kernels/ArgMin.ts","../../tfjs-backend-webgl/src/kernels/Asin.ts","../../tfjs-backend-webgl/src/kernels/Asinh.ts","../../tfjs-backend-webgl/src/kernels/Atan.ts","../../tfjs-backend-webgl/src/kernels/Atan2.ts","../../tfjs-backend-webgl/src/kernels/Atanh.ts","../../tfjs-backend-webgl/src/pool_gpu.ts","../../tfjs-backend-webgl/src/kernels/AvgPool.ts","../../tfjs-backend-webgl/src/kernels/AvgPool3D.ts","../../tfjs-backend-webgl/src/avg_pool_backprop_gpu.ts","../../tfjs-backend-webgl/src/kernels/AvgPool3DGrad.ts","../../tfjs-backend-webgl/src/kernels/AvgPoolGrad.ts","../../tfjs-backend-webgl/src/kernels/BatchMatMul.ts","../../tfjs-backend-webgl/src/batchnorm_gpu.ts","../../tfjs-backend-webgl/src/batchnorm_packed_gpu.ts","../../tfjs-backend-webgl/src/kernels/BatchNorm.ts","../../tfjs-backend-webgl/src/slice_gpu.ts","../../tfjs-backend-webgl/src/slice_packed_gpu.ts","../../tfjs-backend-webgl/src/kernels/Slice.ts","../../tfjs-backend-webgl/src/kernels/BatchToSpaceND.ts","../../tfjs-backend-webgl/src/kernels/Bincount.ts","../../tfjs-backend-webgl/src/kernels/BroadcastArgs.ts","../../tfjs-backend-webgl/src/kernels/NotEqual.ts","../../tfjs-backend-webgl/src/kernels/Real.ts","../../tfjs-backend-webgl/src/kernel_utils/int.ts","../../tfjs-backend-webgl/src/kernels/Cast.ts","../../tfjs-backend-webgl/src/kernels/Ceil.ts","../../tfjs-backend-webgl/src/clip_gpu.ts","../../tfjs-backend-webgl/src/clip_packed_gpu.ts","../../tfjs-backend-webgl/src/kernels/ClipByValue.ts","../../tfjs-backend-webgl/src/complex_abs_gpu.ts","../../tfjs-backend-webgl/src/kernels/ComplexAbs.ts","../../tfjs-backend-webgl/src/concat_gpu.ts","../../tfjs-backend-webgl/src/concat_packed_gpu.ts","../../tfjs-backend-webgl/src/kernels/Imag.ts","../../tfjs-backend-webgl/src/kernels/Concat_impl.ts","../../tfjs-backend-webgl/src/kernels/Concat.ts","../../tfjs-backend-webgl/src/conv_gpu.ts","../../tfjs-backend-webgl/src/conv_packed_gpu.ts","../../tfjs-backend-webgl/src/im2col_packed_gpu.ts","../../tfjs-backend-webgl/src/kernels/Conv2D_impl.ts","../../tfjs-backend-webgl/src/kernels/Conv2D.ts","../../tfjs-backend-webgl/src/conv_backprop_gpu.ts","../../tfjs-backend-webgl/src/kernels/Conv2DBackpropFilter.ts","../../tfjs-backend-webgl/src/kernels/Conv2DBackpropInput.ts","../../tfjs-backend-webgl/src/kernels/Conv3D.ts","../../tfjs-backend-webgl/src/kernels/Conv3DBackpropFilterV2.ts","../../tfjs-backend-webgl/src/kernels/Conv3DBackpropInputV2.ts","../../tfjs-backend-webgl/src/kernels/Cos.ts","../../tfjs-backend-webgl/src/kernels/Cosh.ts","../../tfjs-backend-webgl/src/crop_and_resize_gpu.ts","../../tfjs-backend-webgl/src/kernels/CropAndResize.ts","../../tfjs-backend-webgl/src/cum_gpu.ts","../../tfjs-backend-webgl/src/kernels/Cum_impl.ts","../../tfjs-backend-webgl/src/kernels/Cumprod.ts","../../tfjs-backend-webgl/src/kernels/Cumsum.ts","../../tfjs-backend-webgl/src/kernels/DenseBincount.ts","../../tfjs-backend-webgl/src/depth_to_space_gpu.ts","../../tfjs-backend-webgl/src/kernels/DepthToSpace.ts","../../tfjs-backend-webgl/src/conv_gpu_depthwise.ts","../../tfjs-backend-webgl/src/conv_packed_gpu_depthwise.ts","../../tfjs-backend-webgl/src/kernels/DepthwiseConv2dNative.ts","../../tfjs-backend-webgl/src/conv_backprop_gpu_depthwise.ts","../../tfjs-backend-webgl/src/kernels/DepthwiseConv2dNativeBackpropFilter.ts","../../tfjs-backend-webgl/src/kernels/DepthwiseConv2dNativeBackpropInput.ts","../../tfjs-backend-webgl/src/diag_gpu.ts","../../tfjs-backend-webgl/src/kernels/Diag.ts","../../tfjs-backend-webgl/src/dilation_gpu.ts","../../tfjs-backend-webgl/src/kernels/Dilation2D.ts","../../tfjs-backend-webgl/src/kernels/Einsum.ts","../../tfjs-backend-webgl/src/kernels/Elu.ts","../../tfjs-backend-webgl/src/kernels/EluGrad.ts","../../tfjs-backend-webgl/src/kernels/Equal.ts","../../tfjs-backend-webgl/src/kernels/Erf.ts","../../tfjs-backend-webgl/src/kernels/Exp.ts","../../tfjs-backend-webgl/src/kernels/ExpandDims.ts","../../tfjs-backend-webgl/src/kernels/Expm1.ts","../../tfjs-backend-webgl/src/fft_gpu.ts","../../tfjs-backend-webgl/src/kernels/FFT_impl.ts","../../tfjs-backend-webgl/src/kernels/FFT.ts","../../tfjs-backend-webgl/src/fill_gpu.ts","../../tfjs-backend-webgl/src/kernels/Fill.ts","../../tfjs-backend-webgl/src/flip_left_right_gpu.ts","../../tfjs-backend-webgl/src/kernels/FlipLeftRight.ts","../../tfjs-backend-webgl/src/kernels/Floor.ts","../../tfjs-backend-webgl/src/kernels/FloorDiv.ts","../../tfjs-backend-webgl/src/kernels/FromPixels_utils/from_pixels_gpu.ts","../../tfjs-backend-webgl/src/kernels/FromPixels_utils/from_pixels_packed_gpu.ts","../../tfjs-backend-webgl/src/kernels/FromPixels.ts","../../tfjs-backend-webgl/src/kernels/FusedConv2D.ts","../../tfjs-backend-webgl/src/kernels/FusedDepthwiseConv2D.ts","../../tfjs-backend-webgl/src/gather_nd_gpu.ts","../../tfjs-backend-webgl/src/kernels/GatherNd.ts","../../tfjs-backend-webgl/src/gather_gpu.ts","../../tfjs-backend-webgl/src/kernels/GatherV2.ts","../../tfjs-backend-webgl/src/kernels/Greater.ts","../../tfjs-backend-webgl/src/kernels/GreaterEqual.ts","../../tfjs-backend-webgl/src/kernels/IFFT.ts","../../tfjs-backend-webgl/src/kernels/IsFinite.ts","../../tfjs-backend-webgl/src/kernels/IsInf.ts","../../tfjs-backend-webgl/src/kernels/IsNaN.ts","../../tfjs-backend-webgl/src/kernels/Less.ts","../../tfjs-backend-webgl/src/kernels/LessEqual.ts","../../tfjs-backend-webgl/src/kernels/LinSpace.ts","../../tfjs-backend-webgl/src/kernels/Log.ts","../../tfjs-backend-webgl/src/kernels/Log1p.ts","../../tfjs-backend-webgl/src/kernels/LogicalAnd.ts","../../tfjs-backend-webgl/src/kernels/LogicalNot.ts","../../tfjs-backend-webgl/src/kernels/LogicalOr.ts","../../tfjs-backend-webgl/src/lrn_gpu.ts","../../tfjs-backend-webgl/src/lrn_packed_gpu.ts","../../tfjs-backend-webgl/src/kernels/LRN.ts","../../tfjs-backend-webgl/src/lrn_grad_gpu.ts","../../tfjs-backend-webgl/src/kernels/LRNGrad.ts","../../tfjs-backend-webgl/src/kernels/Max.ts","../../tfjs-backend-webgl/src/kernels/Max_impl.ts","../../tfjs-backend-webgl/src/kernels/Maximum.ts","../../tfjs-backend-webgl/src/kernels/MaxPool.ts","../../tfjs-backend-webgl/src/kernels/MaxPool3D.ts","../../tfjs-backend-webgl/src/max_pool_backprop_gpu.ts","../../tfjs-backend-webgl/src/kernels/MaxPool3DGrad.ts","../../tfjs-backend-webgl/src/kernels/MaxPoolGrad.ts","../../tfjs-backend-webgl/src/kernels/MaxPoolWithArgmax.ts","../../tfjs-backend-webgl/src/kernels/MaxPoolWithArgmax_impl.ts","../../tfjs-backend-webgl/src/kernels/Mean.ts","../../tfjs-backend-webgl/src/kernels/Mean_impl.ts","../../tfjs-backend-webgl/src/kernels/Min.ts","../../tfjs-backend-webgl/src/kernels/Minimum.ts","../../tfjs-backend-webgl/src/mirror_pad_gpu.ts","../../tfjs-backend-webgl/src/mirror_pad_packed_gpu.ts","../../tfjs-backend-webgl/src/kernels/MirrorPad.ts","../../tfjs-backend-webgl/src/kernels/Mod.ts","../../tfjs-backend-webgl/src/multinomial_gpu.ts","../../tfjs-backend-webgl/src/kernels/RealDiv.ts","../../tfjs-backend-webgl/src/kernels/Sub.ts","../../tfjs-backend-webgl/src/kernels/Softmax.ts","../../tfjs-backend-webgl/src/kernels/Multinomial.ts","../../tfjs-backend-webgl/src/kernels/Neg.ts","../../tfjs-backend-webgl/src/kernels/NonMaxSuppressionV3.ts","../../tfjs-backend-webgl/src/kernels/NonMaxSuppressionV4.ts","../../tfjs-backend-webgl/src/kernels/NonMaxSuppressionV5.ts","../../tfjs-backend-webgl/src/onehot_gpu.ts","../../tfjs-backend-webgl/src/kernels/OneHot.ts","../../tfjs-backend-webgl/src/kernels/ZerosLike.ts","../../tfjs-backend-webgl/src/kernels/OnesLike.ts","../../tfjs-backend-webgl/src/kernels/Pack.ts","../../tfjs-backend-webgl/src/pad_gpu.ts","../../tfjs-backend-webgl/src/pad_packed_gpu.ts","../../tfjs-backend-webgl/src/kernels/PadV2.ts","../../tfjs-backend-webgl/src/kernels/Pow.ts","../../tfjs-backend-webgl/src/kernels/Prod.ts","../../tfjs-backend-webgl/src/kernels/RaggedGather.ts","../../tfjs-backend-webgl/src/kernels/RaggedRange.ts","../../tfjs-backend-webgl/src/kernels/RaggedTensorToTensor.ts","../../tfjs-backend-webgl/src/kernels/Range.ts","../../tfjs-backend-webgl/src/kernels/Reciprocal.ts","../../tfjs-backend-webgl/src/kernels/Relu.ts","../../tfjs-backend-webgl/src/kernels/Relu6.ts","../../tfjs-backend-webgl/src/resize_bilinear_gpu.ts","../../tfjs-backend-webgl/src/resize_bilinear_packed_gpu.ts","../../tfjs-backend-webgl/src/kernels/ResizeBilinear.ts","../../tfjs-backend-webgl/src/resize_bilinear_backprop_gpu.ts","../../tfjs-backend-webgl/src/kernels/ResizeBilinearGrad.ts","../../tfjs-backend-webgl/src/resize_nearest_neighbor_gpu.ts","../../tfjs-backend-webgl/src/resize_nearest_neighbor_packed_gpu.ts","../../tfjs-backend-webgl/src/kernels/ResizeNearestNeighbor.ts","../../tfjs-backend-webgl/src/resize_nearest_neighbor_backprop_gpu.ts","../../tfjs-backend-webgl/src/kernels/ResizeNearestNeighborGrad.ts","../../tfjs-backend-webgl/src/reverse_gpu.ts","../../tfjs-backend-webgl/src/reverse_packed_gpu.ts","../../tfjs-backend-webgl/src/kernels/Reverse.ts","../../tfjs-backend-webgl/src/rotate_gpu.ts","../../tfjs-backend-webgl/src/kernels/RotateWithOffset.ts","../../tfjs-backend-webgl/src/kernels/Round.ts","../../tfjs-backend-webgl/src/kernels/Rsqrt.ts","../../tfjs-backend-webgl/src/scatter_gpu.ts","../../tfjs-backend-webgl/src/kernels/ScatterNd.ts","../../tfjs-backend-webgl/src/search_sorted_gpu.ts","../../tfjs-backend-webgl/src/kernels/SearchSorted.ts","../../tfjs-backend-webgl/src/select_gpu.ts","../../tfjs-backend-webgl/src/kernels/Select.ts","../../tfjs-backend-webgl/src/kernels/Selu.ts","../../tfjs-backend-webgl/src/kernels/Sigmoid.ts","../../tfjs-backend-webgl/src/kernels/Sign.ts","../../tfjs-backend-webgl/src/kernels/Sin.ts","../../tfjs-backend-webgl/src/kernels/Sinh.ts","../../tfjs-backend-webgl/src/kernels/Softplus.ts","../../tfjs-backend-webgl/src/kernels/SpaceToBatchND.ts","../../tfjs-backend-webgl/src/kernels/SparseFillEmptyRows.ts","../../tfjs-backend-webgl/src/kernels/SparseReshape.ts","../../tfjs-backend-webgl/src/kernels/SparseSegmentMean.ts","../../tfjs-backend-webgl/src/kernels/SparseSegmentSum.ts","../../tfjs-backend-webgl/src/kernels/SparseToDense.ts","../../tfjs-backend-webgl/src/kernels/SplitV.ts","../../tfjs-backend-webgl/src/kernels/Sqrt.ts","../../tfjs-backend-webgl/src/kernels/Square.ts","../../tfjs-backend-webgl/src/kernels/SquaredDifference.ts","../../tfjs-backend-webgl/src/kernels/Step.ts","../../tfjs-backend-webgl/src/strided_slice_gpu.ts","../../tfjs-backend-webgl/src/kernels/StridedSlice.ts","../../tfjs-backend-webgl/src/kernels/StringNGrams.ts","../../tfjs-backend-webgl/src/kernels/StringSplit.ts","../../tfjs-backend-webgl/src/kernels/StringToHashBucketFast.ts","../../tfjs-backend-webgl/src/kernels/Tan.ts","../../tfjs-backend-webgl/src/kernels/Tanh.ts","../../tfjs-backend-webgl/src/tile_gpu.ts","../../tfjs-backend-webgl/src/kernels/Tile.ts","../../tfjs-backend-webgl/src/top_k_gpu.ts","../../tfjs-backend-webgl/src/kernels/TopK.ts","../../tfjs-backend-webgl/src/transform_gpu.ts","../../tfjs-backend-webgl/src/kernels/Transform.ts","../../tfjs-backend-webgl/src/kernels/Unique.ts","../../tfjs-backend-webgl/src/kernels/Unpack.ts","../../tfjs-backend-webgl/src/segment_gpu.ts","../../tfjs-backend-webgl/src/kernels/UnsortedSegmentSum.ts","../../tfjs-backend-webgl/src/register_all_kernels.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {env} from '@tensorflow/tfjs-core';\n\nconst contexts: {[key: string]: WebGLRenderingContext} = {};\n\nconst WEBGL_ATTRIBUTES: WebGLContextAttributes = {\n  alpha: false,\n  antialias: false,\n  premultipliedAlpha: false,\n  preserveDrawingBuffer: false,\n  depth: false,\n  stencil: false,\n  failIfMajorPerformanceCaveat: true\n};\n\nexport function clearWebGLContext(webGLVersion: number) {\n  delete contexts[webGLVersion];\n}\n\nexport function setWebGLContext(\n    webGLVersion: number, gl: WebGLRenderingContext) {\n  contexts[webGLVersion] = gl;\n}\n\nexport function getWebGLContext(\n    webGLVersion: number,\n    customCanvas?: HTMLCanvasElement|OffscreenCanvas): WebGLRenderingContext {\n  if (!(webGLVersion in contexts) || customCanvas != null) {\n    const newCtx = getWebGLRenderingContext(webGLVersion, customCanvas);\n    if (newCtx !== null) {\n      contexts[webGLVersion] = newCtx;\n    } else {\n      console.log('Could not get context for WebGL version', webGLVersion);\n      return null;\n    }\n  }\n  const gl = contexts[webGLVersion];\n  if (gl == null || gl.isContextLost()) {\n    delete contexts[webGLVersion];\n    return getWebGLContext(webGLVersion);\n  }\n\n  gl.disable(gl.DEPTH_TEST);\n  gl.disable(gl.STENCIL_TEST);\n  gl.disable(gl.BLEND);\n  gl.disable(gl.DITHER);\n  gl.disable(gl.POLYGON_OFFSET_FILL);\n  gl.disable(gl.SAMPLE_COVERAGE);\n  gl.enable(gl.SCISSOR_TEST);\n  gl.enable(gl.CULL_FACE);\n  gl.cullFace(gl.BACK);\n\n  return contexts[webGLVersion];\n}\n\nfunction createCanvas(webGLVersion: number) {\n  if (typeof OffscreenCanvas !== 'undefined' && webGLVersion === 2) {\n    return new OffscreenCanvas(300, 150);\n  } else if (typeof document !== 'undefined') {\n    return document.createElement('canvas');\n  } else {\n    throw new Error('Cannot create a canvas in this context');\n  }\n}\n\nfunction getWebGLRenderingContext(\n    webGLVersion: number,\n    customCanvas?: HTMLCanvasElement|OffscreenCanvas): WebGLRenderingContext {\n  if (webGLVersion !== 1 && webGLVersion !== 2) {\n    throw new Error('Cannot get WebGL rendering context, WebGL is disabled.');\n  }\n  const canvas =\n      customCanvas == null ? createCanvas(webGLVersion) : customCanvas;\n\n  canvas.addEventListener('webglcontextlost', (ev: Event) => {\n    ev.preventDefault();\n    delete contexts[webGLVersion];\n  }, false);\n\n  if (env().getBool('SOFTWARE_WEBGL_ENABLED')) {\n    WEBGL_ATTRIBUTES.failIfMajorPerformanceCaveat = false;\n  }\n\n  if (webGLVersion === 1) {\n    return (canvas.getContext('webgl', WEBGL_ATTRIBUTES) ||\n      (canvas as HTMLCanvasElement)\n        .getContext('experimental-webgl', WEBGL_ATTRIBUTES));\n  }\n  return canvas.getContext('webgl2', WEBGL_ATTRIBUTES) as WebGLRenderingContext;\n}\n","/**\n * @license\n * Copyright 2017 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {backend_util, DataId, DataType, env, TensorInfo, util} from '@tensorflow/tfjs-core';\n\nexport enum PackingScheme {\n  /**\n   * All values in a single texel are densely packed without any constraints.\n   *\n   * This is how the shader encodes a tensor with shape = [2, 3, 4]\n   * (indices are [batch, row, col]).\n   *\n   * 000|001   010|011   020|021\n   * -------   -------   -------\n   * 002|003   012|013   022|023\n   *\n   * 100|101   110|111   120|121\n   * -------   -------   -------\n   * 102|103   112|113   122|123\n   *\n   */\n  DENSE,\n\n  /**\n   * Single texels contain only values from the same batch, and from adjacent\n   * rows and columns.\n   *\n   * This is how the shader encodes a tensor with shape = [2, 3, 5]\n   * (indices are [batch, row, col]).\n   *\n   * 000|001   002|003   004|xxx   020|021   022|023   024|xxx\n   * -------   -------   -------   -------   -------   -------\n   * 010|011   012|013   014|xxx   xxx|xxx   xxx|xxx   xxx|xxx\n   *\n   * 100|101   102|103   104|xxx   120|121   122|123   124|xxx\n   * -------   -------   -------   -------   -------   -------\n   * 110|111   112|113   114|xxx   xxx|xxx   xxx|xxx   xxx|xxx\n   *\n   */\n  SHARED_BATCH\n}\n\nexport enum TextureUsage {\n  RENDER,\n  UPLOAD,\n  PIXELS,\n  DOWNLOAD\n}\n\nexport enum PhysicalTextureType {\n  UNPACKED_FLOAT16,\n  UNPACKED_FLOAT32,\n  PACKED_4X1_UNSIGNED_BYTE,\n  PACKED_2X2_FLOAT32,\n  PACKED_2X2_FLOAT16\n}\n\nexport interface Texture {\n  texture: WebGLTexture;\n  texShape: [number, number];\n}\nexport interface TextureData {\n  // Required.\n  shape: number[];\n  dtype: DataType;\n\n  // Optional.\n  values?: backend_util.BackendValues;\n  texture?: Texture;\n  // For complex numbers, the real and imaginary parts are stored as their own\n  // individual tensorInfos, with a parent joining the two with the\n  // complexTensors field. When this is defined, texture will be null.\n  complexTensorInfos?: {real: TensorInfo, imag: TensorInfo};\n  /** [rows, columns] shape of the texture. */\n  texShape?: [number, number];\n  usage?: TextureUsage;\n  isPacked?: boolean;\n\n  refCount: number;\n\n  // Available when the tensor has been sliced.\n  slice?: {\n    // Offset in the 'flat index' space.\n    flatOffset: number;\n    // Used for counting how many sliced tensors point to the same texture.\n    origDataId: DataId;\n  };\n}\n\nexport function getUnpackedMatrixTextureShapeWidthHeight(\n    rows: number, columns: number): [number, number] {\n  return [columns, rows];\n}\n\nexport function getUnpackedArraySizeFromMatrixSize(\n    matrixSize: number, channelsPerTexture: number): number {\n  return matrixSize * channelsPerTexture;\n}\n\nexport function getColorMatrixTextureShapeWidthHeight(\n    rows: number, columns: number): [number, number] {\n  return [columns * 4, rows];\n}\n\n/**\n * Get shape for densely packed RGBA texture.\n */\nexport function getDenseTexShape(shape: number[]): [number, number] {\n  const size = util.sizeFromShape(shape);\n  const texelsNeeded = Math.ceil(size / 4);\n  return util.sizeToSquarishShape(texelsNeeded);\n}\n\nexport function getMatrixSizeFromUnpackedArraySize(\n    unpackedSize: number, channelsPerTexture: number): number {\n  if (unpackedSize % channelsPerTexture !== 0) {\n    throw new Error(\n        `unpackedSize (${unpackedSize}) must be a multiple of ` +\n        `${channelsPerTexture}`);\n  }\n  return unpackedSize / channelsPerTexture;\n}\n\nexport function decodeMatrixFromUnpackedColorRGBAArray(\n    unpackedArray: Float32Array, matrix: Float32Array, channels: number) {\n  const requiredSize = unpackedArray.length * channels / 4;\n  if (matrix.length < requiredSize) {\n    throw new Error(\n        `matrix length (${matrix.length}) must be >= ${requiredSize}`);\n  }\n  let dst = 0;\n  for (let src = 0; src < unpackedArray.length; src += 4) {\n    for (let c = 0; c < channels; c++) {\n      matrix[dst++] = unpackedArray[src + c];\n    }\n  }\n}\n\nexport function getPackedMatrixTextureShapeWidthHeight(\n    rows: number, columns: number): [number, number] {\n  return [\n    Math.max(1, Math.ceil(columns / 2)), Math.max(1, Math.ceil(rows / 2))\n  ];\n}\n\nexport function getPackedRGBAArraySizeFromMatrixShape(\n    rows: number, columns: number): number {\n  const [w, h] = getPackedMatrixTextureShapeWidthHeight(rows, columns);\n  return w * h * 4;\n}\n\nexport interface TextureConfig {\n  internalFormatFloat: number;\n  textureFormatFloat: number;\n  internalFormatPackedHalfFloat: number;\n  internalFormatHalfFloat: number;\n  internalFormatPackedFloat: number;\n\n  // The format to use during a gl.readPixels call.\n  downloadTextureFormat: number;\n  // How many channels need to be unpacked after a gl.readPixels call.\n  downloadUnpackNumChannels: number;\n\n  defaultNumChannels: number;\n  textureTypeHalfFloat: number;\n  textureTypeFloat: number;\n}\n\nexport function getTextureConfig(\n    // tslint:disable-next-line:no-any\n    gl: WebGLRenderingContext, textureHalfFloatExtension?: any): TextureConfig {\n  // tslint:disable-next-line:no-any\n  const glany = gl as any;\n\n  let internalFormatFloat: number;\n  let internalFormatHalfFloat: number;\n  let internalFormatPackedHalfFloat: number;\n  let internalFormatPackedFloat: number;\n  let textureFormatFloat: number;\n\n  let downloadTextureFormat: number;\n  let downloadUnpackNumChannels: number;\n\n  let defaultNumChannels: number;\n  let textureTypeHalfFloat: number;\n  let textureTypeFloat: number;\n\n  if (env().getNumber('WEBGL_VERSION') === 2) {\n    internalFormatFloat = glany.R32F;\n    internalFormatHalfFloat = glany.R16F;\n    internalFormatPackedHalfFloat = glany.RGBA16F;\n    internalFormatPackedFloat = glany.RGBA32F;\n    textureFormatFloat = glany.RED;\n    downloadUnpackNumChannels = 4;\n    defaultNumChannels = 1;\n    textureTypeHalfFloat = glany.HALF_FLOAT;\n    textureTypeFloat = glany.FLOAT;\n    downloadTextureFormat = glany.RGBA8;\n  } else {\n    internalFormatFloat = gl.RGBA;\n    internalFormatHalfFloat = gl.RGBA;\n    internalFormatPackedHalfFloat = gl.RGBA;\n    internalFormatPackedFloat = glany.RGBA;\n    textureFormatFloat = gl.RGBA;\n    downloadUnpackNumChannels = 4;\n    defaultNumChannels = 4;\n    textureTypeHalfFloat = textureHalfFloatExtension != null ?\n        textureHalfFloatExtension.HALF_FLOAT_OES :\n        null;\n    textureTypeFloat = gl.FLOAT;\n    downloadTextureFormat = gl.RGBA;\n  }\n\n  return {\n    internalFormatFloat,\n    internalFormatHalfFloat,\n    internalFormatPackedHalfFloat,\n    internalFormatPackedFloat,\n    textureFormatFloat,\n    downloadTextureFormat,\n    downloadUnpackNumChannels,\n    defaultNumChannels,\n    textureTypeHalfFloat,\n    textureTypeFloat\n  };\n}\n","/**\n * @license\n * Copyright 2017 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {env, TensorInfo, util} from '@tensorflow/tfjs-core';\n\nimport {getWebGLContext} from './canvas_util';\nimport {getTextureConfig} from './tex_util';\n\nexport function callAndCheck<T>(gl: WebGLRenderingContext, func: () => T): T {\n  const returnValue = func();\n  if (env().getBool('DEBUG')) {\n    checkWebGLError(gl);\n  }\n  return returnValue;\n}\n\nfunction checkWebGLError(gl: WebGLRenderingContext) {\n  const error = gl.getError();\n  if (error !== gl.NO_ERROR) {\n    throw new Error('WebGL Error: ' + getWebGLErrorMessage(gl, error));\n  }\n}\n\n// https://en.wikipedia.org/wiki/Half-precision_floating-point_format\nconst MIN_FLOAT16 = 5.96e-8;\nconst MAX_FLOAT16 = 65504;\n\nexport function canBeRepresented(num: number): boolean {\n  if (env().getBool('WEBGL_RENDER_FLOAT32_ENABLED') || num === 0 ||\n      (MIN_FLOAT16 < Math.abs(num) && Math.abs(num) < MAX_FLOAT16)) {\n    return true;\n  }\n  return false;\n}\n\nexport function getWebGLErrorMessage(\n    gl: WebGLRenderingContext, status: number): string {\n  switch (status) {\n    case gl.NO_ERROR:\n      return 'NO_ERROR';\n    case gl.INVALID_ENUM:\n      return 'INVALID_ENUM';\n    case gl.INVALID_VALUE:\n      return 'INVALID_VALUE';\n    case gl.INVALID_OPERATION:\n      return 'INVALID_OPERATION';\n    case gl.INVALID_FRAMEBUFFER_OPERATION:\n      return 'INVALID_FRAMEBUFFER_OPERATION';\n    case gl.OUT_OF_MEMORY:\n      return 'OUT_OF_MEMORY';\n    case gl.CONTEXT_LOST_WEBGL:\n      return 'CONTEXT_LOST_WEBGL';\n    default:\n      return `Unknown error code ${status}`;\n  }\n}\n\nexport function getExtensionOrThrow(\n    gl: WebGLRenderingContext, extensionName: string): {} {\n  return throwIfNull<{}>(\n      gl, () => gl.getExtension(extensionName),\n      'Extension \"' + extensionName + '\" not supported on this browser.');\n}\n\nexport function createVertexShader(\n    gl: WebGLRenderingContext, vertexShaderSource: string): WebGLShader {\n  const vertexShader: WebGLShader = throwIfNull<WebGLShader>(\n      gl, () => gl.createShader(gl.VERTEX_SHADER),\n      'Unable to create vertex WebGLShader.');\n  callAndCheck(gl, () => gl.shaderSource(vertexShader, vertexShaderSource));\n  callAndCheck(gl, () => gl.compileShader(vertexShader));\n  if (gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS) === false) {\n    console.log(gl.getShaderInfoLog(vertexShader));\n    throw new Error('Failed to compile vertex shader.');\n  }\n  return vertexShader;\n}\n\nexport function createFragmentShader(\n    gl: WebGLRenderingContext, fragmentShaderSource: string): WebGLShader {\n  const fragmentShader: WebGLShader = throwIfNull<WebGLShader>(\n      gl, () => gl.createShader(gl.FRAGMENT_SHADER),\n      'Unable to create fragment WebGLShader.');\n  callAndCheck(gl, () => gl.shaderSource(fragmentShader, fragmentShaderSource));\n  callAndCheck(gl, () => gl.compileShader(fragmentShader));\n  if (env().get('ENGINE_COMPILE_ONLY')) {\n    return fragmentShader;\n  }\n  if (gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS) === false) {\n    logShaderSourceAndInfoLog(\n        fragmentShaderSource, gl.getShaderInfoLog(fragmentShader));\n    throw new Error('Failed to compile fragment shader.');\n  }\n  return fragmentShader;\n}\n\nconst lineNumberRegex = /ERROR: [0-9]+:([0-9]+):/g;\nexport function logShaderSourceAndInfoLog(\n    shaderSource: string, shaderInfoLog: string) {\n  const lineNumberRegexResult = lineNumberRegex.exec(shaderInfoLog);\n  if (lineNumberRegexResult == null) {\n    console.log(`Couldn't parse line number in error: ${shaderInfoLog}`);\n    console.log(shaderSource);\n    return;\n  }\n\n  const lineNumber = +lineNumberRegexResult[1];\n\n  const shaderLines = shaderSource.split('\\n');\n  const pad = shaderLines.length.toString().length + 2;\n  const linesWithLineNumbers = shaderLines.map(\n      (line, lineNumber) =>\n          util.rightPad((lineNumber + 1).toString(), pad) + line);\n  let maxLineLength = 0;\n  for (let i = 0; i < linesWithLineNumbers.length; i++) {\n    maxLineLength = Math.max(linesWithLineNumbers[i].length, maxLineLength);\n  }\n\n  const beforeErrorLines = linesWithLineNumbers.slice(0, lineNumber - 1);\n  const errorLine = linesWithLineNumbers.slice(lineNumber - 1, lineNumber);\n  const afterErrorLines = linesWithLineNumbers.slice(lineNumber);\n\n  console.log(beforeErrorLines.join('\\n'));\n  console.log(shaderInfoLog.split('\\n')[0]);\n  console.log(\n      `%c ${util.rightPad(errorLine[0], maxLineLength)}`,\n      'border:1px solid red; background-color:#e3d2d2; color:#a61717');\n  console.log(afterErrorLines.join('\\n'));\n}\n\nexport function createProgram(gl: WebGLRenderingContext): WebGLProgram {\n  return throwIfNull<WebGLProgram>(\n      gl, () => gl.createProgram(), 'Unable to create WebGLProgram.');\n}\n\nexport function linkProgram(gl: WebGLRenderingContext, program: WebGLProgram) {\n  callAndCheck(gl, () => gl.linkProgram(program));\n  if (env().get('ENGINE_COMPILE_ONLY')) {\n    return;\n  }\n  if (gl.getProgramParameter(program, gl.LINK_STATUS) === false) {\n    console.log(gl.getProgramInfoLog(program));\n    throw new Error('Failed to link vertex and fragment shaders.');\n  }\n}\n\n/// validateProgram is effectively \"If we `useProgram(program); drawArrays();`,\n/// give feedback in log about perf/correctness warnings or errors that would\n/// occur.\"\n/// So make sure we set up all vertex/texture/sampler/uniform data before\n/// calling validateProgram!\nexport function validateProgram(\n    gl: WebGLRenderingContext, program: WebGLProgram) {\n  callAndCheck(gl, () => gl.validateProgram(program));\n  if (gl.getProgramParameter(program, gl.VALIDATE_STATUS) === false) {\n    console.log(gl.getProgramInfoLog(program));\n    throw new Error('Shader program validation failed.');\n  }\n}\n\nexport function createStaticVertexBuffer(\n    gl: WebGLRenderingContext, data: Float32Array): WebGLBuffer {\n  const buffer: WebGLBuffer = throwIfNull<WebGLBuffer>(\n      gl, () => gl.createBuffer(), 'Unable to create WebGLBuffer');\n  callAndCheck(gl, () => gl.bindBuffer(gl.ARRAY_BUFFER, buffer));\n  callAndCheck(gl, () => gl.bufferData(gl.ARRAY_BUFFER, data, gl.STATIC_DRAW));\n  return buffer;\n}\n\nexport function createStaticIndexBuffer(\n    gl: WebGLRenderingContext, data: Uint16Array): WebGLBuffer {\n  const buffer: WebGLBuffer = throwIfNull<WebGLBuffer>(\n      gl, () => gl.createBuffer(), 'Unable to create WebGLBuffer');\n  callAndCheck(gl, () => gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, buffer));\n  callAndCheck(\n      gl, () => gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, data, gl.STATIC_DRAW));\n  return buffer;\n}\n\nexport function getNumChannels(): number {\n  if (env().getNumber('WEBGL_VERSION') === 2) {\n    return 1;\n  }\n  return 4;\n}\n\nexport function createTexture(gl: WebGLRenderingContext): WebGLTexture {\n  return throwIfNull<WebGLTexture>(\n      gl, () => gl.createTexture(), 'Unable to create WebGLTexture.');\n}\n\nexport function validateTextureSize(width: number, height: number) {\n  const maxTextureSize = env().getNumber('WEBGL_MAX_TEXTURE_SIZE');\n  if ((width <= 0) || (height <= 0)) {\n    const requested = `[${width}x${height}]`;\n    throw new Error('Requested texture size ' + requested + ' is invalid.');\n  }\n  if ((width > maxTextureSize) || (height > maxTextureSize)) {\n    const requested = `[${width}x${height}]`;\n    const max = `[${maxTextureSize}x${maxTextureSize}]`;\n    throw new Error(\n        'Requested texture size ' + requested +\n        ' greater than WebGL maximum on this browser / GPU ' + max + '.');\n  }\n}\n\nexport function createFramebuffer(gl: WebGLRenderingContext): WebGLFramebuffer {\n  return throwIfNull<WebGLFramebuffer>(\n      gl, () => gl.createFramebuffer(), 'Unable to create WebGLFramebuffer.');\n}\n\nexport function bindVertexBufferToProgramAttribute(\n    gl: WebGLRenderingContext, program: WebGLProgram, attribute: string,\n    buffer: WebGLBuffer, arrayEntriesPerItem: number, itemStrideInBytes: number,\n    itemOffsetInBytes: number): boolean {\n  const loc = gl.getAttribLocation(program, attribute);\n  if (loc === -1) {\n    // The GPU compiler decided to strip out this attribute because it's unused,\n    // thus no need to bind.\n    return false;\n  }\n  callAndCheck(gl, () => gl.bindBuffer(gl.ARRAY_BUFFER, buffer));\n  callAndCheck(\n      gl,\n      () => gl.vertexAttribPointer(\n          loc, arrayEntriesPerItem, gl.FLOAT, false, itemStrideInBytes,\n          itemOffsetInBytes));\n  callAndCheck(gl, () => gl.enableVertexAttribArray(loc));\n  return true;\n}\n\nexport function bindTextureUnit(\n    gl: WebGLRenderingContext, texture: WebGLTexture, textureUnit: number) {\n  validateTextureUnit(gl, textureUnit);\n  callAndCheck(gl, () => gl.activeTexture(gl.TEXTURE0 + textureUnit));\n  callAndCheck(gl, () => gl.bindTexture(gl.TEXTURE_2D, texture));\n}\n\nexport function unbindTextureUnit(\n    gl: WebGLRenderingContext, textureUnit: number) {\n  validateTextureUnit(gl, textureUnit);\n  callAndCheck(gl, () => gl.activeTexture(gl.TEXTURE0 + textureUnit));\n  callAndCheck(gl, () => gl.bindTexture(gl.TEXTURE_2D, null));\n}\n\nexport function getProgramUniformLocationOrThrow(\n    gl: WebGLRenderingContext, program: WebGLProgram,\n    uniformName: string): WebGLUniformLocation {\n  return throwIfNull<WebGLUniformLocation>(\n      gl, () => gl.getUniformLocation(program, uniformName),\n      'uniform \"' + uniformName + '\" not present in program.');\n}\n\nexport function getProgramUniformLocation(\n    gl: WebGLRenderingContext, program: WebGLProgram,\n    uniformName: string): WebGLUniformLocation {\n  return gl.getUniformLocation(program, uniformName);\n}\n\nexport function bindTextureToProgramUniformSampler(\n    gl: WebGLRenderingContext, texture: WebGLTexture,\n    uniformSamplerLocation: WebGLUniformLocation, textureUnit: number) {\n  callAndCheck(gl, () => bindTextureUnit(gl, texture, textureUnit));\n  callAndCheck(gl, () => gl.uniform1i(uniformSamplerLocation, textureUnit));\n}\n\nexport function bindCanvasToFramebuffer(gl: WebGLRenderingContext) {\n  callAndCheck(gl, () => gl.bindFramebuffer(gl.FRAMEBUFFER, null));\n  callAndCheck(gl, () => gl.viewport(0, 0, gl.canvas.width, gl.canvas.height));\n  callAndCheck(gl, () => gl.scissor(0, 0, gl.canvas.width, gl.canvas.height));\n}\n\nexport function bindColorTextureToFramebuffer(\n    gl: WebGLRenderingContext, texture: WebGLTexture,\n    framebuffer: WebGLFramebuffer) {\n  callAndCheck(gl, () => gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer));\n  callAndCheck(\n      gl,\n      () => gl.framebufferTexture2D(\n          gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0));\n}\n\nexport function unbindColorTextureFromFramebuffer(\n    gl: WebGLRenderingContext, framebuffer: WebGLFramebuffer) {\n  callAndCheck(gl, () => gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer));\n  callAndCheck(\n      gl,\n      () => gl.framebufferTexture2D(\n          gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, null, 0));\n}\n\nexport function validateFramebuffer(gl: WebGLRenderingContext) {\n  const status = gl.checkFramebufferStatus(gl.FRAMEBUFFER);\n  if (status !== gl.FRAMEBUFFER_COMPLETE) {\n    throw new Error(\n        'Error binding framebuffer: ' + getFramebufferErrorMessage(gl, status));\n  }\n}\n\nexport function getFramebufferErrorMessage(\n    gl: WebGLRenderingContext, status: number): string {\n  switch (status) {\n    case gl.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:\n      return 'FRAMEBUFFER_INCOMPLETE_ATTACHMENT';\n    case gl.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:\n      return 'FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT';\n    case gl.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:\n      return 'FRAMEBUFFER_INCOMPLETE_DIMENSIONS';\n    case gl.FRAMEBUFFER_UNSUPPORTED:\n      return 'FRAMEBUFFER_UNSUPPORTED';\n    default:\n      return `unknown error ${status}`;\n  }\n}\n\nfunction throwIfNull<T>(\n    gl: WebGLRenderingContext, returnTOrNull: () => T | null,\n    failureMessage: string): T {\n  const tOrNull: T|null = callAndCheck(gl, () => returnTOrNull());\n  if (tOrNull == null) {\n    throw new Error(failureMessage);\n  }\n  return tOrNull;\n}\n\nfunction validateTextureUnit(gl: WebGLRenderingContext, textureUnit: number) {\n  const maxTextureUnit = gl.MAX_COMBINED_TEXTURE_IMAGE_UNITS - 1;\n  const glTextureUnit = textureUnit + gl.TEXTURE0;\n  if (glTextureUnit < gl.TEXTURE0 || glTextureUnit > maxTextureUnit) {\n    const textureUnitRange = `[gl.TEXTURE0, gl.TEXTURE${maxTextureUnit}]`;\n    throw new Error(`textureUnit must be in ${textureUnitRange}.`);\n  }\n}\n\nexport function getBatchDim(shape: number[], dimsToSkip = 2): number {\n  return util.sizeFromShape(shape.slice(0, shape.length - dimsToSkip));\n}\n\nexport function getRowsCols(shape: number[]): [number, number] {\n  if (shape.length === 0) {\n    throw Error('Cannot get rows and columns of an empty shape array.');\n  }\n\n  return [\n    shape.length > 1 ? shape[shape.length - 2] : 1, shape[shape.length - 1]\n  ];\n}\n\nexport function getShapeAs3D(shape: number[]): [number, number, number] {\n  let shapeAs3D: [number, number, number] = [1, 1, 1];\n  const isScalar = shape.length === 0 || (shape.length === 1 && shape[0] === 1);\n  if (!isScalar) {\n    shapeAs3D =\n        [getBatchDim(shape), ...getRowsCols(shape)] as [number, number, number];\n  }\n  return shapeAs3D;\n}\n\nexport function getTextureShapeFromLogicalShape(\n    logShape: number[], isPacked = false): [number, number] {\n  let maxTexSize = env().getNumber('WEBGL_MAX_TEXTURE_SIZE');\n  let maxSizeForNarrowTex =\n      env().getNumber('WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE');\n  if (maxSizeForNarrowTex === Infinity &&\n      env().getBool('WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE')) {\n    maxSizeForNarrowTex = maxTexSize / 2;\n  }\n\n  if (isPacked) {\n    maxTexSize = maxTexSize * 2;\n    maxSizeForNarrowTex = maxSizeForNarrowTex * 2;\n\n    // This logic ensures we accurately count the number of packed texels needed\n    // to accommodate the tensor. We can only pack values in the same texel if\n    // they are from adjacent pairs of rows/cols within the same batch. So if a\n    // tensor has 3 rows, we pretend it has 4 rows in order to account for the\n    // fact that the texels containing the third row are half empty.\n    logShape = logShape.map(\n        (d, i) => i >= logShape.length - 2 ?\n            util.nearestLargerEven(logShape[i]) :\n            logShape[i]);\n\n    // Packed texture height is at least 2 (the channel height of a single\n    // texel).\n    if (logShape.length === 1) {\n      logShape = [2, logShape[0]];\n    }\n  }\n\n  // If logical shape is 2, we don't squeeze, since we want to match physical.\n  if (logShape.length !== 2) {\n    const squeezeResult = util.squeezeShape(logShape);\n    logShape = squeezeResult.newShape;\n  }\n\n  let size = util.sizeFromShape(logShape);\n  let textureShape: [number, number] = null;\n  if (logShape.length <= 1 && size <= maxTexSize) {\n    textureShape = [1, size];\n  } else if (\n      logShape.length === 2 && logShape[0] <= maxTexSize &&\n      logShape[1] <= maxTexSize) {\n    textureShape = logShape as [number, number];\n  } else if (\n      logShape.length === 3 && logShape[0] * logShape[1] <= maxTexSize &&\n      logShape[2] <= maxTexSize) {\n    textureShape = [logShape[0] * logShape[1], logShape[2]];\n  } else if (\n      logShape.length === 3 && logShape[0] <= maxTexSize &&\n      logShape[1] * logShape[2] <= maxTexSize) {\n    textureShape = [logShape[0], logShape[1] * logShape[2]];\n  } else if (\n      logShape.length === 4 &&\n      logShape[0] * logShape[1] * logShape[2] <= maxTexSize &&\n      logShape[3] <= maxTexSize) {\n    textureShape = [logShape[0] * logShape[1] * logShape[2], logShape[3]];\n  } else if (\n      logShape.length === 4 && logShape[0] <= maxTexSize &&\n      logShape[1] * logShape[2] * logShape[3] <= maxTexSize) {\n    textureShape = [logShape[0], logShape[1] * logShape[2] * logShape[3]];\n  }\n\n  // true if one edge length is 1 (1 or 2, if packed), while another edge\n  // length exceeds maxSizeForNarrowTex.\n  const isLongNarrowTex = textureShape != null &&\n      Math.max(...textureShape) > maxSizeForNarrowTex &&\n      Math.min(...textureShape) <= (isPacked ? 2 : 1) &&\n      Math.min(...textureShape) > 0;\n\n  if (textureShape == null || isLongNarrowTex) {\n    if (isPacked) {\n      // For packed textures size equals the number of channels required to\n      // accommodate the texture data. However in order to squarify such that\n      // inner dimensions stay even, we rewrite size to equal the number of\n      // texels. Then in the return statement we rehydrate the squarified\n      // dimensions to channel units.\n\n      const batchDim = getBatchDim(logShape);\n      let rows = 2, cols = 2;\n      if (logShape.length) {\n        [rows, cols] = getRowsCols(logShape);\n      }\n      size = batchDim * (rows / 2) * (cols / 2);\n      textureShape =\n          util.sizeToSquarishShape(size).map(d => d * 2) as [number, number];\n    } else {\n      textureShape = util.sizeToSquarishShape(size);\n    }\n  }\n\n  return textureShape;\n}\n\nfunction isEven(n: number): boolean {\n  return n % 2 === 0;\n}\n\n/**\n * This determines whether reshaping a packed texture requires rearranging\n * the data within the texture, assuming 2x2 packing.\n */\nexport function isReshapeFree(shape1: number[], shape2: number[]): boolean {\n  shape1 = shape1.slice(-2);\n  shape2 = shape2.slice(-2);\n\n  if (util.arraysEqual(shape1, shape2)) {\n    return true;\n  }\n\n  if (!shape1.length || !shape2.length) {  // One of the shapes is a scalar.\n    return true;\n  }\n\n  if (shape1[0] === 0 || shape1[1] === 0 || shape2[0] === 0 ||\n      shape2[1] === 0) {\n    return true;\n  }\n\n  if (shape1.length !== shape2.length) {  // One of the shapes is a vector.\n    const shape1Cols = shape1.slice(-1)[0];\n    const shape2Cols = shape2.slice(-1)[0];\n    if (shape1Cols === shape2Cols) {\n      return true;\n    }\n\n    if (isEven(shape1Cols) && isEven(shape2Cols) &&\n        (shape1[0] === 1 || shape2[0] === 1)) {\n      return true;\n    }\n  }\n  return shape1[1] === shape2[1] && isEven(shape1[0]) && isEven(shape2[0]);\n}\n\n// We cache webgl params because the environment gets reset between\n// unit tests and we don't want to constantly query the WebGLContext for\n// MAX_TEXTURE_SIZE.\nlet MAX_TEXTURE_SIZE: number;\nlet MAX_TEXTURES_IN_SHADER: number;\n\nexport function getWebGLMaxTextureSize(webGLVersion: number): number {\n  if (MAX_TEXTURE_SIZE == null) {\n    const gl = getWebGLContext(webGLVersion);\n    MAX_TEXTURE_SIZE = gl.getParameter(gl.MAX_TEXTURE_SIZE);\n  }\n  return MAX_TEXTURE_SIZE;\n}\n\nexport function resetMaxTextureSize() {\n  MAX_TEXTURE_SIZE = null;\n}\nexport function resetMaxTexturesInShader() {\n  MAX_TEXTURES_IN_SHADER = null;\n}\n\nexport function getMaxTexturesInShader(webGLVersion: number): number {\n  if (MAX_TEXTURES_IN_SHADER == null) {\n    const gl = getWebGLContext(webGLVersion);\n    MAX_TEXTURES_IN_SHADER = gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS);\n  }\n  // We cap at 16 to avoid spurious runtime \"memory exhausted\" error.\n  return Math.min(16, MAX_TEXTURES_IN_SHADER);\n}\n\nexport function getWebGLDisjointQueryTimerVersion(webGLVersion: number):\n    number {\n  if (webGLVersion === 0) {\n    return 0;\n  }\n\n  let queryTimerVersion: number;\n  const gl = getWebGLContext(webGLVersion);\n\n  if (hasExtension(gl, 'EXT_disjoint_timer_query_webgl2') &&\n      webGLVersion === 2) {\n    queryTimerVersion = 2;\n  } else if (hasExtension(gl, 'EXT_disjoint_timer_query')) {\n    queryTimerVersion = 1;\n  } else {\n    queryTimerVersion = 0;\n  }\n  return queryTimerVersion;\n}\n\nexport function hasExtension(gl: WebGLRenderingContext, extensionName: string) {\n  const ext = gl.getExtension(extensionName);\n  return ext != null;\n}\n\nexport function isWebGLVersionEnabled(webGLVersion: 1|2) {\n  try {\n    const gl = getWebGLContext(webGLVersion);\n    if (gl != null) {\n      return true;\n    }\n  } catch (e) {\n    console.log('Error when getting WebGL context: ', e);\n    return false;\n  }\n  return false;\n}\n\nexport function isCapableOfRenderingToFloatTexture(webGLVersion: number):\n    boolean {\n  if (webGLVersion === 0) {\n    return false;\n  }\n\n  const gl = getWebGLContext(webGLVersion);\n\n  if (webGLVersion === 1) {\n    if (!hasExtension(gl, 'OES_texture_float')) {\n      return false;\n    }\n  } else {\n    if (!hasExtension(gl, 'EXT_color_buffer_float')) {\n      return false;\n    }\n  }\n\n  const isFrameBufferComplete = createFloatTextureAndBindToFramebuffer(gl);\n  return isFrameBufferComplete;\n}\n\n/**\n * Check if we can download values from a float/half-float texture.\n *\n * Note that for performance reasons we use binding a texture to a framebuffer\n * as a proxy for ability to download float values later using readPixels. The\n * texture params of this texture will not match those in readPixels exactly\n * but if we are unable to bind some kind of float texture to the frameBuffer\n * then we definitely will not be able to read float values from it.\n */\nexport function isDownloadFloatTextureEnabled(webGLVersion: number): boolean {\n  if (webGLVersion === 0) {\n    return false;\n  }\n\n  const gl = getWebGLContext(webGLVersion);\n\n  if (webGLVersion === 1) {\n    if (!hasExtension(gl, 'OES_texture_float')) {\n      return false;\n    }\n    if (!hasExtension(gl, 'WEBGL_color_buffer_float')) {\n      return false;\n    }\n  } else {\n    if (hasExtension(gl, 'EXT_color_buffer_float')) {\n      return createFloatTextureAndBindToFramebuffer(gl);\n    }\n\n    const COLOR_BUFFER_HALF_FLOAT = 'EXT_color_buffer_half_float';\n    if (hasExtension(gl, COLOR_BUFFER_HALF_FLOAT)) {\n      const textureHalfFloatExtension =\n          gl.getExtension(COLOR_BUFFER_HALF_FLOAT);\n      return createHalfFloatTextureAndBindToFramebuffer(\n          gl, textureHalfFloatExtension);\n    }\n\n    return false;\n  }\n\n  const isFrameBufferComplete = createFloatTextureAndBindToFramebuffer(gl);\n  return isFrameBufferComplete;\n}\n\nfunction createFloatTextureAndBindToFramebuffer(gl: WebGLRenderingContext):\n    boolean {\n  const texConfig = getTextureConfig(gl);\n\n  const texture = gl.createTexture();\n  gl.bindTexture(gl.TEXTURE_2D, texture);\n\n  const width = 1;\n  const height = 1;\n  gl.texImage2D(\n      gl.TEXTURE_2D, 0, texConfig.internalFormatFloat, width, height, 0,\n      texConfig.textureFormatFloat, texConfig.textureTypeFloat, null);\n\n  const frameBuffer = gl.createFramebuffer();\n  gl.bindFramebuffer(gl.FRAMEBUFFER, frameBuffer);\n  gl.framebufferTexture2D(\n      gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);\n\n  const isFrameBufferComplete =\n      gl.checkFramebufferStatus(gl.FRAMEBUFFER) === gl.FRAMEBUFFER_COMPLETE;\n\n  gl.bindTexture(gl.TEXTURE_2D, null);\n  gl.bindFramebuffer(gl.FRAMEBUFFER, null);\n  gl.deleteTexture(texture);\n  gl.deleteFramebuffer(frameBuffer);\n\n  return isFrameBufferComplete;\n}\n\nfunction createHalfFloatTextureAndBindToFramebuffer(\n    // tslint:disable-next-line:no-any\n    gl: WebGLRenderingContext, textureHalfFloatExtension: any): boolean {\n  const texConfig = getTextureConfig(gl, textureHalfFloatExtension);\n  const texture = gl.createTexture();\n  gl.bindTexture(gl.TEXTURE_2D, texture);\n\n  const width = 1;\n  const height = 1;\n  gl.texImage2D(\n      gl.TEXTURE_2D, 0, texConfig.internalFormatHalfFloat, width, height, 0,\n      texConfig.textureFormatFloat, texConfig.textureTypeHalfFloat, null);\n\n  const frameBuffer = gl.createFramebuffer();\n  gl.bindFramebuffer(gl.FRAMEBUFFER, frameBuffer);\n  gl.framebufferTexture2D(\n      gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);\n\n  const isFrameBufferComplete =\n      gl.checkFramebufferStatus(gl.FRAMEBUFFER) === gl.FRAMEBUFFER_COMPLETE;\n\n  gl.bindTexture(gl.TEXTURE_2D, null);\n  gl.bindFramebuffer(gl.FRAMEBUFFER, null);\n  gl.deleteTexture(texture);\n  gl.deleteFramebuffer(frameBuffer);\n\n  return isFrameBufferComplete;\n}\n\nexport function isWebGLFenceEnabled(webGLVersion: number) {\n  if (webGLVersion !== 2) {\n    return false;\n  }\n  const gl = getWebGLContext(webGLVersion);\n\n  // tslint:disable-next-line:no-any\n  const isEnabled = (gl as any).fenceSync != null;\n  return isEnabled;\n}\n\nexport function assertNotComplex(\n    tensor: TensorInfo|TensorInfo[], opName: string): void {\n  if (!Array.isArray(tensor)) {\n    tensor = [tensor];\n  }\n  tensor.forEach(t => {\n    if (t != null) {\n      util.assert(\n          t.dtype !== 'complex64',\n          () => `${opName} does not support complex64 tensors ` +\n              'in the WebGL backend.');\n    }\n  });\n}\n","/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {device_util, env} from '@tensorflow/tfjs-core';\n\nimport {getMaxTexturesInShader, getWebGLDisjointQueryTimerVersion, getWebGLMaxTextureSize, isCapableOfRenderingToFloatTexture, isDownloadFloatTextureEnabled, isWebGLFenceEnabled, isWebGLVersionEnabled} from './webgl_util';\n\nconst ENV = env();\n\n/**\n * This file contains WebGL-specific flag registrations.\n */\n\n/**\n * True if WebGL is supported.\n */\nENV.registerFlag('HAS_WEBGL', () => ENV.getNumber('WEBGL_VERSION') > 0);\n\n/** 0: No WebGL, 1: WebGL 1.0, 2: WebGL 2.0. */\nENV.registerFlag('WEBGL_VERSION', () => {\n  if (isWebGLVersionEnabled(2)) {\n    return 2;\n  } else if (isWebGLVersionEnabled(1)) {\n    return 1;\n  }\n  return 0;\n});\n\n/** Whether to check for numerical representation problems. */\nENV.registerFlag('WEBGL_CHECK_NUMERICAL_PROBLEMS', () => false);\n\nENV.registerFlag(\n    'WEBGL_BUFFER_SUPPORTED', () => ENV.get('WEBGL_VERSION') === 2);\n\n/** Whether the WebGL backend will sometimes forward ops to the CPU. */\nENV.registerFlag('WEBGL_CPU_FORWARD', () => true);\n\n/** Whether the WebGL backend will always use f16 textures for rendering. */\nENV.registerFlag('WEBGL_FORCE_F16_TEXTURES', () => false);\n\n/** Whether to turn all packing related flags on. */\nENV.registerFlag('WEBGL_PACK', () => ENV.getBool('HAS_WEBGL'));\n\n/** Whether we will pack the batchnormalization op. */\nENV.registerFlag('WEBGL_PACK_NORMALIZATION', () => ENV.getBool('WEBGL_PACK'));\n\n/** Whether we will pack the clip op. */\nENV.registerFlag('WEBGL_PACK_CLIP', () => ENV.getBool('WEBGL_PACK'));\n\n/** Whether we will pack the depthwise conv op. */\nENV.registerFlag('WEBGL_PACK_DEPTHWISECONV', () => ENV.getBool('WEBGL_PACK'));\n\n/** Whether we will pack binary ops. */\nENV.registerFlag(\n    'WEBGL_PACK_BINARY_OPERATIONS', () => ENV.getBool('WEBGL_PACK'));\n\n/** Whether we will pack unary ops. */\nENV.registerFlag(\n    'WEBGL_PACK_UNARY_OPERATIONS', () => ENV.getBool('WEBGL_PACK'));\n\n/** Whether we will pack array ops. */\nENV.registerFlag(\n    'WEBGL_PACK_ARRAY_OPERATIONS', () => ENV.getBool('WEBGL_PACK'));\n\n/** Whether we will pack image ops. */\nENV.registerFlag(\n    'WEBGL_PACK_IMAGE_OPERATIONS', () => ENV.getBool('WEBGL_PACK'));\n\n/** Whether we will pack reduce ops. */\nENV.registerFlag('WEBGL_PACK_REDUCE', () => ENV.getBool('WEBGL_PACK'));\n\n/** Whether packed WebGL kernels lazily unpack their outputs. */\nENV.registerFlag('WEBGL_LAZILY_UNPACK', () => ENV.getBool('WEBGL_PACK'));\n\n/** Whether we will use the im2col algorithm to speed up convolutions. */\nENV.registerFlag('WEBGL_CONV_IM2COL', () => ENV.getBool('WEBGL_PACK'));\n\n/** The maximum texture dimension. */\nENV.registerFlag(\n    'WEBGL_MAX_TEXTURE_SIZE',\n    () => getWebGLMaxTextureSize(ENV.getNumber('WEBGL_VERSION')));\n\n/** The maximum texture dimension. */\nENV.registerFlag(\n    'WEBGL_MAX_TEXTURES_IN_SHADER',\n    () => getMaxTexturesInShader(ENV.getNumber('WEBGL_VERSION')));\n\n/**\n * The disjoint_query_timer extension version.\n * 0: disabled, 1: EXT_disjoint_timer_query, 2:\n * EXT_disjoint_timer_query_webgl2.\n * In Firefox with WebGL 2.0,\n * EXT_disjoint_timer_query_webgl2 is not available, so we must use the\n * WebGL 1.0 extension.\n */\nENV.registerFlag('WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION', () => {\n  const webGLVersion = ENV.getNumber('WEBGL_VERSION');\n\n  if (webGLVersion === 0) {\n    return 0;\n  }\n  return getWebGLDisjointQueryTimerVersion(webGLVersion);\n});\n\n/**\n * Whether the timer object from the disjoint_query_timer extension gives\n * timing information that is reliable.\n */\nENV.registerFlag(\n    'WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE',\n    () => ENV.getNumber('WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION') > 0 &&\n        !device_util.isMobile());\n\n/**\n * Whether the device is physically capable of rendering to float32 textures.\n */\nENV.registerFlag(\n    'WEBGL_RENDER_FLOAT32_CAPABLE',\n    () => isCapableOfRenderingToFloatTexture(ENV.getNumber('WEBGL_VERSION')));\n\n/**\n * Whether rendering to float32 textures is enabled. If disabled, renders to\n * float16 textures.\n */\nENV.registerFlag('WEBGL_RENDER_FLOAT32_ENABLED', () => {\n  return ENV.getBool('WEBGL_FORCE_F16_TEXTURES') ?\n      false :\n      ENV.getBool('WEBGL_RENDER_FLOAT32_CAPABLE');\n});\n\n/**\n * Whether downloading float textures is enabled (16 or 32 bit). If disabled,\n * uses IEEE 754 encoding of the float32 values to 4 uint8 when downloading.\n */\nENV.registerFlag(\n    'WEBGL_DOWNLOAD_FLOAT_ENABLED',\n    () => isDownloadFloatTextureEnabled(ENV.getNumber('WEBGL_VERSION')));\n\n/** Whether the fence API is available. */\nENV.registerFlag(\n    'WEBGL_FENCE_API_ENABLED',\n    () => isWebGLFenceEnabled(ENV.getNumber('WEBGL_VERSION')));\n\n/**\n * Tensors with size <= than this will be uploaded as uniforms, not textures.\n */\nENV.registerFlag('WEBGL_SIZE_UPLOAD_UNIFORM', () => {\n  // Use uniform uploads only when 32bit floats are supported. In\n  // 16bit\n  // environments there are problems with comparing a 16bit texture value\n  // with a 32bit uniform value.\n  const useUniforms = ENV.getBool('WEBGL_RENDER_FLOAT32_ENABLED');\n  return useUniforms ? 4 : 0;\n});\n\n/**\n * If the total number of bytes allocated on the GPU is greater than this\n * number, we will aggressively delete textures upon disposal with\n * gl.deleteMatrixTexture, rather than making them available for reuse.\n *\n * Default value -1 indicates that we will never aggressively delete textures.\n */\nENV.registerFlag(\n    'WEBGL_DELETE_TEXTURE_THRESHOLD',\n    () => {\n      return -1;\n    },\n    threshold => {\n      if (threshold < 0 && threshold !== -1) {\n        throw new Error(\n            `WEBGL_DELETE_TEXTURE_THRESHOLD must be -1 (indicating never ` +\n            `delete) or at least 0, but got ${threshold}.`);\n      }\n    });\n\n/**\n * Trigger a manual GL command flush if the threshold of time has passed since\n * previous Kernel execution. This can be useful for Andorid device where GL\n * command flush are delayed un til the end of javascript task. This value is\n * measured in millisecond. Typically you want to set this value to close to 1.\n *\n * Default value 1 for mobile chrome, and -1 for rest cases. -1 indicates that\n * we will not enforce manual flush and depend on system default flush schedule.\n */\nENV.registerFlag(\n    'WEBGL_FLUSH_THRESHOLD',\n    () => {\n      return device_util.isMobile() ? 1 : -1;\n    },\n    threshold => {\n      if (threshold < 0 && threshold !== -1) {\n        throw new Error(\n            `WEBGL_FLUSH_THRESHOLD must be -1 (indicating never ` +\n            `manual flush) or at least 0, but got ${threshold}.`);\n      }\n    });\n\n/**\n * Threshold for input tensor size that determines whether WebGL backend will\n * delegate computation to CPU.\n *\n * Default value is 128.\n */\nENV.registerFlag('CPU_HANDOFF_SIZE_THRESHOLD', () => 128);\n\n/** Whether we will use shapes uniforms. */\nENV.registerFlag('WEBGL_USE_SHAPES_UNIFORMS', () => false);\n\n/**\n * Threshold for last dimension of input tensor that determines whether\n * WebGL backend for the Top K op will delegate computation to CPU. If input\n * is smaller than threshold then CPU will be used\n *\n * Default value is 100000.\n */\nENV.registerFlag('TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD', () => 100000);\n\n/**\n * Threshold for K that determines whether\n * WebGL backend for the Top K op will delegate computation to CPU. If k\n * is larger than threshold then CPU will be used\n *\n * Default value is 128.\n */\nENV.registerFlag('TOPK_K_CPU_HANDOFF_THRESHOLD', () => 128);\n\n/** Whether we will use the experimental conv op. */\nENV.registerFlag('WEBGL_EXP_CONV', () => false);\n\n/**\n * If the device performance is low or if no hardware GPU is available, whether\n * software WebGL will be used.\n */\nENV.registerFlag('SOFTWARE_WEBGL_ENABLED', () => ENV.getBool('IS_TEST'));\n\n/**\n * For narrow texture (physical height or physical width is 1), if the length of\n * any texture edges exceed the threshold, the texture will be reshaped to be\n * more squarish.\n *\n * This flag is used to help some GPUs that could not provide correct\n * interpolations for long skinny triangles. We found Mali GPU probably has this\n * problem: https://github.com/tensorflow/tfjs/issues/6775.\n */\nENV.registerFlag('WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE', () => Infinity);\n\n/**\n * If the flag is set to true, the max size of the narrow texture will be auto\n * computed and it will be considerred as a threshold to reshape the narrow\n * texture to be more squarish.\n *\n * This flag is used to help some GPUs that could not provide correct\n * interpolations for long skinny triangles. We found Mali GPU probably has this\n * problem: https://github.com/tensorflow/tfjs/issues/6775.\n */\nENV.registerFlag('WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE', () => false);\n\n/**\n * Whether to use the customized isnan. It's only useful for webgl2 since webgl1\n * doesn't have the builtin isnan.\n */\nENV.registerFlag('WEBGL2_ISNAN_CUSTOM', () => false);\n\n/** Experimental flag, whether enter compile only phase. */\nENV.registerFlag('ENGINE_COMPILE_ONLY', () => false);\n","/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport {env} from '@tensorflow/tfjs-core';\n\nexport type GLSL = {\n  version: string,\n  attribute: string,\n  varyingVs: string,\n  varyingFs: string,\n  texture2D: string,\n  output: string,\n  defineOutput: string,\n  defineSpecialNaN: string,\n  defineSpecialInf: string,\n  defineRound: string\n};\n\nexport function getGlslDifferences(): GLSL {\n  let version: string;\n  let attribute: string;\n  let varyingVs: string;\n  let varyingFs: string;\n  let texture2D: string;\n  let output: string;\n  let defineOutput: string;\n  let defineSpecialNaN: string;\n  let defineSpecialInf: string;\n  let defineRound: string;\n\n  if (env().getNumber('WEBGL_VERSION') === 2) {\n    version = '#version 300 es';\n    attribute = 'in';\n    varyingVs = 'out';\n    varyingFs = 'in';\n    texture2D = 'texture';\n    output = 'outputColor';\n    defineOutput = 'out vec4 outputColor;';\n\n    // Use custom isnan definition to work across differences between\n    // implementations on various platforms. While this should happen in ANGLE\n    // we still see differences between android and windows (on chrome) when\n    // using isnan directly. Since WebGL2 supports uint type and\n    // floatBitsToUinT built-in function, we could implment isnan following\n    // IEEE 754 rules.\n    // NaN defination in IEEE 754-1985 is :\n    //   - sign = either 0 or 1.\n    //   - biased exponent = all 1 bits.\n    //   - fraction = anything except all 0 bits (since all 0 bits represents\n    //   infinity).\n    // https://en.wikipedia.org/wiki/IEEE_754-1985#Representation_of_non-numbers\n    defineSpecialNaN = env().getBool('WEBGL2_ISNAN_CUSTOM') ? `\n      bool isnan_custom(float val) {\n        uint floatToUint = floatBitsToUint(val);\n        return (floatToUint & 0x7fffffffu) > 0x7f800000u;\n      }\n\n      bvec4 isnan_custom(vec4 val) {\n        return bvec4(isnan_custom(val.x),\n          isnan_custom(val.y), isnan_custom(val.z), isnan_custom(val.w));\n      }\n\n      #define isnan(value) isnan_custom(value)\n    ` :\n                                                              '';\n    // In webgl 2 we do not need to specify a custom isinf so there is no\n    // need for a special INFINITY constant.\n    defineSpecialInf = ``;\n    defineRound = `\n      #define round(value) newRound(value)\n      int newRound(float value) {\n        return int(floor(value + 0.5));\n      }\n\n      ivec4 newRound(vec4 value) {\n        return ivec4(floor(value + vec4(0.5)));\n      }\n    `;\n  } else {\n    version = '';\n    attribute = 'attribute';\n    varyingVs = 'varying';\n    varyingFs = 'varying';\n    texture2D = 'texture2D';\n    output = 'gl_FragColor';\n    defineOutput = '';\n    // WebGL1 has no built in isnan so we define one here.\n    defineSpecialNaN = `\n      #define isnan(value) isnan_custom(value)\n      bool isnan_custom(float val) {\n        return (val > 0. || val < 1. || val == 0.) ? false : true;\n      }\n      bvec4 isnan_custom(vec4 val) {\n        return bvec4(isnan(val.x), isnan(val.y), isnan(val.z), isnan(val.w));\n      }\n    `;\n    defineSpecialInf = `\n      uniform float INFINITY;\n\n      bool isinf(float val) {\n        return abs(val) == INFINITY;\n      }\n      bvec4 isinf(vec4 val) {\n        return equal(abs(val), vec4(INFINITY));\n      }\n    `;\n    defineRound = `\n      int round(float value) {\n        return int(floor(value + 0.5));\n      }\n\n      ivec4 round(vec4 value) {\n        return ivec4(floor(value + vec4(0.5)));\n      }\n    `;\n  }\n\n  return {\n    version,\n    attribute,\n    varyingVs,\n    varyingFs,\n    texture2D,\n    output,\n    defineOutput,\n    defineSpecialNaN,\n    defineSpecialInf,\n    defineRound\n  };\n}\n","/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {util} from '@tensorflow/tfjs-core';\n\n/**\n * Produces GLSL code that derives logical coordinates from a flat\n * index. The code performs integer division with each stride and decrements\n * the index until the index equals the final dimension coordinate.\n */\nexport function getLogicalCoordinatesFromFlatIndex(\n    coords: string[], shape: number[], index = 'index'): string {\n  const strides = util.computeStrides(shape);\n  return strides\n      .map((stride, i) => {\n        const line1 = `int ${coords[i]} = ${index} / ${stride}`;\n        const line2 = i === strides.length - 1 ?\n            `int ${coords[i + 1]} = ${index} - ${coords[i]} * ${stride}` :\n            `index -= ${coords[i]} * ${stride}`;\n        return `${line1}; ${line2};`;\n      })\n      .join('');\n}\n\nexport function getOutputLogicalCoordinatesFromFlatIndexByUniform(\n    coords: string[], shape: number[], index = 'index'): string {\n  const strides = util.computeStrides(shape);\n  return strides\n      .map((_, i) => {\n        const line1 = `int ${coords[i]} = ${index} / outShapeStrides[${i}]`;\n        const line2 = i === strides.length - 1 ?\n            `int ${coords[i + 1]} = ${index} - ${coords[i]} * outShapeStrides[${\n                i}]` :\n            `index -= ${coords[i]} * outShapeStrides[${i}]`;\n        return `${line1}; ${line2};`;\n      })\n      .join('');\n}\n\n// Produces GLSL code that computes strides.\nfunction symbolicallyComputeStrides(\n    indicesArr: number[], variableName: string): string[] {\n  const numCoords = indicesArr.length;\n  const shape = indicesArr.map(d => `${variableName}[${d}]`);\n  const strides = new Array(numCoords - 1);\n  strides[numCoords - 2] = shape[numCoords - 1];\n  for (let i = numCoords - 3; i >= 0; --i) {\n    strides[i] = `(${strides[i + 1]} * ${shape[i + 1]})`;\n  }\n\n  return strides;\n}\n\nexport function getLogicalCoordinatesFromFlatIndexByUniform(\n    coords: string[], variableName: string, index = 'index'): string {\n  const indicesArray = coords.map((_, i) => i);\n  const strides = symbolicallyComputeStrides(indicesArray, variableName);\n  return strides\n      .map((_, i) => {\n        const line1 = `int ${coords[i]} = ${index} / ${strides[i]}`;\n        const line2 = i === strides.length - 1 ?\n            `int ${coords[i + 1]} = ${index} - ${coords[i]} * ${strides[i]}` :\n            `index -= ${coords[i]} * ${strides[i]}`;\n        return `${line1}; ${line2};`;\n      })\n      .join('');\n}\n\nfunction buildVec(x: string[]): string {\n  if (x.length === 1) {\n    return `${x[0]}`;\n  }\n  return `vec${x.length}(${x.join(',')})`;\n}\n\n/**\n * Produces GLSL code that computes the dot product of the input x and y\n * vectors. Handles splitting inputs into increments of vec4s when necessary.\n */\nexport function dotify(x: string[], y: string[]): string {\n  if (x.length !== y.length) {\n    throw new Error(\n        `Vectors to be dotted must be of the same length -` +\n        `got ${x.length} and ${y.length}`);\n  }\n\n  const slices: string[] = [];\n  const nearestVec4 = Math.floor(x.length / 4);\n  const nearestVec4Remainder = x.length % 4;\n\n  for (let i = 0; i < nearestVec4; i++) {\n    const xSlice = x.slice(i * 4, i * 4 + 4);\n    const ySlice = y.slice(i * 4, i * 4 + 4);\n    slices.push(`${buildVec(xSlice)}, ${buildVec(ySlice)}`);\n  }\n\n  if (nearestVec4Remainder !== 0) {\n    let xSlice = x.slice(nearestVec4 * 4);\n    let ySlice = y.slice(nearestVec4 * 4);\n    if (xSlice.length === 1) {\n      xSlice = xSlice.map(d => `float(${d})`);\n      ySlice = ySlice.map(d => `float(${d})`);\n    }\n    slices.push(`${buildVec(xSlice)}, ${buildVec(ySlice)}`);\n  }\n\n  return slices.map((d, i) => `dot(${d})`).join('+');\n}\n\n/**\n * Produces GLSL that computes the flat index from 3D coordinates.\n */\nexport function getFlatIndexFrom3D(shape: [number, number, number]): string {\n  const strides = util.computeStrides(shape).map(d => d.toString());\n\n  return `\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * ${strides[0]} + coords.y * ${strides[1]} + coords.z;\n  }\n`;\n}\n\nexport function getFlatIndexFrom3DOutput(): string {\n  return `\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;\n  }\n`;\n}\n\nexport const ENCODE_FLOAT_SNIPPET = `\n  const float FLOAT_MAX = 1.70141184e38;\n  const float FLOAT_MIN = 1.17549435e-38;\n\n  lowp vec4 encode_float(highp float v) {\n    if (isnan(v)) {\n      return vec4(255, 255, 255, 255);\n    }\n\n    highp float av = abs(v);\n\n    if(av < FLOAT_MIN) {\n      return vec4(0.0, 0.0, 0.0, 0.0);\n    } else if(v > FLOAT_MAX) {\n      return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;\n    } else if(v < -FLOAT_MAX) {\n      return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;\n    }\n\n    highp vec4 c = vec4(0,0,0,0);\n\n    highp float e = floor(log2(av));\n    highp float m = exp2(fract(log2(av))) - 1.0;\n\n    c[2] = floor(128.0 * m);\n    m -= c[2] / 128.0;\n    c[1] = floor(32768.0 * m);\n    m -= c[1] / 32768.0;\n    c[0] = floor(8388608.0 * m);\n\n    highp float ebias = e + 127.0;\n    c[3] = floor(ebias / 2.0);\n    ebias -= c[3] * 2.0;\n    c[2] += floor(ebias) * 128.0;\n\n    c[3] += 128.0 * step(0.0, -v);\n\n    return c / 255.0;\n  }\n`;\n","/**\n * @license\n * Copyright 2017 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\n// Please make sure the shaker key in makeShaderKey in gpgpu_math.ts is well\n// mapped if any shader source code is changed in this file.\n\nimport {backend_util, util} from '@tensorflow/tfjs-core';\nconst {getBroadcastDims} = backend_util;\nimport {getGlslDifferences, GLSL} from './glsl_version';\nimport * as shader_util from './shader_compiler_util';\n\nexport type ShapeInfo = {\n  logicalShape: number[],\n  texShape: [number, number],\n  isUniform: boolean,\n  isPacked: boolean,\n  flatOffset: number\n};\n\nexport type InputInfo = {\n  name: string,\n  shapeInfo: ShapeInfo\n};\n\nexport type UniformType =\n    'float'|'vec2'|'vec3'|'vec4'|'int'|'ivec2'|'ivec3'|'ivec4';\n\ninterface ProgramParams {\n  userCode: string;\n  enableShapeUniforms?: boolean;\n  packedInputs?: boolean;\n  customUniforms?:\n      Array<{name: string; arrayIndex?: number; type: UniformType;}>;\n}\n\nexport function makeShader(\n    inputsInfo: InputInfo[], outputShape: ShapeInfo,\n    program: ProgramParams): string {\n  const prefixSnippets: string[] = [];\n  inputsInfo.forEach(x => {\n    const size = util.sizeFromShape(x.shapeInfo.logicalShape);\n\n    // Snippet when we decided to upload the values as uniform.\n    if (x.shapeInfo.isUniform) {\n      prefixSnippets.push(\n          `uniform float ${x.name}${size > 1 ? `[${size}]` : ''};`);\n    } else {\n      prefixSnippets.push(`uniform sampler2D ${x.name};`);\n      prefixSnippets.push(`uniform int offset${x.name};`);\n    }\n\n    if (program.enableShapeUniforms) {\n      const {uniformShape} = getUniformInfoFromShape(\n          program.packedInputs, x.shapeInfo.logicalShape, x.shapeInfo.texShape);\n      switch (uniformShape.length) {\n        case 1:\n          prefixSnippets.push(`uniform int ${x.name}Shape;`);\n          break;\n        case 2:\n          prefixSnippets.push(`uniform ivec2 ${x.name}Shape;`);\n          break;\n        case 3:\n          prefixSnippets.push(`uniform ivec3 ${x.name}Shape;`);\n          break;\n        case 4:\n          prefixSnippets.push(`uniform ivec4 ${x.name}Shape;`);\n          break;\n        default:\n          break;\n      }\n      prefixSnippets.push(`uniform ivec2 ${x.name}TexShape;`);\n    }\n  });\n\n  if (program.enableShapeUniforms) {\n    switch (outputShape.logicalShape.length) {\n      case 1:\n        prefixSnippets.push(`uniform int outShape;`);\n        break;\n      case 2:\n        prefixSnippets.push(`uniform ivec2 outShape;`);\n        prefixSnippets.push(`uniform int outShapeStrides;`);\n        break;\n      case 3:\n        prefixSnippets.push(`uniform ivec3 outShape;`);\n        prefixSnippets.push(`uniform ivec2 outShapeStrides;`);\n        break;\n      case 4:\n        prefixSnippets.push(`uniform ivec4 outShape;`);\n        prefixSnippets.push(`uniform ivec3 outShapeStrides;`);\n        break;\n      default:\n        break;\n    }\n    prefixSnippets.push(`uniform ivec2 outTexShape;`);\n  }\n  if (program.customUniforms) {\n    program.customUniforms.forEach((d) => {\n      prefixSnippets.push(`uniform ${d.type} ${d.name}${\n          d.arrayIndex ? `[${d.arrayIndex}]` : ''};`);\n    });\n  }\n  const inputPrefixSnippet = prefixSnippets.join('\\n');\n\n  const inputSamplingSnippet = inputsInfo\n                                   .map(\n                                       x => getInputSamplingSnippet(\n                                           x, outputShape, program.packedInputs,\n                                           program.enableShapeUniforms))\n                                   .join('\\n');\n  const outTexShape = outputShape.texShape;\n  const glsl = getGlslDifferences();\n  const floatTextureSampleSnippet = getFloatTextureSampleSnippet(glsl);\n  let outputSamplingSnippet: string;\n  let floatTextureSetOutputSnippet: string;\n  let shaderPrefix = getShaderPrefix(glsl);\n\n  if (outputShape.isPacked) {\n    outputSamplingSnippet = getPackedOutputSamplingSnippet(\n        outputShape.logicalShape, outTexShape, program.enableShapeUniforms);\n    floatTextureSetOutputSnippet = getFloatTextureSetRGBASnippet(glsl);\n  } else {\n    outputSamplingSnippet = getOutputSamplingSnippet(\n        outputShape.logicalShape, outTexShape, program.enableShapeUniforms);\n    floatTextureSetOutputSnippet = getFloatTextureSetRSnippet(glsl);\n  }\n\n  if (program.packedInputs) {\n    shaderPrefix += SHADER_PACKED_PREFIX;\n  }\n\n  const source = [\n    shaderPrefix, floatTextureSampleSnippet, floatTextureSetOutputSnippet,\n    inputPrefixSnippet, outputSamplingSnippet, inputSamplingSnippet,\n    program.userCode\n  ].join('\\n');\n  return source;\n}\n\nfunction getSamplerFromInInfo(\n    inInfo: InputInfo, enableShapeUniforms = false): string {\n  const shape = inInfo.shapeInfo.logicalShape;\n  switch (shape.length) {\n    case 0:\n      return getSamplerScalar(inInfo, enableShapeUniforms);\n    case 1:\n      return getSampler1D(inInfo, enableShapeUniforms);\n    case 2:\n      return getSampler2D(inInfo, enableShapeUniforms);\n    case 3:\n      return getSampler3D(inInfo, enableShapeUniforms);\n    case 4:\n      return getSampler4D(inInfo, enableShapeUniforms);\n    case 5:\n      return getSampler5D(inInfo);\n    case 6:\n      return getSampler6D(inInfo);\n    default:\n      throw new Error(\n          `${shape.length}-D input sampling` +\n          ` is not yet supported`);\n  }\n}\n\nfunction getPackedSamplerFromInInfo(\n    inInfo: InputInfo, enableShapeUniforms: boolean): string {\n  const shape = inInfo.shapeInfo.logicalShape;\n  switch (shape.length) {\n    case 0:\n      return getPackedSamplerScalar(inInfo);\n    case 1:\n      return getPackedSampler1D(inInfo, enableShapeUniforms);\n    case 2:\n      return getPackedSampler2D(inInfo, enableShapeUniforms);\n    case 3:\n      return getPackedSampler3D(inInfo, enableShapeUniforms);\n    default:\n      return getPackedSamplerND(inInfo, enableShapeUniforms);\n  }\n}\n\nfunction getInputSamplingSnippet(\n    inInfo: InputInfo, outShapeInfo: ShapeInfo, usesPackedTextures = false,\n    enableShapeUniforms: boolean): string {\n  let res = '';\n  if (usesPackedTextures) {\n    res += getPackedSamplerFromInInfo(inInfo, enableShapeUniforms);\n  } else {\n    res += getSamplerFromInInfo(inInfo, enableShapeUniforms);\n  }\n\n  const inShape = inInfo.shapeInfo.logicalShape;\n  const outShape = outShapeInfo.logicalShape;\n  if (inShape.length <= outShape.length) {\n    if (usesPackedTextures) {\n      res += getPackedSamplerAtOutputCoords(inInfo, outShapeInfo);\n    } else {\n      res += getSamplerAtOutputCoords(inInfo, outShapeInfo);\n    }\n  }\n  return res;\n}\n\nfunction getPackedOutputSamplingSnippet(\n    outShape: number[], outTexShape: [number, number],\n    enableShapeUniforms: boolean): string {\n  switch (outShape.length) {\n    case 0:\n      return getOutputScalarCoords();\n    case 1:\n      return getOutputPacked1DCoords(\n          outShape as [number], outTexShape, enableShapeUniforms);\n    case 2:\n      return getOutputPacked2DCoords(\n          outShape as [number, number], outTexShape, enableShapeUniforms);\n    case 3:\n      return getOutputPacked3DCoords(\n          outShape as [number, number, number], outTexShape,\n          enableShapeUniforms);\n    default:\n      return getOutputPackedNDCoords(\n          outShape, outTexShape, enableShapeUniforms);\n  }\n}\n\nfunction getOutputSamplingSnippet(\n    outShape: number[], outTexShape: [number, number],\n    enableShapeUniforms: boolean): string {\n  switch (outShape.length) {\n    case 0:\n      return getOutputScalarCoords();\n    case 1:\n      return getOutput1DCoords(\n          outShape as [number], outTexShape, enableShapeUniforms);\n    case 2:\n      return getOutput2DCoords(\n          outShape as [number, number], outTexShape, enableShapeUniforms);\n    case 3:\n      return getOutput3DCoords(\n          outShape as [number, number, number], outTexShape,\n          enableShapeUniforms);\n    case 4:\n      return getOutput4DCoords(\n          outShape as [number, number, number, number], outTexShape,\n          enableShapeUniforms);\n    case 5:\n      return getOutput5DCoords(\n          outShape as [number, number, number, number, number], outTexShape);\n    case 6:\n      return getOutput6DCoords(\n          outShape as [number, number, number, number, number, number],\n          outTexShape);\n    default:\n      throw new Error(\n          `${outShape.length}-D output sampling is not yet supported`);\n  }\n}\n\nfunction getFloatTextureSampleSnippet(glsl: GLSL): string {\n  return `\n    float sampleTexture(sampler2D textureSampler, vec2 uv) {\n      return ${glsl.texture2D}(textureSampler, uv).r;\n    }\n  `;\n}\n\nfunction getFloatTextureSetRSnippet(glsl: GLSL): string {\n  return `\n    void setOutput(float val) {\n      ${glsl.output} = vec4(val, 0, 0, 0);\n    }\n  `;\n}\n\nfunction getFloatTextureSetRGBASnippet(glsl: GLSL): string {\n  return `\n    void setOutput(vec4 val) {\n      ${glsl.output} = val;\n    }\n  `;\n}\n\nfunction getShaderPrefix(glsl: GLSL): string {\n  const SHADER_PREFIX = `${glsl.version}\n    precision highp float;\n    precision highp int;\n    precision highp sampler2D;\n    ${glsl.varyingFs} vec2 resultUV;\n    ${glsl.defineOutput}\n    const vec2 halfCR = vec2(0.5, 0.5);\n\n    struct ivec5\n    {\n      int x;\n      int y;\n      int z;\n      int w;\n      int u;\n    };\n\n    struct ivec6\n    {\n      int x;\n      int y;\n      int z;\n      int w;\n      int u;\n      int v;\n    };\n\n    uniform float NAN;\n    ${glsl.defineSpecialNaN}\n    ${glsl.defineSpecialInf}\n    ${glsl.defineRound}\n\n    int imod(int x, int y) {\n      return x - y * (x / y);\n    }\n\n    int idiv(int a, int b, float sign) {\n      int res = a / b;\n      int mod = imod(a, b);\n      if (sign < 0. && mod != 0) {\n        res -= 1;\n      }\n      return res;\n    }\n\n    //Based on the work of Dave Hoskins\n    //https://www.shadertoy.com/view/4djSRW\n    #define HASHSCALE1 443.8975\n    float random(float seed){\n      vec2 p = resultUV * seed;\n      vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);\n      p3 += dot(p3, p3.yzx + 19.19);\n      return fract((p3.x + p3.y) * p3.z);\n    }\n\n    ${SAMPLE_1D_SNIPPET}\n    ${SAMPLE_2D_SNIPPET}\n    ${SAMPLE_3D_SNIPPET}\n  `;\n\n  return SHADER_PREFIX;\n}\n\nconst SAMPLE_1D_SNIPPET = `\nvec2 uvFromFlat(int texNumR, int texNumC, int index) {\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\nvec2 packedUVfrom1D(int texNumR, int texNumC, int index) {\n  int texelIndex = index / 2;\n  int texR = texelIndex / texNumC;\n  int texC = texelIndex - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n`;\n\nconst SAMPLE_2D_SNIPPET = `\nvec2 packedUVfrom2D(int texelsInLogicalRow, int texNumR,\n  int texNumC, int row, int col) {\n  int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);\n  int texR = texelIndex / texNumC;\n  int texC = texelIndex - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n`;\n\nconst SAMPLE_3D_SNIPPET = `\nvec2 packedUVfrom3D(int texNumR, int texNumC,\n    int texelsInBatch, int texelsInLogicalRow, int b,\n    int row, int col) {\n  int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n`;\n\nconst SHADER_PACKED_PREFIX = `\n  float getChannel(vec4 frag, vec2 innerDims) {\n    vec2 modCoord = mod(innerDims, 2.);\n    return modCoord.x == 0. ?\n      (modCoord.y == 0. ? frag.r : frag.g) :\n      (modCoord.y == 0. ? frag.b : frag.a);\n  }\n  float getChannel(vec4 frag, int dim) {\n    float modCoord = mod(float(dim), 2.);\n    return modCoord == 0. ? frag.r : frag.g;\n  }\n`;\n\nfunction getOutputScalarCoords() {\n  return `\n    int getOutputCoords() {\n      return 0;\n    }\n  `;\n}\n\nfunction getOutputPacked1DCoords(\n    shape: [number], texShape: [number, number],\n    enableShapeUniforms: boolean): string {\n  const packedTexShape =\n      [Math.ceil(texShape[0] / 2), Math.ceil(texShape[1] / 2)];\n  if (packedTexShape[0] === 1) {\n    if (enableShapeUniforms) {\n      return `\n      int getOutputCoords() {\n        return 2 * int(resultUV.x * ceil(float(outTexShape[1]) / 2.0));\n      }\n    `;\n    }\n\n    return `\n      int getOutputCoords() {\n        return 2 * int(resultUV.x * ${packedTexShape[1]}.0);\n      }\n    `;\n  }\n\n  if (packedTexShape[1] === 1) {\n    if (enableShapeUniforms) {\n      return `\n      int getOutputCoords() {\n        return 2 * int(resultUV.y * ceil(float(outTexShape[0]) / 2.0));\n      }\n    `;\n    }\n\n    return `\n      int getOutputCoords() {\n        return 2 * int(resultUV.y * ${packedTexShape[0]}.0);\n      }\n    `;\n  }\n\n  if (enableShapeUniforms) {\n    return `\n    int getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n      return 2 * (resTexRC.x * packedTexShape[1] + resTexRC.y);\n    }\n  `;\n  }\n\n  return `\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${packedTexShape[0]}, ${packedTexShape[1]}));\n      return 2 * (resTexRC.x * ${packedTexShape[1]} + resTexRC.y);\n    }\n  `;\n}\n\nfunction getOutput1DCoords(\n    shape: [number], texShape: [number, number],\n    enableShapeUniforms: boolean): string {\n  if (texShape[0] === 1) {\n    if (enableShapeUniforms) {\n      return `\n      int getOutputCoords() {\n        return int(resultUV.x * float(outTexShape[1]));\n      }\n    `;\n    }\n    return `\n      int getOutputCoords() {\n        return int(resultUV.x * ${texShape[1]}.0);\n      }\n    `;\n  }\n  if (texShape[1] === 1) {\n    if (enableShapeUniforms) {\n      return `\n      int getOutputCoords() {\n        return int(resultUV.y * float(outTexShape[0]));\n      }\n    `;\n    }\n    return `\n      int getOutputCoords() {\n        return int(resultUV.y * ${texShape[0]}.0);\n      }\n    `;\n  }\n  if (enableShapeUniforms) {\n    return `\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(outTexShape[0], outTexShape[1]));\n      return resTexRC.x * outTexShape[1] + resTexRC.y;\n    }\n  `;\n  }\n  return `\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${texShape[0]}, ${texShape[1]}));\n      return resTexRC.x * ${texShape[1]} + resTexRC.y;\n    }\n  `;\n}\n\nfunction getOutputPacked3DCoords(\n    shape: [number, number, number], texShape: [number, number],\n    enableShapeUniforms: boolean): string {\n  if (enableShapeUniforms) {\n    return `\n    ivec3 getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      int texelsInLogicalRow = int(ceil(float(outShape[2]) / 2.0));\n      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;\n\n      int b = index / texelsInBatch;\n      index -= b * texelsInBatch;\n\n      int r = 2 * (index / texelsInLogicalRow);\n      int c = imod(index, texelsInLogicalRow) * 2;\n\n      return ivec3(b, r, c);\n    }\n  `;\n  }\n\n  const packedTexShape =\n      [Math.ceil(texShape[0] / 2), Math.ceil(texShape[1] / 2)];\n  const texelsInLogicalRow = Math.ceil(shape[2] / 2);\n  const texelsInBatch = texelsInLogicalRow * Math.ceil(shape[1] / 2);\n\n  return `\n    ivec3 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${packedTexShape[0]}, ${packedTexShape[1]}));\n      int index = resTexRC.x * ${packedTexShape[1]} + resTexRC.y;\n\n      int b = index / ${texelsInBatch};\n      index -= b * ${texelsInBatch};\n\n      int r = 2 * (index / ${texelsInLogicalRow});\n      int c = imod(index, ${texelsInLogicalRow}) * 2;\n\n      return ivec3(b, r, c);\n    }\n  `;\n}\n\nfunction getOutput3DCoords(\n    shape: [number, number, number], texShape: [number, number],\n    enableShapeUniforms: boolean): string {\n  if (enableShapeUniforms) {\n    const coordsFromIndexSnippet =\n        shader_util.getOutputLogicalCoordinatesFromFlatIndexByUniform(\n            ['r', 'c', 'd'], shape);\n\n    return `\n  ivec3 getOutputCoords() {\n    ivec2 resTexRC = ivec2(resultUV.yx *\n                           vec2(outTexShape[0], outTexShape[1]));\n    int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n    ${coordsFromIndexSnippet}\n    return ivec3(r, c, d);\n  }\n`;\n  }\n  const coordsFromIndexSnippet =\n      shader_util.getLogicalCoordinatesFromFlatIndex(['r', 'c', 'd'], shape);\n\n  return `\n    ivec3 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${texShape[0]}, ${texShape[1]}));\n      int index = resTexRC.x * ${texShape[1]} + resTexRC.y;\n      ${coordsFromIndexSnippet}\n      return ivec3(r, c, d);\n    }\n  `;\n}\n\nfunction getOutputPackedNDCoords(\n    shape: number[], texShape: [number, number],\n    enableShapeUniforms: boolean): string {\n  if (enableShapeUniforms) {\n    // TODO: support 5d and 6d\n    return `\n    ivec4 getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;\n\n      int texelsInLogicalRow = int(ceil(float(outShape[3]) / 2.0));\n      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[2]) / 2.0));\n      int texelsInBatchN = texelsInBatch * outShape[1];\n\n      int b2 = index / texelsInBatchN;\n      index -= b2 * texelsInBatchN;\n\n      int b = index / texelsInBatch;\n      index -= b * texelsInBatch;\n\n      int r = 2 * (index / texelsInLogicalRow);\n      int c = imod(index, texelsInLogicalRow) * 2;\n\n      return ivec4(b2, b, r, c);\n    }\n  `;\n  }\n  const packedTexShape =\n      [Math.ceil(texShape[0] / 2), Math.ceil(texShape[1] / 2)];\n\n  const texelsInLogicalRow = Math.ceil(shape[shape.length - 1] / 2);\n  const texelsInBatch =\n      texelsInLogicalRow * Math.ceil(shape[shape.length - 2] / 2);\n  let texelsInBatchN = texelsInBatch;\n  let batches = ``;\n  let coords = 'b, r, c';\n\n  for (let b = 2; b < shape.length - 1; b++) {\n    texelsInBatchN *= shape[shape.length - b - 1];\n    batches = `\n      int b${b} = index / ${texelsInBatchN};\n      index -= b${b} * ${texelsInBatchN};\n    ` + batches;\n    coords = `b${b}, ` + coords;\n  }\n\n  return `\n    ivec${shape.length} getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${packedTexShape[0]}, ${packedTexShape[1]}));\n      int index = resTexRC.x * ${packedTexShape[1]} + resTexRC.y;\n\n      ${batches}\n\n      int b = index / ${texelsInBatch};\n      index -= b * ${texelsInBatch};\n\n      int r = 2 * (index / ${texelsInLogicalRow});\n      int c = imod(index, ${texelsInLogicalRow}) * 2;\n\n      return ivec${shape.length}(${coords});\n    }\n  `;\n}\n\nfunction getOutput4DCoords(\n    shape: [number, number, number, number], texShape: [number, number],\n    enableShapeUniforms: boolean): string {\n  if (enableShapeUniforms) {\n    const coordsFromIndexSnippet =\n        shader_util.getOutputLogicalCoordinatesFromFlatIndexByUniform(\n            ['r', 'c', 'd', 'd2'], shape);\n\n    return `\n    ivec4 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(outTexShape[0], outTexShape[1]));\n      int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n      ${coordsFromIndexSnippet}\n      return ivec4(r, c, d, d2);\n    }\n  `;\n  }\n  const coordsFromIndexSnippet = shader_util.getLogicalCoordinatesFromFlatIndex(\n      ['r', 'c', 'd', 'd2'], shape);\n\n  return `\n    ivec4 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(${texShape[0]}, ${texShape[1]}));\n      int index = resTexRC.x * ${texShape[1]} + resTexRC.y;\n      ${coordsFromIndexSnippet}\n      return ivec4(r, c, d, d2);\n    }\n  `;\n}\n\nfunction getOutput5DCoords(\n    shape: [number, number, number, number, number],\n    texShape: [number, number]): string {\n  const coordsFromIndexSnippet = shader_util.getLogicalCoordinatesFromFlatIndex(\n      ['r', 'c', 'd', 'd2', 'd3'], shape);\n\n  return `\n    ivec5 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx * vec2(${texShape[0]},\n                             ${texShape[1]}));\n\n      int index = resTexRC.x * ${texShape[1]} + resTexRC.y;\n\n      ${coordsFromIndexSnippet}\n\n      ivec5 outShape = ivec5(r, c, d, d2, d3);\n      return outShape;\n    }\n  `;\n}\n\nfunction getOutput6DCoords(\n    shape: [number, number, number, number, number, number],\n    texShape: [number, number]): string {\n  const coordsFromIndexSnippet = shader_util.getLogicalCoordinatesFromFlatIndex(\n      ['r', 'c', 'd', 'd2', 'd3', 'd4'], shape);\n\n  return `\n    ivec6 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(${texShape[0]}, ${texShape[1]}));\n      int index = resTexRC.x * ${texShape[1]} + resTexRC.y;\n\n      ${coordsFromIndexSnippet}\n\n      ivec6 result = ivec6(r, c, d, d2, d3, d4);\n      return result;\n    }\n  `;\n}\n\nfunction getOutputPacked2DCoords(\n    shape: [number, number], texShape: [number, number],\n    enableShapeUniforms: boolean): string {\n  const packedTexShape =\n      [Math.ceil(texShape[0] / 2), Math.ceil(texShape[1] / 2)];\n  if (util.arraysEqual(shape, texShape)) {\n    if (enableShapeUniforms) {\n      return `\n      ivec2 getOutputCoords() {\n        ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n        return 2 * ivec2(resultUV.yx * vec2(packedTexShape[0], packedTexShape[1]));\n      }\n    `;\n    }\n\n    return `\n      ivec2 getOutputCoords() {\n        return 2 * ivec2(resultUV.yx * vec2(${packedTexShape[0]}, ${\n        packedTexShape[1]}));\n      }\n    `;\n  }\n\n  // texels needed to accommodate a logical row\n  const texelsInLogicalRow = Math.ceil(shape[1] / 2);\n\n  /**\n   * getOutputCoords\n   *\n   * resTexRC: The rows and columns of the texels. If you move over one\n   * texel to the right in the packed texture, you are moving over one column\n   * (not two).\n   *\n   * index: The texel index\n   */\n  if (enableShapeUniforms) {\n    return `\n    ivec2 getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      int texelsInLogicalRow = int(ceil(float(outShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n\n      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;\n      int r = 2 * (index / texelsInLogicalRow);\n      int c = imod(index, texelsInLogicalRow) * 2;\n\n      return ivec2(r, c);\n    }\n  `;\n  }\n\n  return `\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${packedTexShape[0]}, ${packedTexShape[1]}));\n\n      int index = resTexRC.x * ${packedTexShape[1]} + resTexRC.y;\n      int r = 2 * (index / ${texelsInLogicalRow});\n      int c = imod(index, ${texelsInLogicalRow}) * 2;\n\n      return ivec2(r, c);\n    }\n  `;\n}\n\nfunction getOutput2DCoords(\n    shape: [number, number], texShape: [number, number],\n    enableShapeUniforms: boolean): string {\n  if (util.arraysEqual(shape, texShape)) {\n    if (enableShapeUniforms) {\n      return `\n      ivec2 getOutputCoords() {\n        return ivec2(resultUV.yx * vec2(outTexShape[0], outTexShape[1]));\n      }\n    `;\n    }\n    return `\n      ivec2 getOutputCoords() {\n        return ivec2(resultUV.yx * vec2(${texShape[0]}, ${texShape[1]}));\n      }\n    `;\n  }\n  if (shape[1] === 1) {\n    if (enableShapeUniforms) {\n      return `\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(outTexShape[0], outTexShape[1]));\n        int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n        return ivec2(index, 0);\n      }\n    `;\n    }\n    return `\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(${texShape[0]}, ${texShape[1]}));\n        int index = resTexRC.x * ${texShape[1]} + resTexRC.y;\n        return ivec2(index, 0);\n      }\n    `;\n  }\n  if (shape[0] === 1) {\n    if (enableShapeUniforms) {\n      return `\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(outTexShape[0], outTexShape[1]));\n        int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n        return ivec2(0, index);\n      }\n    `;\n    }\n    return `\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(${texShape[0]}, ${texShape[1]}));\n        int index = resTexRC.x * ${texShape[1]} + resTexRC.y;\n        return ivec2(0, index);\n      }\n    `;\n  }\n  if (enableShapeUniforms) {\n    return `\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(outTexShape[0], outTexShape[1]));\n      int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n      int r = index / outShape[1];\n      int c = index - r * outShape[1];\n      return ivec2(r, c);\n    }\n  `;\n  }\n  return `\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${texShape[0]}, ${texShape[1]}));\n      int index = resTexRC.x * ${texShape[1]} + resTexRC.y;\n      int r = index / ${shape[1]};\n      int c = index - r * ${shape[1]};\n      return ivec2(r, c);\n    }\n  `;\n}\n\nfunction getFlatOffsetUniformName(texName: string): string {\n  return `offset${texName}`;\n}\n\nfunction getPackedSamplerScalar(inputInfo: InputInfo): string {\n  const texName = inputInfo.name;\n  const funcName = 'get' + texName.charAt(0).toUpperCase() + texName.slice(1);\n  const glsl = getGlslDifferences();\n  return `\n    vec4 ${funcName}() {\n      return ${glsl.texture2D}(${texName}, halfCR);\n    }\n  `;\n}\n\nfunction getSamplerScalar(\n    inputInfo: InputInfo, enableShapeUniforms: boolean): string {\n  const texName = inputInfo.name;\n  const funcName = 'get' + texName.charAt(0).toUpperCase() + texName.slice(1);\n  if (inputInfo.shapeInfo.isUniform) {\n    return `float ${funcName}() {return ${texName};}`;\n  }\n  const [texNumR, texNumC] = inputInfo.shapeInfo.texShape;\n  if (texNumR === 1 && texNumC === 1) {\n    return `\n      float ${funcName}() {\n        return sampleTexture(${texName}, halfCR);\n      }\n    `;\n  }\n\n  const offset = getFlatOffsetUniformName(texName);\n  if (enableShapeUniforms) {\n    return `\n    float ${funcName}() {\n      vec2 uv = uvFromFlat(${texName}TexShape[0], ${texName}TexShape[1], ${\n        offset});\n      return sampleTexture(${texName}, uv);\n    }\n  `;\n  }\n\n  const [tNumR, tNumC] = inputInfo.shapeInfo.texShape;\n  return `\n    float ${funcName}() {\n      vec2 uv = uvFromFlat(${tNumR}, ${tNumC}, ${offset});\n      return sampleTexture(${texName}, uv);\n    }\n  `;\n}\n\nfunction getPackedSampler1D(\n    inputInfo: InputInfo, enableShapeUniforms: boolean): string {\n  const texName = inputInfo.name;\n  const funcName = 'get' + texName.charAt(0).toUpperCase() + texName.slice(1);\n  const texShape = inputInfo.shapeInfo.texShape;\n  const glsl = getGlslDifferences();\n  if (enableShapeUniforms) {\n    return `\n    vec4 ${funcName}(int index) {\n      ivec2 packedTexShape = ivec2(ceil(float(${\n        texName}TexShape[0]) / 2.0), ceil(float(${texName}TexShape[1]) / 2.0));\n      vec2 uv = packedUVfrom1D(\n        packedTexShape[0], packedTexShape[1], index);\n      return ${glsl.texture2D}(${texName}, uv);\n    }\n  `;\n  }\n  const packedTexShape =\n      [Math.ceil(texShape[0] / 2), Math.ceil(texShape[1] / 2)];\n  return `\n    vec4 ${funcName}(int index) {\n      vec2 uv = packedUVfrom1D(\n        ${packedTexShape[0]}, ${packedTexShape[1]}, index);\n      return ${glsl.texture2D}(${texName}, uv);\n    }\n  `;\n}\n\nfunction getSampler1D(\n    inputInfo: InputInfo, enableShapeUniforms: boolean): string {\n  const texName = inputInfo.name;\n  const funcName = 'get' + texName.charAt(0).toUpperCase() + texName.slice(1);\n\n  if (inputInfo.shapeInfo.isUniform) {\n    // Uniform arrays will be less than 65505 (no risk of float16 overflow).\n    return `\n      float ${funcName}(int index) {\n        ${getUniformSampler(inputInfo)}\n      }\n    `;\n  }\n\n  const texShape = inputInfo.shapeInfo.texShape;\n  const tNumR = texShape[0];\n  const tNumC = texShape[1];\n\n  if (tNumC === 1 && tNumR === 1) {\n    return `\n      float ${funcName}(int index) {\n        return sampleTexture(${texName}, halfCR);\n      }\n    `;\n  }\n  const offset = getFlatOffsetUniformName(texName);\n  if (tNumC === 1) {\n    if (enableShapeUniforms) {\n      return `\n      float ${funcName}(int index) {\n        vec2 uv = vec2(0.5, (float(index + ${offset}) + 0.5) / float(${\n          texName}TexShape[0]));\n        return sampleTexture(${texName}, uv);\n      }\n    `;\n    }\n\n    return `\n      float ${funcName}(int index) {\n        vec2 uv = vec2(0.5, (float(index + ${offset}) + 0.5) / ${tNumR}.0);\n        return sampleTexture(${texName}, uv);\n      }\n    `;\n  }\n  if (tNumR === 1) {\n    if (enableShapeUniforms) {\n      return `\n      float ${funcName}(int index) {\n        vec2 uv = vec2((float(index + ${offset}) + 0.5) / float(${\n          texName}TexShape[1]), 0.5);\n        return sampleTexture(${texName}, uv);\n      }\n    `;\n    }\n\n    return `\n      float ${funcName}(int index) {\n        vec2 uv = vec2((float(index + ${offset}) + 0.5) / ${tNumC}.0, 0.5);\n        return sampleTexture(${texName}, uv);\n      }\n    `;\n  }\n\n  if (enableShapeUniforms) {\n    return `\n    float ${funcName}(int index) {\n      vec2 uv = uvFromFlat(${texName}TexShape[0], ${\n        texName}TexShape[1], index + ${offset});\n      return sampleTexture(${texName}, uv);\n    }\n  `;\n  }\n\n  return `\n    float ${funcName}(int index) {\n      vec2 uv = uvFromFlat(${tNumR}, ${tNumC}, index + ${offset});\n      return sampleTexture(${texName}, uv);\n    }\n  `;\n}\n\nfunction getPackedSampler2D(\n    inputInfo: InputInfo, enableShapeUniforms: boolean): string {\n  const shape = inputInfo.shapeInfo.logicalShape;\n  const texName = inputInfo.name;\n  const funcName = 'get' + texName.charAt(0).toUpperCase() + texName.slice(1);\n  const texShape = inputInfo.shapeInfo.texShape;\n\n  const texNumR = texShape[0];\n  const texNumC = texShape[1];\n  const glsl = getGlslDifferences();\n  if (texShape != null && util.arraysEqual(shape, texShape)) {\n    if (enableShapeUniforms) {\n      return `\n      vec4 ${funcName}(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(${texName}TexShape[1], ${\n          texName}TexShape[0]);\n\n        return ${glsl.texture2D}(${texName}, uv);\n      }\n    `;\n    }\n    return `\n      vec4 ${funcName}(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(${texNumC}.0, ${texNumR}.0);\n\n        return ${glsl.texture2D}(${texName}, uv);\n      }\n    `;\n  }\n\n  if (enableShapeUniforms) {\n    return `\n    vec4 ${funcName}(int row, int col) {\n      ivec2 packedTexShape = ivec2(ceil(float(${\n        texName}TexShape[0]) / 2.0), ceil(float(${texName}TexShape[1]) / 2.0));\n      int valuesPerRow = int(ceil(float(${texName}Shape[1]) / 2.0));\n      vec2 uv = packedUVfrom2D(valuesPerRow, packedTexShape[0], packedTexShape[1], row, col);\n      return ${glsl.texture2D}(${texName}, uv);\n    }\n  `;\n  }\n  const packedTexShape =\n      [Math.ceil(texShape[0] / 2), Math.ceil(texShape[1] / 2)];\n  const valuesPerRow = Math.ceil(shape[1] / 2);\n\n  return `\n    vec4 ${funcName}(int row, int col) {\n      vec2 uv = packedUVfrom2D(${valuesPerRow}, ${packedTexShape[0]}, ${\n      packedTexShape[1]}, row, col);\n      return ${glsl.texture2D}(${texName}, uv);\n    }\n  `;\n}\n\nfunction getSampler2D(\n    inputInfo: InputInfo, enableShapeUniforms: boolean): string {\n  const shape = inputInfo.shapeInfo.logicalShape;\n  const texName = inputInfo.name;\n  const funcName = 'get' + texName.charAt(0).toUpperCase() + texName.slice(1);\n  const texShape = inputInfo.shapeInfo.texShape;\n\n  if (texShape != null && util.arraysEqual(shape, texShape)) {\n    if (enableShapeUniforms) {\n      return `\n      float ${funcName}(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(${texName}TexShape[1], ${\n          texName}TexShape[0]);\n        return sampleTexture(${texName}, uv);\n      }\n    `;\n    }\n\n    const texNumR = texShape[0];\n    const texNumC = texShape[1];\n    return `\n    float ${funcName}(int row, int col) {\n      vec2 uv = (vec2(col, row) + halfCR) / vec2(${texNumC}.0, ${texNumR}.0);\n      return sampleTexture(${texName}, uv);\n    }\n  `;\n  }\n\n  const {newShape, keptDims} = util.squeezeShape(shape);\n  const squeezedShape = newShape;\n  if (squeezedShape.length < shape.length) {\n    const newInputInfo = squeezeInputInfo(inputInfo, squeezedShape);\n    const params = ['row', 'col'];\n    return `\n      ${getSamplerFromInInfo(newInputInfo, enableShapeUniforms)}\n      float ${funcName}(int row, int col) {\n        return ${funcName}(${getSqueezedParams(params, keptDims)});\n      }\n    `;\n  }\n\n  if (inputInfo.shapeInfo.isUniform) {\n    // Uniform arrays will be less than 65505 (no risk of float16 overflow).\n    return `\n      float ${funcName}(int row, int col) {\n        int index = round(dot(vec2(row, col), vec2(${shape[1]}, 1)));\n        ${getUniformSampler(inputInfo)}\n      }\n    `;\n  }\n\n  const texNumR = texShape[0];\n  const texNumC = texShape[1];\n  const offset = getFlatOffsetUniformName(texName);\n  if (texNumC === 1) {\n    // index is used directly as physical (no risk of float16 overflow).\n    if (enableShapeUniforms) {\n      return `\n      float ${funcName}(int row, int col) {\n        float index = dot(vec3(row, col, ${offset}), vec3(${\n          texName}Shape[1], 1, 1));\n        vec2 uv = vec2(0.5, (index + 0.5) / float(${texName}TexShape[0]));\n        return sampleTexture(${texName}, uv);\n      }\n    `;\n    }\n    return `\n    float ${funcName}(int row, int col) {\n      float index = dot(vec3(row, col, ${offset}), vec3(${shape[1]}, 1, 1));\n      vec2 uv = vec2(0.5, (index + 0.5) / ${texNumR}.0);\n      return sampleTexture(${texName}, uv);\n    }\n  `;\n  }\n  if (texNumR === 1) {\n    // index is used directly as physical (no risk of float16 overflow).\n    if (enableShapeUniforms) {\n      return `\n      float ${funcName}(int row, int col) {\n        float index = dot(vec3(row, col, ${offset}), vec3(${\n          texName}Shape[1], 1, 1));\n        vec2 uv = vec2((index + 0.5) / float(${texName}TexShape[1]), 0.5);\n        return sampleTexture(${texName}, uv);\n      }\n    `;\n    }\n    return `\n    float ${funcName}(int row, int col) {\n      float index = dot(vec3(row, col, ${offset}), vec3(${shape[1]}, 1, 1));\n      vec2 uv = vec2((index + 0.5) / ${texNumC}.0, 0.5);\n      return sampleTexture(${texName}, uv);\n    }\n  `;\n  }\n\n  if (enableShapeUniforms) {\n    return `\n      float ${funcName}(int row, int col) {\n        // Explicitly use integer operations as dot() only works on floats.\n        int index = row * ${texName}Shape[1] + col + ${offset};\n        vec2 uv = uvFromFlat(${texName}TexShape[0], ${\n        texName}TexShape[1], index);\n        return sampleTexture(${texName}, uv);\n      }\n    `;\n  }\n  return `\n  float ${funcName}(int row, int col) {\n    // Explicitly use integer operations as dot() only works on floats.\n    int index = row * ${shape[1]} + col + ${offset};\n    vec2 uv = uvFromFlat(${texNumR}, ${texNumC}, index);\n    return sampleTexture(${texName}, uv);\n  }\n`;\n}\n\nfunction getPackedSampler3D(\n    inputInfo: InputInfo, enableShapeUniforms: boolean): string {\n  const shape = inputInfo.shapeInfo.logicalShape;\n  const texName = inputInfo.name;\n  const funcName = 'get' + texName.charAt(0).toUpperCase() + texName.slice(1);\n  const texShape = inputInfo.shapeInfo.texShape;\n  const packedTexShape =\n      [Math.ceil(texShape[0] / 2), Math.ceil(texShape[1] / 2)];\n\n  if (shape[0] === 1) {\n    const squeezedShape = shape.slice(1);\n    const keptDims = [1, 2];\n    const newInputInfo = squeezeInputInfo(inputInfo, squeezedShape);\n    const params = ['b', 'row', 'col'];\n    return `\n        ${getPackedSamplerFromInInfo(newInputInfo, enableShapeUniforms)}\n        vec4 ${funcName}(int b, int row, int col) {\n          return ${funcName}(${getSqueezedParams(params, keptDims)});\n        }\n      `;\n  }\n\n  const glsl = getGlslDifferences();\n  if (enableShapeUniforms) {\n    return `\n    vec4 ${funcName}(int b, int row, int col) {\n      ivec2 packedTexShape = ivec2(ceil(float(${\n        texName}TexShape[0]) / 2.0), ceil(float(${texName}TexShape[1]) / 2.0));\n      int valuesPerRow = int(ceil(float(${texName}Shape[2]) / 2.0));\n      int texelsInBatch = valuesPerRow * int(ceil(float(${\n        texName}Shape[1]) / 2.0));\n      vec2 uv = packedUVfrom3D(\n        packedTexShape[0], packedTexShape[1], texelsInBatch, valuesPerRow, b, row, col);\n      return ${glsl.texture2D}(${texName}, uv);\n    }\n  `;\n  }\n\n  const texNumR = packedTexShape[0];\n  const texNumC = packedTexShape[1];\n\n  const valuesPerRow = Math.ceil(shape[2] / 2);\n  const texelsInBatch = valuesPerRow * Math.ceil(shape[1] / 2);\n\n  return `\n    vec4 ${funcName}(int b, int row, int col) {\n      vec2 uv = packedUVfrom3D(\n        ${texNumR}, ${texNumC}, ${texelsInBatch}, ${valuesPerRow}, b, row, col);\n      return ${glsl.texture2D}(${texName}, uv);\n    }\n  `;\n}\n\nfunction getSampler3D(\n    inputInfo: InputInfo, enableShapeUniforms: boolean): string {\n  const shape = inputInfo.shapeInfo.logicalShape;\n  const texName = inputInfo.name;\n  const funcName = 'get' + texName.charAt(0).toUpperCase() + texName.slice(1);\n  const stride0 = shape[1] * shape[2];\n  const stride1 = shape[2];\n\n  const {newShape, keptDims} = util.squeezeShape(shape);\n  const squeezedShape = newShape;\n  if (squeezedShape.length < shape.length) {\n    const newInputInfo = squeezeInputInfo(inputInfo, squeezedShape);\n    const params = ['row', 'col', 'depth'];\n    return `\n        ${getSamplerFromInInfo(newInputInfo, enableShapeUniforms)}\n        float ${funcName}(int row, int col, int depth) {\n          return ${funcName}(${getSqueezedParams(params, keptDims)});\n        }\n      `;\n  }\n\n  if (inputInfo.shapeInfo.isUniform) {\n    // Uniform arrays will be less than 65505 (no risk of float16 overflow).\n    return `\n      float ${funcName}(int row, int col, int depth) {\n        int index = round(dot(vec3(row, col, depth),\n                          vec3(${stride0}, ${stride1}, 1)));\n        ${getUniformSampler(inputInfo)}\n      }\n    `;\n  }\n\n  const texShape = inputInfo.shapeInfo.texShape;\n  const texNumR = texShape[0];\n  const texNumC = texShape[1];\n  const flatOffset = inputInfo.shapeInfo.flatOffset;\n  if (texNumC === stride0 && flatOffset == null) {\n    // texC is used directly as physical (no risk of float16 overflow).\n    if (enableShapeUniforms) {\n      return `\n      float ${funcName}(int row, int col, int depth) {\n        int stride1 = ${texName}Shape[2];\n        float texR = float(row);\n        float texC = dot(vec2(col, depth), vec2(stride1, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${texName}TexShape[1], ${texName}TexShape[0]);\n        return sampleTexture(${texName}, uv);\n      }\n    `;\n    }\n    return `\n        float ${funcName}(int row, int col, int depth) {\n          float texR = float(row);\n          float texC = dot(vec2(col, depth), vec2(${stride1}, 1));\n          vec2 uv = (vec2(texC, texR) + halfCR) /\n                     vec2(${texNumC}.0, ${texNumR}.0);\n          return sampleTexture(${texName}, uv);\n        }\n      `;\n  }\n\n  if (texNumC === stride1 && flatOffset == null) {\n    // texR is used directly as physical (no risk of float16 overflow).\n    if (enableShapeUniforms) {\n      return `\n      float ${funcName}(int row, int col, int depth) {\n        float texR = dot(vec2(row, col), vec2(${texName}Shape[1], 1));\n        float texC = float(depth);\n        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${texName}TexShape[1], ${\n          texName}TexShape[0]);\n        return sampleTexture(${texName}, uv);\n      }\n    `;\n    }\n    return `\n    float ${funcName}(int row, int col, int depth) {\n      float texR = dot(vec2(row, col), vec2(${shape[1]}, 1));\n      float texC = float(depth);\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${texNumC}.0, ${texNumR}.0);\n      return sampleTexture(${texName}, uv);\n    }\n  `;\n  }\n\n  const offset = getFlatOffsetUniformName(texName);\n  if (enableShapeUniforms) {\n    return `\n    float ${funcName}(int row, int col, int depth) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int stride0 = ${texName}Shape[1] * ${texName}Shape[2];\n      int stride1 = ${texName}Shape[2];\n      int index = row * stride0 + col * stride1 + depth + ${offset};\n      vec2 uv = uvFromFlat(${texName}TexShape[0], ${texName}TexShape[1], index);\n      return sampleTexture(${texName}, uv);\n    }\n    `;\n  }\n  return `\n      float ${funcName}(int row, int col, int depth) {\n        // Explicitly use integer operations as dot() only works on floats.\n        int index = row * ${stride0} + col * ${stride1} + depth + ${offset};\n        vec2 uv = uvFromFlat(${texNumR}, ${texNumC}, index);\n        return sampleTexture(${texName}, uv);\n      }\n  `;\n}\n\nfunction getPackedSamplerND(\n    inputInfo: InputInfo, enableShapeUniforms: boolean): string {\n  const texName = inputInfo.name;\n  const funcName = 'get' + texName.charAt(0).toUpperCase() + texName.slice(1);\n  const glsl = getGlslDifferences();\n  if (enableShapeUniforms) {\n    // TODO: support 5d and 6d\n    return `\n    vec4 ${funcName}(int b2, int b, int row, int col) {\n      int valuesPerRow = int(ceil(float(${texName}Shape[3]) / 2.0));\n      int texelsInBatch = valuesPerRow * int(ceil(float(${\n        texName}Shape[2]) / 2.0));\n      int index = b * texelsInBatch + (row / 2) * valuesPerRow + (col / 2);\n      texelsInBatch *= ${texName}Shape[1];\n      index = b2 * texelsInBatch + index;\n      ivec2 packedTexShape = ivec2(ceil(float(${\n        texName}TexShape[0]) / 2.0), ceil(float(${texName}TexShape[1]) / 2.0));\n      int texR = index / packedTexShape[1];\n      int texC = index - texR * packedTexShape[1];\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(packedTexShape[1], packedTexShape[0]); return ${\n        glsl.texture2D}(${texName}, uv);\n    }\n  `;\n  }\n  const shape = inputInfo.shapeInfo.logicalShape;\n  const rank = shape.length;\n  const texShape = inputInfo.shapeInfo.texShape;\n  const packedTexShape =\n      [Math.ceil(texShape[0] / 2), Math.ceil(texShape[1] / 2)];\n  const texNumR = packedTexShape[0];\n  const texNumC = packedTexShape[1];\n\n  const valuesPerRow = Math.ceil(shape[rank - 1] / 2);\n  let texelsInBatch = valuesPerRow * Math.ceil(shape[rank - 2] / 2);\n  let params = `int b, int row, int col`;\n  let index = `b * ${texelsInBatch} + (row / 2) * ${valuesPerRow} + (col / 2)`;\n  for (let b = 2; b < rank - 1; b++) {\n    params = `int b${b}, ` + params;\n    texelsInBatch *= shape[rank - b - 1];\n    index = `b${b} * ${texelsInBatch} + ` + index;\n  }\n  return `\n    vec4 ${funcName}(${params}) {\n      int index = ${index};\n      int texR = index / ${texNumC};\n      int texC = index - texR * ${texNumC};\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${texNumC}, ${texNumR});\n      return ${glsl.texture2D}(${texName}, uv);\n    }\n  `;\n}\n\nfunction getSampler4D(\n    inputInfo: InputInfo, enableShapeUniforms: boolean): string {\n  const shape = inputInfo.shapeInfo.logicalShape;\n  const texName = inputInfo.name;\n  const funcName = 'get' + texName.charAt(0).toUpperCase() + texName.slice(1);\n  const stride2 = shape[3];\n  const stride1 = shape[2] * stride2;\n  const stride0 = shape[1] * stride1;\n\n  const {newShape, keptDims} = util.squeezeShape(shape);\n  if (newShape.length < shape.length) {\n    const newInputInfo = squeezeInputInfo(inputInfo, newShape);\n    const params = ['row', 'col', 'depth', 'depth2'];\n    return `\n      ${getSamplerFromInInfo(newInputInfo, enableShapeUniforms)}\n      float ${funcName}(int row, int col, int depth, int depth2) {\n        return ${funcName}(${getSqueezedParams(params, keptDims)});\n      }\n    `;\n  }\n\n  if (inputInfo.shapeInfo.isUniform) {\n    // Uniform arrays will be less than 65505 (no risk of float16 overflow).\n    return `\n      float ${funcName}(int row, int col, int depth, int depth2) {\n        int index = round(dot(vec4(row, col, depth, depth2),\n                          vec4(${stride0}, ${stride1}, ${stride2}, 1)));\n        ${getUniformSampler(inputInfo)}\n      }\n    `;\n  }\n\n  const flatOffset = inputInfo.shapeInfo.flatOffset;\n  const texShape = inputInfo.shapeInfo.texShape;\n  const texNumR = texShape[0];\n  const texNumC = texShape[1];\n\n  const stride2Str = `int stride2 = ${texName}Shape[3];`;\n  const stride1Str = `int stride1 = ${texName}Shape[2] * stride2;`;\n  const stride0Str = `int stride0 = ${texName}Shape[1] * stride1;`;\n  if (texNumC === stride0 && flatOffset == null) {\n    // texC is used directly as physical (no risk of float16 overflow).\n    if (enableShapeUniforms) {\n      return `\n      float ${funcName}(int row, int col, int depth, int depth2) {\n        ${stride2Str}\n        ${stride1Str}\n        float texR = float(row);\n        float texC =\n            dot(vec3(col, depth, depth2),\n                vec3(stride1, stride2, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${texName}TexShape[1], ${texName}TexShape[0]);\n        return sampleTexture(${texName}, uv);\n      }\n    `;\n    }\n    return `\n      float ${funcName}(int row, int col, int depth, int depth2) {\n        float texR = float(row);\n        float texC =\n            dot(vec3(col, depth, depth2),\n                vec3(${stride1}, ${stride2}, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${texNumC}.0, ${texNumR}.0);\n        return sampleTexture(${texName}, uv);\n      }\n    `;\n  }\n  if (texNumC === stride2 && flatOffset == null) {\n    // texR is used directly as physical (no risk of float16 overflow).\n    if (enableShapeUniforms) {\n      return `\n      float ${funcName}(int row, int col, int depth, int depth2) {\n        float texR = dot(vec3(row, col, depth),\n                         vec3(${texName}Shape[1] * ${texName}Shape[2], ${\n          texName}Shape[2], 1));\n        float texC = float(depth2);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${texName}TexShape[1], ${texName}TexShape[0]);\n        return sampleTexture(${texName}, uv);\n      }\n    `;\n    }\n    return `\n      float ${funcName}(int row, int col, int depth, int depth2) {\n        float texR = dot(vec3(row, col, depth),\n                         vec3(${shape[1] * shape[2]}, ${shape[2]}, 1));\n        float texC = float(depth2);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${texNumC}.0, ${texNumR}.0);\n        return sampleTexture(${texName}, uv);\n      }\n    `;\n  }\n\n  const offset = getFlatOffsetUniformName(texName);\n  if (enableShapeUniforms) {\n    return `\n    float ${funcName}(int row, int col, int depth, int depth2) {\n      // Explicitly use integer operations as dot() only works on floats.\n      ${stride2Str}\n      ${stride1Str}\n      ${stride0Str}\n      int index = row * stride0 + col * stride1 +\n          depth * stride2 + depth2;\n      vec2 uv = uvFromFlat(${texName}TexShape[0], ${\n        texName}TexShape[1], index + ${offset});\n      return sampleTexture(${texName}, uv);\n    }\n  `;\n  }\n  return `\n    float ${funcName}(int row, int col, int depth, int depth2) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ${stride0} + col * ${stride1} +\n          depth * ${stride2} + depth2;\n      vec2 uv = uvFromFlat(${texNumR}, ${texNumC}, index + ${offset});\n      return sampleTexture(${texName}, uv);\n    }\n  `;\n}\n\nfunction getSampler5D(inputInfo: InputInfo): string {\n  const shape = inputInfo.shapeInfo.logicalShape;\n  const texName = inputInfo.name;\n  const funcName = 'get' + texName.charAt(0).toUpperCase() + texName.slice(1);\n  const stride3 = shape[4];\n  const stride2 = shape[3] * stride3;\n  const stride1 = shape[2] * stride2;\n  const stride0 = shape[1] * stride1;\n\n  const {newShape, keptDims} = util.squeezeShape(shape);\n  if (newShape.length < shape.length) {\n    const newInputInfo = squeezeInputInfo(inputInfo, newShape);\n    const params = ['row', 'col', 'depth', 'depth2', 'depth3'];\n    return `\n      ${getSamplerFromInInfo(newInputInfo)}\n      float ${funcName}(int row, int col, int depth, int depth2, int depth3) {\n        return ${funcName}(${getSqueezedParams(params, keptDims)});\n      }\n    `;\n  }\n\n  if (inputInfo.shapeInfo.isUniform) {\n    // Uniform arrays will be less than 65505 (no risk of float16 overflow).\n    return `\n      float ${funcName}(int row, int col, int depth, int depth2, int depth3) {\n        float index = dot(\n          vec4(row, col, depth, depth2),\n          vec4(${stride0}, ${stride1}, ${stride2}, ${stride3})) +\n          depth3;\n        ${getUniformSampler(inputInfo)}\n      }\n    `;\n  }\n\n  const flatOffset = inputInfo.shapeInfo.flatOffset;\n  const texShape = inputInfo.shapeInfo.texShape;\n  const texNumR = texShape[0];\n  const texNumC = texShape[1];\n\n  if (texNumC === stride0 && flatOffset == null) {\n    // texC is used directly as physical (no risk of float16 overflow).\n    return `\n      float ${funcName}(int row, int col, int depth, int depth2, int depth3) {\n        int texR = row;\n        float texC = dot(vec4(col, depth, depth2, depth3),\n                         vec4(${stride1}, ${stride2}, ${stride3}, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${texNumC}.0, ${texNumR}.0);\n        return sampleTexture(${texName}, uv);\n      }\n    `;\n  }\n\n  if (texNumC === stride3 && flatOffset == null) {\n    // texR is used directly as physical (no risk of float16 overflow).\n    return `\n      float ${funcName}(int row, int col, int depth, int depth2, int depth3) {\n        float texR = dot(\n          vec4(row, col, depth, depth2),\n          vec4(${shape[1] * shape[2] * shape[3]},\n               ${shape[2] * shape[3]}, ${shape[3]}, 1));\n        int texC = depth3;\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${texNumC}.0, ${texNumR}.0);\n        return sampleTexture(${texName}, uv);\n      }\n    `;\n  }\n\n  const offset = getFlatOffsetUniformName(texName);\n  return `\n    float ${funcName}(int row, int col, int depth, int depth2, int depth3) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ${stride0} + col * ${stride1} + depth * ${stride2} +\n          depth2 * ${stride3} + depth3 + ${offset};\n      vec2 uv = uvFromFlat(${texNumR}, ${texNumC}, index);\n      return sampleTexture(${texName}, uv);\n    }\n  `;\n}\n\nfunction getSampler6D(inputInfo: InputInfo): string {\n  const shape = inputInfo.shapeInfo.logicalShape;\n  const texName = inputInfo.name;\n  const funcName = 'get' + texName.charAt(0).toUpperCase() + texName.slice(1);\n\n  const {newShape, keptDims} = util.squeezeShape(shape);\n  if (newShape.length < shape.length) {\n    const newInputInfo = squeezeInputInfo(inputInfo, newShape);\n    const params = ['row', 'col', 'depth', 'depth2', 'depth3', 'depth4'];\n    return `\n      ${getSamplerFromInInfo(newInputInfo)}\n      float ${funcName}(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        return ${funcName}(${getSqueezedParams(params, keptDims)});\n      }\n    `;\n  }\n\n  const stride4 = shape[5];\n  const stride3 = shape[4] * stride4;\n  const stride2 = shape[3] * stride3;\n  const stride1 = shape[2] * stride2;\n  const stride0 = shape[1] * stride1;\n\n  if (inputInfo.shapeInfo.isUniform) {\n    // Uniform arrays will be less than 65505 (no risk of float16 overflow).\n    return `\n      float ${funcName}(int row, int col, int depth,\n                  int depth2, int depth3, int depth4) {\n        int index = round(dot(\n          vec4(row, col, depth, depth2),\n          vec4(${stride0}, ${stride1}, ${stride2}, ${stride3})) +\n          dot(\n            vec2(depth3, depth4),\n            vec2(${stride4}, 1)));\n        ${getUniformSampler(inputInfo)}\n      }\n    `;\n  }\n\n  const flatOffset = inputInfo.shapeInfo.flatOffset;\n  const texShape = inputInfo.shapeInfo.texShape;\n  const texNumR = texShape[0];\n  const texNumC = texShape[1];\n  if (texNumC === stride0 && flatOffset == null) {\n    // texC is used directly as physical (no risk of float16 overflow).\n    return `\n      float ${funcName}(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        int texR = row;\n        float texC = dot(vec4(col, depth, depth2, depth3),\n          vec4(${stride1}, ${stride2}, ${stride3}, ${stride4})) +\n               float(depth4);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${texNumC}.0, ${texNumR}.0);\n        return sampleTexture(${texName}, uv);\n      }\n    `;\n  }\n  if (texNumC === stride4 && flatOffset == null) {\n    // texR is used directly as physical (no risk of float16 overflow).\n    return `\n      float ${funcName}(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        float texR = dot(vec4(row, col, depth, depth2),\n          vec4(${shape[1] * shape[2] * shape[3] * shape[4]},\n               ${shape[2] * shape[3] * shape[4]},\n               ${shape[3] * shape[4]},\n               ${shape[4]})) + float(depth3);\n        int texC = depth4;\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${texNumC}.0, ${texNumR}.0);\n        return sampleTexture(${texName}, uv);\n      }\n    `;\n  }\n  const offset = getFlatOffsetUniformName(texName);\n  return `\n    float ${funcName}(int row, int col, int depth,\n                  int depth2, int depth3, int depth4) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ${stride0} + col * ${stride1} + depth * ${stride2} +\n          depth2 * ${stride3} + depth3 * ${stride4} + depth4 + ${offset};\n      vec2 uv = uvFromFlat(${texNumR}, ${texNumC}, index);\n      return sampleTexture(${texName}, uv);\n    }\n  `;\n}\n\nfunction getUniformSampler(inputInfo: InputInfo): string {\n  const texName = inputInfo.name;\n  const inSize = util.sizeFromShape(inputInfo.shapeInfo.logicalShape);\n\n  if (inSize < 2) {\n    return `return ${texName};`;\n  }\n\n  return `\n    for (int i = 0; i < ${inSize}; i++) {\n      if (i == index) {\n        return ${texName}[i];\n      }\n    }\n  `;\n}\n\nfunction getPackedSamplerAtOutputCoords(\n    inputInfo: InputInfo, outShapeInfo: ShapeInfo) {\n  const texName = inputInfo.name;\n  const texFuncSnippet = texName.charAt(0).toUpperCase() + texName.slice(1);\n  const funcName = 'get' + texFuncSnippet + 'AtOutCoords';\n  const inRank = inputInfo.shapeInfo.logicalShape.length;\n  const outRank = outShapeInfo.logicalShape.length;\n\n  const broadcastDims = getBroadcastDims(\n      inputInfo.shapeInfo.logicalShape, outShapeInfo.logicalShape);\n\n  const type = getCoordsDataType(outRank);\n  const rankDiff = outRank - inRank;\n  let coordsSnippet: string;\n  const fields = ['x', 'y', 'z', 'w', 'u', 'v'];\n\n  if (inRank === 0) {\n    coordsSnippet = '';\n  } else if (outRank < 2 && broadcastDims.length >= 1) {\n    coordsSnippet = 'coords = 0;';\n  } else {\n    coordsSnippet =\n        broadcastDims.map(d => `coords.${fields[d + rankDiff]} = 0;`)\n            .join('\\n');\n  }\n  let unpackedCoordsSnippet = '';\n  if (outRank < 2 && inRank > 0) {\n    unpackedCoordsSnippet = 'coords';\n  } else {\n    unpackedCoordsSnippet = inputInfo.shapeInfo.logicalShape\n                                .map((s, i) => `coords.${fields[i + rankDiff]}`)\n                                .join(', ');\n  }\n\n  let output = `return outputValue;`;\n  const inSize = util.sizeFromShape(inputInfo.shapeInfo.logicalShape);\n  const isInputScalar = inSize === 1;\n  const outSize = util.sizeFromShape(outShapeInfo.logicalShape);\n  const isOutputScalar = outSize === 1;\n\n  if (inRank === 1 && !isInputScalar && !isOutputScalar) {\n    output = `\n      return vec4(outputValue.xy, outputValue.xy);\n    `;\n  } else if (isInputScalar && !isOutputScalar) {\n    if (outRank === 1) {\n      output = `\n        return vec4(outputValue.x, outputValue.x, 0., 0.);\n      `;\n    } else {\n      output = `\n        return vec4(outputValue.x);\n      `;\n    }\n  } else if (broadcastDims.length) {\n    const rows = inRank - 2;\n    const cols = inRank - 1;\n\n    if (broadcastDims.indexOf(rows) > -1 && broadcastDims.indexOf(cols) > -1) {\n      output = `return vec4(outputValue.x);`;\n    } else if (broadcastDims.indexOf(rows) > -1) {\n      output = `return vec4(outputValue.x, outputValue.y, ` +\n          `outputValue.x, outputValue.y);`;\n    } else if (broadcastDims.indexOf(cols) > -1) {\n      output = `return vec4(outputValue.xx, outputValue.zz);`;\n    }\n  }\n\n  return `\n    vec4 ${funcName}() {\n      ${type} coords = getOutputCoords();\n      ${coordsSnippet}\n      vec4 outputValue = get${texFuncSnippet}(${unpackedCoordsSnippet});\n      ${output}\n    }\n  `;\n}\n\nfunction getSamplerAtOutputCoords(\n    inputInfo: InputInfo, outShapeInfo: ShapeInfo) {\n  const texName = inputInfo.name;\n  const texFuncSnippet = texName.charAt(0).toUpperCase() + texName.slice(1);\n  const funcName = 'get' + texFuncSnippet + 'AtOutCoords';\n  const outTexShape = outShapeInfo.texShape;\n  const inTexShape = inputInfo.shapeInfo.texShape;\n  const inRank = inputInfo.shapeInfo.logicalShape.length;\n  const outRank = outShapeInfo.logicalShape.length;\n\n  if (!inputInfo.shapeInfo.isUniform && inRank === outRank &&\n      inputInfo.shapeInfo.flatOffset == null &&\n      util.arraysEqual(inTexShape, outTexShape)) {\n    return `\n      float ${funcName}() {\n        return sampleTexture(${texName}, resultUV);\n      }\n    `;\n  }\n\n  const type = getCoordsDataType(outRank);\n  const broadcastDims = getBroadcastDims(\n      inputInfo.shapeInfo.logicalShape, outShapeInfo.logicalShape);\n  const rankDiff = outRank - inRank;\n  let coordsSnippet: string;\n  const fields = ['x', 'y', 'z', 'w', 'u', 'v'];\n\n  if (inRank === 0) {\n    coordsSnippet = '';\n  } else if (outRank < 2 && broadcastDims.length >= 1) {\n    coordsSnippet = 'coords = 0;';\n  } else {\n    coordsSnippet =\n        broadcastDims.map(d => `coords.${fields[d + rankDiff]} = 0;`)\n            .join('\\n');\n  }\n  let unpackedCoordsSnippet = '';\n  if (outRank < 2 && inRank > 0) {\n    unpackedCoordsSnippet = 'coords';\n  } else {\n    unpackedCoordsSnippet = inputInfo.shapeInfo.logicalShape\n                                .map((s, i) => `coords.${fields[i + rankDiff]}`)\n                                .join(', ');\n  }\n\n  return `\n    float ${funcName}() {\n      ${type} coords = getOutputCoords();\n      ${coordsSnippet}\n      return get${texFuncSnippet}(${unpackedCoordsSnippet});\n    }\n  `;\n}\n\nexport function getCoordsDataType(rank: number): string {\n  if (rank <= 1) {\n    return 'int';\n  } else if (rank === 2) {\n    return 'ivec2';\n  } else if (rank === 3) {\n    return 'ivec3';\n  } else if (rank === 4) {\n    return 'ivec4';\n  } else if (rank === 5) {\n    return 'ivec5';\n  } else if (rank === 6) {\n    return 'ivec6';\n  } else {\n    throw Error(`GPU for rank ${rank} is not yet supported`);\n  }\n}\n\nexport function getUniformInfoFromShape(\n    isPacked: boolean, shape: number[], texShape: number[]) {\n  const {newShape, keptDims} = util.squeezeShape(shape);\n  const rank = shape.length;\n  const useSqueezePackedShape = isPacked && rank === 3 && shape[0] === 1;\n  const squeezeShape = useSqueezePackedShape ? shape.slice(1) : newShape;\n  const useSqueezeShape =\n      (!isPacked && rank > 1 && !util.arraysEqual(shape, texShape) &&\n       newShape.length < rank) ||\n      useSqueezePackedShape;\n  const uniformShape = useSqueezeShape ? squeezeShape : shape;\n  return {useSqueezeShape, uniformShape, keptDims};\n}\n\n/** Returns a new input info (a copy) that has a squeezed logical shape. */\nexport function squeezeInputInfo(\n    inInfo: InputInfo, squeezedShape: number[]): InputInfo {\n  // Deep copy.\n  const newInputInfo: InputInfo = JSON.parse(JSON.stringify(inInfo));\n  newInputInfo.shapeInfo.logicalShape = squeezedShape;\n  return newInputInfo;\n}\n\nfunction getSqueezedParams(params: string[], keptDims: number[]): string {\n  return keptDims.map(d => params[d]).join(', ');\n}\n","/**\n * @license\n * Copyright 2017 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {backend_util, env, Tensor, TypedArray, util} from '@tensorflow/tfjs-core';\n\nimport {GPGPUContext, GPGPUContextProgram} from './gpgpu_context';\nimport * as shader_compiler from './shader_compiler';\nimport {InputInfo, ShapeInfo, UniformType} from './shader_compiler';\nimport {PackingScheme, TextureData, TextureUsage} from './tex_util';\nimport {createFragmentShader} from './webgl_util';\n\nexport interface GPGPUProgram {\n  variableNames: string[];\n  outputShape: number[];\n  userCode: string;\n  enableShapeUniforms?: boolean;\n  /** If true, this program expects packed input textures. Defaults to false. */\n  packedInputs?: boolean;\n  /** If true, this program produces a packed texture. Defaults to false. */\n  packedOutput?: boolean;\n  /**\n   * Affects what type of texture we allocate for the output. Defaults to\n   * `TextureUsage.RENDER`.\n   */\n  outTexUsage?: TextureUsage;\n  /**\n   * The type of scheme to use when packing texels for the output values.\n   * See `PackingScheme` for details. Defaults to `PackingScheme.SHARED_BATCH`.\n   */\n  outPackingScheme?: PackingScheme;\n  customUniforms?:\n      Array<{name: string; arrayIndex?: number; type: UniformType;}>;\n}\n\nexport interface GPGPUBinary {\n  webGLProgram: GPGPUContextProgram;\n  program: GPGPUProgram;\n  uniformLocations: {[name: string]: WebGLUniformLocation};\n  customUniformLocations?: WebGLUniformLocation[];\n  source: string;\n  fragmentShader: WebGLShader;\n  inShapeInfos: ShapeInfo[];\n  outShapeInfo: ShapeInfo;\n  infLoc: WebGLUniformLocation;\n  nanLoc: WebGLUniformLocation;\n  inShapesLocations?: {[name: string]: WebGLUniformLocation};\n  inTexShapesLocations?: {[name: string]: WebGLUniformLocation};\n  outShapeLocation?: WebGLUniformLocation;\n  outShapeStridesLocation?: WebGLUniformLocation;\n  outTexShapeLocation?: WebGLUniformLocation;\n}\n\nexport interface GPGPUBinaryLocations {\n  uniformLocations: {[name: string]: WebGLUniformLocation};\n  customUniformLocations?: WebGLUniformLocation[];\n  infLoc: WebGLUniformLocation;\n  nanLoc: WebGLUniformLocation;\n  inShapesLocations?: {[name: string]: WebGLUniformLocation};\n  inTexShapesLocations?: {[name: string]: WebGLUniformLocation};\n  outShapeLocation?: WebGLUniformLocation;\n  outShapeStridesLocation?: WebGLUniformLocation;\n  outTexShapeLocation?: WebGLUniformLocation;\n}\n\nexport interface TensorData {\n  shape: number[];\n  texData: TextureData;\n  isUniform: boolean;\n  // Available when we decide to upload as uniform instead of texture.\n  uniformValues?: TypedArray;\n}\n\nexport function compileProgram<T extends Tensor, K extends Tensor>(\n    gpgpu: GPGPUContext, program: GPGPUProgram, inputs: TensorData[],\n    output: TensorData): GPGPUBinary {\n  const inputInfos: InputInfo[] = inputs.map((input, i) => {\n    const shapeInfo: ShapeInfo = {\n      logicalShape: input.shape,\n      texShape: input.isUniform ? null : input.texData.texShape,\n      isUniform: input.isUniform,\n      isPacked: input.isUniform ? false : input.texData.isPacked,\n      flatOffset: null\n    };\n    if (input.texData != null && input.texData.slice != null &&\n        input.texData.slice.flatOffset > 0) {\n      shapeInfo.flatOffset = input.texData.slice.flatOffset;\n    }\n    return {name: program.variableNames[i], shapeInfo};\n  });\n  const inShapeInfos = inputInfos.map(x => x.shapeInfo);\n  const outShapeInfo: ShapeInfo = {\n    logicalShape: output.shape,\n    texShape: output.texData.texShape,\n    isUniform: false,\n    isPacked: output.texData.isPacked,\n    flatOffset: null\n  };\n  const source = shader_compiler.makeShader(inputInfos, outShapeInfo, program);\n  const fragmentShader = createFragmentShader(gpgpu.gl, source);\n  const webGLProgram = gpgpu.createProgram(fragmentShader);\n\n  if (!env().get('ENGINE_COMPILE_ONLY')) {\n    return {\n      program,\n      fragmentShader,\n      source,\n      webGLProgram,\n      inShapeInfos,\n      outShapeInfo,\n      ...getUniformLocations(gpgpu, program, webGLProgram)\n    };\n  } else {\n    return {\n      program,\n      fragmentShader,\n      source,\n      webGLProgram,\n      inShapeInfos,\n      outShapeInfo,\n      uniformLocations: null,\n      customUniformLocations: null,\n      infLoc: null,\n      nanLoc: null,\n      inShapesLocations: null,\n      inTexShapesLocations: null,\n      outShapeLocation: null,\n      outShapeStridesLocation: null,\n      outTexShapeLocation: null\n    };\n  }\n}\n\nexport function getUniformLocations(\n    gpgpu: GPGPUContext, program: GPGPUProgram,\n    webGLProgram: WebGLProgram): GPGPUBinaryLocations {\n  const uniformLocations: {[name: string]: WebGLUniformLocation} = {};\n  const inShapesLocations: {[name: string]: WebGLUniformLocation} = {};\n  const inTexShapesLocations: {[name: string]: WebGLUniformLocation} = {};\n  const customUniformLocations: WebGLUniformLocation[] = [];\n  let outShapeLocation: WebGLUniformLocation;\n  let outTexShapeLocation: WebGLUniformLocation;\n  let outShapeStridesLocation: WebGLUniformLocation;\n  let infLoc: WebGLUniformLocation = null;\n  let nanLoc: WebGLUniformLocation = null;\n\n  // Add special uniforms (NAN, INFINITY)\n  nanLoc = gpgpu.getUniformLocation(webGLProgram, 'NAN', false);\n  if (env().getNumber('WEBGL_VERSION') === 1) {\n    infLoc = gpgpu.getUniformLocation(webGLProgram, 'INFINITY', false);\n  }\n\n  // Add user-defined uniforms\n  const shouldThrow = false;\n  for (let i = 0; i < program.variableNames.length; i++) {\n    const varName = program.variableNames[i];\n    uniformLocations[varName] =\n        gpgpu.getUniformLocation(webGLProgram, varName, shouldThrow);\n    uniformLocations[`offset${varName}`] =\n        gpgpu.getUniformLocation(webGLProgram, `offset${varName}`, shouldThrow);\n    if (program.enableShapeUniforms) {\n      inShapesLocations[`${varName}Shape`] = gpgpu.getUniformLocation(\n          webGLProgram, `${varName}Shape`, shouldThrow);\n      inTexShapesLocations[`${varName}TexShape`] = gpgpu.getUniformLocation(\n          webGLProgram, `${varName}TexShape`, shouldThrow);\n    }\n  }\n\n  if (program.enableShapeUniforms) {\n    outShapeLocation =\n        gpgpu.getUniformLocation(webGLProgram, 'outShape', shouldThrow);\n    outShapeStridesLocation =\n        gpgpu.getUniformLocation(webGLProgram, 'outShapeStrides', shouldThrow);\n    outTexShapeLocation =\n        gpgpu.getUniformLocation(webGLProgram, 'outTexShape', shouldThrow);\n  }\n\n  if (program.customUniforms) {\n    program.customUniforms.forEach((d, i) => {\n      customUniformLocations[i] =\n          gpgpu.getUniformLocation(webGLProgram, d.name, shouldThrow);\n    });\n  }\n\n  return {\n    uniformLocations,\n    customUniformLocations,\n    infLoc,\n    nanLoc,\n    inShapesLocations,\n    inTexShapesLocations,\n    outShapeLocation,\n    outShapeStridesLocation,\n    outTexShapeLocation\n  };\n}\n\nfunction validateBinaryAndProgram(\n    shapeInfos: ShapeInfo[], inputs: TensorData[]) {\n  if (shapeInfos.length !== inputs.length) {\n    throw Error(\n        `Binary was compiled with ${shapeInfos.length} inputs, but ` +\n        `was executed with ${inputs.length} inputs`);\n  }\n\n  shapeInfos.forEach((s, i) => {\n    const shapeA = s.logicalShape;\n    const input = inputs[i];\n    const shapeB = input.shape;\n\n    if (!util.arraysEqual(shapeA, shapeB)) {\n      throw Error(\n          `Binary was compiled with different shapes than ` +\n          `the current args. Shapes ${shapeA} and ${shapeB} must match`);\n    }\n    // The input is uploaded as uniform.\n    if (s.isUniform && input.isUniform) {\n      return;\n    }\n\n    const texShapeA = s.texShape;\n    const texShapeB = input.isUniform ? null : input.texData.texShape;\n    if (!util.arraysEqual(texShapeA, texShapeB)) {\n      throw Error(\n          `Binary was compiled with different texture shapes than the` +\n          ` current args. Shape ${texShapeA} and ${texShapeB} must match`);\n    }\n  });\n}\n\nexport function runProgram<T extends Tensor, K extends Tensor>(\n    gpgpu: GPGPUContext, binary: GPGPUBinary, inputs: TensorData[],\n    output: TensorData, customUniformValues?: number[][]): void {\n  if (!binary.program.enableShapeUniforms) {\n    validateBinaryAndProgram(binary.inShapeInfos, inputs);\n    validateBinaryAndProgram([binary.outShapeInfo], [output]);\n  }\n\n  const outTex = output.texData.texture;\n  const outTexShape = output.texData.texShape;\n  if (output.texData.isPacked) {\n    gpgpu.setOutputPackedMatrixTexture(\n        outTex.texture, outTexShape[0], outTexShape[1]);\n  } else {\n    gpgpu.setOutputMatrixTexture(\n        outTex.texture, outTexShape[0], outTexShape[1]);\n  }\n  gpgpu.setProgram(binary.webGLProgram);\n\n  // Set special uniforms (NAN, INFINITY)\n  if (env().getNumber('WEBGL_VERSION') === 1) {\n    if (binary.infLoc !== null) {\n      gpgpu.gl.uniform1f(binary.infLoc, Infinity);\n    }\n  }\n  if (binary.nanLoc !== null) {\n    gpgpu.gl.uniform1f(binary.nanLoc, NaN);\n  }\n\n  // Set user-defined inputs\n  inputs.forEach((input, i) => {\n    const varName = binary.program.variableNames[i];\n    const varLoc = binary.uniformLocations[varName];\n    const varOffsetLoc = binary.uniformLocations[`offset${varName}`];\n    const varShapeLoc = binary.inShapesLocations[`${varName}Shape`];\n    const varTexShapeLoc = binary.inTexShapesLocations[`${varName}TexShape`];\n\n    if (varShapeLoc) {\n      const {uniformShape} = shader_compiler.getUniformInfoFromShape(\n          binary.program.packedInputs, input.shape, input.texData.texShape);\n      switch (uniformShape.length) {\n        case 1:\n          gpgpu.gl.uniform1iv(varShapeLoc, new Int32Array(uniformShape));\n          break;\n        case 2:\n          gpgpu.gl.uniform2iv(varShapeLoc, new Int32Array(uniformShape));\n          break;\n        case 3:\n          gpgpu.gl.uniform3iv(varShapeLoc, new Int32Array(uniformShape));\n          break;\n        case 4:\n          gpgpu.gl.uniform4iv(varShapeLoc, new Int32Array(uniformShape));\n          break;\n        default:\n          break;\n      }\n    }\n    if (varTexShapeLoc) {\n      gpgpu.gl.uniform2i(\n          varTexShapeLoc, input.texData.texShape[0], input.texData.texShape[1]);\n    }\n\n    if (varLoc == null) {\n      // The compiler inferred that this variable is not used in this shader.\n      return;\n    }\n\n    if (input.isUniform) {\n      // Upload the values of the tensor as uniform.\n      if (util.sizeFromShape(input.shape) < 2) {\n        gpgpu.gl.uniform1f(varLoc, input.uniformValues[0]);\n      } else {\n        let vals = input.uniformValues;\n        if (!(vals instanceof Float32Array)) {\n          vals = new Float32Array(vals);\n        }\n        gpgpu.gl.uniform1fv(varLoc, vals);\n      }\n      return;\n    }\n\n    // If the input was sliced, upload the flat offset index.\n    if (input.texData.slice != null && varOffsetLoc != null) {\n      gpgpu.gl.uniform1i(varOffsetLoc, input.texData.slice.flatOffset);\n    }\n\n    gpgpu.setInputMatrixTexture(input.texData.texture.texture, varLoc, i);\n  });\n\n  const outShapeLoc = binary.outShapeLocation;\n  if (outShapeLoc) {\n    switch (output.shape.length) {\n      case 1:\n        gpgpu.gl.uniform1iv(outShapeLoc, new Int32Array(output.shape));\n        break;\n      case 2:\n        gpgpu.gl.uniform2iv(outShapeLoc, new Int32Array(output.shape));\n        break;\n      case 3:\n        gpgpu.gl.uniform3iv(outShapeLoc, new Int32Array(output.shape));\n        break;\n      case 4:\n        gpgpu.gl.uniform4iv(outShapeLoc, new Int32Array(output.shape));\n        break;\n      default:\n        break;\n    }\n  }\n  if (binary.outShapeStridesLocation) {\n    const strides = util.computeStrides(output.shape);\n    switch (output.shape.length) {\n      case 2:\n        gpgpu.gl.uniform1iv(\n            binary.outShapeStridesLocation, new Int32Array(strides));\n        break;\n      case 3:\n        gpgpu.gl.uniform2iv(\n            binary.outShapeStridesLocation, new Int32Array(strides));\n        break;\n      case 4:\n        gpgpu.gl.uniform3iv(\n            binary.outShapeStridesLocation, new Int32Array(strides));\n        break;\n      default:\n        break;\n    }\n  }\n  if (binary.outTexShapeLocation) {\n    gpgpu.gl.uniform2i(\n        binary.outTexShapeLocation, output.texData.texShape[0],\n        output.texData.texShape[1]);\n  }\n\n  if (binary.program.customUniforms && customUniformValues) {\n    binary.program.customUniforms.forEach((d, i) => {\n      const customLoc = binary.customUniformLocations[i];\n      const customValue = customUniformValues[i];\n      if (d.type === 'float') {\n        gpgpu.gl.uniform1fv(customLoc, customValue);\n      } else if (d.type === 'vec2') {\n        gpgpu.gl.uniform2fv(customLoc, customValue);\n      } else if (d.type === 'vec3') {\n        gpgpu.gl.uniform3fv(customLoc, customValue);\n      } else if (d.type === 'vec4') {\n        gpgpu.gl.uniform4fv(customLoc, customValue);\n      } else if (d.type === 'int') {\n        gpgpu.gl.uniform1iv(customLoc, customValue);\n      } else if (d.type === 'ivec2') {\n        gpgpu.gl.uniform2iv(customLoc, customValue);\n      } else if (d.type === 'ivec3') {\n        gpgpu.gl.uniform3iv(customLoc, customValue);\n      } else if (d.type === 'ivec4') {\n        gpgpu.gl.uniform4iv(customLoc, customValue);\n      } else {\n        throw Error(`uniform type ${d.type} is not supported yet.`);\n      }\n    });\n  }\n  gpgpu.executeProgram();\n}\n\nexport function makeShaderKey(\n    program: GPGPUProgram, inputs: TensorData[], output: TensorData): string {\n  let keyInputs = '';\n  inputs.concat(output).forEach(x => {\n    const hasOffset = x.texData != null && x.texData.slice != null &&\n        x.texData.slice.flatOffset > 0;\n    // TODO: Remove the condition of !x.isUniform.\n    if (program.enableShapeUniforms && !x.isUniform) {\n      const xTexShape = x.texData.texShape;\n      const {useSqueezeShape, uniformShape, keptDims} =\n          shader_compiler.getUniformInfoFromShape(\n              program.packedInputs, x.shape, xTexShape);\n      let rank1 = '', rank2 = '', rank34 = '';\n      if (uniformShape.length === 1 && program.packedInputs) {\n        const packedTexShape =\n            [Math.ceil(xTexShape[0] / 2), Math.ceil(xTexShape[1] / 2)];\n        rank1 = `${packedTexShape[0] > 1}_${packedTexShape[1] > 1}`;\n      } else if (uniformShape.length === 2 && !program.packedInputs) {\n        rank2 = `${uniformShape[0] > 1}_${uniformShape[1] > 1}`;\n      } else if (uniformShape.length > 2 && !program.packedInputs) {\n        const strides = util.computeStrides(uniformShape);\n        rank34 = `${strides[0] === xTexShape[1]}_${\n            strides[strides.length - 1] === xTexShape[1]}`;\n      }\n      const xRank = x.shape.length;\n      const isLogicalShapTexShapeEqual =\n          uniformShape.length === 2 && util.arraysEqual(x.shape, xTexShape);\n      const isScalar = util.sizeFromShape(x.shape) === 1;\n      const broadcastDims =\n          backend_util.getBroadcastDims(x.shape, output.shape);\n      const isInOutTexShapeEqual = !program.packedInputs &&\n          xRank === output.shape.length &&\n          util.arraysEqual(xTexShape, output.texData.texShape);\n      const isTexShapeGreaterThanOne =\n          program.packedInputs || uniformShape.length > 2 ?\n          '' :\n          `${xTexShape[0] > 1}_${xTexShape[1] > 1}`;\n      // These key components are needed due to shader_compiler is embedding\n      // them in the shader.\n      // |xRank| is used to determine the coords length. See\n      // get[Packed]SamplerAtOutputCoords.\n      // |isInOutTexShapeEqual| is used to determine whether going to an\n      // optimization path in getSamplerAtOutputCoords.\n      // |useSqueezeShape| is extracted from squeezeInputInfo of\n      // getSampler[2|3|4]D/getPackedSampler3D.\n      // |isScalar| is extracted from isInputScalar/isOutputScalar in\n      // getPackedSamplerAtOutputCoords.\n      // |broadcastDims| is extracted from get[Packed]SamplerAtOutputCoords.\n      // |isLogicalShapTexShapeEqual| is used in\n      // getOutput[Packed]2DCoords/get[Packed]Sampler2D.\n      // |rank1| is used in getOutputPacked1DCoords.\n      // |rank2| is used in getOutput2DCoords.\n      // |rank34| is used in getSampler3D/getSampler4D.\n      // |isTexShapeGreaterThanOne| are used in\n      // getSampler[Scalar|1D|2D]/getOutput1DCoords.\n      keyInputs += `${xRank}_${isInOutTexShapeEqual}_${\n          useSqueezeShape ? keptDims : ''}_${uniformShape.length}_${isScalar}_${\n          broadcastDims}_${isLogicalShapTexShapeEqual}_${rank1}_${rank2}_${\n          rank34}_${isTexShapeGreaterThanOne}_${hasOffset}`;\n    } else {\n      const texShape = x.isUniform ? 'uniform' : x.texData.texShape;\n      keyInputs += `${x.shape}_${texShape}_${hasOffset}`;\n    }\n  });\n  const keyUserCode = program.userCode;\n  let key = program.constructor.name;\n  // Fast string concat. See https://jsperf.com/string-concatenation/14.\n  key += '_' + keyInputs + '_' + keyUserCode +\n      `${env().getNumber('WEBGL_VERSION')}`;\n  return key;\n}\n\nexport function useShapeUniforms(rank: number) {\n  // TODO: Remove the limitaion of rank <= 4.\n  return env().getBool('WEBGL_USE_SHAPES_UNIFORMS') && rank <= 4;\n}\n","/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {getGlslDifferences} from './glsl_version';\nimport {GPGPUProgram, useShapeUniforms} from './gpgpu_math';\nimport * as shader_util from './shader_compiler_util';\nimport {PackingScheme} from './tex_util';\n\nexport class DecodeMatrixProgram implements GPGPUProgram {\n  variableNames = ['A'];\n  userCode: string;\n  outputShape: [number, number, number];\n  packedInputs = false;\n  packedOutput = true;\n  outPackingScheme = PackingScheme.DENSE;\n  enableShapeUniforms: boolean;\n  customUniforms = [{name: 'texShape', type: 'ivec2' as const }];\n\n  constructor(outputShape: [number, number, number]) {\n    const glsl = getGlslDifferences();\n    this.outputShape = outputShape;\n    this.enableShapeUniforms = useShapeUniforms(this.outputShape.length);\n\n    this.userCode = `\n      ivec3 outCoordsFromFlatIndex(int index) {\n        ${\n        this.enableShapeUniforms ?\n            shader_util.getOutputLogicalCoordinatesFromFlatIndexByUniform(\n                ['r', 'c', 'd'], outputShape) :\n            shader_util.getLogicalCoordinatesFromFlatIndex(\n                ['r', 'c', 'd'], outputShape)}\n        return ivec3(r, c, d);\n      }\n\n      void main() {\n        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));\n        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);\n\n        vec4 result = vec4(0.);\n\n        for (int i=0; i<4; i++) {\n          int flatIndex = index + i;\n          ivec3 rc = outCoordsFromFlatIndex(flatIndex);\n          result[i] = getA(rc.x, rc.y, rc.z);\n        }\n\n        ${glsl.output} = result;\n      }\n    `;\n  }\n}\n","/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {getGlslDifferences} from './glsl_version';\nimport {GPGPUProgram, useShapeUniforms} from './gpgpu_math';\nimport * as shader_util from './shader_compiler_util';\nimport {PackingScheme} from './tex_util';\n\nexport class DecodeMatrixPackedProgram implements GPGPUProgram {\n  variableNames = ['A'];\n  userCode: string;\n  packedInputs = true;\n  packedOutput = true;\n  outputShape: [number, number, number];\n  outPackingScheme = PackingScheme.DENSE;\n  enableShapeUniforms: boolean;\n  customUniforms = [{name: 'texShape', type: 'ivec2' as const }];\n\n  constructor(outputShape: [number, number, number]) {\n    const glsl = getGlslDifferences();\n    this.outputShape = outputShape;\n    this.enableShapeUniforms = useShapeUniforms(this.outputShape.length);\n\n    this.userCode = `\n      ivec3 outCoordsFromFlatIndex(int index) {\n        ${\n        this.enableShapeUniforms ?\n            shader_util.getOutputLogicalCoordinatesFromFlatIndexByUniform(\n                ['r', 'c', 'd'], outputShape) :\n            shader_util.getLogicalCoordinatesFromFlatIndex(\n                ['r', 'c', 'd'], outputShape)}\n        return ivec3(r, c, d);\n      }\n\n      void main() {\n        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));\n        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);\n\n        vec4 result = vec4(0.);\n\n        for (int i=0; i<4; i++) {\n          int flatIndex = index + i;\n          ivec3 rc = outCoordsFromFlatIndex(flatIndex);\n          result[i] = getChannel(getA(rc.x, rc.y, rc.z), vec2(rc.y, rc.z));\n        }\n\n        ${glsl.output} = result;\n      }\n    `;\n  }\n}\n","/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {getGlslDifferences} from './glsl_version';\nimport {GPGPUProgram} from './gpgpu_math';\nimport {ENCODE_FLOAT_SNIPPET} from './shader_compiler_util';\nimport {TextureUsage} from './tex_util';\n\nexport class EncodeFloatProgram implements GPGPUProgram {\n  variableNames = ['A'];\n  userCode: string;\n  outputShape: number[];\n  outTexUsage = TextureUsage.DOWNLOAD;\n\n  constructor(outputShape: number[]) {\n    const glsl = getGlslDifferences();\n    this.outputShape = outputShape;\n    this.userCode = `\n      ${ENCODE_FLOAT_SNIPPET}\n\n      void main() {\n        float x = getAAtOutCoords();\n        ${glsl.output} = encode_float(x);\n      }\n    `;\n  }\n}\n","/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {getGlslDifferences} from './glsl_version';\nimport {GPGPUProgram} from './gpgpu_math';\nimport {ENCODE_FLOAT_SNIPPET} from './shader_compiler_util';\nimport {TextureUsage} from './tex_util';\n\nexport class EncodeFloatPackedProgram implements GPGPUProgram {\n  variableNames = ['A'];\n  userCode: string;\n  outputShape: number[];\n  packedInputs = true;\n  packedOutput = false;\n  outTexUsage = TextureUsage.DOWNLOAD;\n\n  constructor(outputShape: [number, number, number]) {\n    const glsl = getGlslDifferences();\n    this.outputShape = outputShape;\n    this.userCode = `\n      ${ENCODE_FLOAT_SNIPPET}\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n        float x = getChannel(getAAtOutCoords(), vec2(coords.y, coords.z));\n        ${glsl.output} = encode_float(x);\n      }\n    `;\n  }\n}\n","/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {getGlslDifferences} from './glsl_version';\nimport {GPGPUProgram, useShapeUniforms} from './gpgpu_math';\nimport * as shader_util from './shader_compiler_util';\n\nconst CHANNEL_CHAR_TO_INDEX_MAP: Record<string, number> = {\n  'R': 0,\n  'G': 1,\n  'B': 2,\n  'A': 3\n};\n\nexport class EncodeMatrixProgram implements GPGPUProgram {\n  variableNames = ['A'];\n  userCode: string;\n  outputShape: number[];\n  enableShapeUniforms: boolean;\n  customUniforms = [{name: 'texShape', type: 'ivec2' as const }];\n\n  constructor(\n      outputShape: [number, number, number], inputIsUnsignedByte = false,\n      usedChannels = 'RGBA') {\n    const glsl = getGlslDifferences();\n    this.outputShape = outputShape;\n    this.enableShapeUniforms = useShapeUniforms(this.outputShape.length);\n\n    let output = `result`;\n    if (inputIsUnsignedByte) {\n      output = `floor(result * 255. + 0.5)`;\n    }\n\n    let mainLoop = '';\n    for (let usedChannelIndex = 0; usedChannelIndex < usedChannels.length;\n         usedChannelIndex++) {\n      const curChannel = usedChannels[usedChannelIndex];\n      mainLoop += `\n          if(offset == ${usedChannelIndex}) {\n            result = values[${CHANNEL_CHAR_TO_INDEX_MAP[curChannel]}];\n          }`;\n    }\n\n    this.userCode = `\n      ${\n        this.enableShapeUniforms ? shader_util.getFlatIndexFrom3DOutput() :\n                                   shader_util.getFlatIndexFrom3D(outputShape)}\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int flatIndex = getFlatIndex(coords);\n        float result = 0.;\n        int offset = imod(flatIndex, ${usedChannels.length});\n\n        flatIndex = idiv(flatIndex, ${usedChannels.length}, 1.);\n\n        int r = flatIndex / texShape[1];\n        if (r < texShape[0]) {\n          int c = imod(flatIndex, texShape[1]);\n          vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);\n          vec4 values = ${glsl.texture2D}(A, uv);\n          ${mainLoop}\n        }\n        ${glsl.output} = vec4(${output}, 0., 0., 0.);\n      }\n    `;\n  }\n}\n","/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {getGlslDifferences} from './glsl_version';\nimport {GPGPUProgram, useShapeUniforms} from './gpgpu_math';\nimport * as shader_util from './shader_compiler_util';\n\n/*\nThis is how the shader encodes a tensor with shape = [2, 3, 5]\n(indices are [batch, row, col]).\n\n000|001   002|003   004|xxx   020|021   022|023   024|xxx\n-------   -------   -------   -------   -------   -------\n010|011   012|013   014|xxx   xxx|xxx   xxx|xxx   xxx|xxx\n\n100|101   102|103   104|xxx   120|121   122|123   124|xxx\n-------   -------   -------   -------   -------   -------\n110|111   112|113   114|xxx   xxx|xxx   xxx|xxx   xxx|xxx\n\nSingle texels contain only values from the same batch, and from adjacent rows\nand columns.\n */\n\nexport class EncodeMatrixPackedProgram implements GPGPUProgram {\n  variableNames = ['A'];\n  userCode: string;\n  outputShape: number[];\n  packedInputs = false;\n  packedOutput = true;\n  enableShapeUniforms: boolean;\n  customUniforms = [{name: 'texShape', type: 'ivec2' as const }];\n\n  constructor(\n      outputShape: [number, number, number], inputIsUnsignedByte = false) {\n    const glsl = getGlslDifferences();\n    this.outputShape = outputShape;\n    this.enableShapeUniforms = useShapeUniforms(this.outputShape.length);\n\n    let mainLoop = '';\n    let output = 'result';\n    if (inputIsUnsignedByte) {\n      output = 'floor(result * 255. + 0.5)';\n    }\n\n    for (let row = 0; row <= 1; row++) {\n      for (let col = 0; col <= 1; col++) {\n        const channel = row * 2 + col;\n\n        mainLoop += `\n          localCoords = coords;\n          if(localCoords[2] + ${col} < ${\n            this.enableShapeUniforms ? 'outShape[2]' : `${outputShape[2]}`}) {\n          localCoords[2] += ${col};\n          if (localCoords[1] + ${row} < ${\n            this.enableShapeUniforms ? 'outShape[1]' : `${outputShape[1]}`}) {\n            localCoords[1] += ${row};\n\n            flatIndex = getFlatIndex(localCoords);\n            offset = imod(flatIndex, 4);\n\n            flatIndex = idiv(flatIndex, 4, 1.);\n\n            int r = flatIndex / texShape[1];\n            int c = imod(flatIndex, texShape[1]);\n            vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);\n            values = ${glsl.texture2D}(A, uv);\n\n            if (offset == 0) {\n              result[${channel}] = values[0];\n            } else if (offset == 1) {\n              result[${channel}] = values[1];\n            } else if (offset == 2) {\n              result[${channel}] = values[2];\n            } else {\n              result[${channel}] = values[3];\n            }\n          }\n        }\n        `;\n      }\n    }\n\n    this.userCode = `\n        ${\n        this.enableShapeUniforms ? shader_util.getFlatIndexFrom3DOutput() :\n                                   shader_util.getFlatIndexFrom3D(outputShape)}\n\n        void main() {\n          ivec3 coords = getOutputCoords();\n\n          vec4 result = vec4(0.);\n          int flatIndex, r, c, offset;\n          ivec3 localCoords;\n          vec2 uv;\n          vec4 values;\n\n          ${mainLoop}\n\n          ${glsl.output} = ${output};\n        }\n    `;\n  }\n}\n","/**\n * @license\n * Copyright 2017 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {env, PixelData, TypedArray} from '@tensorflow/tfjs-core';\n\nimport {getGlslDifferences} from './glsl_version';\nimport * as tex_util from './tex_util';\nimport {Texture, TextureConfig} from './tex_util';\nimport * as webgl_util from './webgl_util';\n\nexport function createVertexShader(gl: WebGLRenderingContext): WebGLShader {\n  const glsl = getGlslDifferences();\n  const vertexShaderSource = `${glsl.version}\n    precision highp float;\n    ${glsl.attribute} vec3 clipSpacePos;\n    ${glsl.attribute} vec2 uv;\n    ${glsl.varyingVs} vec2 resultUV;\n\n    void main() {\n      gl_Position = vec4(clipSpacePos, 1);\n      resultUV = uv;\n    }`;\n  return webgl_util.createVertexShader(gl, vertexShaderSource);\n}\n\nexport function createVertexBuffer(gl: WebGLRenderingContext): WebGLBuffer {\n  // [x y z u v] * [upper-left, lower-left, upper-right, lower-right]\n  const vertexArray = new Float32Array(\n      [-1, 1, 0, 0, 1, -1, -1, 0, 0, 0, 1, 1, 0, 1, 1, 1, -1, 0, 1, 0]);\n  return webgl_util.createStaticVertexBuffer(gl, vertexArray);\n}\n\nexport function createIndexBuffer(gl: WebGLRenderingContext): WebGLBuffer {\n  // OpenGL (and WebGL) have \"CCW == front\" winding\n  const triangleVertexIndices = new Uint16Array([0, 1, 2, 2, 1, 3]);\n  return webgl_util.createStaticIndexBuffer(gl, triangleVertexIndices);\n}\n\nfunction createAndConfigureTexture(\n    gl: WebGLRenderingContext, width: number, height: number,\n    internalFormat: number, textureFormat: number,\n    textureType: number): Texture {\n  webgl_util.validateTextureSize(width, height);\n  const texture = webgl_util.createTexture(gl);\n\n  const tex2d = gl.TEXTURE_2D;\n  webgl_util.callAndCheck(gl, () => gl.bindTexture(tex2d, texture));\n  webgl_util.callAndCheck(\n      gl, () => gl.texParameteri(tex2d, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE));\n  webgl_util.callAndCheck(\n      gl, () => gl.texParameteri(tex2d, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE));\n  webgl_util.callAndCheck(\n      gl, () => gl.texParameteri(tex2d, gl.TEXTURE_MIN_FILTER, gl.NEAREST));\n  webgl_util.callAndCheck(\n      gl, () => gl.texParameteri(tex2d, gl.TEXTURE_MAG_FILTER, gl.NEAREST));\n  if (env().getNumber('WEBGL_VERSION') === 1) {\n    webgl_util.callAndCheck(\n        gl,\n        () => gl.texImage2D(\n            tex2d, 0, internalFormat, width, height, 0, textureFormat,\n            textureType, null));\n  } else {\n    webgl_util.callAndCheck(\n        gl,\n        () => (gl as WebGL2RenderingContext)\n                  .texStorage2D(tex2d, 1, internalFormat, width, height));\n  }\n  webgl_util.callAndCheck(gl, () => gl.bindTexture(gl.TEXTURE_2D, null));\n\n  return {texture, texShape: [height, width]};\n}\n\nexport function getInternalFormatForFloat32MatrixTexture(\n    textureConfig: TextureConfig) {\n  return textureConfig.internalFormatFloat;\n}\n\nexport function createFloat32MatrixTexture(\n    gl: WebGLRenderingContext, rows: number, columns: number,\n    textureConfig: TextureConfig): Texture {\n  const [width, height] =\n      tex_util.getUnpackedMatrixTextureShapeWidthHeight(rows, columns);\n  return createAndConfigureTexture(\n      gl, width, height,\n      getInternalFormatForFloat32MatrixTexture(textureConfig),\n      textureConfig.textureFormatFloat, gl.FLOAT);\n}\n\nexport function getInternalFormatForFloat16MatrixTexture(\n    textureConfig: TextureConfig) {\n  return textureConfig.internalFormatHalfFloat;\n}\n\nexport function createFloat16MatrixTexture(\n    gl: WebGLRenderingContext, rows: number, columns: number,\n    textureConfig: TextureConfig): Texture {\n  const [width, height] =\n      tex_util.getUnpackedMatrixTextureShapeWidthHeight(rows, columns);\n  return createAndConfigureTexture(\n      gl, width, height,\n      getInternalFormatForFloat16MatrixTexture(textureConfig),\n      textureConfig.textureFormatFloat, textureConfig.textureTypeHalfFloat);\n}\n\nexport function getInternalFormatForUnsignedBytesMatrixTexture(\n    textureConfig: TextureConfig) {\n  return textureConfig.downloadTextureFormat;\n}\n\nexport function createUnsignedBytesMatrixTexture(\n    gl: WebGLRenderingContext, rows: number, columns: number,\n    textureConfig: TextureConfig): Texture {\n  const [width, height] =\n      tex_util.getUnpackedMatrixTextureShapeWidthHeight(rows, columns);\n  return createAndConfigureTexture(\n      gl, width, height,\n      getInternalFormatForUnsignedBytesMatrixTexture(textureConfig), gl.RGBA,\n      gl.UNSIGNED_BYTE);\n}\n\nexport function getInternalFormatForPackedMatrixTexture(\n    textureConfig: TextureConfig) {\n  return textureConfig.internalFormatPackedFloat;\n}\n\nexport function createPackedMatrixTexture(\n    gl: WebGLRenderingContext, rows: number, columns: number,\n    textureConfig: TextureConfig): Texture {\n  const [width, height] =\n      tex_util.getPackedMatrixTextureShapeWidthHeight(rows, columns);\n  return createAndConfigureTexture(\n      gl, width, height, getInternalFormatForPackedMatrixTexture(textureConfig),\n      gl.RGBA, gl.FLOAT);\n}\n\nexport function getInternalFormatForFloat16PackedMatrixTexture(\n    textureConfig: TextureConfig) {\n  return textureConfig.internalFormatPackedHalfFloat;\n}\n\nexport function createFloat16PackedMatrixTexture(\n    gl: WebGLRenderingContext, rows: number, columns: number,\n    textureConfig: TextureConfig): Texture {\n  const [width, height] =\n      tex_util.getPackedMatrixTextureShapeWidthHeight(rows, columns);\n  return createAndConfigureTexture(\n      gl, width, height,\n      getInternalFormatForFloat16PackedMatrixTexture(textureConfig), gl.RGBA,\n      textureConfig.textureTypeHalfFloat);\n}\n\nexport function bindVertexProgramAttributeStreams(\n    gl: WebGLRenderingContext, program: WebGLProgram,\n    vertexBuffer: WebGLBuffer): boolean {\n  const posOffset = 0;               // x is the first buffer element\n  const uvOffset = 3 * 4;            // uv comes after [x y z]\n  const stride = (3 * 4) + (2 * 4);  // xyz + uv, each entry is 4-byte float.\n  webgl_util.callAndCheck(\n      gl, () => gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer));\n  const success = webgl_util.bindVertexBufferToProgramAttribute(\n      gl, program, 'clipSpacePos', vertexBuffer, 3, stride, posOffset);\n  return success &&\n      webgl_util.bindVertexBufferToProgramAttribute(\n          gl, program, 'uv', vertexBuffer, 2, stride, uvOffset);\n}\n\nexport function uploadDenseMatrixToTexture(\n    gl: WebGLRenderingContext, texture: WebGLTexture, width: number,\n    height: number, data: TypedArray, textureConfig: TextureConfig) {\n  webgl_util.callAndCheck(gl, () => gl.bindTexture(gl.TEXTURE_2D, texture));\n\n  let dataForUpload: TypedArray, texelDataType: number, internalFormat: number;\n  if (data instanceof Uint8Array) {\n    dataForUpload = new Uint8Array(width * height * 4);\n    texelDataType = gl.UNSIGNED_BYTE;\n    internalFormat = gl.RGBA;\n  } else {\n    dataForUpload = new Float32Array(width * height * 4);\n    texelDataType = gl.FLOAT;\n    internalFormat = textureConfig.internalFormatPackedFloat;\n  }\n\n  dataForUpload.set(data);\n  if (env().getNumber('WEBGL_VERSION') === 2) {\n    webgl_util.callAndCheck(\n        gl,\n        () => gl.texSubImage2D(\n            gl.TEXTURE_2D, 0, 0, 0, width, height, gl.RGBA, texelDataType,\n            dataForUpload));\n  } else {\n    webgl_util.callAndCheck(\n        gl,\n        () => gl.texImage2D(\n            gl.TEXTURE_2D, 0, internalFormat, width, height, 0, gl.RGBA,\n            texelDataType, dataForUpload));\n  }\n\n  webgl_util.callAndCheck(gl, () => gl.bindTexture(gl.TEXTURE_2D, null));\n}\n\nexport function uploadPixelDataToTexture(\n    gl: WebGLRenderingContext, texture: WebGLTexture,\n    pixels: PixelData|ImageData|HTMLImageElement|HTMLCanvasElement|\n    HTMLVideoElement|ImageBitmap) {\n  webgl_util.callAndCheck(gl, () => gl.bindTexture(gl.TEXTURE_2D, texture));\n  if ((pixels as PixelData).data instanceof Uint8Array) {\n    if (env().getNumber('WEBGL_VERSION') === 2) {\n      webgl_util.callAndCheck(\n          gl,\n          () => gl.texSubImage2D(\n              gl.TEXTURE_2D, 0, 0, 0, pixels.width, pixels.height, gl.RGBA,\n              gl.UNSIGNED_BYTE, (pixels as PixelData).data));\n    } else {\n      webgl_util.callAndCheck(\n          gl,\n          () => gl.texImage2D(\n              gl.TEXTURE_2D, 0, gl.RGBA, pixels.width, pixels.height, 0,\n              gl.RGBA, gl.UNSIGNED_BYTE, (pixels as PixelData).data));\n    }\n  } else {\n    if (env().getNumber('WEBGL_VERSION') === 2) {\n      webgl_util.callAndCheck(\n          gl,\n          () => gl.texSubImage2D(\n              gl.TEXTURE_2D, 0, 0, 0, gl.RGBA, gl.UNSIGNED_BYTE,\n              (pixels as ImageData | HTMLImageElement | HTMLCanvasElement |\n               HTMLVideoElement | ImageBitmap)));\n    } else {\n      webgl_util.callAndCheck(\n          gl,\n          () => gl.texImage2D(\n              gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE,\n              pixels as ImageData | HTMLImageElement | HTMLCanvasElement |\n                  HTMLVideoElement | ImageBitmap));\n    }\n  }\n\n  webgl_util.callAndCheck(gl, () => gl.bindTexture(gl.TEXTURE_2D, null));\n}\n\nexport function createBufferFromOutputTexture(\n    gl2: WebGL2RenderingContext, rows: number, columns: number,\n    textureConfig: TextureConfig): WebGLBuffer {\n  // Create and bind the buffer.\n  const buffer = gl2.createBuffer();\n  webgl_util.callAndCheck(\n      gl2, () => gl2.bindBuffer(gl2.PIXEL_PACK_BUFFER, buffer));\n\n  // Initialize the buffer to the size of the texture in bytes.\n  const bytesPerFloat = 4;\n  const valuesPerTexel = 4;\n  const bufferSizeBytes = bytesPerFloat * valuesPerTexel * rows * columns;\n\n  webgl_util.callAndCheck(\n      gl2,\n      () => gl2.bufferData(\n          gl2.PIXEL_PACK_BUFFER, bufferSizeBytes, gl2.STREAM_READ));\n\n  // Enqueue a command on the GPU command queue to copy of texture into the\n  // buffer.\n  webgl_util.callAndCheck(\n      gl2, () => gl2.readPixels(0, 0, columns, rows, gl2.RGBA, gl2.FLOAT, 0));\n\n  webgl_util.callAndCheck(\n      gl2, () => gl2.bindBuffer(gl2.PIXEL_PACK_BUFFER, null));\n\n  return buffer;\n}\n\nexport function downloadFloat32MatrixFromBuffer(\n    gl: WebGLRenderingContext, buffer: WebGLBuffer,\n    size: number): Float32Array {\n  const gl2 = gl as WebGL2RenderingContext;\n\n  const downloadTarget = new Float32Array(size);\n\n  gl2.bindBuffer(gl2.PIXEL_PACK_BUFFER, buffer);\n  gl2.getBufferSubData(gl2.PIXEL_PACK_BUFFER, 0, downloadTarget);\n  gl2.bindBuffer(gl2.PIXEL_PACK_BUFFER, null);\n\n  return downloadTarget;\n}\n\nexport function downloadByteEncodedFloatMatrixFromOutputTexture(\n    gl: WebGLRenderingContext, rows: number, columns: number,\n    textureConfig: TextureConfig) {\n  const [w, h] =\n      tex_util.getUnpackedMatrixTextureShapeWidthHeight(rows, columns);\n\n  const numChannels = 4;\n  const downloadTarget = new Uint8Array(\n      tex_util.getUnpackedArraySizeFromMatrixSize(rows * columns, numChannels));\n\n  webgl_util.callAndCheck(\n      gl,\n      () => gl.readPixels(\n          0, 0, w, h, textureConfig.downloadTextureFormat, gl.UNSIGNED_BYTE,\n          downloadTarget));\n\n  // By wrapping the buffer in a Float32Array, we use native browser IEEE 754\n  // decoding of the 4 bytes that back each 32 bit float.\n  return new Float32Array(downloadTarget.buffer);\n}\n\nexport function downloadPackedMatrixFromBuffer(\n    gl: WebGLRenderingContext, buffer: WebGLBuffer, batch: number, rows: number,\n    cols: number, physicalRows: number, physicalCols: number,\n    textureConfig: TextureConfig): Float32Array {\n  const gl2 = gl as WebGL2RenderingContext;\n\n  const downloadTarget =\n      new Float32Array(tex_util.getPackedRGBAArraySizeFromMatrixShape(\n          physicalRows, physicalCols));\n\n  gl2.bindBuffer(gl2.PIXEL_PACK_BUFFER, buffer);\n  gl2.getBufferSubData(gl2.PIXEL_PACK_BUFFER, 0, downloadTarget);\n  gl2.bindBuffer(gl2.PIXEL_PACK_BUFFER, null);\n\n  return downloadTarget;\n}\n\nexport function downloadMatrixFromPackedOutputTexture(\n    gl: WebGLRenderingContext, physicalRows: number,\n    physicalCols: number): Float32Array {\n  const packedRGBA = new Float32Array(physicalRows * physicalCols * 4);\n  webgl_util.callAndCheck(\n      gl,\n      () => gl.readPixels(\n          0, 0, physicalCols, physicalRows, gl.RGBA, gl.FLOAT, packedRGBA));\n\n  return packedRGBA;\n}\n","/**\n * @license\n * Copyright 2017 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {env, PixelData, TypedArray, util} from '@tensorflow/tfjs-core';\n\nimport {getWebGLContext, setWebGLContext} from './canvas_util';\nimport * as gpgpu_util from './gpgpu_util';\nimport * as tex_util from './tex_util';\nimport {Texture, TextureConfig} from './tex_util';\nimport {WebGL1DisjointQueryTimerExtension, WebGL2DisjointQueryTimerExtension, WebGLParallelCompilationExtension} from './webgl_types';\nimport * as webgl_util from './webgl_util';\n\nexport interface FenceContext {\n  query: WebGLQuery|WebGLSync;\n  isFencePassed(): boolean;\n}\n\ntype WebGLVao = WebGLVertexArrayObject | WebGLVertexArrayObjectOES;\n\nexport interface GPGPUContextProgram extends WebGLProgram {\n  vao: WebGLVao;\n}\n\nexport class GPGPUContext {\n  gl: WebGLRenderingContext;\n  textureFloatExtension: {};\n  textureHalfFloatExtension: {};\n  colorBufferFloatExtension: {};\n  colorBufferHalfFloatExtension: {};\n  disjointQueryTimerExtension: WebGL2DisjointQueryTimerExtension|\n      WebGL1DisjointQueryTimerExtension;\n  parallelCompilationExtension: WebGLParallelCompilationExtension;\n  vertexBuffer: WebGLBuffer;\n  indexBuffer: WebGLBuffer;\n  framebuffer: WebGLFramebuffer;\n  outputTexture: WebGLTexture|null = null;\n  program: GPGPUContextProgram|null = null;\n  private disposed = false;\n  private disjoint: boolean;\n  private vertexShader: WebGLShader;\n  textureConfig: TextureConfig;\n\n  createVertexArray: () => WebGLVao | null;\n  bindVertexArray: (vao: WebGLVao | null) => void;\n  deleteVertexArray: (vao: WebGLVao | null) => void;\n  getVertexArray: () => WebGLVao | null;\n\n  constructor(gl?: WebGLRenderingContext) {\n    const glVersion = env().getNumber('WEBGL_VERSION');\n    if (gl != null) {\n      this.gl = gl;\n      setWebGLContext(glVersion, gl);\n    } else {\n      this.gl = getWebGLContext(glVersion);\n    }\n    gl = this.gl;\n\n    if (env().getNumber('WEBGL_VERSION') === 2) {\n      const gl2 = gl as WebGL2RenderingContext;\n      this.createVertexArray = () => {\n        return webgl_util.callAndCheck(gl2,\n          () => gl2.createVertexArray());\n      };\n      this.bindVertexArray = (vao: WebGLVao|null) => {\n        return webgl_util.callAndCheck(gl2,\n          () => gl2.bindVertexArray(vao as WebGLVertexArrayObject));\n      };\n      this.deleteVertexArray = (vao: WebGLVao|null) => {\n        return webgl_util.callAndCheck(gl2,\n          () => gl2.deleteVertexArray(vao as WebGLVertexArrayObject));\n      };\n      this.getVertexArray = () => {\n        return webgl_util.callAndCheck(gl2,\n          () => gl2.getParameter(gl2.VERTEX_ARRAY_BINDING));\n      };\n    } else if (gl != null) {\n      const ext = gl.getExtension('OES_vertex_array_object');\n      if (ext == null) {\n        throw new Error(\n            'All WebGL1 implementations are expected to offer' +\n            ' OES_vertex_array_object.');\n      }\n      this.createVertexArray = () => {\n        return webgl_util.callAndCheck(gl,\n          () => ext.createVertexArrayOES());\n      };\n      this.bindVertexArray = (vao: WebGLVao|null) => {\n        return webgl_util.callAndCheck(gl,\n          () => ext.bindVertexArrayOES(vao as WebGLVertexArrayObjectOES));\n      };\n      this.deleteVertexArray = (vao: WebGLVao|null) => {\n        return webgl_util.callAndCheck(gl,\n          () => ext.deleteVertexArrayOES(vao as WebGLVertexArrayObjectOES));\n      };\n      this.getVertexArray = () => {\n        return webgl_util.callAndCheck(gl,\n          () => gl.getParameter(ext.VERTEX_ARRAY_BINDING_OES));\n      };\n    }\n\n    // WebGL 2.0 enables texture floats without an extension.\n    let COLOR_BUFFER_FLOAT = 'WEBGL_color_buffer_float';\n    const COLOR_BUFFER_HALF_FLOAT = 'EXT_color_buffer_half_float';\n    this.parallelCompilationExtension =\n        this.gl.getExtension('KHR_parallel_shader_compile');\n    if (env().getNumber('WEBGL_VERSION') === 1) {\n      const TEXTURE_FLOAT = 'OES_texture_float';\n      const TEXTURE_HALF_FLOAT = 'OES_texture_half_float';\n\n      this.textureFloatExtension =\n          webgl_util.getExtensionOrThrow(this.gl, TEXTURE_FLOAT);\n      if (webgl_util.hasExtension(this.gl, TEXTURE_HALF_FLOAT)) {\n        this.textureHalfFloatExtension =\n            webgl_util.getExtensionOrThrow(this.gl, TEXTURE_HALF_FLOAT);\n      } else if (env().get('WEBGL_FORCE_F16_TEXTURES')) {\n        throw new Error(\n            'GL context does not support half float textures, yet the ' +\n            'environment flag WEBGL_FORCE_F16_TEXTURES is set to true.');\n      }\n\n      this.colorBufferFloatExtension = this.gl.getExtension(COLOR_BUFFER_FLOAT);\n      if (webgl_util.hasExtension(this.gl, COLOR_BUFFER_HALF_FLOAT)) {\n        this.colorBufferHalfFloatExtension =\n            webgl_util.getExtensionOrThrow(this.gl, COLOR_BUFFER_HALF_FLOAT);\n      } else if (env().get('WEBGL_FORCE_F16_TEXTURES')) {\n        throw new Error(\n            'GL context does not support color renderable half floats, yet ' +\n            'the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.');\n      }\n    } else {\n      COLOR_BUFFER_FLOAT = 'EXT_color_buffer_float';\n      if (webgl_util.hasExtension(this.gl, COLOR_BUFFER_FLOAT)) {\n        this.colorBufferFloatExtension =\n            this.gl.getExtension(COLOR_BUFFER_FLOAT);\n      } else if (webgl_util.hasExtension(this.gl, COLOR_BUFFER_HALF_FLOAT)) {\n        this.colorBufferHalfFloatExtension =\n            this.gl.getExtension(COLOR_BUFFER_HALF_FLOAT);\n      } else {\n        throw new Error('GL context does not support color renderable floats');\n      }\n    }\n\n    this.vertexBuffer = gpgpu_util.createVertexBuffer(this.gl);\n    this.indexBuffer = gpgpu_util.createIndexBuffer(this.gl);\n    this.framebuffer = webgl_util.createFramebuffer(this.gl);\n\n    this.textureConfig =\n        tex_util.getTextureConfig(this.gl, this.textureHalfFloatExtension);\n  }\n\n  private get debug(): boolean {\n    return env().getBool('DEBUG');\n  }\n\n  public dispose() {\n    if (this.disposed) {\n      return;\n    }\n    if (this.program != null) {\n      console.warn(\n          'Disposing a GPGPUContext that still has a bound WebGLProgram.' +\n          ' This is probably a resource leak, delete the program with ' +\n          'GPGPUContext.deleteProgram before disposing.');\n    }\n    if (this.outputTexture != null) {\n      console.warn(\n          'Disposing a GPGPUContext that still has a bound output matrix ' +\n          'texture.  This is probably a resource leak, delete the output ' +\n          'matrix texture with GPGPUContext.deleteMatrixTexture before ' +\n          'disposing.');\n    }\n    const gl = this.gl;\n    webgl_util.callAndCheck(gl, () => gl.finish());\n    webgl_util.callAndCheck(gl, () => gl.bindFramebuffer(gl.FRAMEBUFFER, null));\n    webgl_util.callAndCheck(gl, () => gl.deleteFramebuffer(this.framebuffer));\n    webgl_util.callAndCheck(gl, () => gl.bindBuffer(gl.ARRAY_BUFFER, null));\n    webgl_util.callAndCheck(\n        gl, () => gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null));\n    webgl_util.callAndCheck(gl, () => gl.deleteBuffer(this.indexBuffer));\n    this.disposed = true;\n  }\n\n  public createFloat32MatrixTexture(rows: number, columns: number): Texture {\n    this.throwIfDisposed();\n    return gpgpu_util.createFloat32MatrixTexture(\n        this.gl, rows, columns, this.textureConfig);\n  }\n\n  public createFloat16MatrixTexture(rows: number, columns: number): Texture {\n    this.throwIfDisposed();\n    return gpgpu_util.createFloat16MatrixTexture(\n        this.gl, rows, columns, this.textureConfig);\n  }\n\n  public createUnsignedBytesMatrixTexture(rows: number, columns: number):\n      Texture {\n    this.throwIfDisposed();\n    return gpgpu_util.createUnsignedBytesMatrixTexture(\n        this.gl, rows, columns, this.textureConfig);\n  }\n\n  public uploadPixelDataToTexture(\n      texture: WebGLTexture,\n      pixels: PixelData|ImageData|HTMLImageElement|HTMLCanvasElement|\n      ImageBitmap) {\n    this.throwIfDisposed();\n    gpgpu_util.uploadPixelDataToTexture(this.gl, texture, pixels);\n  }\n\n  public uploadDenseMatrixToTexture(\n      texture: WebGLTexture, width: number, height: number, data: TypedArray) {\n    this.throwIfDisposed();\n    gpgpu_util.uploadDenseMatrixToTexture(\n        this.gl, texture, width, height, data, this.textureConfig);\n  }\n\n  public createFloat16PackedMatrixTexture(rows: number, columns: number):\n      Texture {\n    this.throwIfDisposed();\n    return gpgpu_util.createFloat16PackedMatrixTexture(\n        this.gl, rows, columns, this.textureConfig);\n  }\n\n  public createPackedMatrixTexture(rows: number, columns: number): Texture {\n    this.throwIfDisposed();\n    return gpgpu_util.createPackedMatrixTexture(\n        this.gl, rows, columns, this.textureConfig);\n  }\n\n  public deleteMatrixTexture(texture: WebGLTexture) {\n    this.throwIfDisposed();\n    if (this.outputTexture === texture) {\n      webgl_util.unbindColorTextureFromFramebuffer(this.gl, this.framebuffer);\n      this.outputTexture = null;\n    }\n    webgl_util.callAndCheck(this.gl, () => this.gl.deleteTexture(texture));\n  }\n\n  public downloadByteEncodedFloatMatrixFromOutputTexture(\n      texture: WebGLTexture, rows: number, columns: number): Float32Array {\n    return this.downloadMatrixDriver(\n        texture,\n        () => gpgpu_util.downloadByteEncodedFloatMatrixFromOutputTexture(\n            this.gl, rows, columns, this.textureConfig));\n  }\n\n  public downloadPackedMatrixFromBuffer(\n      buffer: WebGLBuffer, batch: number, rows: number, columns: number,\n      physicalRows: number, physicalCols: number): Float32Array {\n    return gpgpu_util.downloadPackedMatrixFromBuffer(\n        this.gl, buffer, batch, rows, columns, physicalRows, physicalCols,\n        this.textureConfig);\n  }\n\n  public downloadFloat32MatrixFromBuffer(buffer: WebGLBuffer, size: number):\n      Float32Array {\n    return gpgpu_util.downloadFloat32MatrixFromBuffer(this.gl, buffer, size);\n  }\n\n  public createBufferFromTexture(\n      texture: WebGLTexture, rows: number, columns: number): WebGLBuffer {\n    this.bindTextureToFrameBuffer(texture);\n    const result = gpgpu_util.createBufferFromOutputTexture(\n        this.gl as WebGL2RenderingContext, rows, columns, this.textureConfig);\n    this.unbindTextureToFrameBuffer();\n    return result;\n  }\n\n  public createAndWaitForFence(): Promise<void> {\n    const fenceContext = this.createFence(this.gl);\n    return this.pollFence(fenceContext);\n  }\n\n  private createFence(gl: WebGLRenderingContext): FenceContext {\n    let query: WebGLQuery|WebGLSync;\n    let isFencePassed: () => boolean;\n\n    if (env().getBool('WEBGL_FENCE_API_ENABLED')) {\n      const gl2 = gl as WebGL2RenderingContext;\n\n      const sync = gl2.fenceSync(gl2.SYNC_GPU_COMMANDS_COMPLETE, 0);\n      gl.flush();\n\n      isFencePassed = () => {\n        const status = gl2.clientWaitSync(sync, 0, 0);\n        return status === gl2.ALREADY_SIGNALED ||\n            status === gl2.CONDITION_SATISFIED;\n      };\n\n      query = sync;\n    } else if (\n        env().getNumber('WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION') > 0) {\n      query = this.beginQuery();\n      this.endQuery();\n      isFencePassed = () => this.isQueryAvailable(\n          query,\n          env().getNumber('WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION'));\n    } else {\n      // If we have no way to fence, return true immediately. This will fire in\n      // WebGL 1.0 when there is no disjoint query timer. In this case, because\n      // the fence passes immediately, we'll immediately ask for a download of\n      // the texture, which will cause the UI thread to hang.\n      isFencePassed = () => true;\n    }\n\n    return {query, isFencePassed};\n  }\n\n  public downloadMatrixFromPackedTexture(\n      texture: WebGLTexture, physicalRows: number,\n      physicalCols: number): Float32Array {\n    return this.downloadMatrixDriver(\n        texture,\n        () => gpgpu_util.downloadMatrixFromPackedOutputTexture(\n            this.gl, physicalRows, physicalCols));\n  }\n\n  public createProgram(fragmentShader: WebGLShader): GPGPUContextProgram {\n    this.throwIfDisposed();\n    const gl = this.gl;\n    if (this.vertexShader == null) {\n      this.vertexShader = gpgpu_util.createVertexShader(gl);\n    }\n    const program: WebGLProgram = webgl_util.createProgram(gl);\n    webgl_util.callAndCheck(\n        gl, () => gl.attachShader(program, this.vertexShader));\n    webgl_util.callAndCheck(gl, () => gl.attachShader(program, fragmentShader));\n    webgl_util.linkProgram(gl, program);\n\n    let program2: GPGPUContextProgram;\n    {\n      program2 = Object.assign(program, {\n        vao: this.createVertexArray(),\n      });\n      this.bindVertexArray(program2.vao);\n      // Bind index buffer, and vertex buffers based on program attrib\n      // locations.\n      webgl_util.callAndCheck(\n          gl, () => gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer));\n      console.assert(\n        gpgpu_util.bindVertexProgramAttributeStreams(gl, program2,\n                                                     this.vertexBuffer),\n        'gpgpu_util.bindVertexProgramAttributeStreams not fully successful.');\n\n      if (this.debug) {\n        webgl_util.validateProgram(gl, program2);\n      }\n    }\n    this.setProgram(program2);\n\n    return program2;\n  }\n\n  public deleteProgram(program: GPGPUContextProgram) {\n    this.throwIfDisposed();\n    if (program === this.program) {\n      this.program = null;\n    }\n    if (program != null) {\n      webgl_util.callAndCheck(this.gl, () => this.gl.deleteProgram(program));\n      this.deleteVertexArray(program.vao);\n    }\n  }\n\n  public setProgram(program: GPGPUContextProgram|null) {\n    this.throwIfDisposed();\n    this.program = program;\n\n    if (this.program != null) {\n      this.bindVertexArray(this.program.vao);\n\n      if (this.debug) {\n        webgl_util.validateProgram(this.gl, this.program);\n      }\n    }\n    webgl_util.callAndCheck(this.gl, () => this.gl.useProgram(program));\n  }\n\n  public getUniformLocation(\n      program: WebGLProgram, uniformName: string,\n      shouldThrow = true): WebGLUniformLocation {\n    this.throwIfDisposed();\n    if (shouldThrow) {\n      return webgl_util.getProgramUniformLocationOrThrow(\n          this.gl, program, uniformName);\n    } else {\n      return webgl_util.getProgramUniformLocation(\n          this.gl, program, uniformName);\n    }\n  }\n\n  public getAttributeLocation(program: WebGLProgram, attribute: string):\n      number {\n    this.throwIfDisposed();\n    return webgl_util.callAndCheck(\n        this.gl, () => this.gl.getAttribLocation(program, attribute));\n  }\n\n  public getUniformLocationNoThrow(program: WebGLProgram, uniformName: string):\n      WebGLUniformLocation {\n    this.throwIfDisposed();\n    return this.gl.getUniformLocation(program, uniformName);\n  }\n\n  public setInputMatrixTexture(\n      inputMatrixTexture: WebGLTexture, uniformLocation: WebGLUniformLocation,\n      textureUnit: number) {\n    this.throwIfDisposed();\n    this.throwIfNoProgram();\n    webgl_util.bindTextureToProgramUniformSampler(\n        this.gl, inputMatrixTexture, uniformLocation, textureUnit);\n  }\n\n  public setOutputMatrixTexture(\n      outputMatrixTexture: WebGLTexture, rows: number, columns: number) {\n    this.setOutputMatrixTextureDriver(outputMatrixTexture, columns, rows);\n  }\n\n  public setOutputPackedMatrixTexture(\n      outputPackedMatrixTexture: WebGLTexture, rows: number, columns: number) {\n    this.throwIfDisposed();\n    const [width, height] =\n        tex_util.getPackedMatrixTextureShapeWidthHeight(rows, columns);\n    this.setOutputMatrixTextureDriver(outputPackedMatrixTexture, width, height);\n  }\n\n  public setOutputMatrixWriteRegion(\n      startRow: number, numRows: number, startColumn: number,\n      numColumns: number) {\n    this.setOutputMatrixWriteRegionDriver(\n        startColumn, startRow, numColumns, numRows);\n  }\n\n  public setOutputPackedMatrixWriteRegion(\n      startRow: number, numRows: number, startColumn: number,\n      numColumns: number) {\n    throw new Error('setOutputPackedMatrixWriteRegion not implemented.');\n  }\n\n  public debugValidate() {\n    if (this.program != null) {\n      webgl_util.validateProgram(this.gl, this.program);\n    }\n    webgl_util.validateFramebuffer(this.gl);\n  }\n\n  public executeProgram() {\n    this.throwIfDisposed();\n    this.throwIfNoProgram();\n    const gl = this.gl;\n    if (this.debug) {\n      const boundVao = this.getVertexArray();\n      console.assert(boundVao === this.program.vao,\n                     'VAO changed between setProgram and executeProgram!');\n\n      this.debugValidate();\n    }\n    webgl_util.callAndCheck(\n        gl, () => gl.drawElements(gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0));\n  }\n\n  public blockUntilAllProgramsCompleted() {\n    this.throwIfDisposed();\n    webgl_util.callAndCheck(this.gl, () => this.gl.finish());\n  }\n\n  private getQueryTimerExtension(): WebGL1DisjointQueryTimerExtension\n      |WebGL2DisjointQueryTimerExtension {\n    if (this.disjointQueryTimerExtension == null) {\n      this.disjointQueryTimerExtension =\n          webgl_util.getExtensionOrThrow(\n              this.gl,\n              env().getNumber(\n                  'WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION') === 2 ?\n                  'EXT_disjoint_timer_query_webgl2' :\n                  'EXT_disjoint_timer_query') as\n              WebGL1DisjointQueryTimerExtension |\n          WebGL2DisjointQueryTimerExtension;\n    }\n    return this.disjointQueryTimerExtension;\n  }\n\n  private getQueryTimerExtensionWebGL2(): WebGL2DisjointQueryTimerExtension {\n    return this.getQueryTimerExtension();\n  }\n\n  private getQueryTimerExtensionWebGL1(): WebGL1DisjointQueryTimerExtension {\n    return this.getQueryTimerExtension() as WebGL1DisjointQueryTimerExtension;\n  }\n\n  beginQuery(): WebGLQuery {\n    if (env().getNumber('WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION') === 2) {\n      const gl2 = this.gl as WebGL2RenderingContext;\n      const ext = this.getQueryTimerExtensionWebGL2();\n\n      const query = gl2.createQuery();\n      gl2.beginQuery(ext.TIME_ELAPSED_EXT, query);\n      return query;\n    }\n    const ext = this.getQueryTimerExtensionWebGL1();\n    const query = ext.createQueryEXT() as WebGLQuery;\n    ext.beginQueryEXT(ext.TIME_ELAPSED_EXT, query);\n    return query;\n  }\n\n  endQuery() {\n    if (env().getNumber('WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION') === 2) {\n      const gl2 = this.gl as WebGL2RenderingContext;\n      const ext = this.getQueryTimerExtensionWebGL2();\n      gl2.endQuery(ext.TIME_ELAPSED_EXT);\n      return;\n    }\n    const ext = this.getQueryTimerExtensionWebGL1();\n    ext.endQueryEXT(ext.TIME_ELAPSED_EXT);\n  }\n\n  public async waitForQueryAndGetTime(query: WebGLQuery): Promise<number> {\n    await util.repeatedTry(\n        () => this.disposed ||  // while testing contexts are created / disposed\n                                // in rapid succession, so without this check we\n                                // may poll for the query timer indefinitely\n            this.isQueryAvailable(\n                query,\n                env().getNumber(\n                    'WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION')));\n    return this.getQueryTime(\n        query, env().getNumber('WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION'));\n  }\n\n  private getQueryTime(query: WebGLQuery, queryTimerVersion: number): number {\n    if (queryTimerVersion === 0) {\n      return null;\n    }\n\n    if (queryTimerVersion === 2) {\n      const gl2 = this.gl as WebGL2RenderingContext;\n\n      const timeElapsedNanos = gl2.getQueryParameter(query, gl2.QUERY_RESULT);\n      // Return milliseconds.\n      return timeElapsedNanos / 1000000;\n    } else {\n      const ext = this.getQueryTimerExtensionWebGL1();\n\n      const timeElapsedNanos =\n          ext.getQueryObjectEXT(query, ext.QUERY_RESULT_EXT);\n      // Return milliseconds.\n      return timeElapsedNanos / 1000000;\n    }\n  }\n\n  private isQueryAvailable(query: WebGLQuery, queryTimerVersion: number):\n      boolean {\n    if (queryTimerVersion === 0) {\n      return true;\n    }\n\n    if (queryTimerVersion === 2) {\n      const gl2 = this.gl as WebGL2RenderingContext;\n      const ext = this.getQueryTimerExtensionWebGL2();\n\n      const available =\n          gl2.getQueryParameter(query, gl2.QUERY_RESULT_AVAILABLE);\n      if (this.disjoint == null) {\n        this.disjoint = this.gl.getParameter(ext.GPU_DISJOINT_EXT);\n      }\n\n      return available && !this.disjoint;\n    } else {\n      const ext = this.getQueryTimerExtensionWebGL1();\n\n      const available =\n          ext.getQueryObjectEXT(query, ext.QUERY_RESULT_AVAILABLE_EXT);\n      if (this.disjoint == null) {\n        this.disjoint = this.gl.getParameter(ext.GPU_DISJOINT_EXT);\n      }\n\n      return available && !this.disjoint;\n    }\n  }\n\n  pollFence(fenceContext: FenceContext) {\n    return new Promise<void>(resolve => {\n      this.addItemToPoll(() => fenceContext.isFencePassed(), () => resolve());\n    });\n  }\n\n  private itemsToPoll: PollItem[] = [];\n\n  pollItems(): void {\n    // Find the last query that has finished.\n    const index = linearSearchLastTrue(this.itemsToPoll.map(x => x.isDoneFn));\n    for (let i = 0; i <= index; ++i) {\n      const {resolveFn} = this.itemsToPoll[i];\n      resolveFn();\n    }\n    this.itemsToPoll = this.itemsToPoll.slice(index + 1);\n  }\n\n  private addItemToPoll(isDoneFn: () => boolean, resolveFn: () => void) {\n    this.itemsToPoll.push({isDoneFn, resolveFn});\n    if (this.itemsToPoll.length > 1) {\n      // We already have a running loop that polls.\n      return;\n    }\n    // Start a new loop that polls.\n    let scheduleFn = undefined;\n    if ('setTimeoutCustom' in env().platform) {\n      scheduleFn = env().platform.setTimeoutCustom.bind(env().platform);\n    }\n    util.repeatedTry(() => {\n      this.pollItems();\n      // End the loop if no more items to poll.\n      return this.itemsToPoll.length === 0;\n    }, () => 0, null, scheduleFn);\n  }\n\n  private bindTextureToFrameBuffer(texture: WebGLTexture) {\n    this.throwIfDisposed();\n    webgl_util.bindColorTextureToFramebuffer(\n        this.gl, texture, this.framebuffer);\n    if (this.debug) {\n      webgl_util.validateFramebuffer(this.gl);\n    }\n  }\n\n  private unbindTextureToFrameBuffer() {\n    if (this.outputTexture != null) {\n      webgl_util.bindColorTextureToFramebuffer(\n          this.gl, this.outputTexture, this.framebuffer);\n      if (this.debug) {\n        webgl_util.validateFramebuffer(this.gl);\n      }\n    } else {\n      webgl_util.unbindColorTextureFromFramebuffer(this.gl, this.framebuffer);\n    }\n  }\n\n  private downloadMatrixDriver(\n      texture: WebGLTexture,\n      downloadAndDecode: () => Float32Array): Float32Array {\n    this.bindTextureToFrameBuffer(texture);\n    const result = downloadAndDecode();\n    this.unbindTextureToFrameBuffer();\n\n    return result;\n  }\n\n  private setOutputMatrixTextureDriver(\n      outputMatrixTextureMaybePacked: WebGLTexture, width: number,\n      height: number) {\n    this.throwIfDisposed();\n    const gl = this.gl;\n    webgl_util.bindColorTextureToFramebuffer(\n        gl, outputMatrixTextureMaybePacked, this.framebuffer);\n    if (this.debug) {\n      webgl_util.validateFramebuffer(gl);\n    }\n    this.outputTexture = outputMatrixTextureMaybePacked;\n    webgl_util.callAndCheck(gl, () => gl.viewport(0, 0, width, height));\n    webgl_util.callAndCheck(gl, () => gl.scissor(0, 0, width, height));\n  }\n\n  private setOutputMatrixWriteRegionDriver(\n      x: number, y: number, width: number, height: number) {\n    this.throwIfDisposed();\n    webgl_util.callAndCheck(\n        this.gl, () => this.gl.scissor(x, y, width, height));\n  }\n\n  private throwIfDisposed() {\n    if (this.disposed) {\n      throw new Error('Attempted to use disposed GPGPUContext.');\n    }\n  }\n\n  private throwIfNoProgram() {\n    if (this.program == null) {\n      throw new Error('No GPU program is currently set.');\n    }\n  }\n}\n\ntype PollItem = {\n  isDoneFn: () => boolean,\n  resolveFn: () => void\n};\n\n/**\n * Finds the index of the last true element using linear search.\n * Note: We can't do binary search because Chrome expects us to explicitly\n * test all fences before download:\n * https://github.com/tensorflow/tfjs/issues/1145\n */\nexport function linearSearchLastTrue(arr: Array<() => boolean>): number {\n  let i = 0;\n  for (; i < arr.length; ++i) {\n    const isDone = arr[i]();\n    if (!isDone) {\n      break;\n    }\n  }\n  return i - 1;\n}\n","/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {TensorInfo, util} from '@tensorflow/tfjs-core';\n\nexport function assertNotComplex(\n    tensor: TensorInfo|TensorInfo[], opName: string): void {\n  if (!Array.isArray(tensor)) {\n    tensor = [tensor];\n  }\n  tensor.forEach(t => {\n    if (t != null) {\n      util.assert(\n          t.dtype !== 'complex64',\n          () => `${\n              opName} does not support complex64 tensors in the CPU backend.`);\n    }\n  });\n}\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the License);\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an AS IS BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {Abs, AbsInputs, KernelConfig, KernelFunc, TypedArray, util} from '@tensorflow/tfjs-core';\n\nimport {MathBackendCPU} from '../backend_cpu';\nimport {assertNotComplex} from '../cpu_util';\n\nexport function simpleAbsImpl(vals: TypedArray): Float32Array {\n  const resultValues = new Float32Array(vals.length);\n  for (let i = 0; i < vals.length; ++i) {\n    resultValues[i] = Math.abs(vals[i]);\n  }\n  return resultValues;\n}\n\nexport const abs = (args: {inputs: AbsInputs, backend: MathBackendCPU}) => {\n  const {x} = args.inputs;\n  const cpuBackend = args.backend;\n\n  assertNotComplex(x, 'abs');\n\n  let resultValues = new Float32Array(util.sizeFromShape(x.shape));\n  const values = cpuBackend.data.get(x.dataId).values as TypedArray;\n  resultValues = simpleAbsImpl(values);\n\n  return cpuBackend.makeOutput(resultValues, x.shape, x.dtype);\n};\n\nexport const absConfig: KernelConfig = {\n  kernelName: Abs,\n  backendName: 'cpu',\n  kernelFunc: abs as {} as KernelFunc,\n};\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {backend_util, DataType, DataValues, NumericDataType, TypedArray, util} from '@tensorflow/tfjs-core';\n\nimport {SimpleBinaryKernelImpl, SimpleBinaryOperation} from './binary_types';\n\n/**\n * Template that creates implementation for binary ops. Supports broadcast.\n */\nexport function createSimpleBinaryKernelImpl(op: SimpleBinaryOperation):\n    SimpleBinaryKernelImpl {\n  return (aShape: number[], bShape: number[], aVals: DataValues,\n          bVals: DataValues, dtype: DataType): [TypedArray, number[]] => {\n    const newShape = backend_util.assertAndGetBroadcastShape(aShape, bShape);\n\n    const resultRank = newShape.length;\n    const resultStrides = util.computeStrides(newShape);\n    const resultSize = util.sizeFromShape(newShape);\n\n    const result =\n        util.getTypedArrayFromDType(dtype as NumericDataType, resultSize);\n\n    const aRank = aShape.length;\n    const bRank = bShape.length;\n\n    const aStrides = util.computeStrides(aShape);\n    const bStrides = util.computeStrides(bShape);\n\n    const aBroadcastDims = backend_util.getBroadcastDims(aShape, newShape);\n    const bBroadcastDims = backend_util.getBroadcastDims(bShape, newShape);\n\n    if (aBroadcastDims.length + bBroadcastDims.length === 0) {\n      for (let i = 0; i < result.length; ++i) {\n        result[i] = op(aVals[i % aVals.length], bVals[i % bVals.length]);\n      }\n    } else {\n      for (let i = 0; i < result.length; ++i) {\n        const loc = util.indexToLoc(i, resultRank, resultStrides);\n\n        const aLoc = loc.slice(-aRank);\n        aBroadcastDims.forEach(d => aLoc[d] = 0);\n        const aIndex = util.locToIndex(aLoc, aRank, aStrides);\n\n        const bLoc = loc.slice(-bRank);\n        bBroadcastDims.forEach(d => bLoc[d] = 0);\n        const bIndex = util.locToIndex(bLoc, bRank, bStrides);\n\n        result[i] = op(aVals[aIndex], bVals[bIndex]);\n      }\n    }\n\n    return [result, newShape];\n  };\n}\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {Complex, ComplexInputs, KernelConfig, KernelFunc, TensorInfo, TypedArray} from '@tensorflow/tfjs-core';\n\nimport {MathBackendCPU} from '../backend_cpu';\n\nexport function complex(args: {inputs: ComplexInputs, backend: MathBackendCPU}):\n    TensorInfo {\n  const {inputs, backend} = args;\n  const {real, imag} = inputs;\n\n  const realVals = backend.data.get(real.dataId).values as TypedArray;\n  const imagVals = backend.data.get(imag.dataId).values as TypedArray;\n\n  const complexInfo = backend.makeTensorInfo(real.shape, 'complex64');\n\n  const complex = backend.data.get(complexInfo.dataId);\n\n  // The complex tensor owns the underlying real and imag tensorInfos, only the\n  // complex tensor tracks refCount, when complexData is disposed the\n  // underlying tensorData will be disposed.\n  complex.complexTensorInfos = {\n    real: backend.makeTensorInfo(real.shape, 'float32', realVals),\n    imag: backend.makeTensorInfo(imag.shape, 'float32', imagVals)\n  };\n\n  return complexInfo;\n}\n\nexport const complexConfig: KernelConfig = {\n  kernelName: Complex,\n  backendName: 'cpu',\n  kernelFunc: complex as {} as KernelFunc\n};\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {DataType, TensorInfo, util} from '@tensorflow/tfjs-core';\nimport {MathBackendCPU} from '../backend_cpu';\nimport {complex} from '../kernels/Complex';\n\n/**\n * Generates a tensorInfo with all zeros value.\n * @param backend cpu backend.\n * @param shape Shape for the zeros tensor.\n * @param dtype Optional. If set, the result has this dtype.\n */\nexport function zeros(\n    backend: MathBackendCPU, shape: number[],\n    dtype: DataType = 'float32'): TensorInfo {\n  if (dtype === 'complex64') {\n    const real = zeros(backend, shape, 'float32');\n    const imag = zeros(backend, shape, 'float32');\n\n    return complex({inputs: {real, imag}, backend});\n  }\n\n  const values = util.makeZerosTypedArray(util.sizeFromShape(shape), dtype);\n\n  return backend.makeTensorInfo(shape, dtype, values);\n}\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {Identity, IdentityInputs, KernelConfig, KernelFunc, TensorInfo} from '@tensorflow/tfjs-core';\n\nimport {MathBackendCPU} from '../backend_cpu';\n\nexport function identity(\n    args: {inputs: IdentityInputs, backend: MathBackendCPU}): TensorInfo {\n  const {inputs, backend} = args;\n  const {x} = inputs;\n\n  backend.incRef(x.dataId);\n\n  return {dataId: x.dataId, shape: x.shape, dtype: x.dtype};\n}\n\nexport const identityConfig: KernelConfig = {\n  kernelName: Identity,\n  backendName: 'cpu',\n  kernelFunc: identity as {} as KernelFunc\n};\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {KernelConfig, KernelFunc, Real, RealInputs, TensorInfo} from '@tensorflow/tfjs-core';\n\nimport {MathBackendCPU} from '../backend_cpu';\n\nexport function real(args: {inputs: RealInputs, backend: MathBackendCPU}):\n    TensorInfo {\n  const {inputs, backend} = args;\n  const {input} = inputs;\n\n  const real = backend.data.get(input.dataId).complexTensorInfos.real;\n  const realVal = backend.data.get(real.dataId).values;\n\n  // When complex tensor is disposed, its underlying parts will be disposed too.\n  // Make new tensor out of the real value of the complex. This makes sure the\n  // value is still accessible even if complex tensor is disposed.\n  return backend.makeTensorInfo(real.shape, real.dtype, realVal);\n}\n\nexport const realConfig: KernelConfig = {\n  kernelName: Real,\n  backendName: 'cpu',\n  kernelFunc: real as {} as KernelFunc\n};\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport {Cast, CastAttrs, CastInputs, DataType, KernelConfig, KernelFunc, TensorInfo, TypedArray, util} from '@tensorflow/tfjs-core';\n\nimport {MathBackendCPU} from '../backend_cpu';\nimport {createSimpleBinaryKernelImpl} from '../utils/binary_impl';\nimport {zeros} from '../utils/zeros_impl';\n\nimport {complex} from './Complex';\nimport {identity} from './Identity';\nimport {real} from './Real';\n\nexport function castImpl(\n    values: TypedArray, shape: number[], inputType: DataType,\n    dtype: DataType): [number[], DataType, TypedArray] {\n  if (dtype === 'int32') {\n    const resultValues = Int32Array.from(values);\n    return [shape, 'int32', resultValues];\n  }\n\n  if (dtype === 'bool') {\n    // This is essentially the result of notEqual(x, 0). We avoid using\n    // kernel notEqual to avoid circular dependency, i.e. binary_utils ->\n    // cast -> notEqual -> binary_utils.\n    const zero = util.toTypedArray([0], inputType);\n\n    const [resultData, resultShape] = createSimpleBinaryKernelImpl(\n        (a, b) => (a !== b) ? 1 : 0)(shape, [], values, zero, 'bool');\n\n    return [resultShape, 'bool', resultData];\n  }\n  throw new Error(`Error in Cast: failed to cast ${inputType} to ${dtype}`);\n}\n\nexport function cast(\n    args: {inputs: CastInputs, backend: MathBackendCPU, attrs: CastAttrs}):\n    TensorInfo {\n  const {inputs, backend, attrs} = args;\n  const {x} = inputs;\n  const {dtype} = attrs;\n\n  // Casting to complex64.\n  if (dtype === 'complex64') {\n    if (x.dtype === 'complex64') {\n      return identity({inputs: {x}, backend});\n    }\n\n    const zerosTensorInfo = zeros(backend, x.shape, x.dtype);\n    const floatX = cast({inputs: {x}, backend, attrs: {dtype: 'float32'}});\n\n    const result =\n        complex({inputs: {real: floatX, imag: zerosTensorInfo}, backend});\n\n    backend.disposeIntermediateTensorInfo(zerosTensorInfo);\n    backend.disposeIntermediateTensorInfo(floatX);\n\n    return result;\n  }\n\n  // Casting from complex64\n  if (x.dtype === 'complex64') {\n    const realPart = real({inputs: {input: x}, backend});\n    const result = cast({inputs: {x: realPart}, backend, attrs: {dtype}});\n\n    backend.disposeIntermediateTensorInfo(realPart);\n\n    return result;\n  }\n\n  if (!util.hasEncodingLoss(x.dtype, dtype)) {\n    // We don't change the underlying data, since we cast to higher\n    // precision.\n    const result = identity({inputs: {x}, backend});\n    return {dataId: result.dataId, shape: result.shape, dtype};\n  }\n\n  const values = backend.data.get(x.dataId).values as TypedArray;\n  const [resultShape, resultType, resultData] =\n      castImpl(values, x.shape, x.dtype, dtype);\n  return backend.makeTensorInfo(resultShape, resultType, resultData);\n}\n\nexport const castConfig: KernelConfig = {\n  kernelName: Cast,\n  backendName: 'cpu',\n  kernelFunc: cast as {} as KernelFunc\n};\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {backend_util, BinaryInputs, DataType, KernelFunc, TypedArray, util} from '@tensorflow/tfjs-core';\n\nimport {MathBackendCPU} from '../backend_cpu';\nimport {assertNotComplex} from '../cpu_util';\nimport {cast} from '../kernels/Cast';\nimport {complex} from '../kernels/Complex';\n\nimport {ComplexBinaryKernelImpl, ComplexBinaryOperation, SimpleBinaryKernelImpl} from './binary_types';\n\n/**\n * Template that creates a `KernelFunc` for binary ops.\n * @param name Kernel name.\n * @param binaryKernelImpl A `SimpleBinaryKernelImpl` for the kernel.\n * @param binaryKernelComplexImpl Optional. If exists, represents a\n *     `ComplexBinaryKernelImpl` for the kernel, will be used when input dtype\n *     is `complex64`.\n * @param dtype Optional. If set, the result has this dtype. Otherwise, the\n *     result has the same dtype as the first input. This is mainly used in\n *     comparison kernels, such as Equal, Less, Greater, etc.\n */\nexport function binaryKernelFunc(\n    name: string, simpleImpl: SimpleBinaryKernelImpl,\n    complexImpl?: ComplexBinaryKernelImpl, dtype?: DataType): KernelFunc {\n  if (complexImpl == null) {\n    return ({inputs, backend}) => {\n      const {a, b} = inputs as BinaryInputs;\n      const cpuBackend = backend as MathBackendCPU;\n\n      assertNotComplex([a, b], name);\n\n      const aVals = cpuBackend.data.get(a.dataId).values as TypedArray;\n      const bVals = cpuBackend.data.get(b.dataId).values as TypedArray;\n\n      const decodedAVals = a.dtype === 'string' ?\n          // tslint:disable-next-line: no-any\n          backend_util.fromUint8ToStringArray(aVals as any as Uint8Array[]) :\n          aVals;\n      const decodedBVals = a.dtype === 'string' ?\n          // tslint:disable-next-line: no-any\n          backend_util.fromUint8ToStringArray(bVals as any as Uint8Array[]) :\n          bVals;\n      const $dtype = dtype || a.dtype;\n\n      const [resultData, resultShape] =\n          simpleImpl(a.shape, b.shape, decodedAVals, decodedBVals, $dtype);\n\n      return cpuBackend.makeTensorInfo(resultShape, $dtype, resultData);\n    };\n  }\n\n  return ({inputs, backend}) => {\n    const {a, b} = inputs as BinaryInputs;\n    const cpuBackend = backend as MathBackendCPU;\n\n    if (a.dtype === 'complex64' || b.dtype === 'complex64') {\n      const $aComplex = cast(\n          {inputs: {x: a}, backend: cpuBackend, attrs: {dtype: 'complex64'}});\n\n      const $aComplexVals = cpuBackend.data.get($aComplex.dataId);\n\n      const aReal = $aComplexVals.complexTensorInfos.real;\n      const aImag = $aComplexVals.complexTensorInfos.imag;\n\n      const aRealVals =\n          cpuBackend.data.get(aReal.dataId).values as Float32Array;\n      const aImagVals =\n          cpuBackend.data.get(aImag.dataId).values as Float32Array;\n\n      const $bComplex = cast(\n          {inputs: {x: b}, backend: cpuBackend, attrs: {dtype: 'complex64'}});\n\n      const $bComplexVals = cpuBackend.data.get($bComplex.dataId);\n\n      const bReal = $bComplexVals.complexTensorInfos.real;\n      const bImag = $bComplexVals.complexTensorInfos.imag;\n\n      const bRealVals =\n          cpuBackend.data.get(bReal.dataId).values as Float32Array;\n      const bImagVals =\n          cpuBackend.data.get(bImag.dataId).values as Float32Array;\n\n      const [resultRealData, resultImagData, resultShape] = complexImpl(\n          a.shape, b.shape, aRealVals, aImagVals, bRealVals, bImagVals);\n\n      const resultReal =\n          cpuBackend.makeTensorInfo(resultShape, 'float32', resultRealData);\n\n      const resultImag =\n          cpuBackend.makeTensorInfo(resultShape, 'float32', resultImagData);\n\n      const result = complex(\n          {inputs: {real: resultReal, imag: resultImag}, backend: cpuBackend});\n\n      cpuBackend.disposeIntermediateTensorInfo($aComplex);\n      cpuBackend.disposeIntermediateTensorInfo($bComplex);\n      cpuBackend.disposeIntermediateTensorInfo(resultReal);\n      cpuBackend.disposeIntermediateTensorInfo(resultImag);\n\n      return result;\n    } else {\n      const aVals = cpuBackend.data.get(a.dataId).values as TypedArray;\n      const bVals = cpuBackend.data.get(b.dataId).values as TypedArray;\n\n      const $dtype = dtype || a.dtype;\n\n      const [resultData, resultShape] =\n          simpleImpl(a.shape, b.shape, aVals, bVals, $dtype);\n\n      return cpuBackend.makeTensorInfo(resultShape, $dtype, resultData);\n    }\n  };\n}\n\n/**\n * Template that creates the complex type implementation for binary ops.\n * Supports broadcast.\n */\nexport function createComplexBinaryKernelImpl(op: ComplexBinaryOperation):\n    ComplexBinaryKernelImpl {\n  return (aShape: number[], bShape: number[], aRealVals: Float32Array,\n          aImagVals: Float32Array, bRealVals: Float32Array,\n          bImagVals: Float32Array): [TypedArray, TypedArray, number[]] => {\n    const resultShape = backend_util.assertAndGetBroadcastShape(aShape, bShape);\n    const resultSize = util.sizeFromShape(resultShape);\n    const resultRank = resultShape.length;\n    const resultStrides = util.computeStrides(resultShape);\n\n    const resultRealVals = util.getTypedArrayFromDType('float32', resultSize);\n    const resultImagVals = util.getTypedArrayFromDType('float32', resultSize);\n\n    const aBroadcastDims = backend_util.getBroadcastDims(aShape, resultShape);\n    const bBroadcastDims = backend_util.getBroadcastDims(bShape, resultShape);\n\n    const aVals = backend_util.mergeRealAndImagArrays(aRealVals, aImagVals);\n    const bVals = backend_util.mergeRealAndImagArrays(bRealVals, bImagVals);\n\n    const aRank = aShape.length;\n    const aStrides = util.computeStrides(aShape);\n\n    const bRank = bShape.length;\n    const bStrides = util.computeStrides(bShape);\n\n    if (aBroadcastDims.length + bBroadcastDims.length === 0) {\n      for (let i = 0; i < resultRealVals.length; i++) {\n        const aIdx = i % aVals.length;\n        const bIdx = i % bVals.length;\n\n        const result =\n            op(aVals[aIdx * 2], aVals[aIdx * 2 + 1], bVals[bIdx * 2],\n               bVals[bIdx * 2 + 1]);\n\n        resultRealVals[i] = result.real;\n        resultImagVals[i] = result.imag;\n      }\n    } else {\n      for (let i = 0; i < resultRealVals.length; i++) {\n        const loc = util.indexToLoc(i, resultRank, resultStrides);\n\n        const aLoc = loc.slice(-aRank);\n        aBroadcastDims.forEach(d => aLoc[d] = 0);\n        const aIndex = util.locToIndex(aLoc, aRank, aStrides);\n\n        const bLoc = loc.slice(-bRank);\n        bBroadcastDims.forEach(d => bLoc[d] = 0);\n        const bIndex = util.locToIndex(bLoc, bRank, bStrides);\n\n        const opResult =\n            op(aVals[aIndex * 2], aVals[aIndex * 2 + 1], bVals[bIndex * 2],\n               bVals[bIndex * 2 + 1]);\n\n        resultRealVals[i] = opResult.real;\n        resultImagVals[i] = opResult.imag;\n      }\n    }\n    return [resultRealVals, resultImagVals, resultShape];\n  };\n}\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {Add, KernelConfig} from '@tensorflow/tfjs-core';\n\nimport {createSimpleBinaryKernelImpl} from '../utils/binary_impl';\nimport {binaryKernelFunc, createComplexBinaryKernelImpl} from '../utils/binary_utils';\n\nexport const addImpl =\n    createSimpleBinaryKernelImpl(((a: number, b: number) => a + b));\nexport const addComplexImpl =\n    createComplexBinaryKernelImpl(((aReal, aImag, bReal, bImag) => {\n      return {real: aReal + bReal, imag: aImag + bImag};\n    }));\n\nexport const add = binaryKernelFunc(Add, addImpl, addComplexImpl);\n\nexport const addConfig: KernelConfig = {\n  kernelName: Add,\n  backendName: 'cpu',\n  kernelFunc: add\n};\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {buffer, DataType, Rank, TensorBuffer, TypedArray, util} from '@tensorflow/tfjs-core';\n\nexport function bincountImpl(\n    xVals: TypedArray, weightsVals: TypedArray, weightsDtype: DataType,\n    weightsShape: number[], size: number): TypedArray {\n  const weightsSize = util.sizeFromShape(weightsShape);\n  const outVals = util.makeZerosTypedArray(size, weightsDtype) as TypedArray;\n\n  for (let i = 0; i < xVals.length; i++) {\n    const value = xVals[i];\n    if (value < 0) {\n      throw new Error('Input x must be non-negative!');\n    }\n\n    if (value >= size) {\n      continue;\n    }\n\n    if (weightsSize > 0) {\n      outVals[value] += weightsVals[i];\n    } else {\n      outVals[value] += 1;\n    }\n  }\n\n  return outVals;\n}\n\nexport function bincountReduceImpl<R extends Rank>(\n    xBuf: TensorBuffer<R>, weightsBuf: TensorBuffer<R>, size: number,\n    binaryOutput = false): TensorBuffer<R> {\n  const numRows = xBuf.shape[0];\n  const numCols = xBuf.shape[1];\n\n  const outBuf = buffer([numRows, size], weightsBuf.dtype);\n\n  for (let i = 0; i < numRows; i++) {\n    for (let j = 0; j < numCols; j++) {\n      const value = xBuf.get(i, j);\n      if (value < 0) {\n        throw new Error('Input x must be non-negative!');\n      }\n\n      if (value >= size) {\n        continue;\n      }\n\n      if (binaryOutput) {\n        outBuf.set(1, i, value);\n      } else {\n        if (weightsBuf.size > 0) {\n          outBuf.set(outBuf.get(i, value) + weightsBuf.get(i, j), i, value);\n        } else {\n          outBuf.set(outBuf.get(i, value) + 1, i, value);\n        }\n      }\n    }\n  }\n\n  return outBuf as TensorBuffer<R>;\n}\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {NumericDataType, util} from '@tensorflow/tfjs-core';\n\nimport {SimpleUnaryImpl, SimpleUnaryOperation} from './unary_types';\n\n/**\n * Template that creates implementation for unary op.\n */\nexport function createSimpleUnaryImpl(op: SimpleUnaryOperation):\n    SimpleUnaryImpl {\n  return (values, dtype, attrs) => {\n    const newValues =\n        util.getTypedArrayFromDType(dtype as NumericDataType, values.length);\n    for (let i = 0; i < values.length; ++i) {\n      newValues[i] = op(values[i], attrs);\n    }\n    return newValues;\n  };\n}\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {DataType, KernelFunc, TypedArray, UnaryInputs, util} from '@tensorflow/tfjs-core';\n\nimport {MathBackendCPU} from '../backend_cpu';\nimport {assertNotComplex} from '../cpu_util';\n\nimport {SimpleUnaryImpl, SimpleUnaryOperation} from './unary_types';\n\n/**\n * Template that creates a `KernelFunc` for unary ops.\n * @param name Kernel name.\n * @param op A `SimpleUnaryOperation` for the kernel.\n * @param dtype Optional. If set, the result has this dtype. Otherwise, the\n *     result has the same dtype as the input. This is mainly used in certain\n *     kernels that return bool type, such as isFinite, isInf, etc.\n */\nexport function unaryKernelFunc(\n    name: string, op: SimpleUnaryOperation, dtype?: DataType): KernelFunc {\n  return ({inputs, attrs, backend}) => {\n    const {x} = inputs as UnaryInputs;\n    assertNotComplex(x, name);\n    if (x.dtype === 'string' || dtype === 'string') {\n      throw new Error('unaryKernelFunc does not support string input/output');\n    }\n\n    const cpuBackend = backend as MathBackendCPU;\n    const values = cpuBackend.data.get(x.dataId).values as TypedArray;\n    const xSize = util.sizeFromShape(x.shape);\n    const $dtype = dtype || x.dtype;\n    const newValues = util.getArrayFromDType($dtype, xSize);\n    for (let i = 0; i < xSize; ++i) {\n      newValues[i] = op(values[i], attrs);\n    }\n    return cpuBackend.makeTensorInfo(x.shape, $dtype, newValues);\n  };\n}\n\n/**\n * Template that creates a `KernelFunc` for unary ops from the given\n * `SimpleUnaryImpl`..\n * @param name Kernel name.\n * @param unaryImpl A `SimpleUnaryImpl` that implements the op.\n * @param dtype Optional. If set, the result has this dtype. Otherwise, the\n *     result has the same dtype as the input. This is mainly used in certain\n *     kernels that return bool type, such as isFinite, isInf, etc.\n */\nexport function unaryKernelFuncFromImpl(\n    name: string, unaryImpl: SimpleUnaryImpl, dtype?: DataType): KernelFunc {\n  return ({inputs, attrs, backend}) => {\n    const {x} = inputs as UnaryInputs;\n    assertNotComplex(x, name);\n    if (x.dtype === 'string' || dtype === 'string') {\n      throw new Error('unaryKernelFunc does not support string input/output');\n    }\n\n    const cpuBackend = backend as MathBackendCPU;\n    const values = cpuBackend.data.get(x.dataId).values as TypedArray;\n    const $dtype = dtype || x.dtype;\n    const newValues = unaryImpl(values, $dtype, attrs);\n    return cpuBackend.makeTensorInfo(x.shape, $dtype, newValues);\n  };\n}\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the License);\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an AS IS BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {Ceil, KernelConfig} from '@tensorflow/tfjs-core';\n\nimport {createSimpleUnaryImpl} from '../utils/unary_impl';\nimport {unaryKernelFuncFromImpl} from '../utils/unary_utils';\n\nexport const ceilImpl = createSimpleUnaryImpl((xi) => Math.ceil(xi));\nexport const ceil = unaryKernelFuncFromImpl(Ceil, ceilImpl);\n\nexport const ceilConfig: KernelConfig = {\n  kernelName: Ceil,\n  backendName: 'cpu',\n  kernelFunc: ceil,\n};\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {backend_util, BackendValues, DataType, TypedArray, util} from '@tensorflow/tfjs-core';\n\nexport function concatImpl(\n    inputs: Array<{vals: BackendValues, shape: number[]}>, outShape: number[],\n    dtype: DataType, simplyConcat: boolean): TypedArray|string[] {\n  const outVals = util.getArrayFromDType(dtype, util.sizeFromShape(outShape));\n\n  if (simplyConcat && dtype !== 'string') {\n    // Use built-in TypedArray.set() method for speed.\n    let offset = 0;\n    inputs.forEach(input => {\n      const size = util.sizeFromShape(input.shape);\n\n      (outVals as TypedArray).set(input.vals as TypedArray, offset);\n      offset += size;\n    });\n  } else {\n    let colOffset = 0;\n\n    inputs.forEach(input => {\n      const decodedData = dtype === 'string' ?\n          backend_util.fromUint8ToStringArray(input.vals as Uint8Array[]) :\n          input.vals as TypedArray;\n\n      let tIdx = 0;\n\n      for (let row = 0; row < input.shape[0]; ++row) {\n        const resIdx = row * outShape[1] + colOffset;\n        for (let col = 0; col < input.shape[1]; ++col) {\n          outVals[resIdx + col] = decodedData[tIdx++];\n        }\n      }\n\n      colOffset += input.shape[1];\n    });\n  }\n\n  return outVals;\n}\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {Equal, KernelConfig} from '@tensorflow/tfjs-core';\n\nimport {createSimpleBinaryKernelImpl} from '../utils/binary_impl';\nimport {binaryKernelFunc} from '../utils/binary_utils';\n\nexport const equalImpl =\n    createSimpleBinaryKernelImpl((a: number, b: number) => (a === b) ? 1 : 0);\nexport const equal =\n    binaryKernelFunc(Equal, equalImpl, null /* complexImpl */, 'bool');\n\nexport const equalConfig: KernelConfig = {\n  kernelName: Equal,\n  backendName: 'cpu',\n  kernelFunc: equal\n};\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the License);\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an AS IS BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {Exp, KernelConfig} from '@tensorflow/tfjs-core';\n\nimport {createSimpleUnaryImpl} from '../utils/unary_impl';\nimport {unaryKernelFuncFromImpl} from '../utils/unary_utils';\n\nexport const expImpl = createSimpleUnaryImpl((xi) => Math.exp(xi));\nexport const exp = unaryKernelFuncFromImpl(Exp, expImpl, 'float32');\n\nexport const expConfig: KernelConfig = {\n  kernelName: Exp,\n  backendName: 'cpu',\n  kernelFunc: exp,\n};\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the License);\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an AS IS BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {Expm1, KernelConfig} from '@tensorflow/tfjs-core';\n\nimport {createSimpleUnaryImpl} from '../utils/unary_impl';\nimport {unaryKernelFuncFromImpl} from '../utils/unary_utils';\n\nexport const expm1Impl = createSimpleUnaryImpl((xi) => Math.expm1(xi));\nexport const expm1 = unaryKernelFuncFromImpl(Expm1, expm1Impl);\n\nexport const expm1Config: KernelConfig = {\n  kernelName: Expm1,\n  backendName: 'cpu',\n  kernelFunc: expm1,\n};\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the License);\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an AS IS BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {Floor, KernelConfig} from '@tensorflow/tfjs-core';\n\nimport {createSimpleUnaryImpl} from '../utils/unary_impl';\nimport {unaryKernelFuncFromImpl} from '../utils/unary_utils';\n\nexport const floorImpl = createSimpleUnaryImpl((xi) => Math.floor(xi));\nexport const floor = unaryKernelFuncFromImpl(Floor, floorImpl);\n\nexport const floorConfig: KernelConfig = {\n  kernelName: Floor,\n  backendName: 'cpu',\n  kernelFunc: floor,\n};\n","/**\n * @license\n * Copyright 2021 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {buffer, DataType, Rank, TensorBuffer, TypedArray} from '@tensorflow/tfjs-core';\n\nexport function gatherNdImpl<R extends Rank>(\n    indicesData: TypedArray, paramsBuf: TensorBuffer<R>, dtype: DataType,\n    numSlices: number, sliceRank: number, sliceSize: number, strides: number[],\n    paramsShape: number[], paramsSize: number): TensorBuffer<R> {\n  const outBuf = buffer([numSlices, sliceSize], dtype);\n\n  for (let i = 0; i < numSlices; i++) {\n    const index = [];\n    let flattenIndex = 0;\n    for (let j = 0; j < sliceRank; j++) {\n      const dim = indicesData[i * sliceRank + j];\n      flattenIndex += dim * strides[j];\n      index.push(dim);\n    }\n    if (flattenIndex < 0 || flattenIndex >= paramsSize / sliceSize) {\n      throw new Error(\n          `Invalid indices: ${index} does not index into ${paramsShape}`);\n    }\n\n    for (let k = 0; k < sliceSize; k++) {\n      outBuf.values[i * sliceSize + k] =\n          paramsBuf.get(...paramsBuf.indexToLoc(flattenIndex * sliceSize + k));\n    }\n  }\n\n  return outBuf as TensorBuffer<R>;\n}\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {buffer, DataType, Rank, TensorBuffer} from '@tensorflow/tfjs-core';\n\nexport function gatherV2Impl<R extends Rank, D extends DataType>(\n    xBuf: TensorBuffer<R, D>, indicesBuf: TensorBuffer<R, D>,\n    flattenOutputShape: number[]): TensorBuffer<R, D> {\n  const outBuf = buffer(flattenOutputShape, xBuf.dtype);\n  for (let i = 0; i < outBuf.size; ++i) {\n    const newLoc = outBuf.indexToLoc(i);\n\n    const originalLoc: number[] = newLoc.slice();\n    const batchIdx = originalLoc[0];\n    const indicesIdx = originalLoc[2];\n    const indicesIndex = indicesBuf.locToIndex([batchIdx, indicesIdx]);\n    originalLoc[2] = indicesBuf.values[indicesIndex] as number;\n\n    const originalIndex = xBuf.locToIndex(originalLoc);\n\n    if (0 <= originalIndex && originalIndex < xBuf.values.length) {\n      outBuf.values[i] = xBuf.values[originalIndex];\n    } // Else, index is out of bounds, so leave the default zero val in outBuf.\n  }\n\n  return outBuf as TensorBuffer<R, D>;\n}\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {Greater, KernelConfig} from '@tensorflow/tfjs-core';\n\nimport {createSimpleBinaryKernelImpl} from '../utils/binary_impl';\nimport {binaryKernelFunc} from '../utils/binary_utils';\n\nexport const greaterImpl =\n    createSimpleBinaryKernelImpl((a: number, b: number) => (a > b) ? 1 : 0);\nexport const greater =\n    binaryKernelFunc(Greater, greaterImpl, null /* complexImpl */, 'bool');\n\nexport const greaterConfig: KernelConfig = {\n  kernelName: Greater,\n  backendName: 'cpu',\n  kernelFunc: greater\n};\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {GreaterEqual, KernelConfig} from '@tensorflow/tfjs-core';\n\nimport {createSimpleBinaryKernelImpl} from '../utils/binary_impl';\nimport {binaryKernelFunc} from '../utils/binary_utils';\n\nexport const greaterEqualImpl =\n    createSimpleBinaryKernelImpl((a: number, b: number) => (a >= b) ? 1 : 0);\nexport const greaterEqual = binaryKernelFunc(\n    GreaterEqual, greaterEqualImpl, null /* complexImpl */, 'bool');\n\nexport const greaterEqualConfig: KernelConfig = {\n  kernelName: GreaterEqual,\n  backendName: 'cpu',\n  kernelFunc: greaterEqual\n};\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {KernelConfig, Less} from '@tensorflow/tfjs-core';\n\nimport {createSimpleBinaryKernelImpl} from '../utils/binary_impl';\nimport {binaryKernelFunc} from '../utils/binary_utils';\n\nexport const lessImpl =\n    createSimpleBinaryKernelImpl((a: number, b: number) => (a < b) ? 1 : 0);\nexport const less =\n    binaryKernelFunc(Less, lessImpl, null /* complexImpl */, 'bool');\n\nexport const lessConfig: KernelConfig = {\n  kernelName: Less,\n  backendName: 'cpu',\n  kernelFunc: less\n};\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {KernelConfig, LessEqual} from '@tensorflow/tfjs-core';\n\nimport {createSimpleBinaryKernelImpl} from '../utils/binary_impl';\nimport {binaryKernelFunc} from '../utils/binary_utils';\n\nexport const lessEqualImpl =\n    createSimpleBinaryKernelImpl((a: number, b: number) => (a <= b) ? 1 : 0);\nexport const lessEqual =\n    binaryKernelFunc(LessEqual, lessEqualImpl, null /* complexImpl */, 'bool');\n\nexport const lessEqualConfig: KernelConfig = {\n  kernelName: LessEqual,\n  backendName: 'cpu',\n  kernelFunc: lessEqual\n};\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {TypedArray, util} from '@tensorflow/tfjs-core';\n\nexport function linSpaceImpl(\n    start: number, stop: number, num: number): TypedArray {\n  const step = (stop - start) / (num - 1);\n\n  const values = util.makeZerosTypedArray(num, 'float32');\n  values[0] = start;\n  for (let i = 1; i < values.length; i++) {\n    values[i] = values[i - 1] + step;\n  }\n\n  return values;\n}\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the License);\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an AS IS BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {KernelConfig, Log} from '@tensorflow/tfjs-core';\n\nimport {createSimpleUnaryImpl} from '../utils/unary_impl';\nimport {unaryKernelFuncFromImpl} from '../utils/unary_utils';\n\nexport const logImpl = createSimpleUnaryImpl((xi) => Math.log(xi));\nexport const log = unaryKernelFuncFromImpl(Log, logImpl);\n\nexport const logConfig: KernelConfig = {\n  kernelName: Log,\n  backendName: 'cpu',\n  kernelFunc: log,\n};\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {DataType, NumericDataType, TypedArray, util} from '@tensorflow/tfjs-core';\n\nexport function maxImpl(\n    aVals: TypedArray, reduceSize: number, outShape: number[],\n    dtype: DataType): TypedArray {\n  const vals = util.getTypedArrayFromDType(\n      dtype as NumericDataType, util.sizeFromShape(outShape));\n\n  for (let i = 0; i < vals.length; ++i) {\n    const offset = i * reduceSize;\n    let max = aVals[offset];\n    for (let j = 0; j < reduceSize; ++j) {\n      const value = aVals[offset + j];\n      if (Number.isNaN(value) ||\n          value > max) {  // comparison with NaN always return false\n        max = value;\n      }\n    }\n    vals[i] = max;\n  }\n  return vals;\n}\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {KernelConfig, Maximum} from '@tensorflow/tfjs-core';\n\nimport {createSimpleBinaryKernelImpl} from '../utils/binary_impl';\nimport {binaryKernelFunc} from '../utils/binary_utils';\n\nexport const maximumImpl = createSimpleBinaryKernelImpl(\n    ((aValue, bValue) => Math.max(aValue as number, bValue as number)));\nexport const maximum = binaryKernelFunc(Maximum, maximumImpl);\n\nexport const maximumConfig: KernelConfig = {\n  kernelName: Maximum,\n  backendName: 'cpu',\n  kernelFunc: maximum\n};\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {KernelConfig, Minimum} from '@tensorflow/tfjs-core';\n\nimport {createSimpleBinaryKernelImpl} from '../utils/binary_impl';\nimport {binaryKernelFunc} from '../utils/binary_utils';\n\nexport const minimumImpl = createSimpleBinaryKernelImpl(\n    ((aValue, bValue) => Math.min(aValue as number, bValue as number)));\nexport const minimum = binaryKernelFunc(Minimum, minimumImpl);\n\nexport const minimumConfig: KernelConfig = {\n  kernelName: Minimum,\n  backendName: 'cpu',\n  kernelFunc: minimum\n};\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {KernelConfig, Multiply} from '@tensorflow/tfjs-core';\nimport {createSimpleBinaryKernelImpl} from '../utils/binary_impl';\nimport {binaryKernelFunc, createComplexBinaryKernelImpl} from '../utils/binary_utils';\n\nexport const multiplyImpl = createSimpleBinaryKernelImpl(\n    ((aValue: number, bValue: number) => aValue * bValue));\nexport const multiplyComplexImpl =\n    createComplexBinaryKernelImpl(((aReal, aImag, bReal, bImag) => {\n      return {\n        real: aReal * bReal - aImag * bImag,\n        imag: aReal * bImag + aImag * bReal\n      };\n    }));\n\nexport const multiply =\n    binaryKernelFunc(Multiply, multiplyImpl, multiplyComplexImpl);\n\nexport const multiplyConfig: KernelConfig = {\n  kernelName: Multiply,\n  backendName: 'cpu',\n  kernelFunc: multiply\n};\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {DataType, KernelConfig, KernelFunc, Neg, TensorInfo, TypedArray, UnaryInputs, util} from '@tensorflow/tfjs-core';\n\nimport {MathBackendCPU} from '../backend_cpu';\nimport {assertNotComplex} from '../cpu_util';\nimport {multiplyImpl} from './Multiply';\n\nexport function negImpl(xVals: TypedArray, xShape: number[], xDtype: DataType):\n    [TypedArray, number[]] {\n  const minusOne =\n      util.createScalarValue(-1 as {} as 'float32', xDtype) as TypedArray;\n  return multiplyImpl([], xShape, minusOne, xVals, xDtype);\n}\n\nexport function neg(args: {inputs: UnaryInputs, backend: MathBackendCPU}):\n    TensorInfo {\n  const {inputs, backend} = args;\n  const {x} = inputs;\n\n  assertNotComplex(x, 'neg');\n\n  const xVals = backend.data.get(x.dataId).values as TypedArray;\n  const [res, newShape] = negImpl(xVals, x.shape, x.dtype);\n\n  return backend.makeTensorInfo(newShape, x.dtype, res);\n}\n\nexport const negConfig: KernelConfig = {\n  kernelName: Neg,\n  backendName: 'cpu',\n  kernelFunc: neg as {} as KernelFunc\n};\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {KernelConfig, NotEqual} from '@tensorflow/tfjs-core';\n\nimport {createSimpleBinaryKernelImpl} from '../utils/binary_impl';\nimport {binaryKernelFunc} from '../utils/binary_utils';\n\nexport const notEqualImpl =\n    createSimpleBinaryKernelImpl(((a, b) => (a !== b) ? 1 : 0));\nexport const notEqual =\n    binaryKernelFunc(NotEqual, notEqualImpl, null /* complexOp */, 'bool');\n\nexport const notEqualConfig: KernelConfig = {\n  kernelName: NotEqual,\n  backendName: 'cpu',\n  kernelFunc: notEqual\n};\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {DataType, NumericDataType, TypedArray} from '@tensorflow/tfjs-core';\nimport {util} from '@tensorflow/tfjs-core';\n\nexport function transposeImpl(\n    xVals: TypedArray, xShape: number[], dtype: DataType, perm: number[],\n    newShape: number[]): TypedArray {\n  const xRank = xShape.length;\n  const xSize = util.sizeFromShape(xShape);\n  const xStrides = util.computeStrides(xShape);\n  const newStrides = util.computeStrides(newShape);\n\n  const result = util.getTypedArrayFromDType(\n      dtype as NumericDataType, util.sizeFromShape(newShape));\n\n  for (let i = 0; i < xSize; ++i) {\n    const loc = util.indexToLoc(i, xRank, xStrides);\n\n    // Permute location.\n    const newLoc: number[] = new Array(loc.length);\n    for (let i = 0; i < newLoc.length; i++) {\n      newLoc[i] = loc[perm[i]];\n    }\n\n    const newIndex = util.locToIndex(newLoc, xRank, newStrides);\n    result[newIndex] = xVals[i];\n  }\n  return result;\n}\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {KernelConfig, KernelFunc, TensorInfo, Transpose, TransposeAttrs, TransposeInputs, TypedArray} from '@tensorflow/tfjs-core';\n\nimport {MathBackendCPU} from '../backend_cpu';\nimport {assertNotComplex} from '../cpu_util';\n\nimport {transposeImpl} from './Transpose_impl';\n\nexport function transpose(args: {\n  inputs: TransposeInputs,\n  attrs: TransposeAttrs,\n  backend: MathBackendCPU\n}): TensorInfo {\n  const {inputs, attrs, backend} = args;\n  const {x} = inputs;\n  const {perm} = attrs;\n\n  assertNotComplex(x, 'transpose');\n\n  const xRank = x.shape.length;\n\n  const newShape: number[] = new Array(xRank);\n  for (let i = 0; i < newShape.length; i++) {\n    newShape[i] = x.shape[perm[i]];\n  }\n\n  const values = backend.data.get(x.dataId).values as TypedArray;\n  const result = transposeImpl(values, x.shape, x.dtype, perm, newShape);\n\n  const dataId = backend.write(result, newShape, x.dtype);\n  return {dataId, shape: newShape, dtype: x.dtype};\n}\n\nexport const transposeConfig: KernelConfig = {\n  kernelName: Transpose,\n  backendName: 'cpu',\n  kernelFunc: transpose as {} as KernelFunc\n};\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {backend_util, DataType, KernelConfig, KernelFunc, Prod, ProdAttrs, ProdInputs, TensorInfo, TypedArray, upcastType, util} from '@tensorflow/tfjs-core';\n\nimport {MathBackendCPU} from '../backend_cpu';\nimport {assertNotComplex} from '../cpu_util';\nimport {transpose} from './Transpose';\n\nexport function prodImpl(\n    xShape: number[], xDtype: DataType, xVals: TypedArray,\n    reductionAxes: number[]):\n    {outVals: TypedArray, outShape: number[], outDtype: DataType} {\n  const [outShape, reduceShape] =\n      backend_util.computeOutAndReduceShapes(xShape, reductionAxes);\n  const outDtype = upcastType(xDtype, 'int32');\n  const outVals = util.makeZerosTypedArray(\n                      util.sizeFromShape(outShape), outDtype) as TypedArray;\n  const reduceSize = util.sizeFromShape(reduceShape);\n\n  for (let i = 0; i < outVals.length; ++i) {\n    const offset = i * reduceSize;\n    let prod = 1;\n    for (let j = 0; j < reduceSize; ++j) {\n      prod *= xVals[offset + j];\n    }\n    outVals[i] = prod;\n  }\n\n  return {outVals, outShape, outDtype};\n}\n\nexport function prod(\n    args: {inputs: ProdInputs, backend: MathBackendCPU, attrs: ProdAttrs}):\n    TensorInfo {\n  const {inputs, backend, attrs} = args;\n  const {x} = inputs;\n  const {axis, keepDims} = attrs;\n\n  assertNotComplex(x, 'prod');\n\n  const xRank = x.shape.length;\n  const axes = util.parseAxisParam(axis, x.shape);\n\n  const permutation = backend_util.getAxesPermutation(axes, xRank);\n  let reductionAxes = axes;\n  let permutedX = x;\n  const intermediateTensorInfos = [];\n  if (permutation != null) {\n    permutedX = transpose({inputs: {x}, backend, attrs: {perm: permutation}});\n    intermediateTensorInfos.push(permutedX);\n    reductionAxes = backend_util.getInnerMostAxes(reductionAxes.length, xRank);\n  }\n\n  const xVals = backend.data.get(permutedX.dataId).values as TypedArray;\n  const {outVals, outShape, outDtype} =\n      prodImpl(permutedX.shape, permutedX.dtype, xVals, reductionAxes);\n\n  let resultShape = outShape;\n  if (keepDims) {\n    resultShape = backend_util.expandShapeToKeepDim(outShape, axes);\n  }\n\n  intermediateTensorInfos.forEach(\n      t => backend.disposeIntermediateTensorInfo(t));\n\n  return backend.makeTensorInfo(resultShape, outDtype, outVals);\n}\n\nexport const prodConfig: KernelConfig = {\n  kernelName: Prod,\n  backendName: 'cpu',\n  kernelFunc: prod as {} as KernelFunc\n};\n","/**\n * @license\n * Copyright 2022 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {DataType, TypedArray, util} from '@tensorflow/tfjs-core';\n\nfunction validateIndices(\n    indices: TypedArray, indicesShape: number[], numParams: number) {\n  indices.forEach((index: number, i: number) => {\n    if (index < 0 || index >= numParams) {\n      const locString =\n          util.indexToLoc(\n                  i, indicesShape.length, util.computeStrides(indicesShape))\n              .join(',');\n      throw new Error(\n          `indices[${locString}] = ${index} is not in [0, ${numParams})`);\n    }\n  });\n}\n\nfunction validateSplits(\n    paramsNestedSplits: TypedArray[], numParamsDenseValues: number) {\n  // Validate\n  for (let dim = 0; dim < paramsNestedSplits.length; ++dim) {\n    const splits = paramsNestedSplits[dim];\n    const lastSplit = (dim === paramsNestedSplits.length - 1) ?\n        numParamsDenseValues :\n        paramsNestedSplits[dim + 1].length;\n    if (splits.length === 0) {\n      throw new Error('Ragged splits may not be empty');\n    }\n    if (splits[0] < 0) {\n      throw new Error('Ragged splits must be non-negative');\n    }\n    if (splits[splits.length - 1] > lastSplit) {\n      throw new Error('Ragged splits must not point past values');\n    }\n    for (let i = 1; i < splits.length; ++i) {\n      if (splits[i - 1] > splits[i]) {\n        throw new Error('Ragged splits must be sorted in ascending order');\n      }\n    }\n  }\n}\n\n// Construct the `splits` output tensors, encoded using a nested vector.\n// Also find the slices of values that need to be copied, and store them\n// in `valueSlices`.  The total number of values that will be copied (which\n// we need for allocating the output values tensor) is stored in `numValues`.\nfunction makeSplits(\n    indices: TypedArray, indicesShape: number[],\n    paramsNestedSplits: TypedArray[], numParamsDenseValues: number) {\n  const valueSlices: Array<[number, number]> = [];\n  let numValues = 0;\n\n  const numSplits = indicesShape.length - 1 + paramsNestedSplits.length;\n  const outSplits = new Array(numSplits).fill(null).map(() => [0]);\n\n  validateSplits(paramsNestedSplits, numParamsDenseValues);\n\n  // Add `splits` that come from all but the last dimension of the dense\n  // Tensor `indices`.  In particular, for each dimension D, we add a\n  // splits tensor whose values are:\n  //   range(reduceProd(splits.shape[:D]) + 1) * splits.shape[D+1]\n  // E.g., if indices.shape=[2, 3, 4] then we will add splits tensors:\n  //   [0, 3, 6]                    # length=2+1, stride=3\n  //   [0, 4, 8, 12, 16, 20, 24]    # length=2*3+1, stride=4\n  let nrows = 1;\n  for (let dim = 0; dim < indicesShape.length - 1; ++dim) {\n    nrows *= indicesShape[dim];\n    const rowLength = indicesShape[dim + 1];\n    for (let i = 1; i < nrows + 1; ++i) {\n      outSplits[dim].push(i * rowLength);\n    }\n  }\n\n  // Add `splits` that come from `paramsNestedSplits`.  Starting with the\n  // outermost ragged dimension (i.e., the first `splits` tensor), we work\n  // our way in, finding the range of values that should be copied.  As we\n  // go, we update the output `splits` for each dimension with the appropriate\n  // values.  In particular, the *lengths* of the slices from `param_splits`\n  // should be copied to generate corresponding slice lengths in the output\n  // splits.  E.g., if we are copying a ragged row with length 4, then we\n  // should add a new split point to outSplits that is 4 greater than the\n  // previous split point in outSplits.\n  for (let i = 0; i < indices.length; ++i) {\n    let start = indices[i];\n    let limit = indices[i] + 1;\n\n    // Copy splits.\n    for (let dim = 0; dim < paramsNestedSplits.length; ++dim) {\n      const splits = paramsNestedSplits[dim];\n      const outDim = dim + indicesShape.length - 1;\n      if (outDim >= 0) {\n        const outSplitsOutDim = outSplits[outDim];\n        const delta =\n            outSplitsOutDim[outSplitsOutDim.length - 1] - splits[start];\n        for (let j = start; j < limit; ++j) {\n          outSplits[outDim].push(splits[j + 1] + delta);\n        }\n      }\n      start = splits[start];\n      limit = splits[limit];\n    }\n    if (limit !== start) {\n      valueSlices.push([start, limit]);\n      numValues += limit - start;\n    }\n  }\n\n  return {outSplits, valueSlices, numValues};\n}\n\nfunction getSplits(outSplits: number[][]) {\n  const splitsOut: TypedArray[] = [];\n  for (let i = 0; i < outSplits.length; ++i) {\n    const numSplits = outSplits[i].length;\n    const splits = util.getArrayFromDType('int32', numSplits) as TypedArray;\n    splitsOut.push(splits);\n\n    outSplits[i].forEach((value, j: number) => splits[j] = value);\n  }\n\n  return splitsOut;\n}\n\nfunction computeFlatOuterDims(orig: number[], numOutDims: number) {\n  const outDims = orig.slice(0, numOutDims);\n  while (outDims.length < numOutDims) {\n    outDims.push(1);\n  }\n\n  for (let inDim = numOutDims; inDim < orig.length; inDim++) {\n    outDims[numOutDims - 1] *= orig[inDim];\n  }\n\n  return outDims;\n}\n// For each slice in `(start, limit)` in `valueSlices`, append\n// `paramsDenseValues[start,...,limit] to `values`.  `valueSize` indicates\n// the number of scalars contained in each value paramsDenseValues[i].\nfunction writeValueSlices(\n    paramsDenseValues: TypedArray, paramsDenseValuesShape: number[],\n    valueSlices: Array<[number, number]>, valueSize: number, values: TypedArray,\n    valuesShape: number[]) {\n  const denseM = computeFlatOuterDims(paramsDenseValuesShape, 2)[1];\n  const valuesM = computeFlatOuterDims(valuesShape, 2)[1];\n\n  let outPos = 0;\n  for (const slice of valueSlices) {\n    for (let i = slice[0]; i < slice[1]; ++i) {\n      for (let j = 0; j < valueSize; ++j) {\n        values[outPos * valuesM + j] = paramsDenseValues[i * denseM + j];\n      }\n      ++outPos;\n    }\n  }\n}\n\nfunction getValues(\n    paramsDenseValues: TypedArray, paramsDenseValuesShape: number[],\n    paramsDenseValuesDType: DataType, valueSlices: Array<[number, number]>,\n    numValues: number): [TypedArray, number[]] {\n  const valuesShape = paramsDenseValuesShape.slice();\n  valuesShape[0] = numValues;\n\n  const valuesOut = util.getArrayFromDType(\n                        paramsDenseValuesDType,\n                        util.sizeFromShape(valuesShape)) as TypedArray;\n\n  const numElements = paramsDenseValues.length;\n  const valueSize =\n      numElements === 0 ? 0 : (numElements / paramsDenseValuesShape[0]);\n  writeValueSlices(\n      paramsDenseValues, paramsDenseValuesShape, valueSlices, valueSize,\n      valuesOut, valuesShape);\n\n  return [valuesOut, valuesShape];\n}\nexport function raggedGatherImpl(\n    paramsNestedSplits: TypedArray[], paramsNestedSplitsShapes: number[][],\n    paramsDenseValues: TypedArray, paramsDenseValuesShape: number[],\n    paramsDenseValuesDType: DataType, indices: TypedArray,\n    indicesShape: number[],\n    outputRaggedRank: number): [TypedArray[], TypedArray, number[]] {\n  if (paramsNestedSplits.length === 0) {\n    throw new Error('paramsNestedSplits must be non empty');\n  }\n\n  if (paramsNestedSplitsShapes[0].length === 0) {\n    throw new Error('Split tensors must not be scalars');\n  }\n  const numParams = paramsNestedSplitsShapes[0][0] - 1;\n  validateIndices(indices, indicesShape, numParams);\n\n  if (paramsDenseValuesShape.length === 0) {\n    throw new Error('params.rank must be nonzero');\n  }\n  const numParamsDenseValues = paramsDenseValuesShape[0];\n\n  // Calculate the `splits`, and store the value slices that we need to\n  // copy in `valueSlices`.\n  const {outSplits, valueSlices, numValues} = makeSplits(\n      indices, indicesShape, paramsNestedSplits, numParamsDenseValues);\n\n  // Write the output tensors.\n  const outputNestedSplits = getSplits(outSplits);\n  const outputDenseValues = getValues(\n      paramsDenseValues, paramsDenseValuesShape, paramsDenseValuesDType,\n      valueSlices, numValues);\n\n  return [outputNestedSplits, outputDenseValues[0], outputDenseValues[1]];\n}\n","/**\n * @license\n * Copyright 2022 Google LLC.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {DataType, TypedArray, util} from '@tensorflow/tfjs-core';\n\nconst INT32_MAX = 2147483647;\n\nexport function raggedRangeImpl(\n    starts: TypedArray, startsShape: number[], startsDType: DataType,\n    limits: TypedArray, limitsShape: number[], deltas: TypedArray,\n    deltasShape: number[]): [TypedArray, TypedArray] {\n  // Check input tensor shapes.\n  if (startsShape.length > 1) {\n    throw new Error('starts must be a scalar or vector');\n  }\n  if (limitsShape.length > 1) {\n    throw new Error('limits must be a scalar or vector');\n  }\n  if (deltasShape.length > 1) {\n    throw new Error('deltas must be a scalar or vector');\n  }\n\n  // Determine which tensors we need to broadcast.\n  const broadcastStarts = startsShape.length === 0;\n  const broadcastLimits = limitsShape.length === 0;\n  const broadcastDeltas = deltasShape.length === 0;\n\n  // nRows (number of output rows) is the size of the non-broadcast inputs,\n  // or 1 if all inputs are scalars.\n  const inSizes: number[] = [];\n  if (!broadcastStarts) {\n    inSizes.push(startsShape[0]);\n  }\n  if (!broadcastLimits) {\n    inSizes.push(limitsShape[0]);\n  }\n  if (!broadcastDeltas) {\n    inSizes.push(deltasShape[0]);\n  }\n\n  for (let i = 1; i < inSizes.length; ++i) {\n    if (inSizes[i] !== inSizes[i - 1]) {\n      throw new Error('starts, limits, and deltas must have the same shape');\n    }\n  }\n  const nRows = inSizes.length === 0 ? 1 : inSizes[0];\n\n  // Construct the rtNestedSplits tensor.\n  const rtNestedSplits =\n      util.getArrayFromDType('int32', nRows + 1) as TypedArray;\n  rtNestedSplits[0] = 0;\n  for (let row = 0; row < nRows; ++row) {\n    const start = broadcastStarts ? starts[0] : starts[row];\n    const limit = broadcastLimits ? limits[0] : limits[row];\n    const delta = broadcastDeltas ? deltas[0] : deltas[row];\n    if (delta === 0) {\n      throw new Error('Requires delta != 0');\n    }\n    let size: number;  // The number of elements in the specified range.\n    if (((delta > 0) && (limit < start)) || ((delta < 0) && (limit > start))) {\n      size = 0;\n    } else {\n      size = Math.ceil(Math.abs((limit - start) / delta));\n\n      if (size > INT32_MAX) {\n        throw new Error(`Requires ((limit - start) / delta) <= ${INT32_MAX}`);\n      }\n    }\n    rtNestedSplits[row + 1] = rtNestedSplits[row] + size;\n  }\n\n  const nVals = rtNestedSplits[nRows];\n\n  // Construct the rtDenseValues tensor.\n  const rtDenseValues =\n      util.getArrayFromDType(startsDType, nVals) as TypedArray;\n\n  let valueIndex = 0;\n  for (let row = 0; row < nRows; ++row) {\n    const rowSize = rtNestedSplits[row + 1] - rtNestedSplits[row];\n    let value = broadcastStarts ? starts[0] : starts[row];\n    const delta = broadcastDeltas ? deltas[0] : deltas[row];\n    for (let i = 0; i < rowSize; ++i) {\n      rtDenseValues[valueIndex++] = value;\n      value += delta;\n    }\n  }\n\n  return [rtNestedSplits, rtDenseValues];\n}\n","/**\n * @license\n * Copyright 2022 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {backend_util, broadcastTo, DataType, reshape, tidy, TypedArray, util} from '@tensorflow/tfjs-core';\n\nimport RowPartitionType = backend_util.RowPartitionType;\n// Based on\n// https://github.com/tensorflow/tensorflow/blob/master/tensorflow/core/kernels/ragged_tensor_to_tensor_op.cc\nclass RaggedTensorToTensorOp {\n  private readonly rowPartitionTypes: RowPartitionType[];\n  private readonly raggedRank: number;\n  constructor(\n      private shape: TypedArray, private shapeShape: number[],\n      private values: TypedArray, private valuesShape: number[],\n      private valuesDType: DataType, private defaultValue: TypedArray,\n      private defaultValueShape: number[],\n      private readonly rowPartitionValues: TypedArray[],\n      private readonly rowPartitionValuesShapes: number[][],\n      rowPartitionTypeStrings: string[]) {\n    this.rowPartitionTypes =\n        backend_util.getRowPartitionTypesHelper(rowPartitionTypeStrings);\n    this.raggedRank = backend_util.getRaggedRank(this.rowPartitionTypes);\n  }\n\n  private getRowPartitionTypeByDimension(dimension: number) {\n    if (this.rowPartitionTypes[0] === RowPartitionType.FIRST_DIM_SIZE) {\n      return this.rowPartitionTypes[dimension + 1];\n    } else {\n      return this.rowPartitionTypes[dimension];\n    }\n  }\n\n  // Returns the relationship between dimension and dimension + 1.\n  private getRowPartitionTensor(dimension: number) {\n    if (this.rowPartitionTypes[0] === RowPartitionType.FIRST_DIM_SIZE) {\n      return this.rowPartitionValues[dimension + 1];\n    } else {\n      return this.rowPartitionValues[dimension];\n    }\n  }\n\n  private getMaxWidth(dimension: number) {\n    const rowPartitionTensor = this.getRowPartitionTensor(dimension - 1);\n    switch (this.getRowPartitionTypeByDimension(dimension - 1)) {\n      case RowPartitionType.VALUE_ROWIDS:\n        return RaggedTensorToTensorOp.getMaxWidthValueRowID(rowPartitionTensor);\n      case RowPartitionType.ROW_SPLITS:\n        return RaggedTensorToTensorOp.getMaxWidthRowSplit(rowPartitionTensor);\n      default:\n        throw new Error(`Cannot handle partition type ${\n            RowPartitionType[this.getRowPartitionTypeByDimension(\n                dimension - 1)]}`);\n    }\n  }\n\n  static getMaxWidthRowSplit(rowSplit: TypedArray) {\n    const tensorLength = rowSplit.length;\n    if (tensorLength === 0 || tensorLength === 1) {\n      return 0;\n    }\n    let maxWidth = 0;\n    for (let i = 0; i < tensorLength - 1; ++i) {\n      const currentWidth = rowSplit[i + 1] - rowSplit[i];\n      if (currentWidth > maxWidth) {\n        maxWidth = currentWidth;\n      }\n    }\n    return maxWidth;\n  }\n\n  static getMaxWidthValueRowID(valueRowIds: TypedArray) {\n    const indexLength = valueRowIds.length;\n    if (indexLength === 0) {\n      return 0;\n    }\n    let firstEqualIndex = 0;\n    let firstEqualIndexValue = valueRowIds[0];\n    let maxWidth = 0;\n    for (let i = 1; i < indexLength; ++i) {\n      const value = valueRowIds[i];\n      if (value !== firstEqualIndexValue) {\n        firstEqualIndexValue = value;\n        maxWidth = Math.max(i - firstEqualIndex, maxWidth);\n        firstEqualIndex = i;\n      }\n    }\n    return Math.max(indexLength - firstEqualIndex, maxWidth);\n  }\n\n  private tensorShapeFromTensor(\n      t: TypedArray, tShape: number[], isPartial = true) {\n    if (tShape.length === 0) {\n      if (t[0] === -1) {\n        return [];\n      }\n      throw new Error(\n          `The only valid scalar shape tensor is the fully unknown shape specified as -1.`);\n    }\n    // MakePartialShape/MakeShapeHelper.\n    return makeShape(t, isPartial);\n  }\n\n  private calculateOutputSize(firstDim: number) {\n    const valueShape = this.valuesShape;\n    const defaultValueShape = this.defaultValueShape;\n\n    backend_util.validateDefaultValueShape(defaultValueShape, valueShape);\n\n    const shape = this.tensorShapeFromTensor(this.shape, this.shapeShape);\n    const outputShape = backend_util.combineRaggedTensorToTensorShapes(\n        this.raggedRank, shape, valueShape);\n\n    const result = outputShape;\n\n    if (result[0] < 0) {\n      result[0] = firstDim;\n    }\n    for (let i = 1; i <= this.raggedRank; ++i) {\n      if (result[i] < 0) {\n        result[i] = this.getMaxWidth(i);\n      }\n    }\n\n    return result;\n  }\n\n  /**\n   * The outputIndex represents the index in the output tensor\n   * where the first element of a particular dimension would be written.\n   * If it is -1, it indicates that the index is out of scope.\n   * Example, given firstDimension = 10, firstDimensionOutput = 6,\n   * and outputIndexMultiplier = 100:\n   * result = [0 100 200 300 400 500 -1 -1 -1 -1]\n   * If firstDimensionOutput = 11 instead, then:\n   * result = [0 100 200 300 400 500 600 700 800 900]\n   */\n  private calculateFirstParentOutputIndex(\n      firstDimension: number, outputIndexMultiplier: number,\n      firstDimensionOutput: number) {\n    const minDimension = Math.min(firstDimension, firstDimensionOutput);\n    const result: number[] = [];\n    let currentOutputIndex = 0;\n    for (let i = 0; i < minDimension;\n         ++i, currentOutputIndex += outputIndexMultiplier) {\n      result.push(currentOutputIndex);\n    }\n    for (let i = minDimension; i < firstDimension; ++i) {\n      result.push(-1);\n    }\n    util.assert(\n        result.length === firstDimension,\n        () => 'Final length of result must be equal to firstDimension.');\n\n    return result;\n  }\n\n  private calculateOutputIndexRowSplit(\n      rowSplit: TypedArray, parentOutputIndex: number[],\n      outputIndexMultiplier: number, outputSize: number) {\n    const rowSplitSize = rowSplit.length;\n    const result: number[] = [];\n    for (let i = 0; i < rowSplitSize - 1; ++i) {\n      const rowLength = rowSplit[i + 1] - rowSplit[i];\n      let realLength = Math.min(outputSize, rowLength);\n      let parentOutputIndexCurrent = parentOutputIndex[i];\n\n      if (parentOutputIndexCurrent === -1) {\n        realLength = 0;\n      }\n      for (let j = 0; j < realLength; ++j) {\n        result.push(parentOutputIndexCurrent);\n        parentOutputIndexCurrent += outputIndexMultiplier;\n      }\n      for (let j = 0; j < rowLength - realLength; ++j) {\n        result.push(-1);\n      }\n    }\n    if (rowSplitSize > 0 && result.length !== rowSplit[rowSplitSize - 1]) {\n      throw new Error('Invalid row split size.');\n    }\n\n    return result;\n  }\n\n  // Calculate the output index of the first element of a list.\n  // The parentOutputIndex is the same computation for the previous list.\n  // -1 indicates an element or list that is out of range.\n  // The outputIndexMultiplier is the number of output indices one moves\n  // forward for each column.\n  // E.g., given:\n  // valueRowIds:[0 1 2 2 2 3 5 5 6]\n  // parentOutputIndex:[1000 1100 2000 2100 -1 3000 4000]\n  // outputIndexMultiplier: 10\n  // outputSize: 2\n  // You get:\n  // result = [1000 1100 2000 2010 -1 2100 -1 -1 3000]\n  // result[0] = parentOutputIndex[valueRowIds[0]]\n  // result[1] = parentOutputIndex[valueRowIds[1]]\n  // result[2] = parentOutputIndex[valueRowIds[2]]\n  // result[3] = parentOutputIndex[valueRowIds[2] + 10]\n  // result[4] = -1 because it is the third element the size is 2.\n  // result[5] = parentOutputIndex[valueRowIds[3]]\n  // result[6] = -1 because parentOutputIndex[valueRowIds[6]] == -1\n  // result[7] = -1 because parentOutputIndex[valueRowIds[6]] == -1\n  // result[8] = parentOutputIndex[valueRowIds[7]]\n  private calculateOutputIndexValueRowID(\n      valueRowIds: TypedArray, parentOutputIndex: number[],\n      outputIndexMultiplier: number, outputSize: number) {\n    const indexSize = valueRowIds.length;\n    const result: number[] = [];\n    if (indexSize === 0) {\n      return [];\n    }\n\n    let currentOutputColumn = 0;\n    let currentValueRowId = valueRowIds[0];\n\n    if (currentValueRowId >= parentOutputIndex.length) {\n      throw new Error(\n          `Got currentValueRowId=${currentValueRowId}, which is not less than ${\n              parentOutputIndex.length}`);\n    }\n\n    let currentOutputIndex = parentOutputIndex[currentValueRowId];\n    result.push(currentOutputIndex);\n    for (let i = 1; i < indexSize; ++i) {\n      const nextValueRowId = valueRowIds[i];\n      if (nextValueRowId === currentValueRowId) {\n        if (currentOutputIndex >= 0) {\n          ++currentOutputColumn;\n          if (currentOutputColumn < outputSize) {\n            currentOutputIndex += outputIndexMultiplier;\n          } else {\n            currentOutputIndex = -1;\n          }\n        }\n      } else {\n        currentOutputColumn = 0;\n        currentValueRowId = nextValueRowId;\n\n        if (nextValueRowId >= parentOutputIndex.length) {\n          throw new Error(\n              `Got nextValueRowId=${nextValueRowId} which is not less than ${\n                  parentOutputIndex.length}`);\n        }\n\n        currentOutputIndex = parentOutputIndex[nextValueRowId];\n      }\n      result.push(currentOutputIndex);\n    }\n\n    if (result.length !== valueRowIds.length) {\n      throw new Error('Invalid row ids.');\n    }\n\n    return result;\n  }\n\n  private calculateOutputIndex(\n      dimension: number, parentOutputIndex: number[],\n      outputIndexMultiplier: number, outputSize: number) {\n    const rowPartitionTensor = this.getRowPartitionTensor(dimension);\n    const partitionType = this.getRowPartitionTypeByDimension(dimension);\n    switch (partitionType) {\n      case RowPartitionType.VALUE_ROWIDS:\n        return this.calculateOutputIndexValueRowID(\n            rowPartitionTensor, parentOutputIndex, outputIndexMultiplier,\n            outputSize);\n      case RowPartitionType.ROW_SPLITS:\n        if (rowPartitionTensor.length - 1 > parentOutputIndex.length) {\n          throw new Error(`Row partition size is greater than output size: ${\n              rowPartitionTensor.length - 1} > ${parentOutputIndex.length}`);\n        }\n        return this.calculateOutputIndexRowSplit(\n            rowPartitionTensor, parentOutputIndex, outputIndexMultiplier,\n            outputSize);\n      default:\n        throw new Error(\n            `Unsupported partition type: ${RowPartitionType[partitionType]}`);\n    }\n  }\n\n  private getFirstDimensionSize() {\n    const firstPartitionTensor = this.rowPartitionValues[0];\n    if (this.rowPartitionTypes.length === 0) {\n      throw new Error('No row_partition_types given.');\n    }\n    const firstPartitionType = this.rowPartitionTypes[0];\n    switch (firstPartitionType) {\n      case RowPartitionType.FIRST_DIM_SIZE:\n        return firstPartitionTensor[0];\n      case RowPartitionType.VALUE_ROWIDS:\n        throw new Error('Cannot handle VALUE_ROWIDS in first dimension.');\n      case RowPartitionType.ROW_SPLITS:\n        return this.rowPartitionValuesShapes[0][0] - 1;\n      default:\n        throw new Error(\n            `Cannot handle type ${RowPartitionType[firstPartitionType]}`);\n    }\n  }\n\n  compute(): [number[], TypedArray] {\n    const firstPartitionTensor = this.rowPartitionValues[0];\n    if (firstPartitionTensor.length <= 0) {\n      throw new Error(\n          'Invalid first partition input. ' +\n          'Tensor requires at least one element.');\n    }\n    const firstDimension = this.getFirstDimensionSize();\n    const outputSize = this.calculateOutputSize(firstDimension);\n    const multiplier: number[] = new Array(this.raggedRank + 1);\n\n    multiplier[multiplier.length - 1] = 1;\n    for (let i = multiplier.length - 2; i >= 0; --i) {\n      multiplier[i] = multiplier[i + 1] * outputSize[i + 1];\n    }\n    // Full size of the tensor.\n    const outputShape: number[] = makeShape(outputSize, false);\n    const outputTensor =\n        util.getArrayFromDType(\n            this.valuesDType, util.sizeFromShape(outputShape)) as TypedArray;\n\n    const fullSize = multiplier[0] * outputSize[0];\n    if (fullSize > 0) {\n      let outputIndex = this.calculateFirstParentOutputIndex(\n          firstDimension, multiplier[0], outputSize[0]);\n      for (let i = 1; i <= this.raggedRank; ++i) {\n        const newOutputIndex = this.calculateOutputIndex(\n            i - 1, outputIndex, multiplier[i], outputSize[i]);\n        outputIndex = newOutputIndex;\n      }\n\n      this.setOutput(this.raggedRank, outputIndex, outputTensor, outputShape);\n    }\n\n    return [outputShape, outputTensor];\n  }\n  setOutput(\n      raggedRank: number, outputIndex: number[], outputTensor: TypedArray,\n      outputShape: number[]) {\n    if (outputTensor.length === 0) {\n      return;\n    }\n\n    const valuesBase = this.values;\n    const outputBase = outputTensor;\n\n    let elementShape = outputShape.slice();\n    elementShape = elementShape.slice(raggedRank + 1);\n    const valueElementSize = util.sizeFromShape(elementShape);\n    const outputIndexSize = outputIndex.length;\n\n    // Broadcast the default value to value_element_size.  (We can skip this\n    // if defaultValueTensor.size == 1, since we use fill when that's true.)\n    let defaultValue = this.defaultValue;\n    if (defaultValue.length !== valueElementSize && defaultValue.length !== 1) {\n      const srcShape = this.defaultValueShape;\n      tidy(() => {\n        const defaultValueTensor = reshape(defaultValue, srcShape);\n        const bCastDefault = broadcastTo(defaultValueTensor, elementShape);\n        defaultValue = bCastDefault.dataSync();\n      });\n    }\n\n    // Loop through the outputIndex array, finding contiguous regions that\n    // should be copied.  Once we find the end of a contiguous region, copy it\n    // and add any necessary padding (with defaultValue).\n    let srcStart = 0;  // Start of contiguous region (in values)\n    let dstStart = 0;  // Destination for contiguous region (in output)\n    let dstEnd = 0;    // Destination for contiguous region (in output)\n    for (let srcI = 0; srcI <= outputIndexSize; ++srcI) {\n      // dstI is the destination where the value at srcI should be copied.\n      let dstI = srcI < outputIndexSize ? outputIndex[srcI] : -1;\n\n      // If we're still in a contiguous region, then update dstEnd go to the\n      // next srcI.\n      if (dstI === dstEnd) {\n        ++dstEnd;\n        continue;\n      }\n\n      // We found the end of contiguous region.  This can be because we found\n      // a gap (dstI > dstEnd), or a source value that shouldn't be copied\n      // because it's out-of-bounds (dstI == -1), or the end of the tensor\n      // (dstI === -1).\n      if (dstStart < dstEnd) {\n        // Copy the contiguous region.\n        const src = valuesBase.subarray(srcStart * valueElementSize);\n        const dst = outputBase.subarray(dstStart * valueElementSize);\n        const nVals = (dstEnd - dstStart) * valueElementSize;\n        copyArray(dst, src, nVals);\n      }\n\n      // Add any necessary padding (w/ defaultValue).\n      if (srcI >= outputIndexSize) {\n        // We reached the end of values: pad to the end of output.\n        const outputSize = outputTensor.length;\n        dstI = Math.floor(outputSize / valueElementSize);\n      }\n      if (dstI > dstEnd) {\n        if (this.defaultValue.length === 1) {\n          outputBase\n              .subarray(dstEnd * valueElementSize, dstI * valueElementSize)\n              .fill(this.defaultValue[0]);\n          dstEnd = dstI;\n        } else {\n          while (dstI > dstEnd) {\n            const dst = outputBase.slice(dstEnd * valueElementSize);\n            copyArray(dst, defaultValue, valueElementSize);\n            ++dstEnd;\n          }\n        }\n      }\n\n      // Update indices.\n      if (dstI < 0) {\n        // srcI should be skipped -- leave it out of the contiguous region.\n        srcStart = srcI + 1;\n        dstStart = dstEnd;\n      } else {\n        // srcI should be copied -- include it in the contiguous region.\n        srcStart = srcI;\n        dstStart = dstEnd;\n        dstEnd = dstStart + 1;\n      }\n    }\n  }\n}\n\nfunction copyArray(dst: TypedArray, src: TypedArray, size: number) {\n  for (let i = 0; i < size; i++) {\n    dst[i] = src[i];\n  }\n}\n\nfunction makeShape(shape: number[]|TypedArray, isPartial: boolean) {\n  const out: number[] = [];\n  for (let dim of shape) {\n    if (dim < 0) {\n      if (!isPartial) {\n        throw new Error(`Dimension ${dim} must be >= 0`);\n      }\n      if (dim < -1) {\n        throw new Error(`Dimension ${dim} must be >= -1`);\n      }\n      dim = -1;\n    }\n    out.push(dim);\n  }\n\n  return out;\n}\n\nexport function raggedTensorToTensorImpl(\n    shape: TypedArray, shapesShape: number[], values: TypedArray,\n    valuesShape: number[], valuesDType: DataType, defaultValue: TypedArray,\n    defaultValueShape: number[], rowPartitionValues: TypedArray[],\n    rowPartitionValuesShapes: number[][],\n    rowPartitionTypes: string[]): [number[], TypedArray] {\n  return new RaggedTensorToTensorOp(\n             shape, shapesShape, values, valuesShape, valuesDType, defaultValue,\n             defaultValueShape, rowPartitionValues, rowPartitionValuesShapes,\n             rowPartitionTypes)\n      .compute();\n}\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {DataTypeMap, util} from '@tensorflow/tfjs-core';\n\nexport function rangeImpl(\n    start: number, stop: number, step: number,\n    dtype: 'float32'|'int32'): DataTypeMap['float32' | 'int32'] {\n  const sameStartStop = start === stop;\n  const increasingRangeNegativeStep = start < stop && step < 0;\n  const decreasingRangePositiveStep = stop < start && step > 1;\n\n  if (sameStartStop || increasingRangeNegativeStep ||\n      decreasingRangePositiveStep) {\n    return util.makeZerosTypedArray(0, dtype);\n  }\n\n  const numElements = Math.abs(Math.ceil((stop - start) / step));\n  const values = util.makeZerosTypedArray(numElements, dtype);\n\n  if (stop < start && step === 1) {\n    // Auto adjust the step's sign if it hasn't been set\n    // (or was set to 1)\n    step = -1;\n  }\n\n  values[0] = start;\n  for (let i = 1; i < values.length; i++) {\n    values[i] = values[i - 1] + step;\n  }\n  return values;\n}\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the License);\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an AS IS BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {KernelConfig, Rsqrt} from '@tensorflow/tfjs-core';\n\nimport {createSimpleUnaryImpl} from '../utils/unary_impl';\nimport {unaryKernelFuncFromImpl} from '../utils/unary_utils';\n\nexport const rsqrtImpl = createSimpleUnaryImpl((xi) => 1 / Math.sqrt(xi));\nexport const rsqrt = unaryKernelFuncFromImpl(Rsqrt, rsqrtImpl);\n\nexport const rsqrtConfig: KernelConfig = {\n  kernelName: Rsqrt,\n  backendName: 'cpu',\n  kernelFunc: rsqrt,\n};\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport {buffer, Rank, ShapeMap, TensorBuffer, TypedArray} from '@tensorflow/tfjs-core';\n\ninterface DefaultValueTypeMap {\n  bool: boolean;\n  int32: number;\n  float32: number;\n  string: string;\n}\n\nexport function\nscatterImpl<R extends Rank, D extends 'float32'|'int32'|'bool'|'string'>(\n    indices: TensorBuffer<R, 'int32'>, updates: TensorBuffer<R, D>,\n    shape: number[], outputSize: number, sliceSize: number, numUpdates: number,\n    sliceRank: number, strides: number[], defaultValue: DefaultValueTypeMap[D],\n    sumDupeIndices: boolean): TensorBuffer<R, D> {\n  const flattenShape = [outputSize / sliceSize, sliceSize];\n\n  const indicesData = indices.values as TypedArray;\n  const updatesData = updates.values;\n\n  if (outputSize === 0) {\n    return buffer(shape as ShapeMap[R], updates.dtype);\n  }\n\n  const outBuf = buffer(flattenShape, updates.dtype);\n  if (typeof defaultValue === 'string') {\n    (outBuf.values as string[]).fill(defaultValue);\n  } else if (typeof defaultValue === 'number') {\n    (outBuf.values as TypedArray).fill(defaultValue);\n  } else if (typeof defaultValue === 'boolean') {\n    (outBuf.values as TypedArray).fill(+defaultValue);\n  }\n\n  for (let i = 0; i < numUpdates; i++) {\n    const index = [];\n    let flattenIndex = 0;\n    for (let j = 0; j < sliceRank; j++) {\n      const dim = indicesData[i * sliceRank + j];\n      index.push(dim);\n      flattenIndex += dim * strides[j];\n    }\n\n    if (flattenIndex < 0 || flattenIndex >= outputSize / sliceSize) {\n      throw new Error(`Invalid indices: ${index} does not index into ${shape}`);\n    }\n\n    for (let k = 0; k < sliceSize; k++) {\n      if (sumDupeIndices) {\n        (outBuf.values as TypedArray)[flattenIndex * sliceSize + k] +=\n            (updatesData as TypedArray)[i * sliceSize + k];\n      } else {\n        outBuf.values[flattenIndex * sliceSize + k] = updates.rank === 0 ?\n            updatesData[0] :\n            updatesData[i * sliceSize + k];\n      }\n    }\n  }\n\n  return outBuf as TensorBuffer<R, D>;\n}\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the License);\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an AS IS BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {KernelConfig, Sigmoid} from '@tensorflow/tfjs-core';\n\nimport {createSimpleUnaryImpl} from '../utils/unary_impl';\nimport {unaryKernelFunc} from '../utils/unary_utils';\n\nexport const sigmoidImpl =\n    createSimpleUnaryImpl((xi) => 1 / (1 + Math.exp(-xi)));\nexport const sigmoid =\n    unaryKernelFunc(Sigmoid, (xi) => 1 / (1 + Math.exp(-xi)));\n\nexport const sigmoidConfig: KernelConfig = {\n  kernelName: Sigmoid,\n  backendName: 'cpu',\n  kernelFunc: sigmoid,\n};\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {backend_util, BackendValues, buffer, DataType, KernelConfig, KernelFunc, Slice, slice_util, SliceAttrs, SliceInputs, TensorInfo, TypedArray, util} from '@tensorflow/tfjs-core';\n\nimport {MathBackendCPU} from '../backend_cpu';\nimport {assertNotComplex} from '../cpu_util';\n\nexport function sliceImpl(\n    vals: BackendValues, begin: number[], size: number[], shape: number[],\n    dtype: DataType): BackendValues {\n  const isContinous = slice_util.isSliceContinous(shape, begin, size);\n  const length = util.sizeFromShape(size);\n  const xStrides = util.computeStrides(shape);\n\n  if (isContinous) {\n    const flatOffset = slice_util.computeFlatOffset(begin, xStrides);\n\n    if (dtype === 'string') {\n      return (vals as Uint8Array[]).slice(flatOffset, flatOffset + length);\n    }\n\n    return (vals as TypedArray).subarray(flatOffset, flatOffset + length);\n  }\n\n  const decodedData = dtype === 'string' ?\n      backend_util.fromUint8ToStringArray(vals as Uint8Array[]) :\n      vals as TypedArray;\n\n  const inBuf = buffer(shape, dtype, decodedData);\n  const outBuf = buffer(size, dtype);\n  for (let i = 0; i < outBuf.size; ++i) {\n    const outLoc = outBuf.indexToLoc(i);\n    const inLoc = outLoc.map((idx: number, j) => idx + begin[j]);\n    outBuf.set(inBuf.get(...inLoc), ...outLoc);\n  }\n\n  if (dtype === 'string') {\n    return backend_util.fromStringArrayToUint8(outBuf.values as string[]);\n  }\n  return outBuf.values as TypedArray;\n}\n\nexport function slice(\n    args: {inputs: SliceInputs, backend: MathBackendCPU, attrs: SliceAttrs}):\n    TensorInfo {\n  const {inputs, backend, attrs} = args;\n  const {x} = inputs;\n  const {begin, size} = attrs;\n\n  assertNotComplex(x, 'slice');\n\n  const [$begin, $size] = slice_util.parseSliceParams(x, begin, size);\n  slice_util.assertParamsValid(x, $begin, $size);\n\n  const vals = backend.data.get(x.dataId).values;\n  const outVals = sliceImpl(vals, $begin, $size, x.shape, x.dtype);\n  return backend.makeTensorInfo($size, x.dtype, outVals);\n}\n\nexport const sliceConfig: KernelConfig = {\n  kernelName: Slice,\n  backendName: 'cpu',\n  kernelFunc: slice as {} as KernelFunc\n};\n","/**\n * @license\n * Copyright 2021 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {backend_util, DataType, TypedArray, util} from '@tensorflow/tfjs-core';\n\nexport function sparseFillEmptyRowsImpl(\n    indices: TypedArray, indicesShape: number[], indicesDType: DataType,\n    values: TypedArray, valuesDType: DataType, denseShape: TypedArray,\n    defaultValue: number):\n    [TypedArray, number[], TypedArray, boolean[], number[]] {\n  const indicesCount = indicesShape[0];\n  const denseRows = denseShape[0];\n\n  const emptyRowIndicator: boolean[] = new Array(denseRows);\n  const reverseIndexMap: number[] = new Array(indicesCount);\n\n  const rank = indicesShape[1];\n\n  if (denseRows === 0) {\n    if (indicesCount !== 0) {\n      throw new Error(\n          backend_util.getSparseFillEmptyRowsIndicesDenseShapeMismatch(\n              indicesCount));\n    }\n    const outputIndices = util.getArrayFromDType(indicesDType, 0) as TypedArray;\n    const outputValues = util.getArrayFromDType(valuesDType, 0) as TypedArray;\n    return [\n      outputIndices, [0, rank], outputValues, emptyRowIndicator, reverseIndexMap\n    ];\n  }\n\n  let rowsAreOrdered = true;\n  let lastIndicesRow = 0;\n  const csrOffset: number[] = new Array(denseRows).fill(0);\n\n  for (let i = 0; i < indicesCount; ++i) {\n    // indices is a 2d tensor with shape of [N, rank]\n    const row = indices[i * rank];\n    if (row < 0) {\n      throw new Error(\n          backend_util.getSparseFillEmptyRowsNegativeIndexErrorMessage(i, row));\n    }\n    if (row >= denseRows) {\n      throw new Error(\n          backend_util.getSparseFillEmptyRowsOutOfRangeIndexErrorMessage(\n              i, row, denseRows));\n    }\n    ++csrOffset[row];\n    rowsAreOrdered = rowsAreOrdered && (row >= lastIndicesRow);\n    lastIndicesRow = row;\n  }\n\n  let allRowsFull = true;\n  for (let row = 0; row < denseRows; ++row) {\n    // csrOffset here describes the number of elements in this dense row\n    const rowEmpty = (csrOffset[row] === 0);\n    emptyRowIndicator[row] = rowEmpty;\n    allRowsFull = allRowsFull && !rowEmpty;\n    // In filled version, each row has at least one element.\n    csrOffset[row] = Math.max(csrOffset[row], 1);\n    // Update csrOffset to represent the number of elements up to and\n    // including denseRows + 1:\n    //  csrOffset[0] == #{elements of row 0}\n    //  csrOffset[1] == #{elements of row 1} + #{elements of row 0}\n    //  ..\n    //  csrOffset[i] == starting index for elements in row i + 1.\n    if (row > 0) {\n      csrOffset[row] += csrOffset[row - 1];\n    }\n  }\n\n  if (allRowsFull && rowsAreOrdered) {\n    const outputIndices: TypedArray = indices;\n    const outputValues: TypedArray = values;\n    for (let i = 0; i < indicesCount; ++i) {\n      reverseIndexMap[i] = i;\n    }\n    return [\n      outputIndices, [indicesCount, rank], outputValues, emptyRowIndicator,\n      reverseIndexMap\n    ];\n  } else {\n    const fullIndicesCount = csrOffset[denseRows - 1];\n    const outputIndices =\n        util.getArrayFromDType(indicesDType, fullIndicesCount * rank) as\n        TypedArray;\n    const outputValues =\n        util.getArrayFromDType(valuesDType, fullIndicesCount) as TypedArray;\n    const filledCount: number[] = new Array(denseRows).fill(0);\n\n    // Fill in values for rows that are not missing\n    for (let i = 0; i < indicesCount; ++i) {\n      // indices is a 2d tensor with shape of [N, rank]\n      const row = indices[i * rank];\n      const offset = filledCount[row];\n      const outputI = ((row === 0) ? 0 : csrOffset[row - 1]) + offset;\n      filledCount[row]++;  // Increment the filled count for this row.\n      for (let j = 0; j < rank; ++j) {\n        // indices and outputIndices are 2d tensors with shape of [N, rank]\n        outputIndices[outputI * rank + j] = indices[i * rank + j];\n      }\n      outputValues[outputI] = values[i];\n      // We'll need this reverse index map to backprop correctly.\n      reverseIndexMap[i] = outputI;\n    }\n\n    // Fill in values for rows that are missing\n    for (let row = 0; row < denseRows; ++row) {\n      const rowCount = filledCount[row];\n      if (rowCount === 0) {  // We haven't filled this row\n        const startingIndex = (row === 0) ? 0 : csrOffset[row - 1];\n        // Remaining index values were set to zero already.\n        // Just need to set the row index in the right location.\n        // outputIndices is a 2d tensor with shape of [N, rank]\n        outputIndices[startingIndex * rank + 0] = row;\n        for (let col = 1; col < rank; ++col) {\n          outputIndices[startingIndex * rank + col] = 0;\n        }\n        outputValues[startingIndex] = defaultValue;\n      }\n    }\n    return [\n      outputIndices, [fullIndicesCount, rank], outputValues, emptyRowIndicator,\n      reverseIndexMap\n    ];\n  }\n}\n","/**\n * @license\n * Copyright 2021 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {backend_util, DataType, TypedArray, util} from '@tensorflow/tfjs-core';\n\nexport function sparseReshapeImpl(\n    inputIndices: TypedArray, inputIndicesShape: number[], inputDType: DataType,\n    inputShape: number[],\n    targetShape: number[]): [TypedArray, number[], number[]] {\n  const denseSize = util.sizeFromShape(inputShape);\n  const nnz = inputIndicesShape[0];\n  const outputRank = targetShape.length;\n\n  // Compute the output shape. Determine product of specified dimensions, and\n  // find the index of the unspecified one.\n  const outputShape: number[] = [];\n  let product = 1;\n  let unknownIndex = -1;\n  for (let d = 0; d < outputRank; ++d) {\n    const size = targetShape[d];\n    if (size === -1) {\n      if (unknownIndex !== -1) {\n        throw new Error(\n            backend_util\n                .getSparseReshapeMultipleNegativeOneOutputDimErrorMessage(\n                    unknownIndex, d));\n      }\n      unknownIndex = d;\n      outputShape.push(1);\n    } else {\n      if (size < 0) {\n        throw new Error(\n            backend_util.getSparseReshapeNegativeOutputDimErrorMessage(\n                d, size));\n      }\n      product *= size;\n      outputShape.push(size);\n    }\n  }\n  if (unknownIndex !== -1) {\n    if (product <= 0) {\n      throw new Error(\n          backend_util.getSparseReshapeEmptyTensorZeroOutputDimErrorMessage());\n    }\n    const missing = Math.trunc(denseSize / product);\n    if (product * missing !== denseSize) {\n      throw new Error(\n          backend_util.getSparseReshapeInputOutputMultipleErrorMessage(\n              inputShape, outputShape));\n    }\n\n    outputShape[unknownIndex] = missing;\n  }\n  const outputSize = util.sizeFromShape(outputShape);\n  if (outputSize !== denseSize) {\n    throw new Error(\n        backend_util.getSparseReshapeInputOutputMismatchErrorMessage(\n            inputShape, outputShape));\n  }\n\n  const inputRank = inputShape.length;\n  const inputStrides: number[] = [];\n  if (inputRank > 0) {\n    inputStrides[inputRank - 1] = 1;\n    for (let d = inputRank - 2; d >= 0; --d) {\n      inputStrides[d] = inputStrides[d + 1] * inputShape[d + 1];\n    }\n  }\n\n  const outputStrides: number[] = [];\n  if (outputRank > 0) {\n    outputStrides[outputRank - 1] = 1;\n    for (let d = outputRank - 2; d >= 0; --d) {\n      outputStrides[d] = outputStrides[d + 1] * outputShape[d + 1];\n    }\n  }\n\n  const newIndices =\n      util.getArrayFromDType(inputDType, nnz * outputRank) as TypedArray;\n  for (let i = 0; i < nnz; ++i) {\n    let id = 0;\n    for (let j = 0; j < inputRank; ++j) {\n      // inputIndices is a 2d tensor with shape of [nnz, inputRank]\n      id += inputIndices[i * inputRank + j] * inputStrides[j];\n    }\n    for (let j = 0; j < outputRank; ++j) {\n      // newIndices is a 2d tensor with shape of [nnz, outputRank]\n      newIndices[i * outputRank + j] = Math.trunc(id / outputStrides[j]);\n      id %= outputStrides[j];\n    }\n  }\n  return [newIndices, [nnz, outputRank], outputShape];\n}\n","/**\n * @license\n * Copyright 2021 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {backend_util, DataType, TypedArray, util} from '@tensorflow/tfjs-core';\n\nexport function sparseSegmentReductionImpl(\n    input: TypedArray, inputShape: number[], inputDType: DataType,\n    indices: TypedArray, segmentIds: TypedArray, isMean = false,\n    defaultValue = 0): [TypedArray, number[]] {\n  const numIndices = indices.length;\n\n  // Flatten the array to two dimensions\n  const inputFlat: number[] = [inputShape[0], input.length / inputShape[0]];\n  const numCol = inputFlat[1];\n  // Note that the current implementation assumes that segmentIds values are\n  // sorted.\n  const lastSegmentIdPlusOne =\n      numIndices > 0 ? segmentIds[numIndices - 1] + 1 : 0;\n  const outputRows = lastSegmentIdPlusOne;\n\n  if (outputRows < 0) {\n    throw new Error(\n        backend_util.getSparseSegmentReductionNegativeSegmentIdsErrorMessage());\n  }\n\n  const outputShape = inputShape.slice();\n  outputShape[0] = outputRows;\n\n  const outputLength =\n      outputShape.reduce((product, value) => product * value, 1);\n  // Output array is initialized with the value 0 by default.\n  const output = util.getArrayFromDType(inputDType, outputLength) as TypedArray;\n\n  // Note that we do not initialize the output buffer with a default value, so\n  // we need to explicitly set missing indices to the default value.\n  if (numIndices === 0) {\n    if (outputRows > 0) {\n      output.fill(defaultValue);\n    }\n    return [output, outputShape];\n  }\n\n  if (outputRows <= 0) {\n    throw new Error(\n        backend_util.getSparseSegmentReductionNegativeSegmentIdsErrorMessage());\n  }\n\n  let start = 0, end = 1;\n  // Index from which the output is not initialized.\n  let uninitializedIndex = 0;\n  let outIndex = segmentIds[start];\n\n  while (true) {\n    // We initialize nextIndex to 0 to avoid may be uninitialized warning\n    let nextIndex = 0;\n    if (end < numIndices) {\n      nextIndex = segmentIds[end];\n      if (outIndex === nextIndex) {\n        ++end;\n        continue;\n      }\n      // We have a new segment here.  Verify that the segment ids are growing.\n      if (outIndex >= nextIndex) {\n        throw new Error(backend_util\n            .getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage());\n      }\n    }\n\n    if (outIndex < 0 || outIndex >= outputRows) {\n      throw new Error(\n          backend_util.getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage(\n              outIndex, outputRows));\n    }\n\n    // If there is a gap between two indices, we need to set that gap to the\n    // default value.\n    if (outIndex > uninitializedIndex) {\n      output.fill(defaultValue, uninitializedIndex * numCol, outIndex * numCol);\n    }\n\n    for (let i = start; i < end; ++i) {\n      const index = indices[i];\n      if (index < 0 || index >= inputFlat[0]) {\n        throw new Error(\n            backend_util.getSparseSegmentReductionIndicesOutOfRangeErrorMessage(\n                i, indices[i], inputFlat[0]));\n      }\n      for (let j = 0; j < numCol; j++) {\n        output[outIndex * numCol + j] += input[index * numCol + j];\n      }\n    }\n\n    if (isMean) {\n      for (let j = 0; j < numCol; j++) {\n        output[outIndex * numCol + j] /= end - start;\n      }\n    }\n\n    start = end;\n    ++end;\n    uninitializedIndex = outIndex + 1;\n    outIndex = nextIndex;\n    if (end > numIndices) {\n      break;\n    }\n  }\n\n  // Fill the gap at the end with the default value.\n  if (uninitializedIndex < outputRows) {\n    output.fill(defaultValue, uninitializedIndex * numCol, outputRows * numCol);\n  }\n\n  return [output, outputShape];\n}\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the License);\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an AS IS BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {KernelConfig, Sqrt} from '@tensorflow/tfjs-core';\n\nimport {createSimpleUnaryImpl} from '../utils/unary_impl';\nimport {unaryKernelFunc} from '../utils/unary_utils';\n\nexport const sqrtImpl = createSimpleUnaryImpl((xi) => Math.sqrt(xi));\nexport const sqrt = unaryKernelFunc(Sqrt, (xi) => Math.sqrt(xi));\n\nexport const sqrtConfig: KernelConfig = {\n  kernelName: Sqrt,\n  backendName: 'cpu',\n  kernelFunc: sqrt,\n};\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {KernelConfig, SquaredDifference} from '@tensorflow/tfjs-core';\n\nimport {createSimpleBinaryKernelImpl} from '../utils/binary_impl';\nimport {binaryKernelFunc} from '../utils/binary_utils';\n\nexport const squaredDifferenceImpl =\n    createSimpleBinaryKernelImpl(((a: number, b: number) => {\n      const diff = a - b;\n      return diff * diff;\n    }));\nexport const squaredDifference =\n    binaryKernelFunc(SquaredDifference, squaredDifferenceImpl);\n\nexport const squaredDifferenceConfig: KernelConfig = {\n  kernelName: SquaredDifference,\n  backendName: 'cpu',\n  kernelFunc: squaredDifference\n};\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {buffer, Rank, TensorBuffer} from '@tensorflow/tfjs-core';\n\nexport function stridedSliceImpl<R extends Rank>(\n    outShape: number[], xBuf: TensorBuffer<R>, strides: number[],\n    begin: number[]): TensorBuffer<R> {\n  const outBuf = buffer(outShape, xBuf.dtype);\n\n  for (let i = 0; i < outBuf.size; i++) {\n    const loc = outBuf.indexToLoc(i);\n\n    const newLoc: number[] = new Array(loc.length);\n    for (let j = 0; j < newLoc.length; j++) {\n      newLoc[j] = loc[j] * strides[j] + begin[j];\n    }\n    outBuf.set(xBuf.get(...newLoc), ...loc);\n  }\n\n  return outBuf as TensorBuffer<R>;\n}\n","/**\n * @license\n * Copyright 2021 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {util} from '@tensorflow/tfjs-core';\n\n/**\n * The StringNGramsOp class creates ngrams from ragged string data.\n * The constructor contains all attributes related to the operation such as\n * padding widths and strings, and the compute function can be used to\n * compute the ngrams for different ragged tensor inputs.\n */\nclass StringNGramsOp {\n  private separator: Uint8Array;\n  private nGramWidths: number[];\n  private padWidth: number;\n  private leftPad: Uint8Array;\n  private rightPad: Uint8Array;\n  private preserveShort: boolean;\n\n  constructor(\n      separator: string, nGramWidths: number[], leftPad: string,\n      rightPad: string, padWidth: number, preserveShortSequences: boolean) {\n    this.separator = util.encodeString(separator);\n    this.nGramWidths = nGramWidths;\n    this.leftPad = util.encodeString(leftPad);\n    this.rightPad = util.encodeString(rightPad);\n    this.padWidth = padWidth;\n    this.preserveShort = preserveShortSequences;\n  }\n\n  private getPadWidth(nGramWidth: number) {\n    // Ngrams can be padded with either a fixed pad width or a dynamic pad\n    // width depending on the 'padWidth' arg, but in no case should the padding\n    // ever be wider than 'nGramWidth' - 1.\n    return Math.min(\n        this.padWidth < 0 ? nGramWidth - 1 : this.padWidth, nGramWidth - 1);\n  }\n\n  private getNumNGrams(length: number, nGramWidth: number) {\n    const padWidth = this.getPadWidth(nGramWidth);\n    return Math.max(0, ((length + 2 * padWidth) - nGramWidth) + 1);\n  }\n\n  private createNGrams(\n      data: Uint8Array[], splitIndex: number, output: Uint8Array[],\n      outputStartIndex: number, numNGrams: number, nGramWidth: number) {\n    for (let nGramIndex = 0; nGramIndex < numNGrams; ++nGramIndex) {\n      const padWidth = this.getPadWidth(nGramWidth);\n      const leftPadding = Math.max(0, padWidth - nGramIndex);\n      const rightPadding =\n          Math.max(0, padWidth - (numNGrams - (nGramIndex + 1)));\n      const numTokens = nGramWidth - (leftPadding + rightPadding);\n      const dataStartIndex =\n          splitIndex + (leftPadding > 0 ? 0 : nGramIndex - padWidth);\n\n      // Calculate the total expected size of the nGram so we can reserve the\n      // correct amount of space in the string.\n      let nGramSize = 0;\n      // Size of the left padding.\n      nGramSize += leftPadding * this.leftPad.length;\n      // Size of the tokens.\n      for (let n = 0; n < numTokens; ++n) {\n        nGramSize += data[dataStartIndex + n].length;\n      }\n      // Size of the right padding.\n      nGramSize += rightPadding * this.rightPad.length;\n      // Size of the separators.\n      const numSeparators = leftPadding + rightPadding + numTokens - 1;\n      nGramSize += numSeparators * this.separator.length;\n\n      // Build the nGram.\n      output[outputStartIndex + nGramIndex] = new Uint8Array(nGramSize);\n      const nGram = output[outputStartIndex + nGramIndex];\n\n      let nextNGramIndex = 0;\n      const appendToNGram = (str: Uint8Array) =>\n          str.forEach((value) => nGram[nextNGramIndex++] = value);\n\n      for (let n = 0; n < leftPadding; ++n) {\n        appendToNGram(this.leftPad);\n        appendToNGram(this.separator);\n      }\n      // Only output first numTokens - 1 pairs of data and separator\n      for (let n = 0; n < numTokens - 1; ++n) {\n        appendToNGram(data[dataStartIndex + n]);\n        appendToNGram(this.separator);\n      }\n      // Handle case when there are no tokens or no right padding as these\n      // can result in consecutive separators.\n      if (numTokens > 0) {\n        // If we have tokens, then output last and then pair each separator\n        // with the right padding that follows, to ensure nGram ends either with\n        // the token or with the right pad.\n        appendToNGram(data[dataStartIndex + numTokens - 1]);\n        for (let n = 0; n < rightPadding; ++n) {\n          appendToNGram(this.separator);\n          appendToNGram(this.rightPad);\n        }\n      } else {\n        // If we don't have tokens, then the last item inserted into the nGram\n        // has been the separator from the left padding loop above. Hence,\n        // output right pad and separator and make sure to finish with a\n        // padding, not a separator.\n        for (let n = 0; n < rightPadding - 1; ++n) {\n          appendToNGram(this.rightPad);\n          appendToNGram(this.separator);\n        }\n        appendToNGram(this.rightPad);\n      }\n    }\n  }\n\n  // Data and splits together form the definition of the ragged tensor,\n  // where data is 1 dimensional and contains the values of the tensor\n  // and splits denotes the indices at which each row starts.\n  public compute(data: Uint8Array[], splits: Int32Array):\n      [Uint8Array[], Int32Array] {\n    // Validate that the splits are valid indices into data, only if there are\n    // splits specified.\n    const inputDataSize = data.length;\n    const splitsSize = splits.length;\n    if (splitsSize > 0) {\n      let prevSplit = splits[0];\n      if (prevSplit !== 0) {\n        throw new Error(`First split value must be 0, got ${prevSplit}`);\n      }\n      for (let i = 1; i < splitsSize; ++i) {\n        let validSplits = splits[i] >= prevSplit;\n        validSplits = validSplits && (splits[i] <= inputDataSize);\n        if (!validSplits) {\n          throw new Error(`Invalid split value ${splits[i]}, must be in [${\n              prevSplit}, ${inputDataSize}]`);\n        }\n        prevSplit = splits[i];\n      }\n      if (prevSplit !== inputDataSize) {\n        throw new Error(`Last split value must be data size. Expected ${\n            inputDataSize}, got ${prevSplit}`);\n      }\n    }\n\n    const numBatchItems = splitsSize - 1;\n    const nGramsSplits = util.getArrayFromDType('int32', splitsSize);\n    // If there is no data or size, return an empty ragged tensor.\n    if (inputDataSize === 0 || splitsSize === 0) {\n      const empty: Uint8Array[] = new Array(inputDataSize);\n      for (let i = 0; i <= numBatchItems; ++i) {\n        nGramsSplits[i] = 0;\n      }\n      return [empty, nGramsSplits];\n    }\n\n    nGramsSplits[0] = 0;\n    for (let i = 1; i <= numBatchItems; ++i) {\n      const length = splits[i] - splits[i - 1];\n      let numNGrams = 0;\n      this.nGramWidths.forEach((nGramWidth) => {\n        numNGrams += this.getNumNGrams(length, nGramWidth);\n      });\n      if (this.preserveShort && length > 0 && numNGrams === 0) {\n        numNGrams = 1;\n      }\n      nGramsSplits[i] = nGramsSplits[i - 1] + numNGrams;\n    }\n\n    const nGrams: Uint8Array[] = new Array(nGramsSplits[numBatchItems]);\n\n    for (let i = 0; i < numBatchItems; ++i) {\n      const splitIndex = splits[i];\n      let outputStartIdx = nGramsSplits[i];\n      this.nGramWidths.forEach((nGramWidth) => {\n        const length = splits[i + 1] - splits[i];\n        const numNGrams = this.getNumNGrams(length, nGramWidth);\n        this.createNGrams(\n            data, splitIndex, nGrams, outputStartIdx, numNGrams, nGramWidth);\n        outputStartIdx += numNGrams;\n      });\n      // If we're preserving short sequences, check to see if no sequence was\n      // generated by comparing the current output start idx to the original\n      // one (nGramSplitsdata). If no ngrams were generated, then they will\n      // be equal (since we increment outputStartIdx by numNGrams every\n      // time we create a set of ngrams.)\n      if (this.preserveShort && outputStartIdx === nGramsSplits[i]) {\n        const dataLength = splits[i + 1] - splits[i];\n        // One legitimate reason to not have any ngrams when this.preserveShort\n        // is true is if the sequence itself is empty. In that case, move on.\n        if (dataLength === 0) {\n          continue;\n        }\n        // We don't have to worry about dynamic padding sizes here: if padding\n        // was dynamic, every sequence would have had sufficient padding to\n        // generate at least one nGram.\n        const nGramWidth = dataLength + 2 * this.padWidth;\n        const numNGrams = 1;\n        this.createNGrams(\n            data, splitIndex, nGrams, outputStartIdx, numNGrams, nGramWidth);\n      }\n    }\n    return [nGrams, nGramsSplits];\n  }\n}\n\nexport function stringNGramsImpl(\n    data: Uint8Array[], dataSplits: Int32Array, separator: string,\n    nGramWidths: number[], leftPad: string, rightPad: string, padWidth: number,\n    preserveShortSequences: boolean): [Uint8Array[], Int32Array] {\n  return new StringNGramsOp(\n             separator, nGramWidths, leftPad, rightPad, padWidth,\n             preserveShortSequences)\n      .compute(data, dataSplits);\n}\n","/**\n * @license\n * Copyright 2021 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {TypedArray, util} from '@tensorflow/tfjs-core';\n\nfunction split(\n    str: Uint8Array, delimiters: Uint8Array, skipEmpty: boolean,\n    result: Uint8Array[]): void {\n  if (!str.length) {\n    return;\n  }\n  // When the delimiter is empty, the input is split into individual characters.\n  if (delimiters.length === 0) {\n    for (let i = 0; i < str.length; ++i) {\n      result.push(str.subarray(i, i + 1));\n    }\n    return;\n  }\n  // When there is one delimiter, the input is split only at that delimiter.\n  if (delimiters.length === 1) {\n    const delimiter = delimiters[0];\n    let f = str.indexOf(delimiter);\n    while (f !== -1) {\n      const token = str.subarray(0, f);\n      if (!skipEmpty || token.length !== 0) {\n        result.push(token);\n      }\n      str = str.subarray(f + 1);\n      f = str.indexOf(delimiter);\n    }\n    if (!skipEmpty || str.length !== 0) {\n      result.push(str);\n    }\n    return;\n  }\n  // When there are multiple delimiters, the input is split at every instance\n  // one of the delimiters appears.\n  let tokenStart = 0;\n  for (let i = 0; i < str.length + 1; i++) {\n    if ((i === str.length) || (delimiters.indexOf(str[i]) !== -1)) {\n      const token = str.subarray(tokenStart, i);\n      if (!skipEmpty || token.length !== 0) {\n        result.push(token);\n      }\n      tokenStart = i + 1;\n    }\n  }\n}\n\nexport function stringSplitImpl(\n    input: Uint8Array[], delimiter: Uint8Array,\n    skipEmpty: boolean): [TypedArray, Uint8Array[], [number, number]] {\n  const batchSize = input.length;\n\n  // Empty delimiter means split the input character by character.\n  const tokens: Uint8Array[] = [];\n\n  let outputSize = 0;\n  let maxNumEntries = 0;\n  const numIndices: number[] = new Array(batchSize);\n  for (let i = 0; i < batchSize; ++i) {\n    const prevTokensLength = tokens.length;\n    split(input[i], delimiter, skipEmpty, tokens);\n    const nEntries = tokens.length - prevTokensLength;\n    numIndices[i] = nEntries;\n    outputSize += nEntries;\n    maxNumEntries = Math.max(maxNumEntries, nEntries);\n  }\n\n  const indices = util.getArrayFromDType('int32', outputSize * 2) as TypedArray;\n  const values: Uint8Array[] = new Array(outputSize);\n  const shape: [number, number] = [batchSize, maxNumEntries];\n\n  let c = 0;\n  for (let i = 0; i < batchSize; ++i) {\n    for (let j = 0; j < numIndices[i]; ++j) {\n      // indices is a 2d tensor with shape of [outputSize, 2]\n      indices[c * 2] = i;\n      indices[c * 2 + 1] = j;\n      values[c] = tokens[c];\n      ++c;\n    }\n  }\n\n  return [indices, values, shape];\n}\n","/**\n * @license\n * Copyright 2021 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {TypedArray, util} from '@tensorflow/tfjs-core';\n\nexport function stringToHashBucketFastImpl(\n    input: Uint8Array[], numBuckets: number): TypedArray {\n  const output = util.getArrayFromDType('int32', input.length) as TypedArray;\n\n  for (let i = 0; i < input.length; ++i) {\n    output[i] =\n        util.fingerPrint64(input[i]).modulo(numBuckets).getLowBitsUnsigned();\n  }\n\n  return output;\n}\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {KernelConfig, Sub} from '@tensorflow/tfjs-core';\n\nimport {createSimpleBinaryKernelImpl} from '../utils/binary_impl';\nimport {binaryKernelFunc, createComplexBinaryKernelImpl} from '../utils/binary_utils';\n\nexport const subImpl = createSimpleBinaryKernelImpl(\n    ((aValue: number, bValue: number) => aValue - bValue));\nexport const subComplexImpl =\n    createComplexBinaryKernelImpl(((aReal, aImag, bReal, bImag) => {\n      return {real: aReal - bReal, imag: aImag - bImag};\n    }));\nexport const sub = binaryKernelFunc(Sub, subImpl, subComplexImpl);\n\nexport const subConfig: KernelConfig = {\n  kernelName: Sub,\n  backendName: 'cpu',\n  kernelFunc: sub\n};\n","/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {buffer, DataType, Rank, TensorBuffer} from '@tensorflow/tfjs-core';\n\n/**\n * An implementation of the tile kernel shared between webgl and cpu for string\n * tensors only.\n */\n\nexport function tileImpl<R extends Rank>(\n    xBuf: TensorBuffer<R, DataType>,\n    reps: number[]): TensorBuffer<R, DataType> {\n  const newShape: number[] = new Array(xBuf.rank);\n  for (let i = 0; i < newShape.length; i++) {\n    newShape[i] = xBuf.shape[i] * reps[i];\n  }\n  const result = buffer(newShape, xBuf.dtype);\n  for (let i = 0; i < result.values.length; ++i) {\n    const newLoc = result.indexToLoc(i);\n\n    const originalLoc: number[] = new Array(xBuf.rank);\n    for (let j = 0; j < originalLoc.length; j++) {\n      originalLoc[j] = newLoc[j] % xBuf.shape[j];\n    }\n\n    const originalIndex = xBuf.locToIndex(originalLoc);\n\n    result.values[i] = xBuf.values[originalIndex];\n  }\n  return result as TensorBuffer<R, DataType>;\n}\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\n/** An implementation of the TopK kernel shared between webgl and cpu. */\n\nimport {buffer, NumericDataType, Rank, ShapeMap, Tensor, TensorBuffer, TypedArray, util} from '@tensorflow/tfjs-core';\n\ntype Pair = {\n  value: number,\n  index: number\n};\n\nconst comparePair = (a: Pair, b: Pair) => {\n  const valueDiff = b.value - a.value;\n  return valueDiff === 0 ? a.index - b.index : valueDiff;\n};\n\n/**\n * Partitions array where all elements smaller than the (k+1) smallest element\n * are found to the left of it, and all larger to the right of it.\n * Based on the Floyd-Rivest Algorithm, ref:\n * https://en.wikipedia.org/wiki/Floyd%E2%80%93Rivest_algorithm\n * @param array: Array to partition\n * @param left: Left index for the interval\n * @param right: Right index for the interval\n * @param k: Desired index value, where array[k] is the (k+1)th smallest element\n *           when left = 0\n */\nfunction select(array: Pair[], k: number, left = 0, right = array.length - 1) {\n  while (right > left) {\n    // Use select recursively to sample a smaller set of size s\n    // the arbitrary constants 600 and 0.5 are used in the original\n    // version to minimize execution time.\n    if (right - left > 600) {\n      const n = right - left + 1;\n      const i = k - left + 1;\n      const z = Math.log(n);\n      const s = 0.5 * Math.exp(2 * z / 3);\n      const sd = 0.5 * Math.sqrt(z * s * (n - s) / n) * Math.sign(i - n / 2);\n      const newLeft = Math.max(left, Math.floor(k - i * s / n + sd));\n      const newRight = Math.min(right, Math.floor(k + (n - i) * s / n + sd));\n      select(array, k, newLeft, newRight);\n    }\n    // partition the elements between left and right around t\n    const t = array[k];\n    let i = left;\n    let j = right;\n\n    util.swap(array, left, k);\n\n    if (comparePair(array[right], t) > 0) {\n      util.swap(array, left, right);\n    }\n    while (i < j) {\n      util.swap(array, i, j);\n      i++;\n      j--;\n      while (comparePair(array[i], t) < 0) {\n        i = i + 1;\n      }\n      while (comparePair(array[j], t) > 0) {\n        j = j - 1;\n      }\n    }\n    if (comparePair(array[left], t) === 0) {\n      util.swap(array, left, j);\n    } else {\n      j = j + 1;\n      util.swap(array, j, right);\n    }\n    // Adjust left and right towards the boundaries of the subset\n    // containing the (k - left + 1)th smallest element.\n    if (j <= k) {\n      left = j + 1;\n    }\n    if (k <= j) {\n      right = j - 1;\n    }\n  }\n}\n\nexport function topKImpl<T extends Tensor, R extends Rank>(\n    x: TypedArray, xShape: number[], xDtype: NumericDataType, k: number,\n    sorted: boolean):\n    [TensorBuffer<R, NumericDataType>, TensorBuffer<R, 'int32'>] {\n  // Reshape into a 2d tensor [batch, lastDim] and compute topk along lastDim.\n  const lastDim = xShape[xShape.length - 1];\n  const [batch, size] = [x.length / lastDim, lastDim];\n  const allTopKVals = util.getTypedArrayFromDType(xDtype, batch * k);\n  const allTopKIndices = util.getTypedArrayFromDType('int32', batch * k);\n\n  for (let b = 0; b < batch; b++) {\n    const offset = b * size;\n    const vals = x.subarray(offset, offset + size);\n\n    let valAndInd: Pair[] = new Array(vals.length);\n    vals.forEach(\n        (value: number, index: number) => valAndInd[index] = {value, index});\n\n    if (k < valAndInd.length) {\n      select(valAndInd, k);\n      valAndInd = valAndInd.slice(0, k);\n    }\n\n    if (sorted) {\n      valAndInd.sort(comparePair);\n    }\n    \n    const outOffset = b * k;\n    const topKVals = allTopKVals.subarray(outOffset, outOffset + k);\n    const topKIndices = allTopKIndices.subarray(outOffset, outOffset + k);\n    for (let i = 0; i < k; i++) {\n      topKVals[i] = valAndInd[i].value;\n      topKIndices[i] = valAndInd[i].index;\n    }\n  }\n  // Reshape back to the original input shape, except that the last\n  // dimension is k.\n  const outputShape = xShape.slice();\n  outputShape[outputShape.length - 1] = k;\n\n  return [\n    buffer(outputShape as ShapeMap[R], xDtype, allTopKVals),\n    buffer(outputShape as ShapeMap[R], 'int32', allTopKIndices)\n  ];\n}\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {BackendValues, DataType, TensorBuffer, TypedArray, util} from '@tensorflow/tfjs-core';\n\nexport function uniqueImpl(\n    values: BackendValues, axis: number, shape: number[], dtype: DataType): {\n  outputValues: BackendValues,\n  outputShape: number[],\n  indices: BackendValues\n} {\n  // Normalize and validate axis.\n  const $axis = util.parseAxisParam(axis, shape)[0];\n\n  // Calculate the new shape that is suitable for extracting data along the\n  // given axis.\n  //\n  // The rank is 3.\n  // The size of the 1st dimension is the size of all the axes < the given axis.\n  // The size of the 2nd dimension is the same as the size of the given axis.\n  // The size of the 3rd dimension is the size of all the axes > the given axis.\n  //\n  // For example, for a 4D tensor with shape=[2, 3, 5, 4] and axis=2, the\n  // newShape would be: [2*3, 5, 4].\n  //\n  // Note that this is not the final output shape. This will be the shape for an\n  // intermediate TensorBuffer (see inputBuffer below) to allow us to extract\n  // values along the given axis. To demonstrate how it works, consider the\n  // following example:\n  //\n  // Input: a 3D tensor, with shape [1, 2, 3]\n  // [\n  //   [\n  //      [1,2,3],\n  //      [4,5,6]\n  //   ]\n  // ]\n  // Axis: 2 (the last axis).\n  // Along axis 2, we expect to extract 3 tensors: [1,4], [2,5], [3,6].\n  //\n  // For this example, newShape would be: [2, 3, 1], where 2 is calculated from\n  // 1*2. The re-shaped data would look like:\n  //\n  // [\n  //   [\n  //     [1], [2], [3]\n  //   ],\n  //   [\n  //     [4], [5], [6]\n  //   ]\n  // ]\n  //\n  // Then, we can construct a 3-level nested loop by the following dimension\n  // order to extract the values along the axis (dimension1):\n  // i: dimension1       // 0,1,2 (newShape[1])\n  //   m: dimension0     // 0,1   (newShape[0])\n  //     n: dimension2   // 0     (newShape[2])\n  //\n  //                       m, i, n\n  //                      ---------\n  // Iteration 0: data at [0, 0, 0] => \"1\"\n  // Iteration 1: data at [1, 0, 0] => \"4\"\n  // We got [1,4].\n  // Iteration 2: data at [0, 1, 0] => \"2\"\n  // Iteration 3: data at [1, 1, 0] => \"5\"\n  // We got [2,5].\n  // Iteration 4: data at [0, 2, 0] => \"3\"\n  // Iteration 5: data at [1, 2, 0] => \"6\"\n  // We got [3,6].\n  const newShape = [1, shape[0], 1];\n  for (let i = 0; i < $axis; i++) {\n    newShape[0] *= shape[i];\n  }\n  newShape[1] = shape[$axis];\n  for (let i = $axis + 1; i < shape.length; i++) {\n    newShape[2] *= shape[i];\n  }\n\n  // A map from unique elements (their string representations) to their values\n  // in \"indices\" (below).\n  const uniqueElements: {[key: string]: number} = {};\n  // The indices of each unique element in the original tensor along the given\n  // axis. It is 1D and has the same size as the given axis.\n  const indices = new Int32Array(shape[$axis]);\n  // Create a buffer so we can easily extract value at a given location.\n  const inputBuffer = new TensorBuffer(newShape, dtype, values as TypedArray);\n  // The indices along the given axis that have unique elements. This is a\n  // de-duped version of \"indices\" above.\n  const uniqueIndices: number[] = [];\n  const is1DTensor = newShape[0] === 1 && newShape[2] === 1;\n  for (let i = 0; i < shape[$axis]; i++) {\n    // Extract values along the axis.\n    let element: string;\n    if (is1DTensor) {\n      // Fast path for 1D tensor input.\n      element = values[i].toString();\n    } else {\n      const axisValues = [];\n      for (let m = 0; m < newShape[0]; m++) {\n        for (let n = 0; n < newShape[2]; n++) {\n          axisValues.push(inputBuffer.get(m, i, n));\n        }\n      }\n      element = axisValues.join(',');\n    }\n\n    // Dedup and update various indices.\n    if (uniqueElements[element] !== undefined) {\n      indices[i] = uniqueElements[element];\n    } else {\n      const uniqueIndex = Object.keys(uniqueElements).length;\n      uniqueElements[element] = uniqueIndex;\n      indices[i] = uniqueIndex;\n      uniqueIndices.push(i);\n    }\n  }\n\n  // Now we know where each of the unique elements are located along the axis\n  // (uniqueIndices). Extract them from input buffer and store them in the\n  // output buffer.\n  const outputTmpShape = newShape.slice();\n  outputTmpShape[1] = Object.keys(uniqueElements).length;\n  const outputBuffer = new TensorBuffer(outputTmpShape, dtype);\n  uniqueIndices.forEach((uniqueElementIndex, i) => {\n    for (let m = 0; m < newShape[0]; m++) {\n      for (let n = 0; n < newShape[2]; n++) {\n        outputBuffer.set(inputBuffer.get(m, uniqueElementIndex, n), m, i, n);\n      }\n    }\n  });\n\n  // The output shape can be calculated from the input shape with the size of\n  // the given axis replaced by the number of unique elements along that axis.\n  const outputShape = shape.slice();\n  outputShape[$axis] = outputTmpShape[1];\n\n  return {\n    outputValues: outputBuffer.values as BackendValues,\n    outputShape,\n    indices,\n  };\n}\n","\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\n// Import shared functionality from tfjs-backend-cpu without triggering\n// side effects.\n// tslint:disable-next-line: no-imports-from-dist\nimport * as shared from '@tensorflow/tfjs-backend-cpu/dist/shared';\n// tslint:disable-next-line: no-imports-from-dist\nimport {SimpleBinaryKernelImpl} from '@tensorflow/tfjs-backend-cpu/dist/shared';\n// tslint:disable-next-line: no-imports-from-dist\nimport {SimpleUnaryImpl} from '@tensorflow/tfjs-backend-cpu/dist/utils/unary_types';\n\nexport type SimpleBinaryKernelImplCPU = SimpleBinaryKernelImpl;\nexport type SimpleUnaryKernelImplCPU = SimpleUnaryImpl;\nconst {\n  addImpl: addImplCPU,\n  bincountImpl: bincountImplCPU,\n  bincountReduceImpl: bincountReduceImplCPU,\n  castImpl: castImplCPU,\n  ceilImpl: ceilImplCPU,\n  concatImpl: concatImplCPU,\n  equalImpl: equalImplCPU,\n  expImpl: expImplCPU,\n  expm1Impl: expm1ImplCPU,\n  floorImpl: floorImplCPU,\n  gatherNdImpl: gatherNdImplCPU,\n  gatherV2Impl: gatherV2ImplCPU,\n  greaterImpl: greaterImplCPU,\n  greaterEqualImpl: greaterEqualImplCPU,\n  lessImpl: lessImplCPU,\n  lessEqualImpl: lessEqualImplCPU,\n  linSpaceImpl: linSpaceImplCPU,\n  logImpl: logImplCPU,\n  maxImpl: maxImplCPU,\n  maximumImpl: maximumImplCPU,\n  minimumImpl: minimumImplCPU,\n  multiplyImpl: multiplyImplCPU,\n  negImpl: negImplCPU,\n  notEqualImpl: notEqualImplCPU,\n  prodImpl: prodImplCPU,\n  raggedGatherImpl: raggedGatherImplCPU,\n  raggedRangeImpl: raggedRangeImplCPU,\n  raggedTensorToTensorImpl: raggedTensorToTensorImplCPU,\n  rangeImpl: rangeImplCPU,\n  rsqrtImpl: rsqrtImplCPU,\n  scatterImpl: scatterImplCPU,\n  sigmoidImpl: sigmoidImplCPU,\n  simpleAbsImpl: simpleAbsImplCPU,\n  sliceImpl: sliceImplCPU,\n  sparseFillEmptyRowsImpl: sparseFillEmptyRowsImplCPU,\n  sparseReshapeImpl: sparseReshapeImplCPU,\n  sparseSegmentReductionImpl: sparseSegmentReductionImplCPU,\n  sqrtImpl: sqrtImplCPU,\n  stridedSliceImpl: stridedSliceImplCPU,\n  stringNGramsImpl: stringNGramsImplCPU,\n  stringSplitImpl: stringSplitImplCPU,\n  stringToHashBucketFastImpl: stringToHashBucketFastImplCPU,\n  subImpl: subImplCPU,\n  tileImpl: tileImplCPU,\n  topKImpl: topKImplCPU,\n  transposeImpl: transposeImplCPU,\n  uniqueImpl: uniqueImplCPU,\n} = shared;\n\nexport {\n  addImplCPU,\n  bincountImplCPU,\n  bincountReduceImplCPU,\n  castImplCPU,\n  ceilImplCPU,\n  concatImplCPU,\n  equalImplCPU,\n  expImplCPU,\n  expm1ImplCPU,\n  floorImplCPU,\n  gatherNdImplCPU,\n  gatherV2ImplCPU,\n  greaterEqualImplCPU,\n  greaterImplCPU,\n  lessEqualImplCPU,\n  lessImplCPU,\n  linSpaceImplCPU,\n  logImplCPU,\n  maxImplCPU,\n  maximumImplCPU,\n  minimumImplCPU,\n  multiplyImplCPU,\n  negImplCPU,\n  notEqualImplCPU,\n  prodImplCPU,\n  raggedGatherImplCPU,\n  raggedRangeImplCPU,\n  raggedTensorToTensorImplCPU,\n  scatterImplCPU,\n  sigmoidImplCPU,\n  simpleAbsImplCPU,\n  sliceImplCPU,\n  sparseFillEmptyRowsImplCPU,\n  sparseReshapeImplCPU,\n  sparseSegmentReductionImplCPU,\n  sqrtImplCPU,\n  stridedSliceImplCPU,\n  stringNGramsImplCPU,\n  stringSplitImplCPU,\n  stringToHashBucketFastImplCPU,\n  subImplCPU,\n  rangeImplCPU,\n  rsqrtImplCPU,\n  tileImplCPU,\n  topKImplCPU,\n  transposeImplCPU,\n  uniqueImplCPU,\n};\n","/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nexport function getVecChannels(name: string, rank: number): string[] {\n  return ['x', 'y', 'z', 'w', 'u', 'v'].slice(0, rank).map(d => `${name}.${d}`);\n}\n\nexport function getChannels(name: string, rank: number): string[] {\n  if (rank === 1) {\n    return [name];\n  }\n  return getVecChannels(name, rank);\n}\n\nexport function getSourceCoords(rank: number, dims: string[]): string {\n  if (rank === 1) {\n    return 'rc';\n  }\n\n  let coords = '';\n  for (let i = 0; i < rank; i++) {\n    coords += dims[i];\n    if (i < rank - 1) {\n      coords += ',';\n    }\n  }\n  return coords;\n}","/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {GPGPUProgram, useShapeUniforms} from './gpgpu_math';\nimport {getChannels} from './packing_util';\nimport {getCoordsDataType} from './shader_compiler';\n\nexport class PackProgram implements GPGPUProgram {\n  variableNames = ['A'];\n  outputShape: number[];\n  userCode: string;\n  packedInputs = false;\n  packedOutput = true;\n  enableShapeUniforms: boolean;\n  rank: number;\n\n  constructor(\n      outputShape:\n          number[]) {  // TODO(https://github.com/tensorflow/tfjs/issues/893):\n                       // Only input / output 3D tensors.\n    this.outputShape = outputShape;\n    this.rank = outputShape.length;\n    this.enableShapeUniforms = useShapeUniforms(this.outputShape.length);\n\n    if (this.rank === 0) {\n      this.userCode = `\n        void main() {\n          setOutput(vec4(getA(), 0., 0., 0.));\n        }\n      `;\n    } else {\n      const channels = getChannels('rc', this.rank);\n      const dtype = getCoordsDataType(this.rank);\n      const outOfBoundsCondition = this.getOutOfBoundsCondition(channels);\n      const setup = this.getSetup(channels);\n      const output = this.getOutput(channels);\n\n      this.userCode = `\n        void main() {\n          ${dtype} rc = getOutputCoords();\n\n          if(${outOfBoundsCondition}) {\n            setOutput(vec4(0));\n          } else {\n            ${setup}\n\n            setOutput(vec4(${output}));\n          }\n        }\n      `;\n    }\n  }\n\n  private getSourceCoordsArr(dims: string[]): string[] {\n    const coords = [];\n\n    for (let row = 0; row <= 1; row++) {\n      for (let col = 0; col <= 1; col++) {\n        let coord = `${row === 0 ? 'r' : 'rp1'}, ${col === 0 ? 'c' : 'cp1'}`;\n\n        for (let d = 2; d < this.rank; d++) {\n          coord = `${dims[dims.length - 1 - d]},` + coord;\n        }\n\n        coords.push(coord);\n      }\n    }\n    return coords;\n  }\n\n  private getOutOfBoundsCondition(dims: string[]): string {\n    if (this.rank === 1) {\n      return `rc > ${\n          this.enableShapeUniforms ? 'outShape' : this.outputShape[0]}`;\n    }\n\n    let cond = '';\n    for (let i = this.rank - 2; i < this.rank; i++) {\n      cond += `${dims[i]} >= ${\n          this.enableShapeUniforms ? `outShape[${i}]` : this.outputShape[i]}`;\n      if (i < this.rank - 1) {\n        cond += '||';\n      }\n    }\n\n    return cond;\n  }\n\n  private getSetup(dims: string[]): string {\n    if (this.rank === 1) {\n      return '';\n    }\n\n    const innerDims = dims.slice(-2);\n    const col = this.enableShapeUniforms ? `outShape[${this.rank} - 1]` :\n                                           this.outputShape[this.rank - 1];\n    const row = this.enableShapeUniforms ? `outShape[${this.rank} - 2]` :\n                                           this.outputShape[this.rank - 2];\n\n    return `\n      int r = ${innerDims[0]};\n      int c = ${innerDims[1]};\n      int rp1 = r + 1;\n      int cp1 = c + 1;\n\n      bool cEdge = cp1 >= ${col};\n      bool rEdge = rp1 >= ${row};\n    `;\n  }\n\n  private getOutput(dims: string[]): string {\n    const sourceCoords = this.getSourceCoordsArr(dims);\n    if (this.rank === 1) {\n      const outShape =\n          this.enableShapeUniforms ? 'outShape' : this.outputShape[0];\n      return `getA(rc), (rc + 1 >= ${outShape} ? 0. : getA(rc + 1)), 0, 0`;\n    }\n\n    return `getA(${sourceCoords[0]}),\n            cEdge ? 0. : getA(${sourceCoords[1]}),\n            rEdge ? 0. : getA(${sourceCoords[2]}),\n            rEdge || cEdge ? 0. : getA(${sourceCoords[3]})`;\n  }\n}\n","/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {GPGPUProgram, useShapeUniforms} from './gpgpu_math';\nimport * as shader_util from './shader_compiler_util';\n\nexport class ReshapePackedProgram implements GPGPUProgram {\n  variableNames = ['A'];\n  packedInputs = true;\n  packedOutput = true;\n  outputShape: number[];\n  userCode: string;\n  enableShapeUniforms: boolean;\n  customUniforms = [{name: 'inputShape', type: 'ivec3' as const }];\n\n  constructor(outputShape: [number, number, number], inputShape: [\n    number, number, number\n  ]) {\n    this.outputShape = outputShape;\n    this.enableShapeUniforms = useShapeUniforms(this.outputShape.length);\n\n    let mainLoop = ``;\n    for (let i = 0; i < 4; i++) {\n      let thisRC = `thisRC = rc;`;\n      if (i % 2 === 1) {\n        thisRC += `thisRC.z += 1;`;\n      }\n      if (i > 1) {\n        thisRC += `thisRC.y += 1;`;\n      }\n\n      mainLoop += `\n        ${thisRC}\n        ${i > 0 ? `if(thisRC.y < rows && thisRC.z < cols){` : ''}\n          int flatIndex = getFlatIndex(thisRC);\n\n          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flatIndex);\n          vec2 inputRCInnerDims = vec2(float(inputRC.y),float(inputRC.z));\n\n          result[${i}] =\n            getChannel(getA(inputRC.x, inputRC.y, inputRC.z), inputRCInnerDims);\n        ${i > 0 ? '}' : ''}\n      `;\n    }\n\n    this.userCode = `\n      ${getReshapedInputCoords(inputShape, this.enableShapeUniforms)}\n      ${\n        this.enableShapeUniforms ? shader_util.getFlatIndexFrom3DOutput() :\n                                   shader_util.getFlatIndexFrom3D(outputShape)}\n\n      void main() {\n        ivec3 rc = getOutputCoords();\n\n        vec4 result = vec4(0.);\n\n        ivec3 thisRC;\n        int rows = ${this.enableShapeUniforms ? 'outShape[1]' : outputShape[1]};\n        int cols = ${this.enableShapeUniforms ? 'outShape[2]' : outputShape[2]};\n\n        ${mainLoop}\n\n        setOutput(result);\n      }\n    `;\n  }\n}\n\nfunction getReshapedInputCoords(\n    shape: [number, number, number], enableShapeUniforms: boolean): string {\n  const coordsFromIndexSnippet = enableShapeUniforms ?\n      shader_util.getLogicalCoordinatesFromFlatIndexByUniform(\n          ['r', 'c', 'd'], 'inputShape') :\n      shader_util.getLogicalCoordinatesFromFlatIndex(['r', 'c', 'd'], shape);\n\n  return `\n    ivec3 inputCoordsFromReshapedOutCoords(int index) {\n      ${coordsFromIndexSnippet}\n      return ivec3(r, c, d);\n    }\n  `;\n}\n","/**\n * @license\n * Copyright 2017 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {env} from '@tensorflow/tfjs-core';\n\nimport {GPGPUContext} from './gpgpu_context';\nimport {getInternalFormatForFloat16MatrixTexture, getInternalFormatForFloat16PackedMatrixTexture, getInternalFormatForFloat32MatrixTexture, getInternalFormatForPackedMatrixTexture, getInternalFormatForUnsignedBytesMatrixTexture} from './gpgpu_util';\nimport {getPackedMatrixTextureShapeWidthHeight, getUnpackedMatrixTextureShapeWidthHeight, PhysicalTextureType, Texture, TextureConfig, TextureUsage} from './tex_util';\n\nexport class TextureManager {\n  private numUsedTextures = 0;\n  private numFreeTextures = 0;\n  private _numBytesAllocated = 0;\n  private _numBytesFree = 0;  // How many bytes that have been allocated\n                              // are available for reuse.\n  private freeTextures: {[shape: string]: Texture[]} = {};\n  private logEnabled = false;\n  private usedTextures: {[shape: string]: Texture[]} = {};\n\n  constructor(private gpgpu: GPGPUContext) {}\n\n  acquireTexture(\n      shapeRC: [number, number], usage: TextureUsage,\n      isPacked: boolean): Texture {\n    const physicalTexType = getPhysicalFromLogicalTextureType(usage, isPacked);\n\n    const shapeKey = getKeyFromTextureShape(shapeRC, physicalTexType, isPacked);\n    if (!(shapeKey in this.freeTextures)) {\n      this.freeTextures[shapeKey] = [];\n    }\n    if (!(shapeKey in this.usedTextures)) {\n      this.usedTextures[shapeKey] = [];\n    }\n\n    const texBytes = computeBytes(\n        shapeRC, physicalTexType, this.gpgpu.gl, this.gpgpu.textureConfig,\n        isPacked);\n\n    if (this.freeTextures[shapeKey].length > 0) {\n      this.numFreeTextures--;\n      this.numUsedTextures++;\n      this._numBytesFree -= texBytes;\n      this.log();\n      const newTexture = this.freeTextures[shapeKey].shift();\n      this.usedTextures[shapeKey].push(newTexture);\n      return newTexture;\n    }\n\n    let newTexture: Texture;\n    if (physicalTexType === PhysicalTextureType.PACKED_2X2_FLOAT32) {\n      newTexture = this.gpgpu.createPackedMatrixTexture(shapeRC[0], shapeRC[1]);\n    } else if (physicalTexType === PhysicalTextureType.PACKED_2X2_FLOAT16) {\n      newTexture =\n          this.gpgpu.createFloat16PackedMatrixTexture(shapeRC[0], shapeRC[1]);\n    } else if (physicalTexType === PhysicalTextureType.UNPACKED_FLOAT32) {\n      newTexture =\n          this.gpgpu.createFloat32MatrixTexture(shapeRC[0], shapeRC[1]);\n    } else if (physicalTexType === PhysicalTextureType.UNPACKED_FLOAT16) {\n      newTexture =\n          this.gpgpu.createFloat16MatrixTexture(shapeRC[0], shapeRC[1]);\n    } else if (\n        physicalTexType === PhysicalTextureType.PACKED_4X1_UNSIGNED_BYTE) {\n      newTexture =\n          this.gpgpu.createUnsignedBytesMatrixTexture(shapeRC[0], shapeRC[1]);\n    }\n    this.usedTextures[shapeKey].push(newTexture);\n\n    this.numUsedTextures++;\n    this._numBytesAllocated += texBytes;\n    this.log();\n\n    return newTexture;\n  }\n\n  releaseTexture(\n      texture: Texture, shape: [number, number], logicalTexType: TextureUsage,\n      isPacked: boolean): void {\n    if (this.freeTextures == null) {\n      // Already disposed.\n      return;\n    }\n    const physicalTexType =\n        getPhysicalFromLogicalTextureType(logicalTexType, isPacked);\n    const shapeKey = getKeyFromTextureShape(shape, physicalTexType, isPacked);\n    if (!(shapeKey in this.freeTextures)) {\n      this.freeTextures[shapeKey] = [];\n    }\n\n    const texBytes = computeBytes(\n        shape, physicalTexType, this.gpgpu.gl, this.gpgpu.textureConfig,\n        isPacked);\n    const deleteTexThreshold = env().get('WEBGL_DELETE_TEXTURE_THRESHOLD');\n    if (deleteTexThreshold !== -1 &&\n        this._numBytesAllocated > deleteTexThreshold) {\n      this.gpgpu.deleteMatrixTexture(texture.texture);\n      this._numBytesAllocated -= texBytes;\n    } else {\n      this.freeTextures[shapeKey].push(texture);\n      this.numFreeTextures++;\n      this._numBytesFree += texBytes;\n    }\n\n    this.numUsedTextures--;\n\n    const texList = this.usedTextures[shapeKey];\n    const texIndex = texList.indexOf(texture);\n    if (texIndex < 0) {\n      throw new Error(\n          'Cannot release a texture that was never provided by this ' +\n          'texture manager');\n    }\n    texList.splice(texIndex, 1);\n    this.log();\n  }\n\n  private log() {\n    if (!this.logEnabled) {\n      return;\n    }\n    const total = this.numFreeTextures + this.numUsedTextures;\n    console.log(\n        'Free/Used', `${this.numFreeTextures} / ${this.numUsedTextures}`,\n        `(${total})`);\n    const freeRatio = this._numBytesFree / this._numBytesAllocated;\n    console.log(`Bytes allocated: ${this._numBytesAllocated}`);\n    console.log(`Bytes unused: ${this._numBytesFree} (${\n        Math.round(100 * freeRatio)}%)`);\n  }\n\n  get numBytesAllocated(): number {\n    return this._numBytesAllocated;\n  }\n\n  get numBytesFree(): number {\n    return this._numBytesFree;\n  }\n\n  getNumUsedTextures(): number {\n    return this.numUsedTextures;\n  }\n\n  getNumFreeTextures(): number {\n    return this.numFreeTextures;\n  }\n\n  dispose() {\n    if (this.freeTextures == null) {\n      // Already disposed.\n      return;\n    }\n    for (const texShape in this.freeTextures) {\n      this.freeTextures[texShape].forEach(tex => {\n        this.gpgpu.deleteMatrixTexture(tex.texture);\n      });\n    }\n    for (const texShape in this.usedTextures) {\n      this.usedTextures[texShape].forEach(tex => {\n        this.gpgpu.deleteMatrixTexture(tex.texture);\n      });\n    }\n    this.freeTextures = null;\n    this.usedTextures = null;\n    this.numUsedTextures = 0;\n    this.numFreeTextures = 0;\n    this._numBytesAllocated = 0;\n    this._numBytesFree = 0;\n  }\n}\n\nfunction numBytesForInternalFormat(\n    gl: WebGLRenderingContext, internalFormat: number): number {\n  // tslint:disable-next-line:no-any\n  const glany = gl as any;\n  if (internalFormat === glany.R32F) {\n    return 4;\n  } else if (internalFormat === glany.R16F) {\n    return 2;\n  } else if (internalFormat === glany.RGBA32F) {\n    return 16;\n  } else if (internalFormat === gl.RGBA) {\n    return 16;\n  } else if (internalFormat === glany.RGBA16F) {\n    return 8;\n  } else if (internalFormat === glany.RGBA8) {\n    return 4;\n  }\n  throw new Error(`Unknown internal format ${internalFormat}`);\n}\n\nexport function computeBytes(\n    shape: [number, number], physicalTexType: PhysicalTextureType,\n    gl: WebGLRenderingContext, textureConfig: TextureConfig,\n    isPacked: boolean): number {\n  // It is not possible to infer packed status from the texture type because\n  // depending on the textureConfig, different  texture types may resolve to the\n  // same internal format (e.g. in WebGL1, the internal format for\n  // UNPACKED_FLOAT16 textures is gl.RGBA). Therefore we pass in `isPacked`\n  // explicitly.\n  const internalFormat =\n      internalFormatForPhysicalTexType(physicalTexType, textureConfig);\n\n  let numElements: number;\n  if (isPacked) {\n    const [packedWidth, packedHeight] =\n        getPackedMatrixTextureShapeWidthHeight(shape[0], shape[1]);\n    numElements = packedWidth * packedHeight;\n\n  } else {\n    const [width, height] =\n        getUnpackedMatrixTextureShapeWidthHeight(shape[0], shape[1]);\n    numElements = width * height;\n  }\n\n  const bytesPerElement = numBytesForInternalFormat(gl, internalFormat);\n  return numElements * bytesPerElement;\n}\n\nfunction internalFormatForPhysicalTexType(\n    physicalTexType: PhysicalTextureType,\n    textureConfig: TextureConfig): number {\n  switch (physicalTexType) {\n    case PhysicalTextureType.PACKED_2X2_FLOAT32:\n      return getInternalFormatForPackedMatrixTexture(textureConfig);\n    case PhysicalTextureType.PACKED_2X2_FLOAT16:\n      return getInternalFormatForFloat16PackedMatrixTexture(textureConfig);\n    case PhysicalTextureType.UNPACKED_FLOAT32:\n      return getInternalFormatForFloat32MatrixTexture(textureConfig);\n    case PhysicalTextureType.UNPACKED_FLOAT16:\n      return getInternalFormatForFloat16MatrixTexture(textureConfig);\n    case PhysicalTextureType.PACKED_4X1_UNSIGNED_BYTE:\n      return getInternalFormatForUnsignedBytesMatrixTexture(textureConfig);\n    default:\n      throw new Error(`Unknown physical texture type ${physicalTexType}`);\n  }\n}\n\nfunction getPhysicalTextureForRendering(isPacked: boolean):\n    PhysicalTextureType {\n  if (env().getBool('WEBGL_RENDER_FLOAT32_ENABLED')) {\n    if (isPacked) {\n      return PhysicalTextureType.PACKED_2X2_FLOAT32;\n    }\n    return PhysicalTextureType.UNPACKED_FLOAT32;\n  }\n\n  if (isPacked) {\n    return PhysicalTextureType.PACKED_2X2_FLOAT16;\n  }\n  return PhysicalTextureType.UNPACKED_FLOAT16;\n}\n\nfunction getPhysicalFromLogicalTextureType(\n    logicalTexType: TextureUsage, isPacked: boolean): PhysicalTextureType {\n  if (logicalTexType === TextureUsage.UPLOAD) {\n    return PhysicalTextureType.PACKED_2X2_FLOAT32;\n  } else if (logicalTexType === TextureUsage.RENDER || logicalTexType == null) {\n    return getPhysicalTextureForRendering(isPacked);\n  } else if (\n      logicalTexType === TextureUsage.DOWNLOAD ||\n      logicalTexType === TextureUsage.PIXELS) {\n    return PhysicalTextureType.PACKED_4X1_UNSIGNED_BYTE;\n  }\n  throw new Error(`Unknown logical texture type ${logicalTexType}`);\n}\n\nfunction getKeyFromTextureShape(\n    shapeRowsCol: [number, number], physicalTexType: PhysicalTextureType,\n    isPacked: boolean): string {\n  return `${shapeRowsCol[0]}_${shapeRowsCol[1]}_${physicalTexType}_${isPacked}`;\n}\n","/**\n * @license\n * Copyright 2017 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {GPGPUProgram, useShapeUniforms} from './gpgpu_math';\n\nexport class UnaryOpProgram implements GPGPUProgram {\n  variableNames = ['A'];\n  userCode: string;\n  outputShape: number[];\n  enableShapeUniforms: boolean;\n\n  constructor(aShape: number[], opSnippet: string) {\n    this.outputShape = aShape;\n    this.enableShapeUniforms = useShapeUniforms(this.outputShape.length);\n    this.userCode = `\n      float unaryOperation(float x) {\n        ${opSnippet}\n      }\n\n      void main() {\n        float x = getAAtOutCoords();\n        float y = unaryOperation(x);\n\n        setOutput(y);\n      }\n    `;\n  }\n}\n\nexport const CHECK_NAN_SNIPPET = `if (isnan(x)) return x;`;\n\nexport const LINEAR = `return x;`;\n\nexport const ABS = `return abs(x);`;\n\nexport function STEP(alpha = 0.0) {\n  return CHECK_NAN_SNIPPET + `\n    return x > 0.0 ? 1.0 : float(${alpha});\n  `;\n}\n\nexport const ELU = `return (x >= 0.0) ? x : (exp(x) - 1.0);`;\nexport const RELU = CHECK_NAN_SNIPPET + `\n  return (x < 0.0) ? 0.0 : x;\n`;\n\nexport const RELU6 = CHECK_NAN_SNIPPET + `\n  return (x < 0.0) ? 0.0 : min(6.0, x);\n`;\n\nexport const CLONE = 'return x;';\n\nexport const SIGMOID = `return 1.0 / (1.0 + exp(-1.0 * x));`;\n","/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {GPGPUProgram, useShapeUniforms} from './gpgpu_math';\n\nexport const LINEAR = `return x;`;\n\nexport const ELU = `\n  vec4 result;\n\n  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);\n  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);\n  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);\n  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);\n\n  return result;\n`;\n\nexport const RELU = `\n  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n`;\n\nexport const RELU6 = `\n  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n`;\n\nexport const SIGMOID = `return 1.0 / (1.0 + exp(-1.0 * x));`;\n\nexport class UnaryOpPackedProgram implements GPGPUProgram {\n  variableNames = ['A'];\n  userCode: string;\n  enableShapeUniforms: boolean;\n  outputShape: number[];\n  packedInputs = true;\n  packedOutput = true;\n\n  constructor(aShape: number[], opSnippet: string) {\n    this.outputShape = aShape;\n    this.enableShapeUniforms = useShapeUniforms(this.outputShape.length);\n    this.userCode = `\n      vec4 unaryOperation(vec4 x) {\n        ${opSnippet}\n      }\n\n      void main() {\n        vec4 x = getAAtOutCoords();\n        vec4 y = unaryOperation(x);\n\n        setOutput(y);\n      }\n    `;\n  }\n}\n","/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {GPGPUProgram, useShapeUniforms} from './gpgpu_math';\nimport {getChannels, getSourceCoords} from './packing_util';\nimport {getCoordsDataType} from './shader_compiler';\n\nexport class UnpackProgram implements GPGPUProgram {\n  variableNames = ['A'];\n  packedInputs = true;\n  packedOutput = false;\n  outputShape: number[];\n  userCode: string;\n  enableShapeUniforms: boolean;\n\n  constructor(outputShape: number[]) {\n    this.outputShape = outputShape;\n    this.enableShapeUniforms = useShapeUniforms(this.outputShape.length);\n    const rank = outputShape.length;\n\n    const channels = getChannels('rc', rank);\n    const dtype = getCoordsDataType(rank);\n    const sourceCoords = getSourceCoords(rank, channels);\n    const innerDims = channels.slice(-2);\n    const coords = rank <= 1 ? 'rc' : `vec2(${innerDims.join(',')})`;\n\n    this.userCode = `\n      void main() {\n        ${dtype} rc = getOutputCoords();\n        vec4 packedInput = getA(${sourceCoords});\n\n        setOutput(getChannel(packedInput, ${coords}));\n      }\n    `;\n  }\n}\n","/**\n * @license\n * Copyright 2017 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\n// Import webgl flags.\nimport './flags_webgl';\n\nimport * as tf from '@tensorflow/tfjs-core';\nimport {backend_util, BackendValues, buffer, DataId, DataStorage, DataToGPUWebGLOption, DataType, engine, env, GPUData, kernel_impls, KernelBackend, MemoryInfo, nextFrame, NumericDataType, Rank, RecursiveArray, scalar, ShapeMap, Tensor, Tensor2D, TensorBuffer, TensorInfo, tidy, TimingInfo, TypedArray, util, WebGLData} from '@tensorflow/tfjs-core';\nimport {getWebGLContext} from './canvas_util';\nimport {DecodeMatrixProgram} from './decode_matrix_gpu';\nimport {DecodeMatrixPackedProgram} from './decode_matrix_packed_gpu';\nimport {EncodeFloatProgram} from './encode_float_gpu';\nimport {EncodeFloatPackedProgram} from './encode_float_packed_gpu';\nimport {EncodeMatrixProgram} from './encode_matrix_gpu';\nimport {EncodeMatrixPackedProgram} from './encode_matrix_packed_gpu';\nimport {GPGPUContext} from './gpgpu_context';\nimport * as gpgpu_math from './gpgpu_math';\nimport {getUniformLocations, GPGPUBinary, GPGPUProgram, TensorData} from './gpgpu_math';\nimport {simpleAbsImplCPU} from './kernel_utils/shared';\nimport {PackProgram} from './pack_gpu';\nimport {ReshapePackedProgram} from './reshape_packed_gpu';\nimport * as tex_util from './tex_util';\nimport {Texture, TextureData, TextureUsage} from './tex_util';\nimport {TextureManager} from './texture_manager';\nimport * as unary_op from './unaryop_gpu';\nimport {UnaryOpProgram} from './unaryop_gpu';\nimport {UnaryOpPackedProgram} from './unaryop_packed_gpu';\nimport {UnpackProgram} from './unpack_gpu';\nimport * as webgl_util from './webgl_util';\n\nconst whereImpl = kernel_impls.whereImpl;\n\nexport const EPSILON_FLOAT32 = 1e-7;\nexport const EPSILON_FLOAT16 = 1e-4;\n\ntype KernelInfo = {\n  name: string; query: Promise<number>;\n};\n\nexport type TimerNode = RecursiveArray<KernelInfo>|KernelInfo;\nexport interface CPUTimerQuery {\n  startMs: number;\n  endMs?: number;\n}\n\nexport interface WebGLMemoryInfo extends MemoryInfo {\n  numBytesInGPU: number;\n  // Tracks the total number of bytes allocated on the GPU, accounting for the\n  // physical texture type.\n  numBytesInGPUAllocated: number;\n  // Tracks byte size of textures that were created and then made available for\n  // reuse (disposed).\n  numBytesInGPUFree: number;\n  unreliable: boolean;\n}\n\nexport interface WebGLTimingInfo extends TimingInfo {\n  uploadWaitMs: number;\n  downloadWaitMs: number;\n}\n\nconst binaryCaches: {[webGLVersion: string]: {[key: string]: GPGPUBinary}} = {};\n\nexport function getBinaryCache(webGLVersion: number) {\n  if (webGLVersion in binaryCaches) {\n    return binaryCaches[webGLVersion];\n  }\n  binaryCaches[webGLVersion] = {};\n  return binaryCaches[webGLVersion];\n}\n\n// Empirically determined constant used to determine size threshold for handing\n// off execution to the CPU.\nconst CPU_HANDOFF_SIZE_THRESHOLD =\n    env().getNumber('CPU_HANDOFF_SIZE_THRESHOLD');\n\n// Empirically determined constant used to decide the number of MB on GPU\n// before we warn about high memory use. The MB are this constant * screen area\n// * dpi / 1024 / 1024.\nconst BEFORE_PAGING_CONSTANT = 600;\nfunction numMBBeforeWarning(): number {\n  if (env().global.screen == null) {\n    return 1024;  // 1 GB.\n  }\n  return (env().global.screen.height * env().global.screen.width *\n          window.devicePixelRatio) *\n      BEFORE_PAGING_CONSTANT / 1024 / 1024;\n}\n\nexport class MathBackendWebGL extends KernelBackend {\n  texData: DataStorage<TextureData>;\n  gpgpu: GPGPUContext;\n\n  private static nextDataId = 0;\n  private nextDataId(): number {\n    return MathBackendWebGL.nextDataId++;\n  }\n  // Maps data ids that have a pending read operation, to list of subscribers.\n  private pendingRead = new WeakMap<DataId, Array<(arr: TypedArray) => void>>();\n  // List of data ids that are scheduled for disposal, but are waiting on a\n  // pending read operation.\n  private pendingDisposal = new WeakSet<DataId>();\n\n  // Used to count the number of 'shallow' sliced tensors that point to the\n  // same data id.\n  dataRefCount = new WeakMap<DataId, number>();\n  private numBytesInGPU = 0;\n\n  private canvas: HTMLCanvasElement|OffscreenCanvas;\n\n  private programTimersStack: TimerNode[];\n  private activeTimers: TimerNode[];\n  // Accumulated time spent (including blocking) in uploading data to webgl.\n  private uploadWaitMs = 0;\n  // Accumulated time spent (including blocking in downloading data from webgl.\n  private downloadWaitMs = 0;\n\n  // record the last manual GL Flush time.\n  private lastGlFlushTime = 0;\n\n  // Number of bits of precision of this backend.\n  private floatPrecisionValue: 32|16;\n\n  private textureManager: TextureManager;\n  private binaryCache: {[key: string]: GPGPUBinary};\n  private gpgpuCreatedLocally: boolean;\n  private numMBBeforeWarning: number;\n  private warnedAboutMemory = false;\n\n  constructor(gpuResource?: GPGPUContext|HTMLCanvasElement|OffscreenCanvas) {\n    super();\n    if (!env().getBool('HAS_WEBGL')) {\n      throw new Error('WebGL is not supported on this device');\n    }\n\n    let newGPGPU;\n    if (gpuResource != null) {\n      if (gpuResource instanceof GPGPUContext) {\n        newGPGPU = gpuResource;\n      } else {\n        const gl =\n            getWebGLContext(env().getNumber('WEBGL_VERSION'), gpuResource);\n        newGPGPU = new GPGPUContext(gl);\n      }\n      this.binaryCache = {};\n      this.gpgpuCreatedLocally = false;\n    } else {\n      const gl = getWebGLContext(env().getNumber('WEBGL_VERSION'));\n      newGPGPU = new GPGPUContext(gl);\n      this.binaryCache = getBinaryCache(env().getNumber('WEBGL_VERSION'));\n      this.gpgpuCreatedLocally = true;\n    }\n\n    this.gpgpu = newGPGPU;\n    this.canvas = this.gpgpu.gl.canvas;\n    this.textureManager = new TextureManager(this.gpgpu);\n    this.numMBBeforeWarning = numMBBeforeWarning();\n    this.texData = new DataStorage(this, engine());\n  }\n\n  override numDataIds() {\n    return this.texData.numDataIds() - this.pendingDeletes;\n  }\n\n  // Writes a new entry to the data store with a WebGL texture, and registers it\n  // to the texture manager.\n  writeTexture(\n      texture: WebGLTexture, shape: number[], dtype: DataType,\n      texHeight: number, texWidth: number, channels: string): DataId {\n    // Temporarily create an tensor info to make the texture compatible with\n    // the runWebGLProgram's input.\n    const input = this.makeTensorInfo(shape, dtype);\n    const inData = this.texData.get(input.dataId);\n    // Even though the input texture could be unpacked or dense packed, it is\n    // always considered as unpacked for EncodeMatrixProgram.\n    inData.isPacked = false;\n\n    // Bind texture to the input tensor.\n    inData.texture = {texture, texShape: [texHeight, texWidth]};\n    inData.texShape = [texHeight, texWidth];\n\n    const shapeAs3D = webgl_util.getShapeAs3D(shape);\n    const program =\n        new EncodeMatrixProgram(shapeAs3D, false /* isByteArray */, channels);\n    const output =\n        this.runWebGLProgram(program, [input], dtype, [[texHeight, texWidth]]);\n    output.shape = shape;\n\n    // Unbind the texture from the input tensor to avoid the texture being\n    // released.\n    inData.texture = null;\n    this.disposeIntermediateTensorInfo(input);\n\n    return output.dataId;\n  }\n\n  override write(values: BackendValues, shape: number[], dtype: DataType):\n      DataId {\n    if (env().getBool('WEBGL_CHECK_NUMERICAL_PROBLEMS') ||\n        env().getBool('DEBUG')) {\n      this.checkNumericalProblems(values);\n    }\n    if (dtype === 'complex64' && values != null) {\n      throw new Error(\n          `Cannot write to a complex64 dtype. ` +\n          `Please use tf.complex(real, imag).`);\n    }\n    const dataId = {id: this.nextDataId()};\n    this.texData.set(\n        dataId,\n        {shape, dtype, values, usage: TextureUsage.UPLOAD, refCount: 1});\n    return dataId;\n  }\n\n  /** Return refCount of a `TensorData`. */\n  override refCount(dataId: DataId): number {\n    if (this.texData.has(dataId)) {\n      const tensorData = this.texData.get(dataId);\n      return tensorData.refCount;\n    }\n    return 0;\n  }\n\n  /** Increase refCount of a `TextureData`. */\n  override incRef(dataId: DataId): void {\n    const texData = this.texData.get(dataId);\n    texData.refCount++;\n  }\n\n  /** Decrease refCount of a `TextureData`. */\n  decRef(dataId: DataId): void {\n    if (this.texData.has(dataId)) {\n      const texData = this.texData.get(dataId);\n      texData.refCount--;\n    }\n  }\n\n  override move(\n      dataId: DataId, values: BackendValues, shape: number[], dtype: DataType,\n      refCount: number): void {\n    if (env().getBool('DEBUG')) {\n      this.checkNumericalProblems(values);\n    }\n    if (dtype === 'complex64') {\n      throw new Error(\n          `Cannot write to a complex64 dtype. ` +\n          `Please use tf.complex(real, imag).`);\n    }\n    this.texData.set(\n        dataId, {shape, dtype, values, usage: TextureUsage.UPLOAD, refCount});\n  }\n\n  disposeIntermediateTensorInfo(tensorInfo: TensorInfo): void {\n    this.disposeData(tensorInfo.dataId);\n  }\n\n  override readSync(dataId: DataId): BackendValues {\n    const texData = this.texData.get(dataId);\n    const {values, dtype, complexTensorInfos, slice, shape, isPacked} = texData;\n\n    // The presence of `slice` indicates this tensor is a shallow slice of a\n    // different tensor, and is using that original tensor's texture. Run\n    // `clone` in order to copy that texture and read from it.\n    if (slice != null) {\n      let program;\n      if (isPacked) {\n        program = new UnaryOpPackedProgram(shape, unary_op.CLONE);\n      } else {\n        program = new UnaryOpProgram(shape, unary_op.CLONE);\n      }\n      const res =\n          this.runWebGLProgram(program, [{dataId, shape, dtype}], dtype);\n      const data = this.readSync(res.dataId);\n      this.disposeIntermediateTensorInfo(res);\n      return data;\n    }\n    if (values != null) {\n      return this.convertAndCacheOnCPU(dataId);\n    }\n    if (dtype === 'string') {\n      return values;\n    }\n    const shouldTimeProgram = this.activeTimers != null;\n    let start: number;\n    if (shouldTimeProgram) {\n      start = util.now();\n    }\n\n    let result: Float32Array;\n    if (dtype === 'complex64') {\n      const realValues =\n          this.readSync(complexTensorInfos.real.dataId) as Float32Array;\n      const imagValues =\n          this.readSync(complexTensorInfos.imag.dataId) as Float32Array;\n      result = backend_util.mergeRealAndImagArrays(realValues, imagValues);\n    } else {\n      result = this.getValuesFromTexture(dataId);\n    }\n\n    if (shouldTimeProgram) {\n      this.downloadWaitMs += util.now() - start;\n    }\n    return this.convertAndCacheOnCPU(dataId, result);\n  }\n\n  override async read(dataId: DataId): Promise<BackendValues> {\n    if (this.pendingRead.has(dataId)) {\n      const subscribers = this.pendingRead.get(dataId);\n      return new Promise<TypedArray>(resolve => subscribers.push(resolve));\n    }\n    const texData = this.texData.get(dataId);\n    const {values, shape, slice, dtype, complexTensorInfos, isPacked} = texData;\n\n    // The presence of `slice` indicates this tensor is a shallow slice of a\n    // different tensor, and is using that original tensor's texture. Run\n    // `clone` in order to copy that texture and read from it.\n    if (slice != null) {\n      let program;\n      if (isPacked) {\n        program = new UnaryOpPackedProgram(shape, unary_op.CLONE);\n      } else {\n        program = new UnaryOpProgram(shape, unary_op.CLONE);\n      }\n      const res =\n          this.runWebGLProgram(program, [{dataId, shape, dtype}], dtype);\n      const data = this.read(res.dataId);\n      this.disposeIntermediateTensorInfo(res);\n      return data;\n    }\n\n    if (values != null) {\n      return this.convertAndCacheOnCPU(dataId);\n    }\n\n    if (env().getBool('DEBUG')) {\n      // getBool('WEBGL_DOWNLOAD_FLOAT_ENABLED') caused a blocking GPU call.\n      // For performance reason, only check it for debugging. In production,\n      // it doesn't handle this use case anyway, so behavior is not changed.\n      if (!env().getBool('WEBGL_DOWNLOAD_FLOAT_ENABLED') &&\n          env().getNumber('WEBGL_VERSION') === 2) {\n        throw new Error(\n            `tensor.data() with WEBGL_DOWNLOAD_FLOAT_ENABLED=false and ` +\n            `WEBGL_VERSION=2 not yet supported.`);\n      }\n    }\n\n    let buffer: WebGLBuffer = null;\n    let tmpDownloadTarget: TensorInfo;\n\n    if (dtype !== 'complex64' && env().get('WEBGL_BUFFER_SUPPORTED')) {\n      // Possibly copy the texture into a buffer before inserting a fence.\n      tmpDownloadTarget = this.decode(dataId);\n      const tmpData = this.texData.get(tmpDownloadTarget.dataId);\n\n      buffer = this.gpgpu.createBufferFromTexture(\n          tmpData.texture.texture, ...tex_util.getDenseTexShape(shape));\n    }\n\n    this.pendingRead.set(dataId, []);\n\n    if (dtype !== 'complex64') {\n      // Create a fence and wait for it to resolve.\n      await this.gpgpu.createAndWaitForFence();\n    }\n\n    // Download the values from the GPU.\n    let vals: Float32Array;\n    if (dtype === 'complex64') {\n      const ps = await Promise.all([\n        this.read(complexTensorInfos.real.dataId),\n        this.read(complexTensorInfos.imag.dataId)\n      ]);\n\n      const realValues = ps[0];\n      const imagValues = ps[1];\n      vals = backend_util.mergeRealAndImagArrays(\n          realValues as Float32Array, imagValues as Float32Array);\n    } else if (buffer == null) {\n      vals = this.getValuesFromTexture(dataId);\n    } else {\n      const size = util.sizeFromShape(shape);\n      vals = this.gpgpu.downloadFloat32MatrixFromBuffer(buffer, size);\n    }\n    if (tmpDownloadTarget != null) {\n      this.disposeIntermediateTensorInfo(tmpDownloadTarget);\n    }\n    if (buffer != null) {\n      const gl = this.gpgpu.gl;\n      webgl_util.callAndCheck(gl, () => gl.deleteBuffer(buffer));\n    }\n    const dTypeVals = this.convertAndCacheOnCPU(dataId, vals);\n\n    const subscribers = this.pendingRead.get(dataId);\n    this.pendingRead.delete(dataId);\n\n    // Notify all pending reads.\n    subscribers.forEach(resolve => resolve(dTypeVals));\n    if (this.pendingDisposal.has(dataId)) {\n      this.pendingDisposal.delete(dataId);\n      if (this.disposeData(dataId)) {\n        engine().removeDataId(dataId, this);\n      }\n      this.pendingDeletes--;\n    }\n    return dTypeVals;\n  }\n\n  /**\n   * Read tensor to a new texture that is densely packed for ease of use.\n   * @param dataId The source tensor.\n   * @param options\n   *     customTexShape: Optional. If set, will use the user defined texture\n   *     shape to create the texture.\n   */\n  override readToGPU(dataId: DataId, options: DataToGPUWebGLOption = {}):\n      GPUData {\n    const texData = this.texData.get(dataId);\n    const {values, shape, slice, dtype, isPacked, texture} = texData;\n\n    if (dtype === 'complex64') {\n      throw new Error('Does not support reading texture for complex64 dtype.');\n    }\n\n    // The presence of `slice` indicates this tensor is a shallow slice of a\n    // different tensor, and is using that original tensor's texture. Run\n    // `clone` in order to copy that texture and read from it.\n    if (slice != null) {\n      let program;\n      if (isPacked) {\n        program = new UnaryOpPackedProgram(shape, unary_op.CLONE);\n      } else {\n        program = new UnaryOpProgram(shape, unary_op.CLONE);\n      }\n      const res =\n          this.runWebGLProgram(program, [{dataId, shape, dtype}], dtype);\n      const gpuResouorce = this.readToGPU(res, options);\n      this.disposeIntermediateTensorInfo(res);\n      return gpuResouorce;\n    }\n\n    if (texture == null) {\n      if (values != null) {\n        throw new Error('Data is not on GPU but on CPU.');\n      } else {\n        throw new Error('There is no data on GPU or CPU.');\n      }\n    }\n\n    // Decode the texture so that it is stored densely (using four channels).\n    const tmpTarget = this.decode(dataId, options.customTexShape);\n\n    // Make engine track this tensor, so that we can dispose it later.\n    const tensorRef = engine().makeTensorFromTensorInfo(tmpTarget);\n\n    const tmpData = this.texData.get(tmpTarget.dataId);\n    return {tensorRef, ...tmpData.texture};\n  }\n\n  bufferSync<R extends Rank, D extends DataType>(t: TensorInfo):\n      TensorBuffer<R, D> {\n    const data = this.readSync(t.dataId);\n    if (t.dtype === 'string') {\n      try {\n        // Decode the bytes into string.\n        const strings = (data as Uint8Array[]).map(d => util.decodeString(d));\n        return buffer(t.shape as ShapeMap[R], t.dtype, strings) as\n            TensorBuffer<R, D>;\n      } catch {\n        throw new Error('Failed to decode encoded string bytes into utf-8');\n      }\n    }\n    return buffer(t.shape as ShapeMap[R], t.dtype, data as TypedArray) as\n        TensorBuffer<R, D>;\n  }\n\n  private checkNumericalProblems(values: BackendValues): void {\n    if (values == null) {\n      return;\n    }\n    for (let i = 0; i < values.length; i++) {\n      const num = values[i] as number;\n      if (!webgl_util.canBeRepresented(num)) {\n        if (env().getBool('WEBGL_RENDER_FLOAT32_CAPABLE')) {\n          throw Error(\n              `The value ${num} cannot be represented with your ` +\n              `current settings. Consider enabling float32 rendering: ` +\n              `'tf.env().set('WEBGL_RENDER_FLOAT32_ENABLED', true);'`);\n        }\n        throw Error(`The value ${num} cannot be represented on this device.`);\n      }\n    }\n  }\n\n  private getValuesFromTexture(dataId: DataId): Float32Array {\n    const {shape, dtype, isPacked} = this.texData.get(dataId);\n    const size = util.sizeFromShape(shape);\n    if (env().getBool('WEBGL_DOWNLOAD_FLOAT_ENABLED')) {\n      const tmpTarget = this.decode(dataId);\n      const tmpData = this.texData.get(tmpTarget.dataId);\n      const vals =\n          this.gpgpu\n              .downloadMatrixFromPackedTexture(\n                  tmpData.texture.texture, ...tex_util.getDenseTexShape(shape))\n              .subarray(0, size);\n\n      this.disposeIntermediateTensorInfo(tmpTarget);\n\n      return vals;\n    }\n\n    const shouldUsePackedProgram =\n        env().getBool('WEBGL_PACK') && isPacked === true;\n    const outputShape =\n        shouldUsePackedProgram ? webgl_util.getShapeAs3D(shape) : shape;\n    const program = shouldUsePackedProgram ?\n        new EncodeFloatPackedProgram(outputShape as [number, number, number]) :\n        new EncodeFloatProgram(outputShape);\n    const output = this.runWebGLProgram(\n        program, [{shape: outputShape, dtype, dataId}], 'float32');\n    const tmpData = this.texData.get(output.dataId);\n    const vals = this.gpgpu\n                     .downloadByteEncodedFloatMatrixFromOutputTexture(\n                         tmpData.texture.texture, tmpData.texShape[0],\n                         tmpData.texShape[1])\n                     .subarray(0, size);\n    this.disposeIntermediateTensorInfo(output);\n\n    return vals;\n  }\n\n  override timerAvailable(): boolean {\n    return env().getNumber('WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE') > 0;\n  }\n\n  override time(f: () => void): Promise<WebGLTimingInfo> {\n    const oldActiveTimers = this.activeTimers;\n    const newActiveTimers: TimerNode[] = [];\n\n    let outerMostTime = false;\n    if (this.programTimersStack == null) {\n      this.programTimersStack = newActiveTimers;\n      outerMostTime = true;\n    } else {\n      this.activeTimers.push(newActiveTimers);\n    }\n    this.activeTimers = newActiveTimers;\n\n    f();\n\n    // needing to split these up because util.flatten only accepts certain types\n    const flattenedActiveTimerQueries =\n        util.flatten(this.activeTimers.map((d: KernelInfo) => d.query))\n            .filter(d => d != null);\n    const flattenedActiveTimerNames =\n        util.flatten(this.activeTimers.map((d: KernelInfo) => d.name))\n            .filter(d => d != null);\n\n    this.activeTimers = oldActiveTimers;\n\n    if (outerMostTime) {\n      this.programTimersStack = null;\n    }\n\n    const res: WebGLTimingInfo = {\n      uploadWaitMs: this.uploadWaitMs,\n      downloadWaitMs: this.downloadWaitMs,\n      kernelMs: null,\n      wallMs: null  // will be filled by the engine\n    };\n\n    return (async () => {\n      if (env().getNumber('WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE') >\n          0) {\n        const kernelMs = await Promise.all(flattenedActiveTimerQueries);\n\n        res['kernelMs'] = util.sum(kernelMs);\n        res['getExtraProfileInfo'] = () =>\n            kernelMs\n                .map((d, i) => ({name: flattenedActiveTimerNames[i], ms: d}))\n                .map(d => `${d.name}: ${d.ms}`)\n                .join(', ');\n      } else {\n        res['kernelMs'] = {\n          error: 'WebGL query timers are not supported in this environment.'\n        };\n      }\n\n      this.uploadWaitMs = 0;\n      this.downloadWaitMs = 0;\n      return res;\n    })();\n  }\n  override memory(): WebGLMemoryInfo {\n    return {\n      unreliable: false,\n      numBytesInGPU: this.numBytesInGPU,\n      numBytesInGPUAllocated: this.textureManager.numBytesAllocated,\n      numBytesInGPUFree: this.textureManager.numBytesFree\n    } as WebGLMemoryInfo;\n  }\n\n  private startTimer(): WebGLQuery|CPUTimerQuery {\n    if (env().getNumber('WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE') > 0) {\n      return this.gpgpu.beginQuery();\n    }\n    return {startMs: util.now(), endMs: null};\n  }\n\n  private endTimer(query: WebGLQuery|CPUTimerQuery): WebGLQuery|CPUTimerQuery {\n    if (env().getNumber('WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE') > 0) {\n      this.gpgpu.endQuery();\n      return query;\n    }\n    (query as CPUTimerQuery).endMs = util.now();\n    return query;\n  }\n\n  private async getQueryTime(query: WebGLQuery|CPUTimerQuery): Promise<number> {\n    if (env().getNumber('WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE') > 0) {\n      return this.gpgpu.waitForQueryAndGetTime(query as WebGLQuery);\n    }\n    const timerQuery = query as CPUTimerQuery;\n    return timerQuery.endMs - timerQuery.startMs;\n  }\n\n  private pendingDeletes = 0;\n\n  /**\n   * Decrease the RefCount on the dataId and dispose the memory if the dataId\n   * has 0 refCount. If there are pending read on the data, the disposal would\n   * added to the pending delete queue. Return true if the dataId is removed\n   * from backend or the backend does not contain the dataId, false if the\n   * dataId is not removed. Memory may or may not be released even when dataId\n   * is removed, which also depends on dataRefCount, see `releaseGPU`.\n   * @param dataId\n   * @oaram force Optional, remove the data regardless of refCount\n   */\n  override disposeData(dataId: DataId, force = false): boolean {\n    if (this.pendingDisposal.has(dataId)) {\n      return false;\n    }\n\n    // No-op if already disposed.\n    if (!this.texData.has(dataId)) {\n      return true;\n    }\n\n    // if force flag is set, change refCount to 0, this would ensure disposal\n    // when added to the pendingDisposal queue. Memory may or may not be\n    // released, which also depends on dataRefCount, see `releaseGPU`.\n    if (force) {\n      this.texData.get(dataId).refCount = 0;\n    } else {\n      this.texData.get(dataId).refCount--;\n    }\n\n    if (!force && this.texData.get(dataId).refCount > 0) {\n      return false;\n    }\n\n    if (this.pendingRead.has(dataId)) {\n      this.pendingDisposal.add(dataId);\n      this.pendingDeletes++;\n      return false;\n    }\n\n    this.releaseGPUData(dataId);\n    const {complexTensorInfos} = this.texData.get(dataId);\n    if (complexTensorInfos != null) {\n      this.disposeData(complexTensorInfos.real.dataId, force);\n      this.disposeData(complexTensorInfos.imag.dataId, force);\n    }\n\n    this.texData.delete(dataId);\n\n    return true;\n  }\n\n  private releaseGPUData(dataId: DataId): void {\n    const {texture, dtype, texShape, usage, isPacked, slice} =\n        this.texData.get(dataId);\n    const key = slice && slice.origDataId || dataId;\n    const refCount = this.dataRefCount.get(key);\n\n    if (refCount > 1) {\n      this.dataRefCount.set(key, refCount - 1);\n    } else {\n      this.dataRefCount.delete(key);\n      if (texture != null) {\n        this.numBytesInGPU -= this.computeBytes(texShape, dtype);\n        this.textureManager.releaseTexture(texture, texShape, usage, isPacked);\n      }\n    }\n\n    const texData = this.texData.get(dataId);\n    texData.texture = null;\n    texData.texShape = null;\n    texData.isPacked = false;\n    texData.slice = null;\n  }\n\n  getTexture(dataId: DataId): WebGLTexture {\n    this.uploadToGPU(dataId);\n    return this.texData.get(dataId).texture.texture;\n  }\n\n  /**\n   * Returns internal information for the specific data bucket. Used in unit\n   * tests.\n   */\n  getDataInfo(dataId: DataId): TextureData {\n    return this.texData.get(dataId);\n  }\n\n  /*\n  Tests whether all the inputs to an op are small and on the CPU. This heuristic\n  determines when it would be faster to execute a kernel on the CPU. WebGL\n  kernels opt into running this check and forwarding when appropriate.\n  TODO(https://github.com/tensorflow/tfjs/issues/872): Develop a more\n  sustainable strategy for optimizing backend execution of ops.\n   */\n  shouldExecuteOnCPU(\n      inputs: TensorInfo[],\n      sizeThreshold = CPU_HANDOFF_SIZE_THRESHOLD): boolean {\n    return env().getBool('WEBGL_CPU_FORWARD') &&\n        inputs.every(\n            input => this.texData.get(input.dataId).texture == null &&\n                util.sizeFromShape(input.shape) < sizeThreshold);\n  }\n\n  getGPGPUContext(): GPGPUContext {\n    return this.gpgpu;\n  }\n\n  where(condition: Tensor): Tensor2D {\n    backend_util.warn(\n        'tf.where() in webgl locks the UI thread. ' +\n        'Call tf.whereAsync() instead');\n    const condVals = condition.dataSync();\n    return whereImpl(condition.shape, condVals);\n  }\n\n  private packedUnaryOp(x: TensorInfo, op: string, dtype: DataType) {\n    const program = new UnaryOpPackedProgram(x.shape, op);\n    const outInfo = this.compileAndRun(program, [x], dtype);\n    return engine().makeTensorFromTensorInfo(outInfo);\n  }\n\n  // TODO(msoulanille) remove this once the backend has been modularized\n  // a copy is needed here to break a circular dependency.\n  // Also remove the op from unary_op.\n  abs<T extends Tensor>(x: T): T {\n    // TODO: handle cases when x is complex.\n    if (this.shouldExecuteOnCPU([x]) && x.dtype !== 'complex64') {\n      const outValues =\n          simpleAbsImplCPU(this.texData.get(x.dataId).values as TypedArray);\n      return this.makeOutput(x.shape, x.dtype, outValues);\n    }\n\n    if (env().getBool('WEBGL_PACK_UNARY_OPERATIONS')) {\n      return this.packedUnaryOp(x, unary_op.ABS, x.dtype) as T;\n    }\n\n    const program = new UnaryOpProgram(x.shape, unary_op.ABS);\n    const outInfo = this.compileAndRun(program, [x]);\n    return engine().makeTensorFromTensorInfo(outInfo) as T;\n  }\n\n  makeTensorInfo(\n      shape: number[], dtype: DataType,\n      values?: BackendValues|string[]): TensorInfo {\n    let dataId;\n    if (dtype === 'string' && values != null && values.length > 0 &&\n        util.isString(values[0])) {\n      const encodedValues =\n          (values as {} as string[]).map(d => util.encodeString(d));\n\n      dataId = this.write(encodedValues, shape, dtype);\n    } else {\n      dataId = this.write(values as TypedArray, shape, dtype);\n    }\n\n    this.texData.get(dataId).usage = null;\n    return {dataId, shape, dtype};\n  }\n\n  private makeOutput<T extends Tensor>(\n      shape: number[], dtype: DataType, values?: BackendValues): T {\n    return engine().makeTensorFromTensorInfo(\n               this.makeTensorInfo(shape, dtype, values), this) as T;\n  }\n\n  unpackTensor(input: TensorInfo): TensorInfo {\n    const program = new UnpackProgram(input.shape);\n    return this.runWebGLProgram(program, [input], input.dtype);\n  }\n\n  packTensor(input: TensorInfo): TensorInfo {\n    const program = new PackProgram(input.shape);\n    const preventEagerUnpackingOutput = true;\n    return this.runWebGLProgram(\n        program, [input], input.dtype, null /* customUniformValues */,\n        preventEagerUnpackingOutput);\n  }\n\n  private packedReshape(input: TensorInfo, afterShape: number[]): TensorInfo {\n    const input3DShape = [\n      webgl_util.getBatchDim(input.shape),\n      ...webgl_util.getRowsCols(input.shape)\n    ] as [number, number, number];\n    const input3D: TensorInfo = {\n      dtype: input.dtype,\n      shape: input3DShape,\n      dataId: input.dataId\n    };\n    const afterShapeAs3D = [\n      webgl_util.getBatchDim(afterShape), ...webgl_util.getRowsCols(afterShape)\n    ] as [number, number, number];\n\n    const program = new ReshapePackedProgram(afterShapeAs3D, input3DShape);\n    const preventEagerUnpackingOfOutput = true;\n    const customValues = [input3DShape];\n    const output = this.runWebGLProgram(\n        program, [input3D], input.dtype, customValues,\n        preventEagerUnpackingOfOutput);\n    return {dataId: output.dataId, shape: afterShape, dtype: output.dtype};\n  }\n\n  private decode(dataId: DataId, customTexShape?: [number, number]):\n      TensorInfo {\n    const texData = this.texData.get(dataId);\n    const {isPacked, shape, dtype} = texData;\n    if (customTexShape != null) {\n      const size = util.sizeFromShape(shape);\n      const texSize = customTexShape[0] * customTexShape[1] * 4;\n      util.assert(\n          size <= texSize,\n          () => 'customTexShape is too small. ' +\n              'Row * Column * 4 should be equal or larger than the ' +\n              'size of the tensor data.');\n    }\n    const shapeAs3D =\n        webgl_util.getShapeAs3D(shape) as [number, number, number];\n    let program;\n    if (isPacked) {\n      program = new DecodeMatrixPackedProgram(shapeAs3D);\n    } else {\n      program = new DecodeMatrixProgram(shapeAs3D);\n    }\n    const preventEagerUnpackingOfOutput = true;\n    const customValues =\n        [customTexShape != null ? customTexShape :\n                                  tex_util.getDenseTexShape(shapeAs3D)];\n    const out = this.runWebGLProgram(\n        program, [{shape: shapeAs3D, dtype, dataId}], dtype, customValues,\n        preventEagerUnpackingOfOutput, customTexShape);\n    return {dtype, shape, dataId: out.dataId};\n  }\n\n  runWebGLProgram(\n      program: GPGPUProgram, inputs: TensorInfo[], outputDtype: DataType,\n      customUniformValues?: number[][], preventEagerUnpackingOfOutput = false,\n      customTexShape?: [number, number]): TensorInfo {\n    const output = this.makeTensorInfo(program.outputShape, outputDtype);\n    const outData = this.texData.get(output.dataId);\n    if (program.packedOutput) {\n      outData.isPacked = true;\n    }\n    if (program.outPackingScheme === tex_util.PackingScheme.DENSE) {\n      const texelShape = customTexShape != null ?\n          customTexShape :\n          tex_util.getDenseTexShape(program.outputShape);\n      // For a densely packed output, we explicitly set texShape\n      // so it doesn't get assigned later according to our typical packing\n      // scheme wherein a single texel can only contain values from adjacent\n      // rows/cols.\n      outData.texShape = texelShape.map(d => d * 2) as [number, number];\n    }\n    if (program.outTexUsage != null) {\n      outData.usage = program.outTexUsage;\n    }\n\n    if (util.sizeFromShape(output.shape) === 0) {\n      // Short-circuit the computation since the result is empty (has 0 in its\n      // shape).\n      outData.values =\n          util.getTypedArrayFromDType(output.dtype as 'float32', 0);\n      return output;\n    }\n\n    const dataToDispose: TensorInfo[] = [];\n    const inputsData: TensorData[] = inputs.map(input => {\n      if (input.dtype === 'complex64') {\n        throw new Error(\n            `GPGPUProgram does not support complex64 input. For complex64 ` +\n            `dtypes, please separate the program into real and imaginary ` +\n            `parts.`);\n      }\n\n      let texData = this.texData.get(input.dataId);\n\n      if (texData.texture == null) {\n        if (!program.packedInputs &&\n            util.sizeFromShape(input.shape) <=\n                env().getNumber('WEBGL_SIZE_UPLOAD_UNIFORM')) {\n          // Upload small tensors that live on the CPU as uniforms, not as\n          // textures. Do this only when the environment supports 32bit floats\n          // due to problems when comparing 16bit floats with 32bit floats.\n          // TODO(https://github.com/tensorflow/tfjs/issues/821): Make it\n          // possible for packed shaders to sample from uniforms.\n          return {\n            shape: input.shape,\n            texData: null,\n            isUniform: true,\n            uniformValues: texData.values as TypedArray\n          };\n        }\n\n        // This ensures that if a packed program's inputs have not yet been\n        // uploaded to the GPU, they get uploaded as packed right off the bat.\n        if (program.packedInputs) {\n          texData.isPacked = true;\n          texData.shape = input.shape;\n        }\n      }\n\n      this.uploadToGPU(input.dataId);\n      if (!!texData.isPacked !== !!program.packedInputs) {\n        input = texData.isPacked ? this.unpackTensor(input) :\n                                   this.packTensor(input);\n        dataToDispose.push(input);\n        texData = this.texData.get(input.dataId);\n      } else if (\n          texData.isPacked &&\n          !webgl_util.isReshapeFree(texData.shape, input.shape)) {\n        // This is a special case where a texture exists for a tensor\n        // but the shapes are incompatible (due to packing constraints) because\n        // the tensor did not have a chance to go through the packed reshape\n        // shader. This only happens when we reshape the *same* tensor to form\n        // *distinct* inputs to an op, e.g. dotting a vector with itself. This\n        // case will disappear once packed uploading is the default.\n\n        const savedInput = input;\n        const targetShape = input.shape;\n\n        input.shape = texData.shape;\n        input = this.packedReshape(input as Tensor, targetShape);\n        dataToDispose.push(input);\n        texData = this.texData.get(input.dataId);\n\n        savedInput.shape = targetShape;\n      }\n\n      return {shape: input.shape, texData, isUniform: false};\n    });\n\n    this.uploadToGPU(output.dataId);\n    const outputData:\n        TensorData = {shape: output.shape, texData: outData, isUniform: false};\n    const key = gpgpu_math.makeShaderKey(program, inputsData, outputData);\n    const binary = this.getAndSaveBinary(key, () => {\n      return gpgpu_math.compileProgram(\n          this.gpgpu, program, inputsData, outputData);\n    });\n    const shouldTimeProgram = this.activeTimers != null;\n    let query: WebGLQuery|CPUTimerQuery;\n    if (shouldTimeProgram) {\n      query = this.startTimer();\n    }\n\n    if (!env().get('ENGINE_COMPILE_ONLY')) {\n      gpgpu_math.runProgram(\n          this.gpgpu, binary, inputsData, outputData, customUniformValues);\n    }\n\n    dataToDispose.forEach(info => this.disposeIntermediateTensorInfo(info));\n\n    if (shouldTimeProgram) {\n      query = this.endTimer(query);\n      this.activeTimers.push(\n          {name: program.constructor.name, query: this.getQueryTime(query)});\n    }\n\n    const glFlushThreshold = env().get('WEBGL_FLUSH_THRESHOLD');\n    // Manually GL flush requested\n    if (glFlushThreshold > 0) {\n      const time = util.now();\n      if ((time - this.lastGlFlushTime) > glFlushThreshold) {\n        this.gpgpu.gl.flush();\n        this.lastGlFlushTime = time;\n      }\n    }\n\n    if (!env().getBool('WEBGL_LAZILY_UNPACK') && outData.isPacked &&\n        preventEagerUnpackingOfOutput === false) {\n      const unpacked = this.unpackTensor(output);\n      this.disposeIntermediateTensorInfo(output);\n      return unpacked;\n    }\n    return output;\n  }\n\n  compileAndRun(\n      program: GPGPUProgram, inputs: TensorInfo[], outputDtype?: DataType,\n      customUniformValues?: number[][],\n      preventEagerUnpackingOfOutput = false): TensorInfo {\n    outputDtype = outputDtype || inputs[0].dtype;\n    const outInfo = this.runWebGLProgram(\n        program, inputs, outputDtype, customUniformValues,\n        preventEagerUnpackingOfOutput);\n    return outInfo;\n  }\n\n  private getAndSaveBinary(key: string, getBinary: () => GPGPUBinary):\n      GPGPUBinary {\n    if (!(key in this.binaryCache)) {\n      this.binaryCache[key] = getBinary();\n    }\n    return this.binaryCache[key];\n  }\n\n  getTextureManager(): TextureManager {\n    return this.textureManager;\n  }\n\n  private disposed = false;\n\n  override dispose() {\n    if (this.disposed) {\n      return;\n    }\n    // Avoid disposing the compiled webgl programs during unit testing because\n    // it slows down test execution.\n    if (!env().getBool('IS_TEST')) {\n      const allKeys = Object.keys(this.binaryCache);\n      allKeys.forEach(key => {\n        this.gpgpu.deleteProgram(this.binaryCache[key].webGLProgram);\n        delete this.binaryCache[key];\n      });\n    }\n    this.textureManager.dispose();\n    if (this.canvas != null &&\n        (typeof (HTMLCanvasElement) !== 'undefined' &&\n         this.canvas instanceof HTMLCanvasElement)) {\n      this.canvas.remove();\n    } else {\n      this.canvas = null;\n    }\n    if (this.gpgpuCreatedLocally) {\n      this.gpgpu.program = null;\n      this.gpgpu.dispose();\n    }\n    this.disposed = true;\n  }\n\n  override floatPrecision(): 16|32 {\n    if (this.floatPrecisionValue == null) {\n      this.floatPrecisionValue = tidy(() => {\n        if (!env().get('WEBGL_RENDER_FLOAT32_ENABLED')) {\n          // Momentarily switching DEBUG flag to false so we don't throw an\n          // error trying to upload a small value.\n          const debugFlag = env().getBool('DEBUG');\n          env().set('DEBUG', false);\n          const underflowCheckValue = this.abs(scalar(1e-8)).dataSync()[0];\n          env().set('DEBUG', debugFlag);\n\n          if (underflowCheckValue > 0) {\n            return 32;\n          }\n        }\n        return 16;\n      });\n    }\n    return this.floatPrecisionValue;\n  }\n\n  /** Returns the smallest representable number.  */\n  override epsilon(): number {\n    return this.floatPrecision() === 32 ? EPSILON_FLOAT32 : EPSILON_FLOAT16;\n  }\n\n  uploadToGPU(dataId: DataId): void {\n    const texData = this.texData.get(dataId);\n    const {shape, dtype, values, texture, usage, isPacked} = texData;\n\n    if (texture != null) {\n      // Array is already on GPU. No-op.\n      return;\n    }\n    const shouldTimeProgram = this.activeTimers != null;\n    let start: number;\n    if (shouldTimeProgram) {\n      start = util.now();\n    }\n\n    let texShape = texData.texShape;\n    if (texShape == null) {\n      // This texShape may not be the final texture shape. For packed or dense\n      // textures, the texShape will be changed when textures are created.\n      texShape = webgl_util.getTextureShapeFromLogicalShape(shape, isPacked);\n      texData.texShape = texShape;\n    }\n\n    if (values != null) {\n      const shapeAs3D = webgl_util.getShapeAs3D(shape);\n\n      let program;\n      let width = texShape[1], height = texShape[0];\n      const isByteArray =\n          values instanceof Uint8Array || values instanceof Uint8ClampedArray;\n\n      // texture for float array is PhysicalTextureType.PACKED_2X2_FLOAT32, we\n      // need to make sure the upload uses the same packed size\n      if (isPacked || !isByteArray) {\n        [width, height] = tex_util.getPackedMatrixTextureShapeWidthHeight(\n            texShape[0], texShape[1]);\n      }\n\n      if (isPacked) {\n        program = new EncodeMatrixPackedProgram(shapeAs3D, isByteArray);\n      } else {\n        program = new EncodeMatrixProgram(shapeAs3D, isByteArray);\n      }\n\n      // TexShape for float array needs to be the original shape, which byte\n      // array needs to be packed size. This allow the data upload shape to be\n      // matched with texture creation logic.\n      const tempDenseInputTexShape: [number, number] =\n          isByteArray ? [height, width] : texShape;\n      const tempDenseInputHandle =\n          this.makeTensorInfo(tempDenseInputTexShape, dtype);\n      const tempDenseInputTexData =\n          this.texData.get(tempDenseInputHandle.dataId);\n      if (isByteArray) {\n        tempDenseInputTexData.usage = TextureUsage.PIXELS;\n      } else {\n        tempDenseInputTexData.usage = TextureUsage.UPLOAD;\n      }\n      tempDenseInputTexData.texShape = tempDenseInputTexShape;\n      this.gpgpu.uploadDenseMatrixToTexture(\n          this.getTexture(tempDenseInputHandle.dataId), width, height,\n          values as TypedArray);\n\n      const customValues = [[height, width]];\n      // We want the output to remain packed regardless of the value of\n      // WEBGL_PACK.\n      const preventEagerUnpacking = true;\n      const encodedOutputTarget = this.runWebGLProgram(\n          program, [tempDenseInputHandle], dtype, customValues,\n          preventEagerUnpacking);\n\n      // Have the original texture assume the identity of the encoded output.\n      const outputTexData = this.texData.get(encodedOutputTarget.dataId);\n      texData.texShape = outputTexData.texShape;\n      texData.isPacked = outputTexData.isPacked;\n      texData.usage = outputTexData.usage;\n\n      if (!env().get('ENGINE_COMPILE_ONLY')) {\n        texData.texture = outputTexData.texture;\n        // Once uploaded, don't store the values on cpu.\n        texData.values = null;\n        this.texData.delete(encodedOutputTarget.dataId);\n      } else {\n        this.disposeData(encodedOutputTarget.dataId);\n      }\n\n      this.disposeIntermediateTensorInfo(tempDenseInputHandle);\n\n      if (shouldTimeProgram) {\n        this.uploadWaitMs += util.now() - start;\n      }\n    } else {\n      const newTexture = this.acquireTexture(texShape, usage, dtype, isPacked);\n      texData.texture = newTexture;\n    }\n  }\n\n  private convertAndCacheOnCPU(dataId: DataId, float32Values?: Float32Array):\n      TypedArray {\n    const texData = this.texData.get(dataId);\n    const {dtype} = texData;\n\n    if (float32Values != null) {\n      texData.values = float32ToTypedArray(float32Values, dtype as 'float32');\n    }\n    return texData.values as TypedArray;\n  }\n\n  private acquireTexture(\n      texShape: [number, number], texType: TextureUsage, dtype: DataType,\n      isPacked: boolean): Texture {\n    this.numBytesInGPU += this.computeBytes(texShape, dtype);\n    if (!this.warnedAboutMemory &&\n        this.numBytesInGPU > this.numMBBeforeWarning * 1024 * 1024) {\n      const mb = (this.numBytesInGPU / 1024 / 1024).toFixed(2);\n      this.warnedAboutMemory = true;\n      console.warn(\n          `High memory usage in GPU: ${mb} MB, ` +\n          `most likely due to a memory leak`);\n    }\n    return this.textureManager.acquireTexture(texShape, texType, isPacked);\n  }\n\n  private computeBytes(shape: [number, number], dtype: DataType) {\n    return shape[0] * shape[1] * util.bytesPerElement(dtype);\n  }\n\n  checkCompileCompletion() {\n    for (const [, binary] of Object.entries(this.binaryCache)) {\n      this.checkCompletion_(binary);\n    }\n  }\n\n  async checkCompileCompletionAsync(): Promise<boolean[]> {\n    const ps = [];\n    if (this.gpgpu.parallelCompilationExtension) {\n      for (const [, binary] of Object.entries(this.binaryCache)) {\n        ps.push(this.checkCompletionAsync_(binary));\n      }\n      return Promise.all(ps);\n    } else {\n      for (const [, binary] of Object.entries(this.binaryCache)) {\n        const p: Promise<boolean> = new Promise((resolve) => {\n          try {\n            this.checkCompletion_(binary);\n            resolve(true);\n          } catch (error) {\n            throw error;\n          }\n        });\n        ps.push(p);\n      }\n      return Promise.all(ps);\n    }\n  }\n\n  private async checkCompletionAsync_(binary: GPGPUBinary): Promise<boolean> {\n    if (this.gpgpu.gl.getProgramParameter(\n            binary.webGLProgram,\n            this.gpgpu.parallelCompilationExtension.COMPLETION_STATUS_KHR)) {\n      return this.checkCompletion_(binary);\n    } else {\n      await nextFrame();\n      return this.checkCompletionAsync_(binary);\n    }\n  }\n\n  private checkCompletion_(binary: GPGPUBinary): boolean {\n    if (this.gpgpu.gl.getProgramParameter(\n            binary.webGLProgram, this.gpgpu.gl.LINK_STATUS) === false) {\n      console.log(this.gpgpu.gl.getProgramInfoLog(binary.webGLProgram));\n      if (this.gpgpu.gl.getShaderParameter(\n              binary.fragmentShader, this.gpgpu.gl.COMPILE_STATUS) === false) {\n        webgl_util.logShaderSourceAndInfoLog(\n            binary.source,\n            this.gpgpu.gl.getShaderInfoLog(binary.fragmentShader));\n        throw new Error('Failed to compile fragment shader.');\n      }\n      throw new Error('Failed to link vertex and fragment shaders.');\n    }\n    return true;\n  }\n\n  getUniformLocations() {\n    for (const [, binary] of Object.entries(this.binaryCache)) {\n      const {\n        uniformLocations,\n        customUniformLocations,\n        infLoc,\n        nanLoc,\n        inShapesLocations,\n        inTexShapesLocations,\n        outShapeLocation,\n        outShapeStridesLocation,\n        outTexShapeLocation\n      } = getUniformLocations(this.gpgpu, binary.program, binary.webGLProgram);\n      binary.uniformLocations = uniformLocations;\n      binary.customUniformLocations = customUniformLocations;\n      binary.infLoc = infLoc;\n      binary.nanLoc = nanLoc;\n      binary.inShapesLocations = inShapesLocations;\n      binary.inTexShapesLocations = inTexShapesLocations;\n      binary.outShapeLocation = outShapeLocation;\n      binary.outShapeStridesLocation = outShapeStridesLocation;\n      binary.outTexShapeLocation = outTexShapeLocation;\n    }\n  }\n\n  /**\n   * Create a TF.js tensor out of an existing WebGL texture. A new texture will\n   * be created.\n   */\n  override createTensorFromTexture(values: WebGLData, shape: number[],\n      dtype: DataType): Tensor {\n    const {texture, height, width, channels} = values;\n    const backend = engine().backend as MathBackendWebGL;\n\n    // Have to throw an error, otherwise WebGL just warns and returns wrong\n    // values.\n    if (!backend.gpgpu.gl.isTexture(texture)) {\n      throw new Error(\n          `The texture is invalid. Also, please make sure the texture and ` +\n          `the TFJS WebGL backend are using the same canvas. If you want to ` +\n          `use your own custom canvas, you have to create and use the custom ` +\n          `TFJS WebGL backend created from the canvas through ` +\n          `'new tf.MathBackendWebGL(customCanvas)'.`);\n    }\n\n    const dataId =\n        backend.writeTexture(texture, shape, dtype, height, width, channels);\n    return engine().makeTensorFromDataId(dataId, shape, dtype, backend);\n  }\n}\n\nfunction float32ToTypedArray<D extends NumericDataType>(\n    a: Float32Array, dtype: D): tf.DataTypeMap[D] {\n  if (dtype === 'float32' || dtype === 'complex64') {\n    return a as tf.DataTypeMap[D];\n  } else if (dtype === 'int32' || dtype === 'bool') {\n    const result = (dtype === 'int32') ? new Int32Array(a.length) :\n                                         new Uint8Array(a.length);\n    for (let i = 0; i < result.length; ++i) {\n      result[i] = Math.round(a[i]);\n    }\n    return result as tf.DataTypeMap[D];\n  } else {\n    throw new Error(`Unknown dtype ${dtype}`);\n  }\n}\n","/**\n * @license\n * Copyright 2020 Google Inc. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\n// base.ts is the webgl backend without auto kernel registration.\n\nimport {device_util, registerBackend} from '@tensorflow/tfjs-core';\nimport {MathBackendWebGL} from './backend_webgl';\nexport {version as version_webgl} from './version';\n\nif (device_util.isBrowser()) {\n  registerBackend('webgl', () => new MathBackendWebGL(), 2 /* priority */);\n}\n\n// Export webgl utilities\nexport * from './webgl';\n\n// Export forceHalfFlost under webgl namespace for the union bundle.\nimport {forceHalfFloat} from './webgl';\nexport const webgl = {forceHalfFloat};\n","/**\n * @license\n * Copyright 2017 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {backend_util} from '@tensorflow/tfjs-core';\n\nimport {GPGPUProgram, useShapeUniforms} from './gpgpu_math';\n\nexport const CHECK_NAN_SNIPPET = `\n  if (isnan(a)) return a;\n  if (isnan(b)) return b;\n`;\n\nexport const SQUARED_DIFFERENCE = 'return (a - b) * (a - b);';\nexport class BinaryOpProgram implements GPGPUProgram {\n  variableNames = ['A', 'B'];\n  outputShape: number[];\n  userCode: string;\n  enableShapeUniforms: boolean;\n\n  constructor(op: string, aShape: number[], bShape: number[]) {\n    this.outputShape = backend_util.assertAndGetBroadcastShape(aShape, bShape);\n    this.enableShapeUniforms = useShapeUniforms(this.outputShape.length);\n    this.userCode = `\n      float binaryOperation(float a, float b) {\n        ${op}\n      }\n\n      void main() {\n        float a = getAAtOutCoords();\n        float b = getBAtOutCoords();\n        setOutput(binaryOperation(a, b));\n      }\n    `;\n  }\n}\n","/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {backend_util, util} from '@tensorflow/tfjs-core';\n\nimport {GPGPUProgram, useShapeUniforms} from './gpgpu_math';\nimport {getChannels} from './packing_util';\nimport {getCoordsDataType} from './shader_compiler';\n\nexport const CHECK_NAN_SNIPPET_PACKED = `\n  result.r = isNaN.r ? NAN : result.r;\n  result.g = isNaN.g ? NAN : result.g;\n  result.b = isNaN.b ? NAN : result.b;\n  result.a = isNaN.a ? NAN : result.a;\n`;\n\nexport const ELU_DER = `\n  vec4 bGTEZero = vec4(greaterThanEqual(b, vec4(0.)));\n  return (bGTEZero * a) + ((vec4(1.0) - bGTEZero) * (a * (b + vec4(1.0))));\n`;\n\nexport const NOT_EQUAL = `\n  return vec4(notEqual(a, b));\n`;\n\nexport class BinaryOpPackedProgram implements GPGPUProgram {\n  variableNames = ['A', 'B'];\n  outputShape: number[];\n  userCode: string;\n  supportsBroadcasting = true;\n  packedInputs = true;\n  packedOutput = true;\n  enableShapeUniforms: boolean;\n\n  constructor(\n      op: string, aShape: number[], bShape: number[],\n      checkOutOfBounds = false) {\n    this.outputShape = backend_util.assertAndGetBroadcastShape(aShape, bShape);\n    const rank = this.outputShape.length;\n    this.enableShapeUniforms = useShapeUniforms(rank);\n    let checkOutOfBoundsString = '';\n    if (checkOutOfBounds) {\n      if (rank === 0 || util.sizeFromShape(this.outputShape) === 1) {\n        checkOutOfBoundsString = `\n          result.y = 0.;\n          result.z = 0.;\n          result.w = 0.;\n        `;\n      } else {\n        const dtype = getCoordsDataType(rank);\n        checkOutOfBoundsString = `\n          ${dtype} coords = getOutputCoords();\n        `;\n        if (rank === 1) {\n          if (this.enableShapeUniforms) {\n            checkOutOfBoundsString += `\n            result.y = (coords + 1) >= outShape ? 0. : result.y;\n            result.z = 0.;\n            result.w = 0.;\n          `;\n          } else {\n            checkOutOfBoundsString += `\n            result.y = (coords + 1) >= ${this.outputShape[0]} ? 0. : result.y;\n            result.z = 0.;\n            result.w = 0.;\n          `;\n          }\n        } else {\n          const channels = getChannels('coords', rank);\n          if (this.enableShapeUniforms) {\n            checkOutOfBoundsString += `\n            bool nextRowOutOfBounds =\n              (${channels[rank - 2]} + 1) >= outShape[${rank} - 2];\n            bool nextColOutOfBounds =\n              (${channels[rank - 1]} + 1) >= outShape[${rank} - 1];\n            result.y = nextColOutOfBounds ? 0. : result.y;\n            result.z = nextRowOutOfBounds ? 0. : result.z;\n            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;\n          `;\n          } else {\n            checkOutOfBoundsString += `\n            bool nextRowOutOfBounds =\n              (${channels[rank - 2]} + 1) >= ${this.outputShape[rank - 2]};\n            bool nextColOutOfBounds =\n              (${channels[rank - 1]} + 1) >= ${this.outputShape[rank - 1]};\n            result.y = nextColOutOfBounds ? 0. : result.y;\n            result.z = nextRowOutOfBounds ? 0. : result.z;\n            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;\n          `;\n          }\n        }\n      }\n    }\n\n    this.userCode = `\n      vec4 binaryOperation(vec4 a, vec4 b) {\n        ${op}\n      }\n\n      void main() {\n        vec4 a = getAAtOutCoords();\n        vec4 b = getBAtOutCoords();\n\n        vec4 result = binaryOperation(a, b);\n        ${checkOutOfBoundsString}\n\n        setOutput(result);\n      }\n    `;\n  }\n}\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {Identity, IdentityInputs, KernelConfig, KernelFunc, TensorInfo} from '@tensorflow/tfjs-core';\n\nimport {MathBackendWebGL} from '../backend_webgl';\n\nexport function identity(\n    args: {inputs: IdentityInputs, backend: MathBackendWebGL}): TensorInfo {\n  const {inputs, backend} = args;\n  const {x} = inputs;\n\n  backend.incRef(x.dataId);\n\n  return {dataId: x.dataId, shape: x.shape, dtype: x.dtype};\n}\n\nexport const identityConfig: KernelConfig = {\n  kernelName: Identity,\n  backendName: 'webgl',\n  kernelFunc: identity as {} as KernelFunc\n};\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {Complex, ComplexInputs, KernelConfig, KernelFunc, TensorInfo} from '@tensorflow/tfjs-core';\n\nimport {MathBackendWebGL} from '../backend_webgl';\nimport {identity} from './Identity';\n\n/**\n * In WebGL data is stored in GPU textures which can't be efficiently copied, so\n * complex tensors share data with their real and imaginary components. Complex\n * tensors' reference to the components is tracked by refCount on the individual\n * component. The refCounts are increased by the identity call.\n *\n * When a complex tensor is disposed, it will reduce the refCount on the\n * components by calling disposeData on each.\n */\nexport function complex(\n    args: {inputs: ComplexInputs, backend: MathBackendWebGL}): TensorInfo {\n  const {inputs, backend} = args;\n  const {real, imag} = inputs;\n\n  const complexInfo = backend.makeTensorInfo(real.shape, 'complex64');\n  const complex = backend.texData.get(complexInfo.dataId);\n\n  const realTensorInfo = identity({inputs: {x: real}, backend});\n\n  const imagTensorInfo = identity({inputs: {x: imag}, backend});\n\n  complex.complexTensorInfos = {real: realTensorInfo, imag: imagTensorInfo};\n\n  return complexInfo;\n}\n\nexport const complexConfig: KernelConfig = {\n  kernelName: Complex,\n  backendName: 'webgl',\n  kernelFunc: complex as {} as KernelFunc\n};\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {env, KernelConfig, KernelFunc, LeakyRelu, LeakyReluAttrs, LeakyReluInputs, TensorInfo, util} from '@tensorflow/tfjs-core';\nimport {MathBackendWebGL} from '../backend_webgl';\nimport {BinaryOpProgram} from '../binaryop_gpu';\nimport {BinaryOpPackedProgram} from '../binaryop_packed_gpu';\n\nexport const LEAKYRELU = `return (a < 0.) ? b * a : a;`;\nexport const LEAKYRELU_PACKED = `\n  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));\n  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);\n`;\n\nexport function leakyRelu(args: {\n  inputs: LeakyReluInputs,\n  backend: MathBackendWebGL,\n  attrs: LeakyReluAttrs\n}): TensorInfo {\n  const {inputs, backend, attrs} = args;\n  const {x} = inputs;\n  const {alpha} = attrs;\n\n  const $alpha = backend.makeTensorInfo(\n      [], 'float32',\n      util.createScalarValue(alpha as {} as 'float32', 'float32'));\n\n  const program = env().getBool('WEBGL_PACK_BINARY_OPERATIONS') ?\n      new BinaryOpPackedProgram(LEAKYRELU_PACKED, x.shape, $alpha.shape) :\n      new BinaryOpProgram(LEAKYRELU, x.shape, $alpha.shape);\n  const result = backend.runWebGLProgram(program, [x, $alpha], 'float32');\n\n  backend.disposeIntermediateTensorInfo($alpha);\n\n  return result;\n}\n\nexport const leakyReluConfig: KernelConfig = {\n  kernelName: LeakyRelu,\n  backendName: 'webgl',\n  kernelFunc: leakyRelu as {} as KernelFunc\n};\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {env, KernelConfig, KernelFunc, Prelu, PreluInputs, TensorInfo} from '@tensorflow/tfjs-core';\n\nimport {MathBackendWebGL} from '../backend_webgl';\nimport {BinaryOpProgram} from '../binaryop_gpu';\nimport {BinaryOpPackedProgram} from '../binaryop_packed_gpu';\n\nexport const PRELU = `return (a < 0.) ? b * a : a;`;\nexport const PRELU_PACKED = `\n  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));\n  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);\n`;\n\nexport function prelu(args: {inputs: PreluInputs, backend: MathBackendWebGL}):\n    TensorInfo {\n  const {inputs, backend} = args;\n  const {x, alpha} = inputs;\n\n  const program = env().getBool('WEBGL_PACK_BINARY_OPERATIONS') ?\n      new BinaryOpPackedProgram(PRELU_PACKED, x.shape, alpha.shape) :\n      new BinaryOpProgram(PRELU, x.shape, alpha.shape);\n  return backend.runWebGLProgram(program, [x, alpha], 'float32');\n}\n\nexport const preluConfig: KernelConfig = {\n  kernelName: Prelu,\n  backendName: 'webgl',\n  kernelFunc: prelu as {} as KernelFunc\n};\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {backend_util, BinaryInputs, DataType, env, KernelFunc, TypedArray, UnaryInputs, upcastType} from '@tensorflow/tfjs-core';\n\nimport {MathBackendWebGL} from '../backend_webgl';\nimport {BinaryOpProgram} from '../binaryop_gpu';\nimport {BinaryOpPackedProgram} from '../binaryop_packed_gpu';\nimport {complex} from '../kernels/Complex';\nimport {LEAKYRELU, LEAKYRELU_PACKED} from '../kernels/LeakyRelu';\nimport {PRELU, PRELU_PACKED} from '../kernels/Prelu';\nimport * as unary_op from '../unaryop_gpu';\nimport {UnaryOpProgram} from '../unaryop_gpu';\nimport * as unary_packed_op from '../unaryop_packed_gpu';\nimport {UnaryOpPackedProgram} from '../unaryop_packed_gpu';\n\nimport {SimpleBinaryKernelImplCPU, SimpleUnaryKernelImplCPU} from './shared';\n\nexport const CHECK_NAN_SNIPPET_UNARY = `if (isnan(x)) return x;`;\n\ntype UnaryKernelFuncConfig = {\n  opSnippet: string,\n  packedOpSnippet?: string,\n  cpuKernelImpl?: SimpleUnaryKernelImplCPU,\n  dtype?: DataType\n};\n\n/**\n * Template that creates a `KernelFunc` for unary ops.\n * @param opSnippet Op snippet to create `UnaryOpProgram`.\n * @param packedOpSnippet Op snippet to create `UnaryOpPackedProgram`.\n * @param dtype Optional. If set, the result has this dtype. Otherwise, the\n *     result has the same dtype as the first input. This is mainly used in\n *     comparison kernels, such as Equal, Less, Greater, etc.\n */\nexport function unaryKernelFunc(\n    {opSnippet, packedOpSnippet, cpuKernelImpl, dtype}: UnaryKernelFuncConfig):\n    KernelFunc {\n  return ({inputs, backend}) => {\n    const {x} = inputs as UnaryInputs;\n    const webglBackend = backend as MathBackendWebGL;\n\n    const $dtype = dtype || x.dtype;\n    if (webglBackend.shouldExecuteOnCPU([x]) && cpuKernelImpl != null) {\n      const xData = webglBackend.texData.get(x.dataId);\n      const outValues = cpuKernelImpl(xData.values as TypedArray, $dtype);\n      return webglBackend.makeTensorInfo(x.shape, $dtype, outValues);\n    }\n\n    const shouldUsePackedProgram =\n        env().getBool('WEBGL_PACK_UNARY_OPERATIONS') && packedOpSnippet != null;\n    let program: UnaryOpProgram|UnaryOpPackedProgram;\n    if (shouldUsePackedProgram) {\n      program = new UnaryOpPackedProgram(x.shape, packedOpSnippet);\n    } else {\n      program = new UnaryOpProgram(x.shape, opSnippet);\n    }\n\n    return webglBackend.runWebGLProgram(program, [x], $dtype);\n  };\n}\n\ntype BinaryKernelFuncConfig = {\n  opSnippet: string,\n  packedOpSnippet?: string,\n  checkOutOfBounds?: boolean,\n  supportsComplex?: boolean,\n  cpuKernelImpl?: SimpleBinaryKernelImplCPU,\n  dtype?: DataType\n};\n\n/**\n * Template that creates a `KernelFunc` for binary ops.\n * @param opSnippet Op snippet to create `BinaryOpProgram`.\n * @param packedOpSnippet Op snippet to create `BinaryOpPackedProgram`.\n * @param checkOutOfBoundsForPackedProgram Whether to set checkOutOfBounds=true\n *     when creating BinaryOpPackedProgram.\n * @param dtype Optional. If set, the result has this dtype. Otherwise, the\n *     result has the same dtype as the first input. This is mainly used in\n *     comparison kernels, such as Equal, Less, Greater, etc.\n */\nexport function binaryKernelFunc({\n  opSnippet,\n  packedOpSnippet,\n  checkOutOfBounds = false,\n  supportsComplex = false,\n  cpuKernelImpl,\n  dtype\n}: BinaryKernelFuncConfig): KernelFunc {\n  return ({inputs, backend}) => {\n    const {a, b} = inputs as BinaryInputs;\n    const webglBackend = backend as MathBackendWebGL;\n\n    if (supportsComplex && a.dtype === 'complex64') {\n      const aData = webglBackend.texData.get(a.dataId);\n      const bData = webglBackend.texData.get(b.dataId);\n\n      const [real, imag] = [\n        [aData.complexTensorInfos.real, bData.complexTensorInfos.real],\n        [aData.complexTensorInfos.imag, bData.complexTensorInfos.imag]\n      ].map(complexParts => {\n        const [aPart, bPart] = complexParts;\n\n        const aHandle = {\n          dataId: aPart.dataId,\n          dtype: aPart.dtype,\n          shape: a.shape\n        };\n        const bHandle = {\n          dataId: bPart.dataId,\n          dtype: bPart.dtype,\n          shape: b.shape\n        };\n\n        const program = new BinaryOpProgram(opSnippet, a.shape, b.shape);\n        return webglBackend.runWebGLProgram(\n            program, [aHandle, bHandle], upcastType(aPart.dtype, bPart.dtype));\n      });\n\n      const complexOutput =\n          complex({inputs: {real, imag}, backend: webglBackend});\n\n      webglBackend.disposeIntermediateTensorInfo(real);\n      webglBackend.disposeIntermediateTensorInfo(imag);\n\n      // TODO(annxingyuan): Implement CPU forwarding for complex inputs.\n\n      return complexOutput;\n    }\n\n    const $dtype = dtype || upcastType(a.dtype, b.dtype);\n    if ((a.dtype === 'string' || b.dtype === 'string' ||\n         webglBackend.shouldExecuteOnCPU([a, b])) &&\n        cpuKernelImpl != null) {\n      const aVals = webglBackend.texData.get(a.dataId).values as TypedArray;\n      const bVals = webglBackend.texData.get(b.dataId).values as TypedArray;\n\n      const decodedAVals = a.dtype === 'string' ?\n          // tslint:disable-next-line: no-any\n          backend_util.fromUint8ToStringArray(aVals as any as Uint8Array[]) :\n          aVals;\n      const decodedBVals = a.dtype === 'string' ?\n          // tslint:disable-next-line: no-any\n          backend_util.fromUint8ToStringArray(bVals as any as Uint8Array[]) :\n          bVals;\n      const [outValues, outShape] =\n          cpuKernelImpl(a.shape, b.shape, decodedAVals, decodedBVals, $dtype);\n\n      const out = webglBackend.makeTensorInfo(outShape, $dtype);\n      const outData = webglBackend.texData.get(out.dataId);\n      outData.values = outValues;\n      return out;\n    }\n\n    const shouldUsePackedProgram =\n        env().getBool('WEBGL_PACK_BINARY_OPERATIONS') &&\n        packedOpSnippet != null;\n    let program: BinaryOpProgram|BinaryOpPackedProgram;\n    if (shouldUsePackedProgram) {\n      program = new BinaryOpPackedProgram(\n          packedOpSnippet, a.shape, b.shape, checkOutOfBounds);\n    } else {\n      program = new BinaryOpProgram(opSnippet, a.shape, b.shape);\n    }\n\n    return webglBackend.runWebGLProgram(program, [a, b], $dtype);\n  };\n}\n\nexport function mapActivationToShaderProgram(\n    activation: backend_util.Activation, packed = false): string {\n  if (activation === 'linear') {\n    if (packed) {\n      return unary_packed_op.LINEAR;\n    }\n    return unary_op.LINEAR;\n  } else if (activation === 'relu') {\n    if (packed) {\n      return unary_packed_op.RELU;\n    }\n    return unary_op.RELU;\n  } else if (activation === 'elu') {\n    if (packed) {\n      return unary_packed_op.ELU;\n    }\n    return unary_op.ELU;\n  } else if (activation === 'relu6') {\n    if (packed) {\n      return unary_packed_op.RELU6;\n    }\n    return unary_op.RELU6;\n  } else if (activation === 'prelu') {\n    if (packed) {\n      return PRELU_PACKED;\n    }\n    return PRELU;\n  } else if (activation === 'leakyrelu') {\n    if (packed) {\n      return LEAKYRELU_PACKED;\n    }\n    return LEAKYRELU;\n  } else if (activation === 'sigmoid') {\n    if (packed) {\n      return unary_packed_op.SIGMOID;\n    }\n    return unary_op.SIGMOID;\n  }\n  throw new Error(`Activation ${\n      activation} has not been implemented for the WebGL backend.`);\n}\n","/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {GPGPUProgram, useShapeUniforms} from './gpgpu_math';\n\nexport class MatMulPackedProgram implements GPGPUProgram {\n  variableNames = ['matrixA', 'matrixB'];\n  packedInputs = true;\n  packedOutput = true;\n  outputShape: number[];\n  userCode: string;\n  enableShapeUniforms: boolean;\n\n  constructor(\n      aShape: [number, number, number], bShape: [number, number, number],\n      outputShape: [number, number, number], transposeA = false,\n      transposeB = false, addBias = false, activation: string = null,\n      hasPreluActivation = false, hasLeakyreluActivation = false) {\n    this.outputShape = outputShape;\n    this.enableShapeUniforms = useShapeUniforms(this.outputShape.length);\n\n    const sharedDim = transposeA ? aShape[1] : aShape[2];\n    const sharedDimensionPacked = Math.ceil(sharedDim / 2);\n\n    const aSample = transposeA ? 'i * 2, rc.y' : 'rc.y, i * 2';\n    const bSample = transposeB ? 'rc.z, i * 2' : 'i * 2, rc.z';\n    const aSwizzle = transposeA ? ['a.xxyy', 'a.zzww'] : ['a.xxzz', 'a.yyww'];\n    const bSwizzle = transposeB ? ['b.xzxz', 'b.ywyw'] : ['b.xyxy', 'b.zwzw'];\n\n    let activationSnippet = '', applyActivationSnippet = '';\n    if (activation) {\n      if (hasPreluActivation) {\n        activationSnippet = `vec4 activation(vec4 a) {\n          vec4 b = getPreluActivationWeightsAtOutCoords();\n          ${activation}\n        }`;\n      } else if (hasLeakyreluActivation) {\n        activationSnippet = `vec4 activation(vec4 a) {\n          vec4 b = getLeakyreluAlphaAtOutCoords();\n          ${activation}\n        }`;\n      } else {\n        activationSnippet = `vec4 activation(vec4 x) {\n          ${activation}\n        }`;\n      }\n\n      applyActivationSnippet = `result = activation(result);`;\n    }\n\n    const addBiasSnippet = addBias ? 'result += getBiasAtOutCoords();' : '';\n    if (addBias) {\n      this.variableNames.push('bias');\n    }\n\n    if (hasPreluActivation) {\n      this.variableNames.push('preluActivationWeights');\n    }\n\n    if (hasLeakyreluActivation) {\n      this.variableNames.push('leakyreluAlpha');\n    }\n\n    let batchASnippet = 'rc.x';\n    let batchBSnippet = 'rc.x';\n    if (aShape[0] < bShape[0]) {\n      batchASnippet = `int(min(float(rc.x), ${aShape[0] - 1}.))`;\n    } else if (bShape[0] < aShape[0]) {\n      batchBSnippet = `int(min(float(rc.x), ${bShape[0] - 1}.))`;\n    }\n\n    this.userCode = `\n      ${activationSnippet}\n      // Don't use uniform for sharedDimensionPacked for performance.\n      const float sharedDimension = ${sharedDimensionPacked}.0;\n\n      vec4 dot2x2ARowBCol(ivec3 rc) {\n        vec4 result = vec4(0);\n        for (int i = 0; i < ${sharedDimensionPacked}; i++) {\n          int batchA = ${batchASnippet};\n          int batchB = ${batchBSnippet};\n          vec4 a = getMatrixA(batchA, ${aSample});\n          vec4 b = getMatrixB(batchB, ${bSample});\n\n          // These swizzled products need to be separately added.\n          // See: https://github.com/tensorflow/tfjs/issues/1735\n          result += (${aSwizzle[0]} * ${bSwizzle[0]});\n          result += (${aSwizzle[1]} * ${bSwizzle[1]});\n        }\n        return result;\n      }\n\n      void main() {\n        ivec3 rc = getOutputCoords();\n        vec4 result = dot2x2ARowBCol(rc);\n\n        ${addBiasSnippet}\n\n        ${applyActivationSnippet}\n\n        setOutput(result);\n      }\n    `;\n  }\n}\n","/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {backend_util} from '@tensorflow/tfjs-core';\nimport {GPGPUProgram} from './gpgpu_math';\n\n// (Ar + Ai)(Br + Bi) =\n// ArBr + ArBi + AiBr + AiBi = ArBr - AB + ArBi + AiBr\n// Yr = ArBr - AB\n// Yi = ArBi + AiBr\nexport const COMPLEX_MULTIPLY = {\n  REAL: 'return areal * breal - aimag * bimag;',\n  IMAG: 'return areal * bimag + aimag * breal;'\n};\n\nexport class BinaryOpComplexProgram implements GPGPUProgram {\n  variableNames = ['AReal', 'AImag', 'BReal', 'BImag'];\n  userCode: string;\n  outputShape: number[];\n\n  constructor(op: string, aShape: number[], bShape: number[]) {\n    this.outputShape = backend_util.assertAndGetBroadcastShape(aShape, bShape);\n\n    this.userCode = `\n      float binaryOpComplex(\n          float areal, float aimag, float breal, float bimag) {\n        ${op}\n      }\n\n      void main() {\n        float areal = getARealAtOutCoords();\n        float aimag = getAImagAtOutCoords();\n        float breal = getBRealAtOutCoords();\n        float bimag = getBImagAtOutCoords();\n        setOutput(binaryOpComplex(areal, aimag, breal, bimag));\n      }\n    `;\n  }\n}\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {backend_util, BinaryInputs, env, KernelConfig, Multiply, TensorInfo, TypedArray} from '@tensorflow/tfjs-core';\n\nimport {MathBackendWebGL} from '../backend_webgl';\nimport * as binaryop_complex_gpu from '../binaryop_complex_gpu';\nimport {BinaryOpComplexProgram} from '../binaryop_complex_gpu';\nimport {BinaryOpProgram} from '../binaryop_gpu';\nimport {BinaryOpPackedProgram} from '../binaryop_packed_gpu';\nimport {multiplyImplCPU as cpuMultiply} from '../kernel_utils/shared';\n\nimport {complex} from './Complex';\n\nconst MUL = 'return a * b;';\n\nexport function multiply(\n    args: {inputs: BinaryInputs, backend: MathBackendWebGL}): TensorInfo {\n  const {inputs, backend} = args;\n  const {a, b} = inputs;\n  const dtype = backend_util.upcastType(a.dtype, b.dtype);\n\n  if (a.dtype === 'complex64') {\n    const aData = backend.texData.get(a.dataId);\n    const bData = backend.texData.get(b.dataId);\n\n    const realProgram = new BinaryOpComplexProgram(\n        binaryop_complex_gpu.COMPLEX_MULTIPLY.REAL, a.shape, b.shape);\n    const imagProgram = new BinaryOpComplexProgram(\n        binaryop_complex_gpu.COMPLEX_MULTIPLY.IMAG, a.shape, b.shape);\n\n    const inputs = [\n      {\n        dataId: aData.complexTensorInfos.real.dataId,\n        dtype: aData.complexTensorInfos.real.dtype,\n        shape: a.shape\n      },\n      {\n        dataId: aData.complexTensorInfos.imag.dataId,\n        dtype: aData.complexTensorInfos.imag.dtype,\n        shape: a.shape\n      },\n      {\n        dataId: bData.complexTensorInfos.real.dataId,\n        dtype: bData.complexTensorInfos.real.dtype,\n        shape: b.shape\n      },\n      {\n        dataId: bData.complexTensorInfos.imag.dataId,\n        dtype: bData.complexTensorInfos.imag.dtype,\n        shape: b.shape\n      }\n    ];\n\n    const realPart = backend.runWebGLProgram(realProgram, inputs, 'float32');\n    const imagPart = backend.runWebGLProgram(imagProgram, inputs, 'float32');\n\n    const complexOutput =\n        complex({inputs: {real: realPart, imag: imagPart}, backend});\n\n    backend.disposeIntermediateTensorInfo(realPart);\n    backend.disposeIntermediateTensorInfo(imagPart);\n\n    // TODO(annxingyuan): CPU forwarding for complex inputs.\n    return complexOutput;\n  }\n\n  if (backend.shouldExecuteOnCPU([a, b])) {\n    const aData = backend.texData.get(a.dataId);\n    const bData = backend.texData.get(b.dataId);\n    const [outValues, outShape] = cpuMultiply(\n        a.shape, b.shape, aData.values as TypedArray,\n        bData.values as TypedArray, dtype);\n\n    const out = backend.makeTensorInfo(outShape, dtype);\n    const outData = backend.texData.get(out.dataId);\n    outData.values = outValues;\n    return out;\n  }\n\n  let program: BinaryOpProgram|BinaryOpPackedProgram;\n  if (env().getBool('WEBGL_PACK_BINARY_OPERATIONS')) {\n    program = new BinaryOpPackedProgram(MUL, a.shape, b.shape);\n  } else {\n    program = new BinaryOpProgram(MUL, a.shape, b.shape);\n  }\n\n  return backend.runWebGLProgram(program, [a, b], dtype);\n}\n\nexport const multiplyConfig: KernelConfig = {\n  kernelName: Multiply,\n  backendName: 'webgl',\n  kernelFunc: multiply\n};\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {KernelConfig, KernelFunc, Reshape, ReshapeAttrs, ReshapeInputs, TensorInfo, util} from '@tensorflow/tfjs-core';\n\nimport {MathBackendWebGL} from '../backend_webgl';\nimport {packedReshape} from '../kernel_utils/reshape';\nimport {isReshapeFree} from '../webgl_util';\n\nexport function reshape(args: {\n  inputs: ReshapeInputs,\n  backend: MathBackendWebGL,\n  attrs: ReshapeAttrs\n}): TensorInfo {\n  const {inputs, backend, attrs} = args;\n  const {x} = inputs;\n  const {shape} = attrs;\n  const webglBackend = backend;\n\n  const xSize = util.sizeFromShape(x.shape);\n  const $shape = util.inferFromImplicitShape(shape, xSize);\n  const $xSize = util.sizeFromShape($shape);\n\n  util.assert(\n      xSize === $xSize,\n      () => `The new shape (${$shape}) has ${$xSize} elements and the old ` +\n          `shape (${x.shape}) has ${xSize} elements. The new shape and old ` +\n          `shape must have the same number of elements.`);\n\n  const xTexData = webglBackend.texData.get(x.dataId);\n  if (xTexData.isPacked && !isReshapeFree(x.shape, $shape) &&\n      !(xTexData.texture !== null && isReshapeFree(xTexData.shape, $shape))) {\n    return packedReshape(x, $shape, webglBackend);\n  }\n\n  webglBackend.incRef(x.dataId);\n\n  return {dataId: x.dataId, shape: $shape, dtype: x.dtype};\n}\n\nexport const reshapeConfig: KernelConfig = {\n  kernelName: Reshape,\n  backendName: 'webgl',\n  kernelFunc: reshape as {} as KernelFunc\n};\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {TensorInfo} from '@tensorflow/tfjs-core';\n\nimport {MathBackendWebGL} from '../backend_webgl';\nimport {ReshapePackedProgram} from '../reshape_packed_gpu';\nimport {getBatchDim, getRowsCols} from '../webgl_util';\n\nexport function packedReshape(\n    input: TensorInfo, afterShape: number[],\n    backend: MathBackendWebGL): TensorInfo {\n  const input3DShape =\n      [getBatchDim(input.shape),\n       ...getRowsCols(input.shape)] as [number, number, number];\n  const input3D: TensorInfo = {\n    dtype: input.dtype,\n    shape: input3DShape,\n    dataId: input.dataId\n  };\n  const afterShapeAs3D =\n      [getBatchDim(afterShape),\n       ...getRowsCols(afterShape)] as [number, number, number];\n\n  const program = new ReshapePackedProgram(afterShapeAs3D, input3DShape);\n  const preventEagerUnpackingOfOutput = true;\n  const customValues = [input3DShape];\n  const output = backend.runWebGLProgram(\n      program, [input3D], input.dtype, customValues,\n      preventEagerUnpackingOfOutput);\n  return {dataId: output.dataId, shape: afterShape, dtype: output.dtype};\n}\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {backend_util, util} from '@tensorflow/tfjs-core';\nimport {GPGPUProgram} from './gpgpu_math';\n\nexport class MeanProgram implements GPGPUProgram {\n  variableNames = ['x'];\n  outputShape: number[];\n  userCode: string;\n\n  constructor(reduceInfo: backend_util.ReduceInfo, divisor?: number) {\n    const {windowSize, batchSize, inSize, outSize} = reduceInfo;\n    this.outputShape = [batchSize, outSize];\n\n    const windowSizeNearestVec4 = Math.floor(windowSize / 4) * 4;\n    const windowSizeVec4Remainder = windowSize % 4;\n\n    let updateSnippet = `sumValue += dot(values, ones);`;\n    if (divisor != null) {\n      const denominator = 1 / divisor;\n      updateSnippet = `sumValue += dot(values * ${\n          util.isInt(denominator) ? denominator.toPrecision(2) :\n                                    denominator}, ones);`;\n    }\n\n    let checkOutOfBounds = '';\n    if (inSize % windowSize > 0) {\n      checkOutOfBounds = `\n        if (inIdx < 0 || inIdx >= ${inSize}) {\n          return 0.0;\n        }\n      `;\n    }\n\n    this.userCode = `\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float getValue(int batch, int inIdx) {\n        ${checkOutOfBounds}\n        return getX(batch, inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ${windowSize};\n\n        float sumValue = 0.0;\n\n        for (int i = 0; i < ${windowSizeNearestVec4}; i += 4) {\n          int inIdx = inOffset + i;\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          ${updateSnippet}\n        }\n\n        int inIdx = inOffset + ${windowSizeNearestVec4};\n        if (${windowSizeVec4Remainder === 1}) {\n          vec4 values = vec4(getValue(batch, inIdx), 0.0, 0.0, 0.0);\n\n          ${updateSnippet}\n        } else if (${windowSizeVec4Remainder === 2}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1), 0.0, 0.0);\n\n          ${updateSnippet}\n        } else if (${windowSizeVec4Remainder === 3}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2), 0.0);\n\n          ${updateSnippet}\n        }\n        setOutput(sumValue);\n      }\n    `;\n  }\n}\n","/**\n * @license\n * Copyright 2017 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {backend_util} from '@tensorflow/tfjs-core';\nimport {GPGPUProgram} from './gpgpu_math';\n\nexport class ReduceProgram implements GPGPUProgram {\n  variableNames = ['x'];\n  outputShape: number[];\n  userCode: string;\n\n  constructor(\n      reduceInfo: backend_util.ReduceInfo,\n      reduceType: 'all'|'any'|'max'|'min'|'sum'|'prod') {\n    const {windowSize, batchSize, inSize, outSize} = reduceInfo;\n    this.outputShape = [batchSize, outSize];\n\n    let initializationValue = '0.0';\n    let compareOp = ``;\n\n    if (reduceType === 'prod') {\n      initializationValue = '1.0';\n    } else if (reduceType === 'min') {\n      // WebGL on Firefox Linux can't compile 1/0 so we do 1/eps.\n      initializationValue = '1.0 / 1e-20';\n      compareOp = `min`;\n    } else if (reduceType === 'max') {\n      // WebGL on Firefox Linux can't compile 1/0 so we do 1/eps.\n      initializationValue = '-1.0 / 1e-20';\n      compareOp = `max`;\n    }\n\n    let returnValue = `${reduceType}(${reduceType}(${reduceType}(` +\n        'minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])';\n\n    if (reduceType === 'sum') {\n      returnValue = `sumValue`;\n    } else if (reduceType === 'prod') {\n      returnValue = `prodValue`;\n    } else if (reduceType === 'all') {\n      returnValue = `allValue`;\n    } else if (reduceType === 'any') {\n      returnValue = `anyValue`;\n    }\n\n    const windowSizeNearestVec4 = Math.floor(windowSize / 4) * 4;\n    const windowSizeVec4Remainder = windowSize % 4;\n\n    let updateSnippet = `\n      if (${reduceType === 'sum'}) {\n        sumValue += dot(values, ones);\n      } else if (${reduceType === 'prod'}) {\n        vec2 tmp = vec2(values[0], values[1]) * vec2(values[2], values[3]);\n        prodValue *= tmp[0] * tmp[1];\n      } else {\n        minMaxValue = ${compareOp}(values, minMaxValue);\n        if (${reduceType === 'min'} || ${reduceType === 'max'}) {\n          minMaxValue = ${compareOp}(values, minMaxValue);\n          bvec4 isNaN = isnan(values);\n          if (isNaN.r || isNaN.g || isNaN.b || isNaN.a) {\n            minMaxValue = vec4(NAN);\n          }\n        }\n      }\n    `;\n\n    let vecType = `vec4`;\n\n    if (reduceType === 'all') {\n      initializationValue = '1.0';\n      updateSnippet = `\n        bool reducedAllValue = all(values);\n        float floatedReducedAllValue = float(reducedAllValue);\n        allValue = float(allValue >= 1.0 && floatedReducedAllValue >= 1.0);\n      `;\n      vecType = `bvec4`;\n    } else if (reduceType === 'any') {\n      initializationValue = '0.0';\n      updateSnippet = `\n        bool reducedAnyValue = any(values);\n        float floatedReducedAnyValue = float(reducedAnyValue);\n        anyValue = float(anyValue >= 1.0 || floatedReducedAnyValue >= 1.0);\n      `;\n      vecType = `bvec4`;\n    }\n\n    let checkOutOfBounds = '';\n    if (inSize % windowSize > 0) {\n      checkOutOfBounds = `\n        if (inIdx < 0 || inIdx >= ${inSize}) {\n          return initializationValue;\n        }\n      `;\n    }\n    this.userCode = `\n      const float initializationValue = ${initializationValue};\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float getValue(int batch, int inIdx) {\n        ${checkOutOfBounds}\n        return getX(batch, inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ${windowSize};\n\n        vec4 minMaxValue = vec4(${initializationValue});\n        float prodValue = 1.0;\n        float sumValue = 0.0;\n        float allValue = 1.0;\n        float anyValue = 0.0;\n\n        for (int i = 0; i < ${windowSizeNearestVec4}; i += 4) {\n          int inIdx = inOffset + i;\n          ${vecType} values = ${vecType}(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          ${updateSnippet}\n        }\n\n        int inIdx = inOffset + ${windowSizeNearestVec4};\n        if (${windowSizeVec4Remainder === 1}) {\n          ${vecType} values = ${vecType}(\n            getValue(batch, inIdx),\n            initializationValue,\n            initializationValue,\n            initializationValue\n          );\n\n          ${updateSnippet}\n        } else if (${windowSizeVec4Remainder === 2}) {\n          ${vecType} values = ${vecType}(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            initializationValue,\n            initializationValue\n          );\n\n          ${updateSnippet}\n        } else if (${windowSizeVec4Remainder === 3}) {\n          ${vecType} values = ${vecType}(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            initializationValue\n          );\n\n          ${updateSnippet}\n        }\n        setOutput(${returnValue});\n      }\n    `;\n  }\n}\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {backend_util, DataType, TensorInfo} from '@tensorflow/tfjs-core';\n\nimport {MathBackendWebGL} from '../backend_webgl';\nimport {MeanProgram} from '../mean_gpu';\nimport {ReduceProgram} from '../reduce_gpu';\n\ntype ReduceTypes = 'all'|'any'|'max'|'min'|'sum'|'prod'|'mean';\n\n// Returns an array of configuration objects that describe each stage of the\n// reduction.\nfunction getReductionStages(inShape: number[]):\n    Array<{inSize: number, windowSize: number, outSize: number}> {\n  const stages = [];\n\n  while (stages.length === 0 || stages[stages.length - 1].outSize !== 1) {\n    const outSize: number =\n        stages.length ? stages[stages.length - 1].outSize : inShape[1];\n    const windowSize = backend_util.computeOptimalWindowSize(outSize);\n    stages.push({\n      inSize: outSize,\n      windowSize,\n      outSize: Math.ceil(outSize / windowSize)\n    });\n  }\n\n  return stages;\n}\n\nexport function reduce(\n    x: TensorInfo, dtype: DataType, reductionType: ReduceTypes,\n    backend: MathBackendWebGL): TensorInfo {\n  const reductionStages = getReductionStages(x.shape);\n\n  let result = x;\n  for (let i = 0; i < reductionStages.length; i++) {\n    const {inSize, windowSize, outSize} = reductionStages[i];\n\n    let program: ReduceProgram|MeanProgram;\n    let previousResult: TensorInfo;\n    if (reductionType === 'mean') {\n      program = i === 0 ?\n          new MeanProgram(\n              {windowSize, inSize, batchSize: x.shape[0], outSize}, inSize) :\n          new MeanProgram({windowSize, inSize, batchSize: x.shape[0], outSize});\n    } else {\n      program = new ReduceProgram(\n          {windowSize, inSize, batchSize: x.shape[0], outSize}, reductionType);\n    }\n\n    previousResult = result;\n    result = backend.runWebGLProgram(program, [result], dtype);\n\n    if (previousResult.dataId !== x.dataId) {\n      backend.disposeIntermediateTensorInfo(previousResult);\n    }\n  }\n\n  return result;\n}\n","/**\n * @license\n * Copyright 2017 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {GPGPUProgram} from './gpgpu_math';\nimport {getCoordsDataType} from './shader_compiler';\n\nexport class TransposeProgram implements GPGPUProgram {\n  variableNames = ['A'];\n  outputShape: number[];\n  userCode: string;\n  rank: number;\n\n  constructor(aShape: number[], newDim: number[]) {\n    const outputShape: number[] = new Array(aShape.length);\n    for (let i = 0; i < outputShape.length; i++) {\n      outputShape[i] = aShape[newDim[i]];\n    }\n    this.outputShape = outputShape;\n    this.rank = outputShape.length;\n    const dtype = getCoordsDataType(this.rank);\n    const switched = getSwitchedCoords(newDim);\n\n    this.userCode = `\n    void main() {\n      ${dtype} resRC = getOutputCoords();\n      setOutput(getA(${switched}));\n    }\n    `;\n  }\n}\n\nfunction getSwitchedCoords(newDim: number[]): string {\n  const rank = newDim.length;\n  if (rank > 6) {\n    throw Error(`Transpose for rank ${rank} is not yet supported`);\n  }\n  const originalOrder =\n      ['resRC.x', 'resRC.y', 'resRC.z', 'resRC.w', 'resRC.u', 'resRC.v'];\n  const switchedCoords = new Array(rank);\n  for (let i = 0; i < newDim.length; i++) {\n    switchedCoords[newDim[i]] = originalOrder[i];\n  }\n  return switchedCoords.join();\n}\n","/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {GPGPUProgram} from './gpgpu_math';\nimport {getVecChannels} from './packing_util';\nimport {getCoordsDataType} from './shader_compiler';\n\nexport class TransposePackedProgram implements GPGPUProgram {\n  variableNames = ['A'];\n  outputShape: number[];\n  userCode: string;\n  rank: number;\n  packedInputs = true;\n  packedOutput = true;\n\n  constructor(aShape: number[], newDim: number[]) {\n    const outputShape: number[] = new Array(aShape.length);\n    for (let i = 0; i < outputShape.length; i++) {\n      outputShape[i] = aShape[newDim[i]];\n    }\n    this.outputShape = outputShape;\n    this.rank = outputShape.length;\n    if (this.rank > 6) {\n      throw Error(\n          `Packed transpose for rank ${this.rank} is not yet supported.`);\n    }\n    const dtype = getCoordsDataType(this.rank);\n\n    const outputOrder = getVecChannels('rc', this.rank);\n    const switchedOrder = new Array(this.rank);\n    for (let i = 0; i < newDim.length; i++) {\n      switchedOrder[newDim[i]] = outputOrder[i];\n    }\n    const innerDims = `vec2(${switchedOrder.slice(-2).join()})`;\n    const nextColumn =\n        `++${outputOrder[this.rank - 1]} < ${outputShape[this.rank - 1]}`;\n    const getc = `getChannel(getA(${switchedOrder.join()}), ${innerDims})`;\n\n    this.userCode = `\n    void main() {\n      ${dtype} rc = getOutputCoords();\n      vec4 result = vec4(0.);\n      result[0] = ${getc};\n      if(${nextColumn}) {\n        result[1] = ${getc};\n      }\n      --${outputOrder[this.rank - 1]};\n      if(++${outputOrder[this.rank - 2]} < ${outputShape[this.rank - 2]}) {\n        result[2] = ${getc};\n        if(${nextColumn}) {\n          result[3] = ${getc};\n        }\n      }\n      setOutput(result);\n    }\n    `;\n  }\n}\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {env, TensorInfo} from '@tensorflow/tfjs-core';\n\nimport {MathBackendWebGL} from '../backend_webgl';\nimport {transposeImplCPU} from '../kernel_utils/shared';\nimport {TransposeProgram} from '../transpose_gpu';\nimport {TransposePackedProgram} from '../transpose_packed_gpu';\n\nexport function transposeImpl(\n    x: TensorInfo, perm: number[], backend: MathBackendWebGL): TensorInfo {\n  const program = env().getBool('WEBGL_PACK_ARRAY_OPERATIONS') ?\n      new TransposePackedProgram(x.shape, perm) :\n      new TransposeProgram(x.shape, perm);\n  return backend.runWebGLProgram(program, [x], x.dtype);\n}\n\nexport {transposeImplCPU};\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {KernelConfig, KernelFunc, Sum, SumAttrs, SumInputs} from '@tensorflow/tfjs-core';\n\nimport {MathBackendWebGL} from '../backend_webgl';\n\nimport {sumImpl} from './Sum_impl';\n\nexport function sum(\n    args: {inputs: SumInputs, attrs: SumAttrs, backend: MathBackendWebGL}) {\n  const {inputs, backend, attrs} = args;\n\n  const {x} = inputs;\n  const {axis, keepDims} = attrs;\n\n  return sumImpl(x, axis, keepDims, backend);\n}\n\nexport const sumConfig: KernelConfig = {\n  kernelName: Sum,\n  backendName: 'webgl',\n  kernelFunc: sum as {} as KernelFunc\n};\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {backend_util, sumOutType, TensorInfo, util} from '@tensorflow/tfjs-core';\n\nimport {MathBackendWebGL} from '../backend_webgl';\nimport {reduce} from '../kernel_utils/reduce';\nimport {reshape} from './Reshape';\n\nimport {transposeImpl} from './Transpose_impl';\n\nexport function sumImpl(\n    x: TensorInfo, axis: number|number[], keepDims: boolean,\n    backend: MathBackendWebGL): TensorInfo {\n  const reductionIndices = axis;\n\n  const xRank = x.shape.length;\n\n  const origAxes = util.parseAxisParam(reductionIndices, x.shape);\n  let axes = origAxes;\n  const permutedAxes = backend_util.getAxesPermutation(axes, xRank);\n  const sumInputIsTransposed = permutedAxes != null;\n\n  let sumInput = x;\n  if (sumInputIsTransposed) {\n    sumInput = transposeImpl(x, permutedAxes, backend);\n\n    axes = backend_util.getInnerMostAxes(axes.length, xRank);\n  }\n\n  backend_util.assertAxesAreInnerMostDims('sum', axes, xRank);\n  const [sumOutShape, reduceShape] =\n      backend_util.computeOutAndReduceShapes(sumInput.shape, axes);\n\n  let outShape = sumOutShape;\n  if (keepDims) {\n    // rather than reshape at the end, set the target shape here.\n    outShape = backend_util.expandShapeToKeepDim(sumOutShape, origAxes);\n  }\n\n  const inSize = util.sizeFromShape(reduceShape);\n  const xSize = util.sizeFromShape(x.shape);\n  const batchSize = xSize / inSize;\n  const reshapedInput = reshape(\n      {inputs: {x: sumInput}, attrs: {shape: [batchSize, inSize]}, backend});\n\n  const outType = sumOutType(x.dtype);\n\n  const reduced = reduce(reshapedInput, outType, 'sum', backend);\n  const out =\n      reshape({inputs: {x: reduced}, attrs: {shape: outShape}, backend});\n\n  backend.disposeIntermediateTensorInfo(reshapedInput);\n  backend.disposeIntermediateTensorInfo(reduced);\n  if (sumInputIsTransposed) {\n    backend.disposeIntermediateTensorInfo(sumInput);\n  }\n\n  return out;\n}\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {KernelConfig, KernelFunc, TensorInfo, Transpose, TransposeAttrs, TransposeInputs, TypedArray} from '@tensorflow/tfjs-core';\n\nimport {MathBackendWebGL} from '../backend_webgl';\n\nimport {transposeImpl} from './Transpose_impl';\nimport {transposeImplCPU as cpuTranspose} from './Transpose_impl';\n\nexport function transpose(args: {\n  inputs: TransposeInputs,\n  attrs: TransposeAttrs,\n  backend: MathBackendWebGL\n}) {\n  const {inputs, backend, attrs} = args;\n  const {x} = inputs;\n  const {perm} = attrs;\n  const webglBackend = backend;\n\n  const xRank = x.shape.length;\n\n  const newShape: number[] = new Array(xRank);\n  for (let i = 0; i < newShape.length; i++) {\n    newShape[i] = x.shape[perm[i]];\n  }\n\n  let out: TensorInfo;\n  if (webglBackend.shouldExecuteOnCPU([x])) {\n    const xTexData = webglBackend.texData.get(x.dataId);\n    const values = xTexData.values as TypedArray;\n    const outValues = cpuTranspose(values, x.shape, x.dtype, perm, newShape);\n\n    out = webglBackend.makeTensorInfo(newShape, x.dtype);\n    const outData = webglBackend.texData.get(out.dataId);\n    outData.values = outValues;\n  } else {\n    out = transposeImpl(x, perm, webglBackend);\n  }\n  return out;\n}\n\nexport const transposeConfig: KernelConfig = {\n  kernelName: Transpose,\n  backendName: 'webgl',\n  kernelFunc: transpose as {} as KernelFunc\n};\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {backend_util, broadcast_util, TensorInfo, upcastType, util} from '@tensorflow/tfjs-core';\n\nimport {MathBackendWebGL} from '../backend_webgl';\nimport {mapActivationToShaderProgram} from '../kernel_utils/kernel_funcs_utils';\nimport {MatMulPackedProgram} from '../mulmat_packed_gpu';\n\nimport {multiply} from './Multiply';\nimport {reshape} from './Reshape';\nimport {sum} from './Sum';\nimport {transpose} from './Transpose';\n\n// Empirically determined minimal shared dimension in matmul before we forward\n// to a.mul(b).sum() in order to take advantage of GPU parallelism. See\n// https://github.com/tensorflow/tfjs-core/pull/1379 for benchmarks.\nexport const MATMUL_SHARED_DIM_THRESHOLD = 1000;\n\ntype BatchMatMulConfig = {\n  a: TensorInfo,\n  b: TensorInfo,\n  transposeA: boolean,\n  transposeB: boolean,\n  backend: MathBackendWebGL,\n  bias?: TensorInfo,\n  preluActivationWeights?: TensorInfo,\n  leakyreluAlpha?: number,\n  activation?: backend_util.Activation\n};\n\nexport function batchMatMulImpl({\n  a,\n  b,\n  transposeA,\n  transposeB,\n  backend,\n  bias = null,\n  preluActivationWeights = null,\n  leakyreluAlpha = 0,\n  activation = null\n}: BatchMatMulConfig): TensorInfo {\n  const aRank = a.shape.length;\n  const bRank = b.shape.length;\n\n  const innerShapeA = transposeA ? a.shape[aRank - 2] : a.shape[aRank - 1];\n  const innerShapeB = transposeB ? b.shape[bRank - 1] : b.shape[bRank - 2];\n\n  const outerShapeA = transposeA ? a.shape[aRank - 1] : a.shape[aRank - 2];\n  const outerShapeB = transposeB ? b.shape[bRank - 2] : b.shape[bRank - 1];\n\n  const outerDimsA = a.shape.slice(0, -2);\n  const outerDimsB = b.shape.slice(0, -2);\n\n  const batchDimA = util.sizeFromShape(outerDimsA);\n  const batchDimB = util.sizeFromShape(outerDimsB);\n\n  const outShapeOuterDims = broadcast_util.assertAndGetBroadcastShape(\n      a.shape.slice(0, -2), b.shape.slice(0, -2));\n  const outShape = outShapeOuterDims.concat([outerShapeA, outerShapeB]);\n\n  util.assert(\n      innerShapeA === innerShapeB,\n      () => `Error in matMul: inner shapes (${innerShapeA}) and (` +\n          `${innerShapeB}) of Tensors with shapes ${a.shape} and ` +\n          `${b.shape} and transposeA=${transposeA}` +\n          ` and transposeB=${transposeB} must match.`);\n\n  const a3dShape: [number, number, number] = transposeA ?\n      [batchDimA, innerShapeA, outerShapeA] :\n      [batchDimA, outerShapeA, innerShapeA];\n  const b3dShape: [number, number, number] = transposeB ?\n      [batchDimB, outerShapeB, innerShapeB] :\n      [batchDimB, innerShapeB, outerShapeB];\n\n  // The rest of the implementation is designed to operate on rank-3 tensors\n  const a3d = reshape({inputs: {x: a}, backend, attrs: {shape: a3dShape}});\n  const b3d = reshape({inputs: {x: b}, backend, attrs: {shape: b3dShape}});\n\n  const intermediates: TensorInfo[] = [a3d, b3d];\n\n  const batchDim = Math.max(batchDimA, batchDimB);\n  const sharedDim = transposeA ? a3d.shape[1] : a3d.shape[2];\n\n  const hasBias = bias != null;\n  const hasPreluActivationWeights = preluActivationWeights != null;\n  const hasLeakyreluAlpha = activation === 'leakyrelu';\n  const fusedActivation = activation != null ?\n      mapActivationToShaderProgram(activation, true) :\n      null;\n  const containsFusedOps = hasBias || hasPreluActivationWeights ||\n      hasLeakyreluAlpha || fusedActivation != null;\n  let out: TensorInfo;\n\n  // Since the matrices are vectors, it is faster to call mul().sum()\n  // because sum() is O(sqrt(N)) due to divide-and-conquer.\n  if ((outerShapeA === 1 || outerShapeB === 1) &&\n      sharedDim > MATMUL_SHARED_DIM_THRESHOLD && containsFusedOps === false) {\n    let aVec = a3d;\n    let bVec = b3d;\n    if (transposeA) {\n      aVec = transpose({inputs: {x: a3d}, backend, attrs: {perm: [0, 2, 1]}});\n      intermediates.push(aVec);\n    }\n    if (transposeB) {\n      bVec = transpose({inputs: {x: b3d}, backend, attrs: {perm: [0, 2, 1]}});\n      intermediates.push(bVec);\n    }\n\n    const shouldReshapeA = outerShapeB !== 1;\n    const shouldReshapeB = outerShapeB === 1;\n\n    let aVec3d = aVec;\n    if (shouldReshapeA) {\n      aVec3d = reshape({\n        inputs: {x: aVec},\n        backend,\n        attrs: {shape: [batchDim, sharedDim, 1]}\n      });\n\n      intermediates.push(aVec3d);\n    }\n\n    const axis = outerShapeB === 1 ? 2 : 1;\n\n    let bVec3d = bVec;\n    if (shouldReshapeB) {\n      bVec3d = reshape({\n        inputs: {x: bVec},\n        backend,\n        attrs: {shape: [batchDim, 1, sharedDim]}\n      });\n\n      intermediates.push(bVec3d);\n    }\n\n    const product = multiply({inputs: {a: aVec3d, b: bVec3d}, backend});\n    out = sum({inputs: {x: product}, backend, attrs: {axis, keepDims: true}});\n    intermediates.push(product);\n  } else {\n    const dtype = upcastType(a.dtype, b.dtype);\n\n    const program = new MatMulPackedProgram(\n        a3dShape, b3dShape, [batchDim, outerShapeA, outerShapeB], transposeA,\n        transposeB, hasBias, fusedActivation, hasPreluActivationWeights,\n        hasLeakyreluAlpha);\n\n    const inputs: TensorInfo[] = [a3d, b3d];\n    if (bias != null) {\n      inputs.push(bias);\n    }\n    if (hasPreluActivationWeights) {\n      inputs.push(preluActivationWeights);\n    }\n    if (hasLeakyreluAlpha) {\n      const $leakyreluAlpha = backend.makeTensorInfo(\n          [], 'float32',\n          util.createScalarValue(leakyreluAlpha as {} as 'float32', 'float32'));\n      inputs.push($leakyreluAlpha);\n      intermediates.push($leakyreluAlpha);\n    }\n\n    out = backend.runWebGLProgram(program, inputs, dtype);\n  }\n\n  const outReshaped =\n      reshape({inputs: {x: out}, backend, attrs: {shape: outShape}});\n  intermediates.push(out);\n  for (const i of intermediates) {\n    backend.disposeIntermediateTensorInfo(i);\n  }\n  return outReshaped;\n}\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the License);\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an AS IS BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {_FusedMatMul, _FusedMatMulAttrs, _FusedMatMulInputs, KernelConfig, KernelFunc} from '@tensorflow/tfjs-core';\n\nimport {MathBackendWebGL} from '../backend_webgl';\nimport {batchMatMulImpl} from './BatchMatMul_impl';\n\nexport function _fusedMatMul(args: {\n  inputs: _FusedMatMulInputs,\n  attrs: _FusedMatMulAttrs,\n  backend: MathBackendWebGL\n}) {\n  const {inputs, backend, attrs} = args;\n  const {a, b, bias, preluActivationWeights} = inputs;\n  const {transposeA, transposeB, activation, leakyreluAlpha} = attrs;\n\n  return batchMatMulImpl({\n    a,\n    b,\n    transposeA,\n    transposeB,\n    backend,\n    bias,\n    preluActivationWeights,\n    leakyreluAlpha,\n    activation\n  });\n}\n\nexport const _fusedMatMulConfig: KernelConfig = {\n  kernelName: _FusedMatMul,\n  backendName: 'webgl',\n  kernelFunc: _fusedMatMul as {} as KernelFunc,\n};\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {Abs, AbsInputs, env, KernelConfig, KernelFunc, TensorInfo, TypedArray} from '@tensorflow/tfjs-core';\n\nimport {MathBackendWebGL} from '../backend_webgl';\nimport {simpleAbsImplCPU} from '../kernel_utils/shared';\nimport {UnaryOpProgram} from '../unaryop_gpu';\nimport {UnaryOpPackedProgram} from '../unaryop_packed_gpu';\n\nconst ABS = `return abs(x);`;\n\nexport function abs(args: {inputs: AbsInputs, backend: MathBackendWebGL}):\n    TensorInfo {\n  const {inputs, backend} = args;\n  const {x} = inputs;\n\n  // TODO: handle cases when x is complex. Once the cpu implementation\n  // can handle complex values, refactor to use unaryKernelFunc.\n  if (backend.shouldExecuteOnCPU([x]) && x.dtype !== 'complex64') {\n    const xData = backend.texData.get(x.dataId);\n    const outValues = simpleAbsImplCPU(xData.values as TypedArray);\n    return backend.makeTensorInfo(x.shape, x.dtype, outValues);\n  }\n\n  let program: UnaryOpProgram|UnaryOpPackedProgram;\n  if (env().getBool('WEBGL_PACK_UNARY_OPERATIONS')) {\n    program = new UnaryOpPackedProgram(x.shape, ABS);\n  } else {\n    program = new UnaryOpProgram(x.shape, ABS);\n  }\n  return backend.runWebGLProgram(program, [x], x.dtype);\n}\n\nexport const absConfig: KernelConfig = {\n  kernelName: Abs,\n  backendName: 'webgl',\n  kernelFunc: abs as {} as KernelFunc\n};\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {Acos, KernelConfig} from '@tensorflow/tfjs-core';\n\nimport {unaryKernelFunc} from '../kernel_utils/kernel_funcs_utils';\nimport {CHECK_NAN_SNIPPET} from '../unaryop_gpu';\n\nconst ACOS = CHECK_NAN_SNIPPET + `\n  if (abs(x) > 1.) {\n    return NAN;\n  }\n  return acos(x);\n`;\n\nexport const acos = unaryKernelFunc({opSnippet: ACOS});\n\nexport const acosConfig: KernelConfig = {\n  kernelName: Acos,\n  backendName: 'webgl',\n  kernelFunc: acos,\n};\n","\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {Acosh, KernelConfig} from '@tensorflow/tfjs-core';\n\nimport {unaryKernelFunc} from '../kernel_utils/kernel_funcs_utils';\nimport {CHECK_NAN_SNIPPET} from '../unaryop_gpu';\n\nconst ACOSH = CHECK_NAN_SNIPPET + `\n  if (x < 1.0) return NAN;\nreturn log(x + sqrt(x * x - 1.0));`;\n\nexport const acosh = unaryKernelFunc({opSnippet: ACOSH});\n\nexport const acoshConfig: KernelConfig = {\n  kernelName: Acosh,\n  backendName: 'webgl',\n  kernelFunc: acosh,\n};\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {Add, KernelConfig} from '@tensorflow/tfjs-core';\n\nimport {binaryKernelFunc} from '../kernel_utils/kernel_funcs_utils';\nimport {addImplCPU as cpuAdd} from '../kernel_utils/shared';\n\nconst ADD = 'return a + b;';\n\nexport const addKernelFunc = binaryKernelFunc({\n  opSnippet: ADD,\n  packedOpSnippet: ADD,\n  supportsComplex: true,\n  cpuKernelImpl: cpuAdd\n});\n\nexport const addConfig: KernelConfig = {\n  kernelName: Add,\n  backendName: 'webgl',\n  kernelFunc: addKernelFunc\n};\n","/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {GPGPUProgram} from './gpgpu_math';\n\nexport class AddNProgram implements GPGPUProgram {\n  variableNames: string[];\n  outputShape: number[] = [];\n  userCode: string;\n\n  constructor(outputShape: number[], shapes: number[][]) {\n    this.outputShape = outputShape;\n    this.variableNames = shapes.map((_, i) => `T${i}`);\n\n    const snippets: string[] = [];\n    // Get target elements from every input tensor.\n    this.variableNames.forEach(variable => {\n      snippets.push(`float v${variable} = get${variable}AtOutCoords();`);\n    });\n\n    // Calculate the sum of all elements.\n    const operation = this.variableNames\n                          .map(variable => {\n                            return `v${variable}`;\n                          })\n                          .join(' + ');\n\n    this.userCode = `\n      void main() {\n        ${snippets.join('\\n        ')}\n\n        float result = ${operation};\n        setOutput(result);\n      }\n    `;\n  }\n}\n","/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {GPGPUProgram} from './gpgpu_math';\n\nexport class AddNPackedProgram implements GPGPUProgram {\n  variableNames: string[];\n  outputShape: number[] = [];\n  userCode: string;\n  packedInputs = true;\n  packedOutput = true;\n\n  constructor(outputShape: number[], shapes: number[][]) {\n    this.outputShape = outputShape;\n    this.variableNames = shapes.map((_, i) => `T${i}`);\n\n    const snippets: string[] = [];\n    // Get target elements from every input tensor.\n    this.variableNames.forEach(variable => {\n      snippets.push(`vec4 v${variable} = get${variable}AtOutCoords();`);\n    });\n\n    // Calculate the sum of all elements.\n    const operation = this.variableNames\n                          .map(variable => {\n                            return `v${variable}`;\n                          })\n                          .join(' + ');\n\n    this.userCode = `\n      void main() {\n        ${snippets.join('\\n        ')}\n\n        vec4 result = ${operation};\n        setOutput(result);\n      }\n    `;\n  }\n}\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {AddN, AddNInputs, env, KernelConfig, KernelFunc, TensorInfo, upcastType} from '@tensorflow/tfjs-core';\n\nimport {AddNProgram} from '../addn_gpu';\nimport {AddNPackedProgram} from '../addn_packed_gpu';\nimport {MathBackendWebGL} from '../backend_webgl';\nimport {identity} from './Identity';\n\nexport function addN(args: {inputs: AddNInputs, backend: MathBackendWebGL}):\n    TensorInfo {\n  const {inputs, backend} = args;\n\n  const tensors = inputs;\n  if (tensors.length === 1) {\n    return identity({inputs: {x: tensors[0]}, backend});\n  }\n\n  // Limit the number of uploaded textures for optimization.\n  if (tensors.length > env().get('WEBGL_MAX_TEXTURES_IN_SHADER')) {\n    const midIndex = Math.floor(tensors.length / 2);\n    const leftSide = addN({inputs: tensors.slice(0, midIndex), backend});\n    const rightSide = addN({inputs: tensors.slice(midIndex), backend});\n    return addN({inputs: [leftSide, rightSide], backend});\n  }\n\n  const dtype =\n      tensors.map(t => t.dtype).reduce((d1, d2) => upcastType(d1, d2));\n  const shapes = tensors.map(t => t.shape);\n  // We can make sure shapes are identical in op level.\n  const usePackedOp = env().getBool('WEBGL_PACK');\n  const program = usePackedOp ?\n      new AddNPackedProgram(tensors[0].shape, shapes) :\n      new AddNProgram(tensors[0].shape, shapes);\n  return backend.runWebGLProgram(program, tensors, dtype);\n}\n\nexport const addNConfig: KernelConfig = {\n  kernelName: AddN,\n  backendName: 'webgl',\n  kernelFunc: addN as {} as KernelFunc\n};\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {All, AllAttrs, AllInputs, backend_util, KernelConfig, KernelFunc, TensorInfo, util} from '@tensorflow/tfjs-core';\n\nimport {MathBackendWebGL} from '../backend_webgl';\nimport {reduce} from '../kernel_utils/reduce';\n\nimport {reshape} from './Reshape';\nimport {transpose} from './Transpose';\n\nexport function all(\n    args: {inputs: AllInputs, backend: MathBackendWebGL, attrs: AllAttrs}):\n    TensorInfo {\n  const {inputs, backend, attrs} = args;\n  const {x} = inputs;\n  const {axis, keepDims} = attrs;\n\n  const xRank = x.shape.length;\n\n  const origAxes = util.parseAxisParam(axis, x.shape);\n  let axes = origAxes;\n  const permutedAxes = backend_util.getAxesPermutation(axes, xRank);\n  let permutedX = x;\n  if (permutedAxes != null) {\n    permutedX = transpose({inputs: {x}, backend, attrs: {perm: permutedAxes}});\n    axes = backend_util.getInnerMostAxes(axes.length, xRank);\n  }\n\n  backend_util.assertAxesAreInnerMostDims('all', axes, xRank);\n  const [outShape, reduceShape] =\n      backend_util.computeOutAndReduceShapes(permutedX.shape, axes);\n  const inSize = util.sizeFromShape(reduceShape);\n\n  const a2D =\n      reshape({inputs: {x: permutedX}, backend, attrs: {shape: [-1, inSize]}});\n  const reduced = reduce(a2D, a2D.dtype, 'all', backend);\n\n  let res;\n  if (keepDims) {\n    const newShape = backend_util.expandShapeToKeepDim(outShape, origAxes);\n    res = reshape({inputs: {x: reduced}, backend, attrs: {shape: newShape}});\n  } else {\n    res = reshape({inputs: {x: reduced}, backend, attrs: {shape: outShape}});\n  }\n\n  backend.disposeIntermediateTensorInfo(a2D);\n  backend.disposeIntermediateTensorInfo(reduced);\n\n  if (permutedAxes != null) {\n    backend.disposeIntermediateTensorInfo(permutedX);\n  }\n\n  return res;\n}\n\nexport const allConfig: KernelConfig = {\n  kernelName: All,\n  backendName: 'webgl',\n  kernelFunc: all as {} as KernelFunc\n};\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {Any, AnyAttrs, AnyInputs, backend_util, KernelConfig, KernelFunc, TensorInfo, util} from '@tensorflow/tfjs-core';\n\nimport {MathBackendWebGL} from '../backend_webgl';\nimport {reduce} from '../kernel_utils/reduce';\nimport {reshape} from './Reshape';\nimport {transpose} from './Transpose';\n\nexport function any(\n    args: {inputs: AnyInputs, backend: MathBackendWebGL, attrs: AnyAttrs}):\n    TensorInfo {\n  const {inputs, backend, attrs} = args;\n  const {x} = inputs;\n  const {axis, keepDims} = attrs;\n\n  const xRank = x.shape.length;\n\n  const origAxes = util.parseAxisParam(axis, x.shape);\n  let axes = origAxes;\n  const permutedAxes = backend_util.getAxesPermutation(axes, xRank);\n  let permutedX = x;\n  if (permutedAxes != null) {\n    permutedX = transpose({inputs: {x}, backend, attrs: {perm: permutedAxes}});\n    axes = backend_util.getInnerMostAxes(axes.length, xRank);\n  }\n\n  backend_util.assertAxesAreInnerMostDims('any', axes, xRank);\n  const [outShape, reduceShape] =\n      backend_util.computeOutAndReduceShapes(permutedX.shape, axes);\n  const inSize = util.sizeFromShape(reduceShape);\n\n  const a2D =\n      reshape({inputs: {x: permutedX}, backend, attrs: {shape: [-1, inSize]}});\n  const reduced = reduce(a2D, a2D.dtype, 'any', backend);\n\n  let res;\n  if (keepDims) {\n    const newShape = backend_util.expandShapeToKeepDim(outShape, origAxes);\n    res = reshape({inputs: {x: reduced}, backend, attrs: {shape: newShape}});\n  } else {\n    res = reshape({inputs: {x: reduced}, backend, attrs: {shape: outShape}});\n  }\n\n  backend.disposeIntermediateTensorInfo(a2D);\n  backend.disposeIntermediateTensorInfo(reduced);\n\n  if (permutedAxes != null) {\n    backend.disposeIntermediateTensorInfo(permutedX);\n  }\n\n  return res;\n}\n\nexport const anyConfig: KernelConfig = {\n  kernelName: Any,\n  backendName: 'webgl',\n  kernelFunc: any as {} as KernelFunc\n};\n","/**\n * @license\n * Copyright 2017 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {backend_util} from '@tensorflow/tfjs-core';\nimport {GPGPUProgram} from './gpgpu_math';\n\nexport class ArgMinMaxProgram implements GPGPUProgram {\n  variableNames = ['A'];\n  outputShape: number[];\n  userCode: string;\n\n  constructor(\n      reduceInfo: backend_util.ReduceInfo, op: 'max'|'min',\n      firstPass: boolean) {\n    const {windowSize, batchSize, outSize} = reduceInfo;\n    if (!firstPass) {\n      this.variableNames.push('bestIndicesA');\n    }\n    this.outputShape = [batchSize, outSize];\n    const compOp = (op === 'max') ? '>' : '<';\n    const indexSnippet = firstPass ?\n        'inOffset + i;' :\n        'round(getBestIndicesA(batch, inOffset + i));';\n\n    this.userCode = `\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ${windowSize};\n\n        int bestIndex = inOffset;\n        float bestValue = getA(batch, bestIndex);\n\n        for (int i = 0; i < ${windowSize}; i++) {\n          int inIdx = ${indexSnippet};\n          float candidate = getA(batch, inIdx);\n          if (candidate ${compOp} bestValue) {\n            bestValue = candidate;\n            bestIndex = inIdx;\n          }\n        }\n        setOutput(float(bestIndex));\n      }\n    `;\n  }\n}\n","/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {util} from '@tensorflow/tfjs-core';\n\nimport {GPGPUProgram} from './gpgpu_math';\nimport {getChannels} from './packing_util';\nimport {getCoordsDataType} from './shader_compiler';\n\nexport class ArgMinMaxPackedProgram implements GPGPUProgram {\n  variableNames = ['A'];\n  outputShape: number[];\n  userCode: string;\n  packedInputs = true;\n  packedOutput = true;\n\n  constructor(\n      shape: number[], windowSize: number, op: 'max'|'min',\n      firstPass: boolean) {\n    util.assert(\n        shape.length > 2,\n        () => `Packed arg${\n            op.charAt(0).toUpperCase() +\n            op.slice(1)} supports only inputs with rank above 2.`);\n    const inSize = shape[shape.length - 1];\n    const outSize = Math.ceil(inSize / windowSize);\n    this.outputShape = shape.slice(0, -1);\n    if (outSize > 1) {\n      this.outputShape.push(outSize);\n    }\n    if (!firstPass) {\n      this.variableNames.push('bestIndicesA');\n    }\n    const outShape = this.outputShape;\n    const rank = outShape.length;\n    const dtype = getCoordsDataType(rank);\n    const coords = getChannels('coords', rank);\n\n    let sourceLocSetup;\n    let sourceRank;\n    if (outSize === 1) {\n      sourceRank = rank + 1;\n      const sourceLocDType = getCoordsDataType(sourceRank);\n      sourceLocSetup = `\n        ${sourceLocDType} sourceLocR = ${sourceLocDType}(${coords.join()}, 0);\n        ++${coords[rank - 1]};\n        ${sourceLocDType} sourceLocG = ${sourceLocDType}(${coords.join()}, 0);\n        ++${coords[rank - 2]};\n        ${sourceLocDType} sourceLocA = ${sourceLocDType}(${coords.join()}, 0);\n        --${coords[rank - 1]};\n        ${sourceLocDType} sourceLocB = ${sourceLocDType}(${coords.join()}, 0);\n        --${coords[rank - 2]};`;\n    } else {\n      sourceRank = rank;\n      sourceLocSetup = `\n        ${dtype} sourceLocR = coords;\n        ++${coords[rank - 1]};\n        ${dtype} sourceLocG = coords;\n        ++${coords[rank - 2]};\n        ${dtype} sourceLocA = coords;\n        --${coords[rank - 1]};\n        ${dtype} sourceLocB = coords;\n        --${coords[rank - 2]};`;\n    }\n    const channels = ['x', 'y', 'z', 'w', 'u', 'v'].slice(0, sourceRank);\n    const inChannel = '.' + channels[sourceRank - 1];  // e.g. \".b\" for rank 3.\n    const intChannels = channels.map(x => 'int ' + x);\n    const srcRCoords =\n        getChannels('sourceLocR', sourceRank - 1).concat('inIdx.r');\n    const srcGCoords =\n        getChannels('sourceLocG', sourceRank - 1).concat('inIdx.g');\n    const srcBCoords =\n        getChannels('sourceLocB', sourceRank - 1).concat('inIdx.b');\n    const srcACoords =\n        getChannels('sourceLocA', sourceRank - 1).concat('inIdx.a');\n\n    const compOp = (op === 'max') ? 'greaterThan' : 'lessThan';\n    const fetchCandidateIdx = firstPass ? '' : `\n          inIdx = round(vec4(getBestIndicesAChannel(${srcRCoords.join()}),\n                             getBestIndicesAChannel(${srcGCoords.join()}),\n                             getBestIndicesAChannel(${srcBCoords.join()}),\n                             getBestIndicesAChannel(${srcACoords.join()})));`;\n\n    const fetchValue = `vec4(\n            getAChannel(${srcRCoords.join()}),\n            hasNextCol ? getAChannel(${srcGCoords.join()}) : 0.,\n            hasNextRow ? getAChannel(${srcBCoords.join()}) : 0.,\n            hasNextRow && hasNextCol ? getAChannel(${srcACoords.join()}) : 0.)`;\n\n    const getBestIndicesAChannelSnippet = firstPass ? '' : `\n      float getBestIndicesAChannel(${intChannels.join()}) {\n        return getChannel(getBestIndicesA(${channels.join()}),\n                                          vec2(${channels.slice(-2).join()}));\n      }`;\n\n    this.userCode = `\n      float getAChannel(${intChannels.join()}) {\n        return getChannel(getA(${channels.join()}),\n                               vec2(${channels.slice(-2).join()}));\n      }\n      ${getBestIndicesAChannelSnippet}\n      void main() {\n        ${dtype} coords = getOutputCoords();\n        bool hasNextCol = ${coords[rank - 1]} < ${outShape[rank - 1] - 1};\n        bool hasNextRow = ${coords[rank - 2]} < ${outShape[rank - 2] - 1};\n        ${sourceLocSetup}\n        ivec4 srcIdx = ivec4(sourceLocR${inChannel}, sourceLocG${inChannel},\n          sourceLocB${inChannel}, sourceLocA${inChannel}) * ${windowSize};\n        ivec4 inIdx = srcIdx;\n        vec4 bestIndex = vec4(inIdx);\n        vec4 bestValue = ${fetchValue};\n\n        for (int i = 0; i < ${windowSize}; i++) {\n          inIdx = srcIdx;\n          ${fetchCandidateIdx}\n          vec4 candidate = ${fetchValue};\n          bvec4 nan = isnan(candidate);\n          bvec4 replace = bvec4(\n            vec4(${compOp}(candidate, bestValue)) * (vec4(1.0) - vec4(nan)));\n\n          bestValue = vec4(replace.x  ? candidate.x : bestValue.x,\n                           replace.y  ? candidate.y : bestValue.y,\n                           replace.z  ? candidate.z : bestValue.z,\n                           replace.w  ? candidate.w : bestValue.w);\n          bestIndex = mix(bestIndex, vec4(inIdx), vec4(replace));\n          srcIdx++;\n        }\n        setOutput(bestIndex);\n      }\n    `;\n  }\n}\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {backend_util, env, TensorInfo, util} from '@tensorflow/tfjs-core';\n\nimport {ArgMinMaxProgram} from '../argminmax_gpu';\nimport {ArgMinMaxPackedProgram} from '../argminmax_packed_gpu';\nimport {MathBackendWebGL} from '../backend_webgl';\nimport {reshape} from '../kernels/Reshape';\n\nfunction argReduce(\n    backend: MathBackendWebGL, x: TensorInfo, reduceType: 'max'|'min',\n    bestIndicesA: TensorInfo = null): TensorInfo {\n  let batchSize = x.shape[0];\n  let inSize = x.shape[1];\n  if (bestIndicesA != null) {\n    batchSize = bestIndicesA.shape[0];\n    inSize = bestIndicesA.shape[1];\n  }\n  const windowSize = backend_util.computeOptimalWindowSize(inSize);\n  const reduceInfo =\n      {windowSize, inSize, batchSize, outSize: Math.ceil(inSize / windowSize)};\n  const program =\n      new ArgMinMaxProgram(reduceInfo, reduceType, bestIndicesA == null);\n  const inputs = [x];\n  if (bestIndicesA != null) {\n    inputs.push(bestIndicesA);\n  }\n  const output = backend.runWebGLProgram(program, inputs, 'int32');\n  // No need to run another GPGPU program.\n  if (output.shape[1] === 1) {\n    return output;\n  }\n  const result = argReduce(backend, x, reduceType, output);\n  backend.disposeIntermediateTensorInfo(output);\n  return result;\n}\n\nfunction argReducePacked(\n    backend: MathBackendWebGL, x: TensorInfo, reduceType: 'max'|'min',\n    bestIndicesA: TensorInfo = null): TensorInfo {\n  const inShape = bestIndicesA != null ? bestIndicesA.shape : x.shape;\n  const inSize = inShape[inShape.length - 1];\n  const windowSize = backend_util.computeOptimalWindowSize(inSize);\n  const program = new ArgMinMaxPackedProgram(\n      inShape, windowSize, reduceType, bestIndicesA == null);\n  const inputs = bestIndicesA == null ? [x] : [x, bestIndicesA];\n  const output = backend.runWebGLProgram(program, inputs, 'int32');\n  if (output.shape.length === x.shape.length) {\n    const result = argReducePacked(backend, x, reduceType, output);\n    backend.disposeIntermediateTensorInfo(output);\n    return result;\n  }\n  return output;\n}\n\nexport function argMinMaxReduce(\n    backend: MathBackendWebGL, x: TensorInfo, axis: number,\n    reduceType: 'min'|'max'): TensorInfo {\n  const axes = [axis];\n  backend_util.assertAxesAreInnerMostDims(\n      'arg' + reduceType.charAt(0).toUpperCase() + reduceType.slice(1), axes,\n      x.shape.length);\n  if (!env().getBool('WEBGL_PACK_REDUCE') || x.shape.length <= 2) {\n    const intermediateTensorInfos = [];\n    // Eagerly unpack x input since it is passed in to all the shaders which\n    // require unpacked inputs.\n    const xtexData = backend.texData.get(x.dataId);\n    const xIsPacked = xtexData !== null && xtexData.isPacked;\n    let xUnPacked = x;\n    if (xIsPacked) {\n      xUnPacked = backend.unpackTensor(x);\n      intermediateTensorInfos.push(xUnPacked);\n    }\n\n    const [outShape, reduceShape] =\n        backend_util.computeOutAndReduceShapes(xUnPacked.shape, axes);\n    const inSize = util.sizeFromShape(reduceShape);\n    const a2D = reshape(\n        {inputs: {x: xUnPacked}, backend, attrs: {shape: [-1, inSize]}});\n    intermediateTensorInfos.push(a2D);\n\n    const reduced = argReduce(backend, a2D, reduceType);\n    intermediateTensorInfos.push(reduced);\n    const reshaped =\n        reshape({inputs: {x: reduced}, backend, attrs: {shape: outShape}});\n\n    intermediateTensorInfos.forEach(\n        t => backend.disposeIntermediateTensorInfo(t));\n    return reshaped;\n  }\n  return argReducePacked(backend, x, reduceType);\n}\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {ArgMax, ArgMaxAttrs, ArgMaxInputs, backend_util, KernelConfig, KernelFunc, TensorInfo, util} from '@tensorflow/tfjs-core';\n\nimport {MathBackendWebGL} from '../backend_webgl';\nimport {argMinMaxReduce} from '../kernel_utils/arg_min_max';\n\nimport {transpose} from './Transpose';\n\nexport function argMax(\n    args:\n        {inputs: ArgMaxInputs, backend: MathBackendWebGL, attrs: ArgMaxAttrs}):\n    TensorInfo {\n  const {inputs, backend, attrs} = args;\n  const {x} = inputs;\n  const {axis} = attrs;\n\n  let axes = util.parseAxisParam(axis, x.shape);\n  const permutedAxes = backend_util.getAxesPermutation(axes, x.shape.length);\n  let $x = x;\n  const intermediateTensorInfos = [];\n  if (permutedAxes != null) {\n    $x = transpose({inputs: {x}, backend, attrs: {perm: permutedAxes}});\n    intermediateTensorInfos.push($x);\n    axes = backend_util.getInnerMostAxes(axes.length, $x.shape.length);\n  }\n\n  backend_util.assertAxesAreInnerMostDims('argMax', [axes[0]], $x.shape.length);\n  const out = argMinMaxReduce(backend, $x, axes[0], 'max');\n\n  intermediateTensorInfos.forEach(\n      t => backend.disposeIntermediateTensorInfo(t));\n  return out;\n}\n\nexport const argMaxConfig: KernelConfig = {\n  kernelName: ArgMax,\n  backendName: 'webgl',\n  kernelFunc: argMax as {} as KernelFunc\n};\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {ArgMin, ArgMinAttrs, ArgMinInputs, backend_util, KernelConfig, KernelFunc, TensorInfo, util} from '@tensorflow/tfjs-core';\n\nimport {MathBackendWebGL} from '../backend_webgl';\nimport {argMinMaxReduce} from '../kernel_utils/arg_min_max';\nimport {transpose} from './Transpose';\n\nexport function argMin(\n    args:\n        {inputs: ArgMinInputs, backend: MathBackendWebGL, attrs: ArgMinAttrs}):\n    TensorInfo {\n  const {inputs, backend, attrs} = args;\n  const {x} = inputs;\n  const {axis} = attrs;\n\n  let axes = util.parseAxisParam(axis, x.shape);\n  const permutedAxes = backend_util.getAxesPermutation(axes, x.shape.length);\n  let $x = x;\n  const intermediateTensorInfos = [];\n  if (permutedAxes != null) {\n    $x = transpose({inputs: {x}, backend, attrs: {perm: permutedAxes}});\n    intermediateTensorInfos.push($x);\n    axes = backend_util.getInnerMostAxes(axes.length, $x.shape.length);\n  }\n\n  backend_util.assertAxesAreInnerMostDims('argMin', [axes[0]], $x.shape.length);\n\n  const out = argMinMaxReduce(backend, $x, axes[0], 'min');\n\n  intermediateTensorInfos.forEach(\n      t => backend.disposeIntermediateTensorInfo(t));\n  return out;\n}\n\nexport const argMinConfig: KernelConfig = {\n  kernelName: ArgMin,\n  backendName: 'webgl',\n  kernelFunc: argMin as {} as KernelFunc\n};\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {Asin, KernelConfig} from '@tensorflow/tfjs-core';\n\nimport {unaryKernelFunc} from '../kernel_utils/kernel_funcs_utils';\nimport {CHECK_NAN_SNIPPET} from '../unaryop_gpu';\n\nconst ASIN = CHECK_NAN_SNIPPET + `\n  if (abs(x) > 1.) {\n    return NAN;\n  }\n  return asin(x);\n`;\n\nexport const asin = unaryKernelFunc({opSnippet: ASIN});\n\nexport const asinConfig: KernelConfig = {\n  kernelName: Asin,\n  backendName: 'webgl',\n  kernelFunc: asin,\n};\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {Asinh, KernelConfig} from '@tensorflow/tfjs-core';\n\nimport {unaryKernelFunc} from '../kernel_utils/kernel_funcs_utils';\nimport {CHECK_NAN_SNIPPET} from '../unaryop_gpu';\n\nconst ASINH = CHECK_NAN_SNIPPET + `return log(x + sqrt(x * x + 1.0));`;\n\nexport const asinh = unaryKernelFunc({opSnippet: ASINH});\n\nexport const asinhConfig: KernelConfig = {\n  kernelName: Asinh,\n  backendName: 'webgl',\n  kernelFunc: asinh,\n};\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {Atan, KernelConfig} from '@tensorflow/tfjs-core';\n\nimport {unaryKernelFunc} from '../kernel_utils/kernel_funcs_utils';\nimport {CHECK_NAN_SNIPPET} from '../unaryop_gpu';\n\nconst ATAN = CHECK_NAN_SNIPPET + `\n  return atan(x);\n`;\n\nexport const atan = unaryKernelFunc({opSnippet: ATAN});\n\nexport const atanConfig: KernelConfig = {\n  kernelName: Atan,\n  backendName: 'webgl',\n  kernelFunc: atan,\n};\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {Atan2} from '@tensorflow/tfjs-core';\nimport {KernelConfig} from '@tensorflow/tfjs-core';\nimport {CHECK_NAN_SNIPPET} from '../binaryop_gpu';\nimport {CHECK_NAN_SNIPPET_PACKED} from '../binaryop_packed_gpu';\nimport {binaryKernelFunc} from '../kernel_utils/kernel_funcs_utils';\n\nconst ATAN2 = CHECK_NAN_SNIPPET + `\n  return atan(a, b);\n`;\n\nconst ATAN2_PACKED = `\n  vec4 result = atan(a, b);\n  bvec4 isNaNA = isnan(a);\n  bvec4 isNaNB = isnan(b);\n  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);\n  ` +\n    CHECK_NAN_SNIPPET_PACKED + `\n  return result;\n`;\n\nexport const atan2 =\n    binaryKernelFunc({opSnippet: ATAN2, packedOpSnippet: ATAN2_PACKED});\n\nexport const atan2Config: KernelConfig = {\n  kernelName: Atan2,\n  backendName: 'webgl',\n  kernelFunc: atan2,\n};\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {Atanh, KernelConfig} from '@tensorflow/tfjs-core';\n\nimport {unaryKernelFunc} from '../kernel_utils/kernel_funcs_utils';\nimport {CHECK_NAN_SNIPPET} from '../unaryop_gpu';\n\nconst ATANH = CHECK_NAN_SNIPPET + `\n  if ((x < -1.0) || (x > 1.0)) return NAN;\nreturn (log(1.0 + x) - log(1.0 - x)) / 2.0;`;\n\nexport const atanh = unaryKernelFunc({opSnippet: ATANH});\n\nexport const atanhConfig: KernelConfig = {\n  kernelName: Atanh,\n  backendName: 'webgl',\n  kernelFunc: atanh,\n};\n","/**\n * @license\n * Copyright 2017 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {backend_util} from '@tensorflow/tfjs-core';\nimport {GPGPUProgram} from './gpgpu_math';\n\nexport class Pool2DProgram implements GPGPUProgram {\n  variableNames = ['x'];\n  outputShape: number[];\n  userCode: string;\n\n  constructor(\n      convInfo: backend_util.Conv2DInfo, poolType: 'max'|'avg',\n      computePositions: boolean, flattenPositions = false,\n      includeBatchInIndex = false) {\n    if (poolType === 'avg' && computePositions) {\n      throw new Error('Cannot compute positions for average pool.');\n    }\n\n    const filterWidth = convInfo.filterWidth;\n    const strideHeight = convInfo.strideHeight;\n    const strideWidth = convInfo.strideWidth;\n    const dilationHeight = convInfo.dilationHeight;\n    const dilationWidth = convInfo.dilationWidth;\n    const effectiveFilterHeight = convInfo.effectiveFilterHeight;\n    const effectiveFilterWidth = convInfo.effectiveFilterWidth;\n\n    const padTop = convInfo.padInfo.top;\n    const padLeft = convInfo.padInfo.left;\n    this.outputShape = convInfo.outShape;\n\n    const isAvgPool = poolType === 'avg';\n    const batchFlattenPositionStr = `((batch  * ${convInfo.inHeight} + xR) * ${\n        convInfo.inWidth} + xC) * ${convInfo.inChannels} + d`;\n    const flattenPositionStr =\n        `(xR * ${convInfo.inWidth} + xC) * ${convInfo.inChannels} + d`;\n\n    let initializationValue = '0.0';\n    if (!isAvgPool) {\n      // WebGL on Firefox Linux can't compile 1/0 so we do 1/eps.\n      initializationValue = '-1.0 / 1e-20';\n    }\n\n    if (computePositions) {\n      const compareOp = '>=';\n\n      this.userCode = `\n        const ivec2 strides = ivec2(${strideHeight}, ${strideWidth});\n        const ivec2 pads = ivec2(${padTop}, ${padLeft});\n\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int batch = coords[0];\n          int d = coords[3];\n\n          ivec2 xRCCorner = coords.yz * strides - pads;\n          int xRCorner = xRCCorner.x;\n          int xCCorner = xRCCorner.y;\n\n          // max/min x(?, ?, d) to get y(yR, yC, d).\n          // ? = to be determined\n          float minMaxValue = 0.0;\n          float minMaxValueFound = 0.0;\n          int minMaxPosition = 0;\n          float avgValue = 0.0;\n\n          for (int wR = 0; wR < ${effectiveFilterHeight};\n              wR += ${dilationHeight}) {\n            int xR = xRCorner + wR;\n\n            if (xR < 0 || xR >= ${convInfo.inHeight}) {\n              continue;\n            }\n\n            for (int wC = 0; wC < ${effectiveFilterWidth};\n                wC += ${dilationWidth}) {\n              int xC = xCCorner + wC;\n\n              if (xC < 0 || xC >= ${convInfo.inWidth}) {\n                continue;\n              }\n\n              float value = getX(batch, xR, xC, d);\n\n              // If a min / max value has already been found, use it. If not,\n              // use the current value.\n              float currMinMaxValue = mix(\n                  value, minMaxValue, minMaxValueFound);\n              if (value ${compareOp} currMinMaxValue) {\n                minMaxValue = value;\n                minMaxValueFound = 1.0;\n                minMaxPosition = ${\n          flattenPositions ? (includeBatchInIndex ? batchFlattenPositionStr :\n                                                    flattenPositionStr) :\n                             `wR * ${effectiveFilterWidth} + wC`};\n              }\n            }\n          }\n          setOutput(float(minMaxPosition));\n        }\n      `;\n      return;\n    }\n\n    const compareOp = 'max';\n\n    let returnValue = `${poolType}(${poolType}(${poolType}(` +\n        'minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])';\n    if (poolType === 'avg') {\n      returnValue = `avgValue / count`;\n    }\n\n    const filterWidthNearestVec4 = Math.floor(filterWidth / 4) * 4;\n    const filterWidthVec4Remainder = filterWidth % 4;\n\n    const updateSnippet = `\n      if (${isAvgPool}) {\n        avgValue += dot(values, ones);\n      } else {\n        minMaxValue = ${compareOp}(values, minMaxValue);\n      }\n    `;\n\n    this.userCode = `\n      const ivec2 strides = ivec2(${strideHeight}, ${strideWidth});\n      const ivec2 pads = ivec2(${padTop}, ${padLeft});\n      const float initializationValue = ${initializationValue};\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float count = 0.0;\n\n      float getValue(int batch, int xR, int xC, int d) {\n        if (xC < 0 || xC >= ${convInfo.inWidth}) {\n          return initializationValue;\n        }\n        count += 1.0;\n        return getX(batch, xR, xC, d);\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d = coords[3];\n\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // max/min x(?, ?, d) to get y(yR, yC, d).\n        // ? = to be determined\n        vec4 minMaxValue = vec4(${initializationValue});\n        float avgValue = 0.0;\n        count = 0.0;\n\n        for (int wR = 0; wR < ${effectiveFilterHeight};\n            wR += ${dilationHeight}) {\n          int xR = xRCorner + wR;\n\n          if (xR < 0 || xR >= ${convInfo.inHeight}) {\n            continue;\n          }\n\n          for (int wC = 0; wC < ${filterWidthNearestVec4}; wC += 4) {\n            int xC = xCCorner + wC * ${dilationWidth};\n\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ${dilationWidth}, d),\n              getValue(batch, xR, xC + 2 * ${dilationWidth}, d),\n              getValue(batch, xR, xC + 3 * ${dilationWidth}, d)\n            );\n\n            ${updateSnippet}\n          }\n\n          int xC = xCCorner + ${filterWidthNearestVec4};\n          if (${filterWidthVec4Remainder === 1}) {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              initializationValue,\n              initializationValue,\n              initializationValue\n            );\n\n            ${updateSnippet}\n          } else if (${filterWidthVec4Remainder === 2}) {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ${dilationWidth}, d),\n              initializationValue,\n              initializationValue\n            );\n\n            ${updateSnippet}\n          } else if (${filterWidthVec4Remainder === 3}) {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ${dilationWidth}, d),\n              getValue(batch, xR, xC + 2 * ${dilationWidth}, d),\n              initializationValue\n            );\n\n            ${updateSnippet}\n          }\n        }\n        setOutput(${returnValue});\n      }\n    `;\n  }\n}\n\nexport class Pool3DProgram implements GPGPUProgram {\n  variableNames = ['x'];\n  outputShape: number[];\n  userCode: string;\n\n  constructor(\n      convInfo: backend_util.Conv3DInfo, poolType: 'max'|'avg',\n      computePositions: boolean, flattenPositions = false,\n      includeBatchInIndex = false) {\n    if (poolType === 'avg' && computePositions) {\n      throw new Error('Cannot compute positions for average pool.');\n    }\n\n    const filterWidth = convInfo.filterWidth;\n    const strideDepth = convInfo.strideDepth;\n    const strideHeight = convInfo.strideHeight;\n    const strideWidth = convInfo.strideWidth;\n    const dilationDepth = convInfo.dilationDepth;\n    const dilationHeight = convInfo.dilationHeight;\n    const dilationWidth = convInfo.dilationWidth;\n    const effectiveFilterDepth = convInfo.effectiveFilterDepth;\n    const effectiveFilterHeight = convInfo.effectiveFilterHeight;\n    const effectiveFilterWidth = convInfo.effectiveFilterWidth;\n\n    const padFront = convInfo.padInfo.front;\n    const padTop = convInfo.padInfo.top;\n    const padLeft = convInfo.padInfo.left;\n    this.outputShape = convInfo.outShape;\n\n    const isAvgPool = poolType === 'avg';\n\n    let initializationValue = '0.0';\n    if (!isAvgPool) {\n      // WebGL on Firefox Linux can't compile 1/0 so we do 1/eps.\n      initializationValue = '-1.0 / 1e-20';\n    }\n\n    if (computePositions) {\n      const compareOp = '>=';\n\n      this.userCode = `\n        const ivec3 strides =\n            ivec3(${strideDepth}, ${strideHeight}, ${strideWidth});\n        const ivec3 pads = ivec3(${padFront}, ${padTop}, ${padLeft});\n\n        void main() {\n          ivec5 coords = getOutputCoords();\n          int batch = coords.x;\n          int ch = coords.u;\n\n          ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n          int xDCorner = xCorner.x;\n          int xRCorner = xCorner.y;\n          int xCCorner = xCorner.z;\n\n          // max/min x(?, ?, ?, ch) to get y(yD, yR, yC, ch).\n          // ? = to be determined\n          float minMaxValue = 0.0;\n          float minMaxValueFound = 0.0;\n          int minMaxPosition = 0;\n\n          for (int wD = 0; wD < ${effectiveFilterDepth};\n              wD += ${dilationDepth}) {\n            int xD = xDCorner + wD;\n\n            if (xD < 0 || xD >= ${convInfo.inDepth}) {\n              continue;\n            }\n\n            for (int wR = 0; wR < ${effectiveFilterHeight};\n                wR += ${dilationHeight}) {\n              int xR = xRCorner + wR;\n\n              if (xR < 0 || xR >= ${convInfo.inHeight}) {\n                continue;\n              }\n\n              for (int wC = 0; wC < ${effectiveFilterWidth};\n                  wC += ${dilationWidth}) {\n                int xC = xCCorner + wC;\n\n                if (xC < 0 || xC >= ${convInfo.inWidth}) {\n                  continue;\n                }\n\n                float value = getX(batch, xD, xR, xC, ch);\n\n                // If a min / max value has already been found, use it. If not,\n                // use the current value.\n                float currMinMaxValue = mix(\n                    value, minMaxValue, minMaxValueFound);\n                if (value ${compareOp} currMinMaxValue) {\n                  minMaxValue = value;\n                  minMaxValueFound = 1.0;\n                  minMaxPosition = ${\n          flattenPositions ?\n              (includeBatchInIndex ?\n                   `(((batch * ${convInfo.inDepth} + xD) * ${\n                       convInfo.inHeight} + xR) * ${convInfo.inWidth} + xC) * ${\n                       convInfo.inChannels} + ch` :\n                   `((xD * ${convInfo.inHeight} + xR) * ${\n                       convInfo.inWidth} + xC) * ${convInfo.inChannels} + ch`) :\n              `wD * ${effectiveFilterHeight} * ${effectiveFilterWidth} +\n                      wR * ${effectiveFilterWidth} + wC`};\n                }\n              }\n            }\n          }\n          setOutput(float(minMaxPosition));\n        }\n      `;\n      return;\n    }\n\n    const compareOp = 'max';\n\n    let returnValue = `${poolType}(${poolType}(${poolType}(` +\n        'minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])';\n    if (poolType === 'avg') {\n      returnValue = `avgValue / count`;\n    }\n\n    const filterWidthNearestVec4 = Math.floor(filterWidth / 4) * 4;\n    const filterWidthVec4Remainder = filterWidth % 4;\n\n    const updateSnippet = `\n      if (${isAvgPool}) {\n        avgValue += dot(values, ones);\n      } else {\n        minMaxValue = ${compareOp}(values, minMaxValue);\n      }\n    `;\n\n    this.userCode = `\n      const ivec3 strides =\n        ivec3(${strideDepth}, ${strideHeight}, ${strideWidth});\n      const ivec3 pads = ivec3(${padFront}, ${padTop}, ${padLeft});\n      const float initializationValue = ${initializationValue};\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float count = 0.0;\n\n      float getValue(int batch, int xD, int xR, int xC, int ch) {\n        if (xC < 0 || xC >= ${convInfo.inWidth}) {\n          return initializationValue;\n        }\n        count += 1.0;\n        return getX(batch, xD, xR, xC, ch);\n      }\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n        int xDCorner = xCorner.x;\n        int xRCorner = xCorner.y;\n        int xCCorner = xCorner.z;\n\n        // max/min x(?, ?, ?, d) to get y(yD, yR, yC, ch).\n        // ? = to be determined\n        vec4 minMaxValue = vec4(${initializationValue});\n        float avgValue = 0.0;\n        count = 0.0;\n\n        for (int wD = 0; wD < ${effectiveFilterDepth};\n            wD += ${dilationDepth}) {\n          int xD = xDCorner + wD;\n\n          if (xD < 0 || xD >= ${convInfo.inDepth}) {\n            continue;\n          }\n\n          for (int wR = 0; wR < ${effectiveFilterHeight};\n            wR += ${dilationHeight}) {\n            int xR = xRCorner + wR;\n\n            if (xR < 0 || xR >= ${convInfo.inHeight}) {\n              continue;\n            }\n\n            for (int wC = 0; wC < ${filterWidthNearestVec4}; wC += 4) {\n              int xC = xCCorner + wC * ${dilationWidth};\n\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ${dilationWidth}, ch),\n                getValue(batch, xD, xR, xC + 2 * ${dilationWidth}, ch),\n                getValue(batch, xD, xR, xC + 3 * ${dilationWidth}, ch)\n              );\n\n              ${updateSnippet}\n            }\n\n            int xC = xCCorner + ${filterWidthNearestVec4};\n            if (${filterWidthVec4Remainder === 1}) {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                initializationValue,\n                initializationValue,\n                initializationValue\n              );\n\n              ${updateSnippet}\n            } else if (${filterWidthVec4Remainder === 2}) {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ${dilationWidth}, ch),\n                initializationValue,\n                initializationValue\n              );\n\n              ${updateSnippet}\n            } else if (${filterWidthVec4Remainder === 3}) {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ${dilationWidth}, ch),\n                getValue(batch, xD, xR, xC + 2 * ${dilationWidth}, ch),\n                initializationValue\n              );\n\n              ${updateSnippet}\n            }\n          }\n          setOutput(${returnValue});\n        }\n      }\n    `;\n  }\n}\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport {AvgPool, AvgPoolAttrs, AvgPoolInputs, backend_util, KernelConfig, KernelFunc, TensorInfo, util} from '@tensorflow/tfjs-core';\n\nimport {MathBackendWebGL} from '../backend_webgl';\nimport {Pool2DProgram} from '../pool_gpu';\nimport {assertNotComplex} from '../webgl_util';\nimport {identity} from './Identity';\n\nexport function avgPool(args: {\n  inputs: AvgPoolInputs,\n  backend: MathBackendWebGL,\n  attrs: AvgPoolAttrs\n}): TensorInfo {\n  const {inputs, backend, attrs} = args;\n  const {x} = inputs;\n  assertNotComplex(x, 'avgPool');\n  const {filterSize, strides, pad, dimRoundingMode} = attrs;\n  const dilations = 1;\n\n  util.assert(\n      backend_util.eitherStridesOrDilationsAreOne(strides, dilations),\n      () => 'Error in avgPool: Either strides or dilations must be 1. ' +\n          `Got strides ${strides} and dilations '${dilations}'`);\n\n  const convInfo = backend_util.computePool2DInfo(\n      x.shape as [number, number, number, number], filterSize, strides,\n      dilations, pad, dimRoundingMode);\n  if (convInfo.filterWidth === 1 && convInfo.filterHeight === 1 &&\n      util.arraysEqual(convInfo.inShape, convInfo.outShape)) {\n    return identity({inputs: {x}, backend});\n  }\n  const avgPoolProgram = new Pool2DProgram(convInfo, 'avg', false);\n  return backend.runWebGLProgram(avgPoolProgram, [x], 'float32');\n}\n\nexport const avgPoolConfig: KernelConfig = {\n  kernelName: AvgPool,\n  backendName: 'webgl',\n  kernelFunc: avgPool as {} as KernelFunc\n};\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport {AvgPool3D, AvgPool3DAttrs, AvgPool3DInputs, backend_util, KernelConfig, KernelFunc, TensorInfo} from '@tensorflow/tfjs-core';\n\nimport {MathBackendWebGL} from '../backend_webgl';\nimport {Pool3DProgram} from '../pool_gpu';\n\nexport function avgPool3D(args: {\n  inputs: AvgPool3DInputs,\n  backend: MathBackendWebGL,\n  attrs: AvgPool3DAttrs\n}): TensorInfo {\n  const {inputs, backend, attrs} = args;\n  const {x} = inputs;\n  const {filterSize, strides, pad, dimRoundingMode, dataFormat} = attrs;\n  const dilations: [number, number, number] = [1, 1, 1];\n\n  const convInfo = backend_util.computePool3DInfo(\n      x.shape as [number, number, number, number, number], filterSize, strides,\n      dilations, pad, dimRoundingMode, dataFormat);\n  const avgPoolProgram = new Pool3DProgram(convInfo, 'avg', false);\n  return backend.runWebGLProgram(avgPoolProgram, [x], 'float32');\n}\n\nexport const avgPool3DConfig: KernelConfig = {\n  kernelName: AvgPool3D,\n  backendName: 'webgl',\n  kernelFunc: avgPool3D as {} as KernelFunc\n};\n","/**\n * @license\n * Copyright 2017 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {backend_util} from '@tensorflow/tfjs-core';\nimport {GPGPUProgram} from './gpgpu_math';\n\nexport class AvgPool2DBackpropProgram implements GPGPUProgram {\n  variableNames = ['dy'];\n  outputShape: number[];\n  userCode: string;\n\n  constructor(convInfo: backend_util.Conv2DInfo) {\n    this.outputShape = convInfo.inShape;\n    const filterHeight = convInfo.filterHeight;\n    const filterWidth = convInfo.filterWidth;\n    const strideHeight = convInfo.strideHeight;\n    const strideWidth = convInfo.strideWidth;\n    const dilationHeight = convInfo.dilationHeight;\n    const dilationWidth = convInfo.dilationWidth;\n    const effectiveFilterHeight = convInfo.effectiveFilterHeight;\n    const effectiveFilterWidth = convInfo.effectiveFilterWidth;\n\n    const padTop = effectiveFilterHeight - 1 - convInfo.padInfo.top;\n    const padLeft = effectiveFilterWidth - 1 - convInfo.padInfo.left;\n\n    const avgMultiplier = 1 / (filterHeight * filterWidth);\n\n    this.userCode = `\n      const ivec2 pads = ivec2(${padTop}, ${padLeft});\n      const float avgMultiplier = float(${avgMultiplier});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n\n        ivec2 dyRCCorner = coords.yz - pads;\n        int dyRCorner = dyRCCorner.x;\n        int dyCCorner = dyRCCorner.y;\n\n        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${effectiveFilterHeight};\n            wR += ${dilationHeight}) {\n          float dyR = float(dyRCorner + wR) / ${strideHeight}.0;\n\n          if (dyR < 0.0 || dyR >= ${convInfo.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          for (int wC = 0; wC < ${effectiveFilterWidth};\n            wC+= ${dilationWidth}) {\n            float dyC = float(dyCCorner + wC) / ${strideWidth}.0;\n\n            if (dyC < 0.0 || dyC >= ${convInfo.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            float dyValue = getDy(b, idyR, idyC, d);\n\n            dotProd += dyValue * avgMultiplier;\n          }\n        }\n        setOutput(dotProd);\n      }\n    `;\n  }\n}\n\nexport class AvgPool3DBackpropProgram implements GPGPUProgram {\n  variableNames = ['dy'];\n  outputShape: number[];\n  userCode: string;\n\n  constructor(convInfo: backend_util.Conv3DInfo) {\n    this.outputShape = convInfo.inShape;\n    const filterDepth = convInfo.filterDepth;\n    const filterHeight = convInfo.filterHeight;\n    const filterWidth = convInfo.filterWidth;\n    const strideDepth = convInfo.strideDepth;\n    const strideHeight = convInfo.strideHeight;\n    const strideWidth = convInfo.strideWidth;\n    const dilationDepth = convInfo.dilationDepth;\n    const dilationHeight = convInfo.dilationHeight;\n    const dilationWidth = convInfo.dilationWidth;\n    const effectiveFilterDepth = convInfo.effectiveFilterDepth;\n    const effectiveFilterHeight = convInfo.effectiveFilterHeight;\n    const effectiveFilterWidth = convInfo.effectiveFilterWidth;\n\n    const padFront = effectiveFilterDepth - 1 - convInfo.padInfo.front;\n    const padTop = effectiveFilterHeight - 1 - convInfo.padInfo.top;\n    const padLeft = effectiveFilterWidth - 1 - convInfo.padInfo.left;\n\n    const avgMultiplier = 1 / (filterDepth * filterHeight * filterWidth);\n\n    this.userCode = `\n      const ivec3 pads = ivec3(${padFront}, ${padTop}, ${padLeft});\n      const float avgMultiplier = float(${avgMultiplier});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyDCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        // Convolve dy(?, ?, ?, d) with pos mask(:, :, :, ch) to get\n        // dx(xD, xR, xC, ch).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int wD = 0; wD < ${effectiveFilterDepth};\n            wD += ${dilationDepth}) {\n          float dyD = float(dyDCorner + wD) / ${strideDepth}.0;\n\n          if (dyD < 0.0 || dyD >= ${convInfo.outDepth}.0 || fract(dyD) > 0.0) {\n            continue;\n          }\n          int idyD = int(dyD);\n\n          for (int wR = 0; wR < ${effectiveFilterHeight};\n              wR += ${dilationHeight}) {\n            float dyR = float(dyRCorner + wR) / ${strideHeight}.0;\n\n            if (dyR < 0.0 || dyR >= ${convInfo.outHeight}.0 ||\n                fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            for (int wC = 0; wC < ${effectiveFilterWidth};\n                wC += ${dilationWidth}) {\n              float dyC = float(dyCCorner + wC) / ${strideWidth}.0;\n\n              if (dyC < 0.0 || dyC >= ${convInfo.outWidth}.0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              float dyValue = getDy(batch, idyD, idyR, idyC, ch);\n\n              dotProd += dyValue * avgMultiplier;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `;\n  }\n}\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport {AvgPool3DGrad, AvgPool3DGradAttrs, AvgPool3DGradInputs, backend_util, KernelConfig, KernelFunc, TensorInfo} from '@tensorflow/tfjs-core';\n\nimport {AvgPool3DBackpropProgram} from '../avg_pool_backprop_gpu';\nimport {MathBackendWebGL} from '../backend_webgl';\n\nexport function avgPool3DGrad(args: {\n  inputs: AvgPool3DGradInputs,\n  backend: MathBackendWebGL,\n  attrs: AvgPool3DGradAttrs\n}): TensorInfo {\n  const {inputs, backend, attrs} = args;\n  const {dy, input} = inputs;\n  const x = input;\n  const {filterSize, strides, pad, dimRoundingMode} = attrs;\n  const dilations: [number, number, number] = [1, 1, 1];\n\n  const convInfo = backend_util.computePool3DInfo(\n      x.shape as [number, number, number, number, number], filterSize, strides,\n      dilations, pad, dimRoundingMode);\n  const avgPoolBackpropProgram = new AvgPool3DBackpropProgram(convInfo);\n  return backend.runWebGLProgram(avgPoolBackpropProgram, [dy], x.dtype);\n}\n\nexport const avgPool3DGradConfig: KernelConfig = {\n  kernelName: AvgPool3DGrad,\n  backendName: 'webgl',\n  kernelFunc: avgPool3DGrad as {} as KernelFunc\n};\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport {AvgPoolGrad, AvgPoolGradAttrs, AvgPoolGradInputs, backend_util, KernelConfig, KernelFunc, TensorInfo} from '@tensorflow/tfjs-core';\n\nimport {AvgPool2DBackpropProgram} from '../avg_pool_backprop_gpu';\nimport {MathBackendWebGL} from '../backend_webgl';\nimport {assertNotComplex} from '../webgl_util';\n\nexport function avgPoolGrad(args: {\n  inputs: AvgPoolGradInputs,\n  backend: MathBackendWebGL,\n  attrs: AvgPoolGradAttrs\n}): TensorInfo {\n  const {inputs, backend, attrs} = args;\n  const {dy, input} = inputs;\n  const x = input;\n  assertNotComplex([dy, input], 'avgPoolGrad');\n  const {filterSize, strides, pad} = attrs;\n\n  const convInfo = backend_util.computePool2DInfo(\n      x.shape as [number, number, number, number], filterSize, strides,\n      1 /* dilations */, pad);\n  const avgPoolBackpropProgram = new AvgPool2DBackpropProgram(convInfo);\n  return backend.runWebGLProgram(avgPoolBackpropProgram, [dy], x.dtype);\n}\n\nexport const avgPoolGradConfig: KernelConfig = {\n  kernelName: AvgPoolGrad,\n  backendName: 'webgl',\n  kernelFunc: avgPoolGrad as {} as KernelFunc\n};\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {BatchMatMul, BatchMatMulAttrs, BatchMatMulInputs, KernelConfig, KernelFunc} from '@tensorflow/tfjs-core';\n\nimport {MathBackendWebGL} from '../backend_webgl';\nimport {batchMatMulImpl} from './BatchMatMul_impl';\n\nexport function batchMatMul(args: {\n  inputs: BatchMatMulInputs,\n  attrs: BatchMatMulAttrs,\n  backend: MathBackendWebGL\n}) {\n  const {inputs, backend, attrs} = args;\n  const {a, b} = inputs;\n  const {transposeA, transposeB} = attrs;\n\n  return batchMatMulImpl({a, b, transposeA, transposeB, backend});\n}\n\nexport const batchMatMulConfig: KernelConfig = {\n  kernelName: BatchMatMul,\n  backendName: 'webgl',\n  kernelFunc: batchMatMul as {} as KernelFunc,\n};\n","/**\n * @license\n * Copyright 2017 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {backend_util} from '@tensorflow/tfjs-core';\nimport {GPGPUProgram} from './gpgpu_math';\n\nexport class BatchNormProgram implements GPGPUProgram {\n  variableNames: string[];\n  outputShape: number[] = [];\n  userCode: string;\n\n  constructor(\n      xShape: number[], meanShape: number[], varianceShape: number[],\n      offsetShape: number[]|null, scaleShape: number[]|null,\n      varianceEpsilon: number) {\n    this.variableNames = ['x', 'mean', 'variance'];\n    backend_util.assertAndGetBroadcastShape(xShape, meanShape);\n    backend_util.assertAndGetBroadcastShape(xShape, varianceShape);\n\n    let offsetSnippet = '0.0';\n    if (offsetShape != null) {\n      backend_util.assertAndGetBroadcastShape(xShape, offsetShape);\n      this.variableNames.push('offset');\n      offsetSnippet = 'getOffsetAtOutCoords()';\n    }\n\n    let scaleSnippet = '1.0';\n    if (scaleShape != null) {\n      backend_util.assertAndGetBroadcastShape(xShape, scaleShape);\n      this.variableNames.push('scale');\n      scaleSnippet = 'getScaleAtOutCoords()';\n    }\n\n    this.outputShape = xShape;\n    this.userCode = `\n      void main() {\n        float x = getXAtOutCoords();\n        float mean = getMeanAtOutCoords();\n        float variance = getVarianceAtOutCoords();\n        float offset = ${offsetSnippet};\n        float scale = ${scaleSnippet};\n        float inv = scale * inversesqrt(variance + float(${varianceEpsilon}));\n        setOutput(dot(vec3(x, -mean, offset), vec3(inv, inv, 1)));\n      }\n    `;\n  }\n}\n","/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {backend_util} from '@tensorflow/tfjs-core';\nimport {GPGPUProgram} from './gpgpu_math';\n\nexport class BatchNormPackedProgram implements GPGPUProgram {\n  variableNames: string[];\n  outputShape: number[];\n  userCode: string;\n  packedInputs = true;\n  packedOutput = true;\n\n  constructor(\n      xShape: number[], meanShape: number[], varianceShape: number[],\n      offsetShape: number[]|null, scaleShape: number[]|null,\n      varianceEpsilon: number) {\n    this.variableNames = ['x', 'mean', 'variance'];\n    backend_util.assertAndGetBroadcastShape(xShape, meanShape);\n    backend_util.assertAndGetBroadcastShape(xShape, varianceShape);\n\n    let offsetSnippet = 'vec4(0.0)';\n    if (offsetShape != null) {\n      backend_util.assertAndGetBroadcastShape(xShape, offsetShape);\n      this.variableNames.push('offset');\n      offsetSnippet = 'getOffsetAtOutCoords()';\n    }\n\n    let scaleSnippet = 'vec4(1.0)';\n    if (scaleShape != null) {\n      backend_util.assertAndGetBroadcastShape(xShape, scaleShape);\n      this.variableNames.push('scale');\n      scaleSnippet = 'getScaleAtOutCoords()';\n    }\n\n    this.outputShape = xShape;\n    this.userCode = `\n      void main() {\n        vec4 offset = ${offsetSnippet};\n        vec4 scale = ${scaleSnippet};\n\n        vec4 x = getXAtOutCoords();\n        vec4 mean = getMeanAtOutCoords();\n        vec4 variance = getVarianceAtOutCoords();\n\n        vec4 inv = scale * inversesqrt(variance + vec4(${varianceEpsilon}));\n\n        setOutput((x - mean) * inv + offset);\n      }\n    `;\n  }\n}\n","\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {env, FusedBatchNorm, FusedBatchNormAttrs, FusedBatchNormInputs, KernelConfig, KernelFunc, TensorInfo, util} from '@tensorflow/tfjs-core';\n\nimport {MathBackendWebGL} from '../backend_webgl';\nimport {BatchNormProgram} from '../batchnorm_gpu';\nimport {BatchNormPackedProgram} from '../batchnorm_packed_gpu';\n\nexport const batchNorm: (params: {\n  inputs: FusedBatchNormInputs,\n  backend: MathBackendWebGL,\n  attrs: FusedBatchNormAttrs\n}) => TensorInfo = ({inputs, backend, attrs}) => {\n  const {x, mean, variance, offset, scale} = inputs;\n\n  util.assert(\n      mean.shape.length === variance.shape.length,\n      () => 'Batch normalization gradient requires mean and variance to have ' +\n          'equal ranks.');\n  util.assert(\n      offset == null || mean.shape.length === offset.shape.length,\n      () => 'Batch normalization gradient requires mean and offset to have ' +\n          'equal ranks.');\n  util.assert(\n      scale == null || mean.shape.length === scale.shape.length,\n      () => 'Batch normalization gradient requires mean and scale to have ' +\n          'equal ranks.');\n\n  let {varianceEpsilon} = attrs;\n  if (varianceEpsilon == null) {\n    varianceEpsilon = 0.001;\n  }\n\n  const finalInputs = [x, mean, variance];\n\n  let offsetShape = null;\n  if (offset != null) {\n    offsetShape = offset.shape;\n    finalInputs.push(offset);\n  }\n\n  let scaleShape = null;\n  if (scale != null) {\n    scaleShape = scale.shape;\n    finalInputs.push(scale);\n  }\n\n  const program = env().getBool('WEBGL_PACK_NORMALIZATION') ?\n      new BatchNormPackedProgram(\n          x.shape, mean.shape, variance.shape, offsetShape, scaleShape,\n          varianceEpsilon) :\n      new BatchNormProgram(\n          x.shape, mean.shape, variance.shape, offsetShape, scaleShape,\n          varianceEpsilon);\n  const output =\n      backend.runWebGLProgram(program, finalInputs, finalInputs[0].dtype);\n\n  return output;\n};\n\nexport const batchNormConfig: KernelConfig = {\n  kernelName: FusedBatchNorm,\n  backendName: 'webgl',\n  kernelFunc: batchNorm as {} as KernelFunc,\n};\n","/**\n * @license\n * Copyright 2017 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {GPGPUProgram} from './gpgpu_math';\nimport {getCoordsDataType, UniformType} from './shader_compiler';\n\nexport class SliceProgram implements GPGPUProgram {\n  variableNames = ['source'];\n  outputShape: number[];\n  userCode: string;\n  rank: number;\n  customUniforms: Array<{name: string; arrayIndex: number; type: UniformType;}>;\n\n  constructor(destSize: number[]) {\n    this.outputShape = destSize;\n    this.rank = destSize.length;\n\n    const dtype = getCoordsDataType(this.rank);\n    this.customUniforms = [{name: 'start', arrayIndex: this.rank, type: 'int'}];\n    const sourceCoords = getCoords(this.rank);\n\n    let body: string;\n    const coordSum = destSize.map((_, i) => {\n      return `sourceLoc.${coords[i]} = start[${i}] + coords.${coords[i]};`;\n    });\n    body = `\n        ${dtype} sourceLoc;\n        ${dtype} coords = getOutputCoords();\n        ${coordSum.join('\\n')}\n      `;\n    this.userCode = `\n      void main() {\n        ${body}\n        setOutput(getSource(${sourceCoords}));\n      }\n    `;\n  }\n}\n\nconst coords = ['x', 'y', 'z', 'w', 'u', 'v'];\n\nfunction getCoords(rank: number): string {\n  if (rank === 1) {\n    return 'sourceLoc';\n  } else if (rank <= 6) {\n    return coords.slice(0, rank).map(x => 'sourceLoc.' + x).join(',');\n  } else {\n    throw Error(`Slicing for rank ${rank} is not yet supported`);\n  }\n}\n","/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {GPGPUProgram} from './gpgpu_math';\nimport {getChannels} from './packing_util';\nimport {getCoordsDataType, UniformType} from './shader_compiler';\n\nexport class SlicePackedProgram implements GPGPUProgram {\n  variableNames = ['source'];\n  packedInputs = true;\n  packedOutput = true;\n  outputShape: number[];\n  userCode: string;\n  rank: number;\n  customUniforms: Array<{name: string; arrayIndex: number; type: UniformType;}>;\n\n  constructor(destSize: number[]) {\n    this.outputShape = destSize;\n    this.rank = destSize.length;\n    this.customUniforms = [{name: 'start', arrayIndex: this.rank, type: 'int'}];\n    const dtype = getCoordsDataType(this.rank);\n    const coords = getChannels('coords', this.rank);\n    const sourceLoc = getChannels('sourceLoc', this.rank);\n\n    const innerDims =\n        this.rank === 1 ? 'sourceLoc' : `vec2(${sourceLoc.slice(-2).join()})`;\n    const getChannel =\n        `getChannel(getSource(${sourceLoc.join()}), ${innerDims})`;\n    const upperRow = `\n      result.x = ${getChannel};\n      if (++${coords[this.rank - 1]} < ${destSize[this.rank - 1]}) {\n        ++${sourceLoc[this.rank - 1]};\n        result.y = ${getChannel};\n        --${sourceLoc[this.rank - 1]};\n      }\n    `;\n    const lowerRow = this.rank === 1 ? '' : `\n      --${coords[this.rank - 1]};\n      if (++${coords[this.rank - 2]} < ${destSize[this.rank - 2]}) {\n        ++${sourceLoc[this.rank - 2]};\n        result.z = ${getChannel};\n        if (++${coords[this.rank - 1]} < ${destSize[this.rank - 1]}) {\n          ++${sourceLoc[this.rank - 1]};\n          result.w = ${getChannel};\n        }\n      }\n    `;\n\n    const sourceLocSetup = this.rank <= 4 ?\n        `sourceLoc = coords +\n            ${dtype}(${destSize.map((_, i) => `start[${i}]`).join()});` :\n        destSize.map((_, i) => `${sourceLoc[i]} = ${coords[i]} + start[${i}];`)\n            .join('\\n');\n    this.userCode = `\n      void main() {\n        ${dtype} coords = getOutputCoords();\n        ${dtype} sourceLoc;\n        ${sourceLocSetup}\n        vec4 result = vec4(0.);\n        ${upperRow}\n        ${lowerRow}\n        setOutput(result);\n      }\n    `;\n  }\n}\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {env, KernelConfig, KernelFunc, Slice, slice_util, SliceAttrs, SliceInputs, TensorInfo, TypedArray, util} from '@tensorflow/tfjs-core';\n\nimport {MathBackendWebGL} from '../backend_webgl';\nimport {sliceImplCPU} from '../kernel_utils/shared';\nimport {SliceProgram} from '../slice_gpu';\nimport {SlicePackedProgram} from '../slice_packed_gpu';\n\nfunction shallowSlice(\n    x: TensorInfo, begin: number[], size: number[], backend: MathBackendWebGL) {\n  const xTexData = backend.texData.get(x.dataId);\n  const t = backend.makeTensorInfo(size, x.dtype);\n  const newTexData = backend.texData.get(t.dataId);\n  // Copy texture data from the original tensor.\n  Object.assign(newTexData, xTexData);\n  newTexData.refCount = 1;\n  newTexData.shape = size;\n  newTexData.dtype = x.dtype;\n  let flatOffset =\n      slice_util.computeFlatOffset(begin, util.computeStrides(x.shape));\n  if (xTexData.slice) {\n    // We are slicing an already sliced tensor, so we have to accumulate\n    // the offset.\n    flatOffset += xTexData.slice.flatOffset;\n  }\n  newTexData.slice = {\n    flatOffset,\n    // Point to the original dataId, which is used to do ref counting.\n    origDataId: xTexData.slice && xTexData.slice.origDataId || x.dataId\n  };\n\n  // Increase the ref count for that data bucket.\n  const refCount = backend.dataRefCount.get(newTexData.slice.origDataId) || 1;\n  backend.dataRefCount.set(newTexData.slice.origDataId, refCount + 1);\n  return t;\n}\n\nexport function slice(\n    args: {inputs: SliceInputs, backend: MathBackendWebGL, attrs: SliceAttrs}):\n    TensorInfo {\n  const {inputs, backend, attrs} = args;\n  const {x} = inputs;\n  const {begin, size} = attrs;\n\n  const [$begin, $size] = slice_util.parseSliceParams(x, begin, size);\n  slice_util.assertParamsValid(x, $begin, $size);\n\n  if (util.sizeFromShape($size) === 0) {\n    return backend.makeTensorInfo($size, x.dtype, []);\n  }\n\n  // Run on cpu if dtype is string. For string, the backend represents it\n  // as Uint8Array[], where each Uint8Array is a character. Given that the\n  // computation is only on the outer array, uploading the whole data onto\n  // gpu is wasteful. Also, currently webgl doesn't have a design to\n  // upload and retrieve Uint8Array[] between cpu and gpu. Therefore, we\n  // just run the kernel on cpu if dtype is string.\n  if (backend.shouldExecuteOnCPU([x]) || x.dtype === 'string') {\n    const xTexData = backend.texData.get(x.dataId);\n    const outValues = sliceImplCPU(\n        xTexData.values as TypedArray, $begin, $size, x.shape, x.dtype);\n    return backend.makeTensorInfo($size, x.dtype, outValues);\n  }\n\n  const {isPacked} = backend.texData.get(x.dataId);\n  const isContinous = slice_util.isSliceContinous(x.shape, $begin, $size);\n  if (isPacked || !isContinous) {\n    const program = env().getBool('WEBGL_PACK_ARRAY_OPERATIONS') ?\n        new SlicePackedProgram($size) :\n        new SliceProgram($size);\n    const customValues = [$begin];\n    return backend.runWebGLProgram(program, [x], x.dtype, customValues);\n  }\n  backend.uploadToGPU(x.dataId);\n  return shallowSlice(x, $begin, $size, backend);\n}\n\nexport const sliceConfig: KernelConfig = {\n  kernelName: Slice,\n  backendName: 'webgl',\n  kernelFunc: slice as {} as KernelFunc\n};\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {backend_util, BatchToSpaceND, BatchToSpaceNDAttrs, BatchToSpaceNDInputs, KernelConfig, KernelFunc, TensorInfo, util} from '@tensorflow/tfjs-core';\n\nimport {MathBackendWebGL} from '../backend_webgl';\n\nimport {reshape} from './Reshape';\nimport {slice} from './Slice';\nimport {transpose} from './Transpose';\n\nexport const batchToSpaceND = (args: {\n  inputs: BatchToSpaceNDInputs,\n  backend: MathBackendWebGL,\n  attrs: BatchToSpaceNDAttrs\n}): TensorInfo => {\n  const {inputs, backend, attrs} = args;\n  const {x} = inputs;\n  const {blockShape, crops} = attrs;\n\n  util.assert(\n      x.shape.length <= 4,\n      () => 'batchToSpaceND for rank > 4 with a WebGL backend not ' +\n          'implemented yet');\n  const prod = blockShape.reduce((a, b) => a * b);\n\n  const reshaped = backend_util.getReshaped(x.shape, blockShape, prod);\n  const permuted = backend_util.getPermuted(reshaped.length, blockShape.length);\n  const reshapedPermuted =\n      backend_util.getReshapedPermuted(x.shape, blockShape, prod);\n  const sliceBeginCoords =\n      backend_util.getSliceBeginCoords(crops, blockShape.length);\n  const sliceSize =\n      backend_util.getSliceSize(reshapedPermuted, crops, blockShape.length);\n\n  const toDispose = [];\n\n  const reshapedIntermediate =\n      reshape({inputs: {x}, backend, attrs: {shape: reshaped}});\n  const transposedIntermediate = transpose(\n      {inputs: {x: reshapedIntermediate}, backend, attrs: {perm: permuted}});\n  const reshapedIntermediate2 = reshape({\n    inputs: {x: transposedIntermediate},\n    backend,\n    attrs: {shape: reshapedPermuted}\n  });\n  const sliced = slice({\n    inputs: {x: reshapedIntermediate2},\n    backend,\n    attrs: {begin: sliceBeginCoords, size: sliceSize}\n  });\n\n  toDispose.push(reshapedIntermediate);\n  toDispose.push(transposedIntermediate);\n  toDispose.push(reshapedIntermediate2);\n\n  toDispose.forEach(t => backend.disposeIntermediateTensorInfo(t));\n\n  return sliced;\n};\n\nexport const batchToSpaceNDConfig: KernelConfig = {\n  kernelName: BatchToSpaceND,\n  backendName: 'webgl',\n  kernelFunc: batchToSpaceND as {} as KernelFunc\n};\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {Bincount, BincountAttrs, BincountInputs, KernelConfig, KernelFunc, TensorInfo, TypedArray} from '@tensorflow/tfjs-core';\n\nimport {MathBackendWebGL} from '../backend_webgl';\nimport {bincountImplCPU} from '../kernel_utils/shared';\n\nexport function bincount(args: {\n  inputs: BincountInputs,\n  backend: MathBackendWebGL,\n  attrs: BincountAttrs\n}): TensorInfo {\n  const {inputs, backend, attrs} = args;\n  const {x, weights} = inputs;\n  const {size} = attrs;\n\n  const xVals = backend.readSync(x.dataId) as TypedArray;\n  const weightsVals = backend.readSync(weights.dataId) as TypedArray;\n\n  const outVals =\n      bincountImplCPU(xVals, weightsVals, weights.dtype, weights.shape, size);\n\n  return backend.makeTensorInfo([size], weights.dtype, outVals);\n}\n\nexport const bincountConfig: KernelConfig = {\n  kernelName: Bincount,\n  backendName: 'webgl',\n  kernelFunc: bincount as {} as KernelFunc\n};\n","/**\n * @license\n * Copyright 2021 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {backend_util, BroadcastArgs, BroadcastArgsInputs, KernelConfig, TensorInfo, TypedArray} from '@tensorflow/tfjs-core';\nimport {MathBackendWebGL} from '../backend_webgl';\n\nexport function broadcastArgs(args: {\n  inputs: BroadcastArgsInputs,\n  backend: MathBackendWebGL,\n}): TensorInfo {\n  const {inputs, backend} = args;\n  const {s0, s1} = inputs;\n\n  const s0Vals = backend.readSync(s0.dataId) as TypedArray;\n  const s1Vals = backend.readSync(s1.dataId) as TypedArray;\n\n  const broadcastShape = backend_util.assertAndGetBroadcastShape(\n      Array.from(s0Vals), Array.from(s1Vals));\n\n  return backend.makeTensorInfo(\n      [broadcastShape.length], 'int32', Int32Array.from(broadcastShape));\n}\n\nexport const broadcastArgsConfig: KernelConfig = {\n  kernelName: BroadcastArgs,\n  backendName: 'webgl',\n  kernelFunc: broadcastArgs\n};\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {NotEqual} from '@tensorflow/tfjs-core';\nimport {KernelConfig} from '@tensorflow/tfjs-core';\nimport {binaryKernelFunc} from '../kernel_utils/kernel_funcs_utils';\nimport {notEqualImplCPU} from '../kernel_utils/shared';\n\nconst NOT_EQUAL = `return float(a != b);`;\n\nexport const notEqual = binaryKernelFunc(\n    {opSnippet: NOT_EQUAL, cpuKernelImpl: notEqualImplCPU, dtype: 'bool'});\n\nexport const notEqualConfig: KernelConfig = {\n  kernelName: NotEqual,\n  backendName: 'webgl',\n  kernelFunc: notEqual,\n};\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {KernelConfig, KernelFunc, Real, RealInputs, TensorInfo} from '@tensorflow/tfjs-core';\n\nimport {MathBackendWebGL} from '../backend_webgl';\nimport {identity} from './Identity';\n\nexport function real(args: {inputs: RealInputs, backend: MathBackendWebGL}):\n    TensorInfo {\n  const {inputs, backend} = args;\n  const {input} = inputs;\n  const inputData = backend.texData.get(input.dataId);\n\n  return identity({inputs: {x: inputData.complexTensorInfos.real}, backend});\n}\n\nexport const realConfig: KernelConfig = {\n  kernelName: Real,\n  backendName: 'webgl',\n  kernelFunc: real as {} as KernelFunc\n};\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {TensorInfo} from '@tensorflow/tfjs-core';\n\nimport {MathBackendWebGL} from '../backend_webgl';\nimport {UnaryOpProgram} from '../unaryop_gpu';\n\nconst TO_INT = `return float(int(x));`;\n\nexport function int(input: TensorInfo, backend: MathBackendWebGL): TensorInfo {\n  const program = new UnaryOpProgram(input.shape, TO_INT);\n  const output = backend.runWebGLProgram(program, [input], 'int32');\n  return {dataId: output.dataId, shape: output.shape, dtype: output.dtype};\n}\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport * as tf from '@tensorflow/tfjs-core';\nimport {BinaryInputs, Cast, CastAttrs, CastInputs, KernelConfig, KernelFunc, TensorInfo, TypedArray, util} from '@tensorflow/tfjs-core';\n\nimport {MathBackendWebGL} from '../backend_webgl';\nimport {castImplCPU} from '../kernel_utils/shared';\nimport {complex} from './Complex';\nimport {identity} from './Identity';\nimport {notEqual} from './NotEqual';\nimport {real} from './Real';\n\nimport {int} from '../kernel_utils/int';\n\nexport function cast(\n    args: {inputs: CastInputs, backend: MathBackendWebGL, attrs: CastAttrs}):\n    TensorInfo {\n  const {inputs, backend, attrs} = args;\n  const {x} = inputs;\n  const {dtype} = attrs;\n\n  // Casting to complex64.\n  if (dtype === 'complex64') {\n    if (x.dtype === 'complex64') {\n      return identity({inputs: {x}, backend});\n    }\n\n    // TODO(annxingyuan): Import kernel function once zeros is modularized.\n    const zerosTensor = tf.zeros(x.shape);\n    const floatX = cast({inputs: {x}, backend, attrs: {dtype: 'float32'}});\n\n    const result =\n        complex({inputs: {real: floatX, imag: zerosTensor}, backend});\n\n    zerosTensor.dispose();\n    backend.disposeIntermediateTensorInfo(floatX);\n\n    return result;\n  }\n\n  // Casting from complex64\n  if (x.dtype === 'complex64') {\n    const realPart = real({inputs: {input: x}, backend});\n    const result = cast({inputs: {x: realPart}, backend, attrs: {dtype}});\n    backend.disposeIntermediateTensorInfo(realPart);\n    return result;\n  }\n\n  if (!util.hasEncodingLoss(x.dtype, dtype)) {\n    // We don't change the underlying data, since we cast to higher\n    // precision.\n    const result = identity({inputs: {x}, backend});\n    return {dataId: result.dataId, shape: result.shape, dtype};\n  }\n\n  if (backend.shouldExecuteOnCPU([x])) {\n    const values = backend.texData.get(x.dataId).values as TypedArray;\n    const [resultShape, resultType, resultData] =\n        castImplCPU(values, x.shape, x.dtype, dtype);\n    return backend.makeTensorInfo(resultShape, resultType, resultData);\n  }\n\n  if (dtype === 'int32') {\n    return int(x, backend);\n  }\n\n  if (dtype === 'bool') {\n    const zerosTensorInfo = backend.makeTensorInfo(\n        [], 'bool', util.getTypedArrayFromDType('bool', 1));\n\n    const binaryInputs: BinaryInputs = {a: x, b: zerosTensorInfo};\n\n    const result = notEqual({inputs: binaryInputs, backend}) as TensorInfo;\n    backend.disposeIntermediateTensorInfo(zerosTensorInfo);\n    return result;\n  }\n\n  throw new Error(`Error in Cast: failed to cast ${x.dtype} to ${dtype}`);\n}\n\nexport const castConfig: KernelConfig = {\n  kernelName: Cast,\n  backendName: 'webgl',\n  kernelFunc: cast as {} as KernelFunc\n};\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {Ceil, KernelConfig, KernelFunc} from '@tensorflow/tfjs-core';\nimport {unaryKernelFunc} from '../kernel_utils/kernel_funcs_utils';\nimport {ceilImplCPU} from '../kernel_utils/shared';\n\nconst CEIL = `return ceil(x);`;\n\nexport const ceil = unaryKernelFunc(\n    {opSnippet: CEIL, packedOpSnippet: CEIL, cpuKernelImpl: ceilImplCPU});\n\nexport const ceilConfig: KernelConfig = {\n  kernelName: Ceil,\n  backendName: 'webgl',\n  kernelFunc: ceil as {} as KernelFunc\n};\n","/**\n * @license\n * Copyright 2017 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {GPGPUProgram} from './gpgpu_math';\nimport {UniformType} from './shader_compiler';\n\nexport class ClipProgram implements GPGPUProgram {\n  variableNames = ['A'];\n  userCode: string;\n  outputShape: number[];\n  customUniforms = [\n    {name: 'minVal', type: 'float' as UniformType},\n    {name: 'maxVal', type: 'float' as UniformType}\n  ];\n\n  constructor(aShape: number[]) {\n    this.outputShape = aShape;\n    this.userCode = `\n\n      void main() {\n        float value = getAAtOutCoords();\n        if (isnan(value)) {\n          setOutput(value);\n          return;\n        }\n\n        setOutput(clamp(value, minVal, maxVal));\n      }\n    `;\n  }\n}\n","/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {GPGPUProgram} from './gpgpu_math';\nimport {UniformType} from './shader_compiler';\n\nexport class ClipPackedProgram implements GPGPUProgram {\n  variableNames = ['A'];\n  packedInputs = true;\n  packedOutput = true;\n  userCode: string;\n  outputShape: number[];\n  customUniforms = [\n    {name: 'minVal', type: 'float' as UniformType},\n    {name: 'maxVal', type: 'float' as UniformType}\n  ];\n\n  constructor(aShape: number[]) {\n    this.outputShape = aShape;\n    this.userCode = `\n      void main() {\n        vec4 value = getAAtOutCoords();\n\n        if (any(isnan(value))) {\n          setOutput(value);\n          return;\n        }\n\n        setOutput(clamp(value, vec4(minVal), vec4(maxVal)));\n      }\n    `;\n  }\n}\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {ClipByValue, ClipByValueAttrs, ClipByValueInputs, env, KernelConfig, KernelFunc, TensorInfo} from '@tensorflow/tfjs-core';\n\nimport {MathBackendWebGL} from '../backend_webgl';\nimport {ClipProgram} from '../clip_gpu';\nimport {ClipPackedProgram} from '../clip_packed_gpu';\n\nexport function clipByValue(args: {\n  inputs: ClipByValueInputs,\n  backend: MathBackendWebGL,\n  attrs: ClipByValueAttrs\n}): TensorInfo {\n  const {inputs, backend, attrs} = args;\n  const {x} = inputs;\n  const {clipValueMin, clipValueMax} = attrs;\n\n  let program;\n  if (env().getBool('WEBGL_PACK_CLIP')) {\n    program = new ClipPackedProgram(x.shape);\n  } else {\n    program = new ClipProgram(x.shape);\n  }\n  const customValues = [[clipValueMin], [clipValueMax]];\n  return backend.runWebGLProgram(program, [x], x.dtype, customValues);\n}\n\nexport const clipByValueConfig: KernelConfig = {\n  kernelName: ClipByValue,\n  backendName: 'webgl',\n  kernelFunc: clipByValue as {} as KernelFunc\n};\n","/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {GPGPUProgram} from './gpgpu_math';\n\nexport class ComplexAbsProgram implements GPGPUProgram {\n  variableNames = ['real', 'imag'];\n  userCode: string;\n  outputShape: number[];\n\n  constructor(shape: number[]) {\n    this.outputShape = shape;\n    this.userCode = `\n      void main() {\n        float re = abs(getRealAtOutCoords());\n        float im = abs(getImagAtOutCoords());\n        float mx = max(re, im);\n\n        // sadly the length function in glsl is not underflow-safe\n        // (at least not on Intel GPUs). So the safe solution is\n        // to ensure underflow-safety in all cases.\n        setOutput(\n          mx == 0.0 ? 0.0 : mx * length(vec2(1, min(re, im)/mx))\n        );\n      }\n    `;\n  }\n}\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {ComplexAbs, ComplexAbsInputs, KernelConfig, KernelFunc, TensorInfo} from '@tensorflow/tfjs-core';\n\nimport {MathBackendWebGL} from '../backend_webgl';\nimport {ComplexAbsProgram} from '../complex_abs_gpu';\n\n// Returns a TensorInfo with the complex shape and the dataId of the\n// underlying part. We need to do this because a reshaped complex tensor is\n// not reflected in its parts.\nfunction makeComplexComponentTensorInfo(\n    complexTensor: TensorInfo, complexPart: TensorInfo): TensorInfo {\n  return {\n    dataId: complexPart.dataId,\n    dtype: complexPart.dtype,\n    shape: complexTensor.shape\n  };\n}\n\nexport function complexAbs(\n    args: {inputs: ComplexAbsInputs, backend: MathBackendWebGL}): TensorInfo {\n  const {inputs, backend} = args;\n  const {x} = inputs;\n\n  const xData = backend.texData.get(x.dataId);\n\n  const program = new ComplexAbsProgram(x.shape);\n  const programInputs = [\n    makeComplexComponentTensorInfo(x, xData.complexTensorInfos.real),\n    makeComplexComponentTensorInfo(x, xData.complexTensorInfos.imag),\n  ];\n\n  return backend.runWebGLProgram(\n      program, programInputs, programInputs[0].dtype);\n}\n\nexport const complexAbsConfig: KernelConfig = {\n  kernelName: ComplexAbs,\n  backendName: 'webgl',\n  kernelFunc: complexAbs as {} as KernelFunc\n};\n","/**\n * @license\n * Copyright 2017 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {backend_util} from '@tensorflow/tfjs-core';\nimport {GPGPUProgram} from './gpgpu_math';\n\nexport class ConcatProgram implements GPGPUProgram {\n  variableNames: string[];\n  outputShape: number[] = [];\n  userCode: string;\n\n  // Concats 2d tensors along axis=1. See comments in MathBackendWebGL.concat().\n  constructor(shapes: Array<[number, number]>) {\n    this.outputShape = backend_util.computeOutShape(shapes, 1 /* axis */);\n    this.variableNames = shapes.map((_, i) => `T${i}`);\n\n    const offsets: number[] = new Array(shapes.length - 1);\n    offsets[0] = shapes[0][1];\n    for (let i = 1; i < offsets.length; i++) {\n      offsets[i] = offsets[i - 1] + shapes[i][1];\n    }\n\n    const snippets = [`if (yC < ${offsets[0]}) setOutput(getT0(yR, yC));`];\n    for (let i = 1; i < offsets.length; i++) {\n      const shift = offsets[i - 1];\n      snippets.push(\n          `else if (yC < ${offsets[i]}) ` +\n          `setOutput(getT${i}(yR, yC-${shift}));`);\n    }\n    const lastIndex = offsets.length;\n    const lastShift = offsets[offsets.length - 1];\n    snippets.push(`else setOutput(getT${lastIndex}(yR, yC-${lastShift}));`);\n\n    this.userCode = `\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int yR = coords.x;\n        int yC = coords.y;\n\n        ${snippets.join('\\n        ')}\n      }\n    `;\n  }\n}\n","/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {backend_util} from '@tensorflow/tfjs-core';\n\nimport {GPGPUProgram} from './gpgpu_math';\nimport {getChannels} from './packing_util';\nimport {getCoordsDataType} from './shader_compiler';\n\nexport class ConcatPackedProgram implements GPGPUProgram {\n  variableNames: string[];\n  packedInputs = true;\n  packedOutput = true;\n  outputShape: number[] = [];\n  userCode: string;\n\n  constructor(shapes: number[][], axis: number) {\n    this.outputShape = backend_util.computeOutShape(shapes, axis);\n    const shape = this.outputShape;\n    const rank = shape.length;\n    const dtype = getCoordsDataType(rank);\n    const coords = getChannels('coords', rank);\n    const channels = ['x', 'y', 'z', 'w', 'u', 'v'].slice(0, rank);\n    this.variableNames = shapes.map((_, i) => `T${i}`);\n\n    const offsets: number[] = new Array(shapes.length - 1);\n    offsets[0] = shapes[0][axis];\n    for (let i = 1; i < offsets.length; i++) {\n      offsets[i] = offsets[i - 1] + shapes[i][axis];\n    }\n\n    const channel = channels[axis];\n    const lastChannels = channels.slice(-2);\n    const allChannels = channels.join();\n\n    let getValueSnippet = `if (${channel} < ${offsets[0]}) {\n        return getChannel(\n            getT0(${allChannels}), vec2(${lastChannels.join()}));\n        }`;\n    for (let i = 1; i < offsets.length; i++) {\n      const shift = offsets[i - 1];\n      // Note: the >= comparison below may seem unnecessary given the check\n      // above but is needed to workaround branch execution issues on some\n      // devices. It makes all the conditions exclusive without relying on\n      // execution order.\n      getValueSnippet += `\n        if (${channel} < ${offsets[i]}  && ${channel} >= ${offsets[i - 1]}) {\n          return getChannel(\n            getT${i}(${shiftedChannels(channels, channel, shift)}),\n            vec2(${shiftedChannels(lastChannels, channel, shift)}));\n        }`;\n    }\n    const lastIndex = offsets.length;\n    const shift = offsets[offsets.length - 1];\n    getValueSnippet += `\n        return getChannel(\n          getT${lastIndex}(${shiftedChannels(channels, channel, shift)}),\n          vec2(${shiftedChannels(lastChannels, channel, shift)}));`;\n\n    this.userCode = `\n      float getValue(${channels.map(x => 'int ' + x)}) {\n        ${getValueSnippet}\n      }\n\n      void main() {\n        ${dtype} coords = getOutputCoords();\n        vec4 result = vec4(getValue(${coords}), 0., 0., 0.);\n\n        ${coords[rank - 1]} = ${coords[rank - 1]} + 1;\n        if (${coords[rank - 1]} < ${shape[rank - 1]}) {\n          result.g = getValue(${coords});\n        }\n\n        ${coords[rank - 2]} = ${coords[rank - 2]} + 1;\n        if (${coords[rank - 2]} < ${shape[rank - 2]}) {\n          result.a = getValue(${coords});\n        }\n\n        ${coords[rank - 1]} = ${coords[rank - 1]} - 1;\n        if (${coords[rank - 2]} < ${shape[rank - 2]} &&\n            ${coords[rank - 1]} < ${shape[rank - 1]}) {\n          result.b = getValue(${coords});\n        }\n        setOutput(result);\n      }\n    `;\n  }\n}\n\n/**\n * Return an expression for coordinates into a vector where a given channel\n * will be offset by [shift].\n *\n * @param channels the channels to consider\n * @param channel the channel we want shifted\n * @param shift  the amount to subtract from the channel.\n *\n * @returns a string of the form 'x, y-[shift], z' where any one channel can\n * have the shift applied.\n */\nfunction shiftedChannels(channels: string[], channel: string, shift: number) {\n  const channelIdx = channels.indexOf(channel);\n  const res = channels.map((c, idx) => {\n    if (idx === channelIdx) {\n      return `${c} - ${shift}`;\n    } else {\n      return c;\n    }\n  });\n  return res.join();\n}\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {Imag, ImagInputs, KernelConfig, KernelFunc, TensorInfo} from '@tensorflow/tfjs-core';\n\nimport {MathBackendWebGL} from '../backend_webgl';\nimport {identity} from './Identity';\n\nexport function imag(args: {inputs: ImagInputs, backend: MathBackendWebGL}):\n    TensorInfo {\n  const {inputs, backend} = args;\n  const {input} = inputs;\n  const inputData = backend.texData.get(input.dataId);\n\n  return identity({inputs: {x: inputData.complexTensorInfos.imag}, backend});\n}\n\nexport const imagConfig: KernelConfig = {\n  kernelName: Imag,\n  backendName: 'webgl',\n  kernelFunc: imag as {} as KernelFunc\n};\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {backend_util, ConcatInputs, env, TensorInfo, util} from '@tensorflow/tfjs-core';\n\nimport {MathBackendWebGL} from '../backend_webgl';\nimport {ConcatProgram} from '../concat_gpu';\nimport {ConcatPackedProgram} from '../concat_packed_gpu';\nimport {concatImplCPU} from '../kernel_utils/shared';\nimport {CLONE, UnaryOpProgram} from '../unaryop_gpu';\nimport {UnaryOpPackedProgram} from '../unaryop_packed_gpu';\n\nimport {complex} from './Complex';\nimport {imag} from './Imag';\nimport {real} from './Real';\nimport {reshape} from './Reshape';\n\nexport function concatImpl(\n    inputs: ConcatInputs, axis: number, backend: MathBackendWebGL): TensorInfo {\n  const dtype = inputs[0].dtype;\n  if (dtype === 'complex64') {\n    const reals = inputs.map((t) => real({inputs: {input: t}, backend}));\n    const imags = inputs.map((t) => imag({inputs: {input: t}, backend}));\n\n    const realConcated = concatImpl(reals, axis, backend);\n    const imagConcated = concatImpl(imags, axis, backend);\n\n    const result =\n        complex({inputs: {real: realConcated, imag: imagConcated}, backend});\n\n    reals.forEach(r => backend.disposeIntermediateTensorInfo(r));\n    imags.forEach(i => backend.disposeIntermediateTensorInfo(i));\n    backend.disposeIntermediateTensorInfo(realConcated);\n    backend.disposeIntermediateTensorInfo(imagConcated);\n\n    return result;\n  }\n\n  let runOnCpu = backend.shouldExecuteOnCPU(inputs);\n\n  // Run on cpu if dtype is string. For string, the backend represents it\n  // as Uint8Array[], where each Uint8Array is a character. Given that the\n  // computation is only on the outer array, uploading the whole data onto\n  // gpu is wasteful. Also, currently webgl doesn't have a design to\n  // upload and retrieve Uint8Array[] between cpu and gpu. Therefore, we\n  // just run the kernel on cpu if dtype is string.\n  if (dtype === 'string') {\n    runOnCpu = true;\n  }\n\n  if (runOnCpu) {\n    // Any concat of n-dimensional tensors across any axis can be reduced to\n    // a concatenation of two-dimensional tensors across the axis 1 by first\n    // partitioning the axes of the original tensors into those less than the\n    // axis to be concatenated and the rest. Then reshape the tensors\n    // into a two-dimensional tensor by collapsing these two sets of axes and\n    // concatenate the resulting matrices across the axis 1, finally reshaping\n    // the result to have the proper shape.\n    const tensors2D = inputs.map(t => {\n      const innerSize = util.sizeFromShape(t.shape.slice(axis));\n      const shape = [-1, innerSize];\n      return reshape({inputs: {x: t}, backend, attrs: {shape}});\n    });\n\n    const inputsValShapes = tensors2D.map(t => {\n      return {vals: backend.readSync(t.dataId), shape: t.shape};\n    });\n\n    // Concats 2d tensors along axis=1.\n    const outShape =\n        backend_util.computeOutShape(tensors2D.map(t => t.shape), 1 /* axis */);\n    const simplyConcat = tensors2D[0].shape[0] === 1;\n    const outVals =\n        concatImplCPU(inputsValShapes, outShape, dtype, simplyConcat);\n\n    const finalOutShape =\n        backend_util.computeOutShape(inputs.map(t => t.shape), axis);\n\n    const outInfo = backend.makeTensorInfo(finalOutShape, dtype, outVals);\n\n    tensors2D.forEach(t => backend.disposeIntermediateTensorInfo(t));\n\n    return outInfo;\n  }\n\n  // Keep only non-empty tensors (ignore tensors with 0 in their shape).\n  const $inputs = inputs.filter(t => util.sizeFromShape(t.shape) > 0);\n\n  const shouldPack: boolean = env().getBool('WEBGL_PACK_ARRAY_OPERATIONS') &&\n      $inputs[0].shape.length > 1;\n\n  if ($inputs.length === 1) {\n    // Clone tensor.\n    const program = shouldPack ?\n        new UnaryOpProgram(inputs[0].shape, CLONE) :\n        new UnaryOpPackedProgram(inputs[0].shape, CLONE);\n    return backend.runWebGLProgram(program, inputs, dtype);\n  }\n\n  const maxTexturesInShader = env().getNumber('WEBGL_MAX_TEXTURES_IN_SHADER');\n  if ($inputs.length > maxTexturesInShader) {\n    const reducedInputs = [];\n    for (let i = 0; i < $inputs.length; i += maxTexturesInShader) {\n      const subArray = $inputs.slice(i, i + maxTexturesInShader);\n      reducedInputs.push(concatImpl(subArray, axis, backend));\n    }\n    const result = concatImpl(reducedInputs, axis, backend);\n\n    for (const i of reducedInputs) {\n      backend.disposeIntermediateTensorInfo(i);\n    }\n\n    return result;\n  }\n\n  if (shouldPack) {\n    const program = new ConcatPackedProgram($inputs.map(t => t.shape), axis);\n    return backend.runWebGLProgram(program, $inputs, dtype);\n  }\n\n  const {tensors2D, outShape} = computeTensors2D($inputs, axis, backend);\n  const program =\n      new ConcatProgram(tensors2D.map(t => t.shape as [number, number]));\n  const result = backend.runWebGLProgram(program, tensors2D, dtype);\n\n  tensors2D.forEach(r => backend.disposeIntermediateTensorInfo(r));\n  const reshapedResult =\n      reshape({inputs: {x: result}, attrs: {shape: outShape}, backend});\n  backend.disposeIntermediateTensorInfo(result);\n\n  return reshapedResult;\n}\n\nfunction computeTensors2D(\n    inputs: ConcatInputs, axis: number, backend: MathBackendWebGL) {\n  // Any concat of n-dimensional tensors across any axis can be reduced to\n  // a concatenation of two-dimensional tensors across the axis 1 by first\n  // partitioning the axes of the original tensors into those less than the\n  // axis to be concatenated and the rest. Then reshape the tensors\n  // into a two-dimensional tensor by collapsing these two sets of axes and\n  // concatenate the resulting matrices across the axis 1, finally reshaping\n  // the result to have the proper shape.\n  const outShape = backend_util.computeOutShape(inputs.map(t => t.shape), axis);\n  const tensors2D = inputs.map(\n      x => reshape({\n        inputs: {x},\n        attrs: {shape: [-1, util.sizeFromShape(x.shape.slice(axis))]},\n        backend\n      }));\n\n  return {tensors2D, outShape};\n}\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {backend_util, Concat, ConcatAttrs, ConcatInputs, KernelConfig, KernelFunc, TensorInfo, util} from '@tensorflow/tfjs-core';\n\nimport {MathBackendWebGL} from '../backend_webgl';\nimport {concatImpl} from './Concat_impl';\nimport {identity} from './Identity';\n\nexport function concat(\n    args:\n        {inputs: ConcatInputs, attrs: ConcatAttrs, backend: MathBackendWebGL}):\n    TensorInfo {\n  const {inputs, backend, attrs} = args;\n  const {axis} = attrs;\n\n  const $axis = util.parseAxisParam(axis, inputs[0].shape)[0];\n\n  const shapes = inputs.map(t => t.shape);\n  backend_util.assertParamsConsistent(shapes, $axis);\n\n  const outShape =\n      backend_util.computeOutShape(inputs.map(t => t.shape), $axis);\n\n  if (util.sizeFromShape(outShape) === 0) {\n    return backend.makeTensorInfo(outShape, inputs[0].dtype, []);\n  }\n\n  // Keep only non-empty tensors (ignore tensors with 0 in their shape).\n  const $inputs = inputs.filter(t => util.sizeFromShape(t.shape) > 0);\n  if ($inputs.length === 1) {\n    return identity({inputs: {x: $inputs[0]}, backend});\n  }\n\n  return concatImpl($inputs, $axis, backend);\n}\n\nexport const concatConfig: KernelConfig = {\n  kernelName: Concat,\n  backendName: 'webgl',\n  kernelFunc: concat as {} as KernelFunc\n};\n","/**\n * @license\n * Copyright 2017 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {backend_util} from '@tensorflow/tfjs-core';\nimport {GPGPUProgram} from './gpgpu_math';\n\nexport class Conv2DProgram implements GPGPUProgram {\n  variableNames = ['x', 'W'];\n  outputShape: number[];\n  userCode: string;\n\n  constructor(\n      convInfo: backend_util.Conv2DInfo, addBias = false,\n      activation: string = null, hasPreluActivationWeights = false,\n      hasLeakyreluAlpha = false) {\n    this.outputShape = convInfo.outShape;\n    const padTop = convInfo.padInfo.top;\n    const padLeft = convInfo.padInfo.left;\n    const strideHeight = convInfo.strideHeight;\n    const strideWidth = convInfo.strideWidth;\n    const dilationHeight = convInfo.dilationHeight;\n    const dilationWidth = convInfo.dilationWidth;\n    const filterHeight = convInfo.filterHeight;\n    const filterWidth = convInfo.filterWidth;\n\n    const inputDepthNearestVec4 = Math.floor(convInfo.inChannels / 4) * 4;\n    const inputDepthVec4Remainder = convInfo.inChannels % 4;\n    const isChannelsLast = convInfo.dataFormat === 'channelsLast';\n\n    const rowDim = isChannelsLast ? 1 : 2;\n    const colDim = isChannelsLast ? 2 : 3;\n    const channelDim = isChannelsLast ? 3 : 1;\n\n    let activationSnippet = '', applyActivationSnippet = '';\n    if (activation) {\n      if (hasPreluActivationWeights) {\n        activationSnippet = `float activation(float a) {\n          float b = getPreluActivationWeightsAtOutCoords();\n          ${activation}\n        }`;\n      } else if (hasLeakyreluAlpha) {\n        activationSnippet = `float activation(float a) {\n          float b = getLeakyreluAlphaAtOutCoords();\n          ${activation}\n        }`;\n      } else {\n        activationSnippet = `\n          float activation(float x) {\n            ${activation}\n          }\n        `;\n      }\n\n      applyActivationSnippet = `result = activation(result);`;\n    }\n\n    const addBiasSnippet = addBias ? 'result += getBiasAtOutCoords();' : '';\n    if (addBias) {\n      this.variableNames.push('bias');\n    }\n\n    if (hasPreluActivationWeights) {\n      this.variableNames.push('preluActivationWeights');\n    }\n\n    if (hasLeakyreluAlpha) {\n      this.variableNames.push('leakyreluAlpha');\n    }\n\n    this.userCode = `\n      ${activationSnippet}\n\n      const ivec2 strides = ivec2(${strideHeight}, ${strideWidth});\n      const ivec2 pads = ivec2(${padTop}, ${padLeft});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d2 = coords[${channelDim}];\n\n        ivec2 xRCCorner =\n            ivec2(coords[${rowDim}], coords[${colDim}]) * strides - pads;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // Convolve x(?, ?, d1) with w(:, :, d1, d2) to get y(yR, yC, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${filterHeight}; wR++) {\n          int xR = xRCorner + wR * ${dilationHeight};\n\n          if (xR < 0 || xR >= ${convInfo.inHeight}) {\n            continue;\n          }\n\n          for (int wC = 0; wC < ${filterWidth}; wC++) {\n            int xC = xCCorner + wC * ${dilationWidth};\n\n            if (xC < 0 || xC >= ${convInfo.inWidth}) {\n              continue;\n            }\n\n            for (int d1 = 0; d1 < ${inputDepthNearestVec4}; d1 += 4) {\n              vec4 wValues = vec4(\n                getW(wR, wC, d1, d2),\n                getW(wR, wC, d1 + 1, d2),\n                getW(wR, wC, d1 + 2, d2),\n                getW(wR, wC, d1 + 3, d2)\n              );\n\n              if (${isChannelsLast}) {\n                vec4 xValues = vec4(\n                  getX(batch, xR, xC, d1),\n                  getX(batch, xR, xC, d1 + 1),\n                  getX(batch, xR, xC, d1 + 2),\n                  getX(batch, xR, xC, d1 + 3)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec4 xValues = vec4(\n                  getX(batch, d1, xR, xC),\n                  getX(batch, d1 + 1, xR, xC),\n                  getX(batch, d1 + 2, xR, xC),\n                  getX(batch, d1 + 3, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n            }\n\n            if (${inputDepthVec4Remainder === 1}) {\n\n              if (${isChannelsLast}) {\n                dotProd +=\n                    getX(batch, xR, xC, ${inputDepthNearestVec4}) *\n                    getW(wR, wC, ${inputDepthNearestVec4}, d2);\n              } else {\n                dotProd +=\n                    getX(batch, ${inputDepthNearestVec4}, xR, xC) *\n                    getW(wR, wC, ${inputDepthNearestVec4}, d2);\n              }\n\n            } else if (${inputDepthVec4Remainder === 2}) {\n              vec2 wValues = vec2(\n                getW(wR, wC, ${inputDepthNearestVec4}, d2),\n                getW(wR, wC, ${inputDepthNearestVec4} + 1, d2)\n              );\n\n              if (${isChannelsLast}) {\n                vec2 xValues = vec2(\n                  getX(batch, xR, xC, ${inputDepthNearestVec4}),\n                  getX(batch, xR, xC, ${inputDepthNearestVec4} + 1)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec2 xValues = vec2(\n                  getX(batch, ${inputDepthNearestVec4}, xR, xC),\n                  getX(batch, ${inputDepthNearestVec4} + 1, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n\n            } else if (${inputDepthVec4Remainder === 3}) {\n              vec3 wValues = vec3(\n                getW(wR, wC, ${inputDepthNearestVec4}, d2),\n                getW(wR, wC, ${inputDepthNearestVec4} + 1, d2),\n                getW(wR, wC, ${inputDepthNearestVec4} + 2, d2)\n              );\n\n              if (${isChannelsLast}) {\n                vec3 xValues = vec3(\n                  getX(batch, xR, xC, ${inputDepthNearestVec4}),\n                  getX(batch, xR, xC, ${inputDepthNearestVec4} + 1),\n                  getX(batch, xR, xC, ${inputDepthNearestVec4} + 2)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec3 xValues = vec3(\n                  getX(batch, ${inputDepthNearestVec4}, xR, xC),\n                  getX(batch, ${inputDepthNearestVec4} + 1, xR, xC),\n                  getX(batch, ${inputDepthNearestVec4} + 2, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n\n            }\n          }\n        }\n\n        float result = dotProd;\n        ${addBiasSnippet}\n        ${applyActivationSnippet}\n        setOutput(result);\n      }\n    `;\n  }\n}\n\nexport class Conv3DProgram implements GPGPUProgram {\n  variableNames = ['x', 'W'];\n  outputShape: number[];\n  userCode: string;\n\n  constructor(convInfo: backend_util.Conv3DInfo) {\n    this.outputShape = convInfo.outShape;\n    const padFront = convInfo.padInfo.front;\n    const padTop = convInfo.padInfo.top;\n    const padLeft = convInfo.padInfo.left;\n    const strideDepth = convInfo.strideDepth;\n    const strideHeight = convInfo.strideHeight;\n    const strideWidth = convInfo.strideWidth;\n    const dilationDepth = convInfo.dilationDepth;\n    const dilationHeight = convInfo.dilationHeight;\n    const dilationWidth = convInfo.dilationWidth;\n    const filterDepth = convInfo.filterDepth;\n    const filterHeight = convInfo.filterHeight;\n    const filterWidth = convInfo.filterWidth;\n\n    const inputDepthNearestVec4 = Math.floor(convInfo.inChannels / 4) * 4;\n    const inputDepthVec4Remainder = convInfo.inChannels % 4;\n\n    this.userCode = `\n      const ivec3 strides = ivec3(${strideDepth}, ${strideHeight}, ${\n        strideWidth});\n      const ivec3 pads = ivec3(${padFront}, ${padTop}, ${padLeft});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int d2 = coords.u;\n\n        ivec3 xFRCCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n        int xFCorner = xFRCCorner.x;\n        int xRCorner = xFRCCorner.y;\n        int xCCorner = xFRCCorner.z;\n\n        // Convolve x(?, ?, ?, d1) with w(:, :, :, d1, d2) to get\n        // y(yF, yR, yC, d2). ? = to be determined. : = across all\n        // values in that axis.\n        float dotProd = 0.0;\n        for (int wF = 0; wF < ${filterDepth}; wF++) {\n          int xF = xFCorner + wF * ${dilationDepth};\n\n          if (xF < 0 || xF >= ${convInfo.inDepth}) {\n            continue;\n          }\n\n          for (int wR = 0; wR < ${filterHeight}; wR++) {\n            int xR = xRCorner + wR * ${dilationHeight};\n\n            if (xR < 0 || xR >= ${convInfo.inHeight}) {\n              continue;\n            }\n\n            for (int wC = 0; wC < ${filterWidth}; wC++) {\n              int xC = xCCorner + wC * ${dilationWidth};\n\n              if (xC < 0 || xC >= ${convInfo.inWidth}) {\n                continue;\n              }\n\n              for (int d1 = 0; d1 < ${inputDepthNearestVec4}; d1 += 4) {\n                vec4 xValues = vec4(\n                  getX(batch, xF, xR, xC, d1),\n                  getX(batch, xF, xR, xC, d1 + 1),\n                  getX(batch, xF, xR, xC, d1 + 2),\n                  getX(batch, xF, xR, xC, d1 + 3)\n                );\n                vec4 wValues = vec4(\n                  getW(wF, wR, wC, d1, d2),\n                  getW(wF, wR, wC, d1 + 1, d2),\n                  getW(wF, wR, wC, d1 + 2, d2),\n                  getW(wF, wR, wC, d1 + 3, d2)\n                );\n\n                dotProd += dot(xValues, wValues);\n              }\n\n              if (${inputDepthVec4Remainder === 1}) {\n                dotProd +=\n                  getX(batch, xF, xR, xC, ${inputDepthNearestVec4}) *\n                  getW(wF, wR, wC, ${inputDepthNearestVec4}, d2);\n              } else if (${inputDepthVec4Remainder === 2}) {\n                vec2 xValues = vec2(\n                  getX(batch, xF, xR, xC, ${inputDepthNearestVec4}),\n                  getX(batch, xF, xR, xC, ${inputDepthNearestVec4} + 1)\n                );\n                vec2 wValues = vec2(\n                  getW(wF, wR, wC, ${inputDepthNearestVec4}, d2),\n                  getW(wF, wR, wC, ${inputDepthNearestVec4} + 1, d2)\n                );\n                dotProd += dot(xValues, wValues);\n              } else if (${inputDepthVec4Remainder === 3}) {\n                vec3 xValues = vec3(\n                  getX(batch, xF, xR, xC, ${inputDepthNearestVec4}),\n                  getX(batch, xF, xR, xC, ${inputDepthNearestVec4} + 1),\n                  getX(batch, xF, xR, xC, ${inputDepthNearestVec4} + 2)\n                );\n                vec3 wValues = vec3(\n                  getW(wF, wR, wC, ${inputDepthNearestVec4}, d2),\n                  getW(wF, wR, wC, ${inputDepthNearestVec4} + 1, d2),\n                  getW(wF, wR, wC, ${inputDepthNearestVec4} + 2, d2)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `;\n  }\n}\n","/**\n * @license\n * Copyright 2022 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\n import {backend_util, util} from '@tensorflow/tfjs-core';\n\n import {GPGPUProgram, useShapeUniforms} from './gpgpu_math';\n\n export class Conv2DPackedProgram implements GPGPUProgram {\n   variableNames = ['x', 'W'];\n   packedInputs = true;\n   packedOutput = true;\n   outputShape: number[];\n   userCode: string;\n   enableShapeUniforms: boolean;\n   customUniforms = [\n     {name: 'pads', type: 'ivec2' as const },\n     {name: 'strides', type: 'ivec2' as const },\n     {name: 'dilations', type: 'ivec2' as const },\n     {name: 'inDims', type: 'ivec2' as const },\n   ];\n\n   constructor(\n       convInfo: backend_util.Conv2DInfo, addBias = false,\n       activation: string = null, hasPreluActivation = false,\n       hasLeakyReluAlpha = false) {\n     this.outputShape = convInfo.outShape;\n     this.enableShapeUniforms = useShapeUniforms(this.outputShape.length);\n     const padLeft = convInfo.padInfo.left;\n     const strideWidth = convInfo.strideWidth;\n     const dilationWidth = convInfo.dilationWidth;\n     const filterHeight = convInfo.filterHeight;\n     const filterWidth = convInfo.filterWidth;\n     const texelsAcross = filterWidth;\n\n     let mainLoop = `\n       int xR; int xC; int xCOffset;\n       vec4 wTexel; vec4 previous; vec4 final;`;\n\n     for (let c = 0; c < filterWidth; c++) {\n       mainLoop += `\n           vec4 xTexelC${c * 2};\n           int xTexelC${c * 2}Ready;\n           vec4 xTexelC${c * 2 + 1};\n           int xTexelC${c * 2 + 1}Ready;\n           vec4 xC${c};`;\n     }\n\n     /**\n      * This vectorized implementation works by gathering the values needed for\n      * each output channel's dot product into vec4's and then multiplying them\n      * all together (this happens in the final double for-loop below). Most of\n      * the main loop consists of constructing these vec4's with the minimum\n      * number of texture2D calls, which means making use of all four returned\n      * values from a texture2D call at once.\n      */\n     mainLoop += `\n     for (int r = 0; r < ${filterHeight}; r++) {\n      for (int d1 = 0; d1 < ${convInfo.inChannels}; d1 += 2) {\n       `;\n     for (let c = 0; c < filterWidth; c++) {\n       mainLoop += `\n           xTexelC${c * 2} = vec4(0.0);\n           xTexelC${c * 2}Ready = 0;\n           xTexelC${c * 2 + 1} = vec4(0.0);\n           xTexelC${c * 2 + 1}Ready = 0;\n           xC${c} = vec4(0.0);`;\n     }\n     mainLoop += `\n         xR = xRCorner + r * dilations[0];\n         if (xR >=0 && xR < inDims[0]) {\n       `;\n\n     for (let texelC = 0; texelC < (texelsAcross + 1) / 2; texelC++) {\n       const colIndex = texelC * 2;\n\n       mainLoop += `\n           xC = xCCorner + ${colIndex * dilationWidth};\n           `;\n\n       if (strideWidth === 1) {\n         if (colIndex < filterWidth) {\n           // If padding is odd, the outer texels have to be composed.\n           if (padLeft % 2 === 1) {\n             // TODO: Ensure vec4 previous does not result in redundant sample,\n             // and avoid setting xTexelRC's that exceed the boundary in the\n             // first place rather than resetting them to vec4(0)).\n\n             // To compute xCOffset:\n             // - If padding is odd, we must add 1 to ensure we ask for an\n             // even-numbered row.\n             // - We subtract 2 to access the previous texel.\n\n             mainLoop += `\n                 xCOffset = xC + 1;\n                 if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${\n                 colIndex}Ready == 0) {\n                   xTexelC${colIndex} = getX(batch, xR, xCOffset, d1);\n\n                   // Need to manually clear unused channels in case\n                   // we're reading from recycled texture.\n                   if (xCOffset + 1 >= inDims[1]) {\n                     xTexelC${colIndex}.zw = vec2(0.0);\n                   }\n                   xTexelC${colIndex}Ready = 1;\n                 }\n               `;\n             // This texel has been read in previous iteration if the dilation\n             // is 1.\n             if (dilationWidth === 1 && colIndex > 0) {\n               mainLoop += `\n                 xC${colIndex} = vec4(xTexelC${colIndex - 2}.zw, xTexelC${\n                   colIndex}.xy);\n                 `;\n             } else {\n               mainLoop += `\n                   xCOffset = xC + 1 - 2;\n\n                   if (xCOffset >= 0 && xCOffset < inDims[1]) {\n                     previous = getX(batch, xR, xCOffset, d1);\n\n                     // Need to manually clear unused channels in case\n                     // we're reading from recycled texture.\n                     if (xCOffset + 1 >= inDims[1]) {\n                       previous.zw = vec2(0.0);\n                     }\n\n                     xC${colIndex} = vec4(previous.zw, xTexelC${colIndex}.xy);\n                   } else {\n                     xC${colIndex} = vec4(0.0, 0.0, xTexelC${colIndex}.xy);\n                   }\n                   `;\n             }\n           } else {\n             // Padding is even, so xRC corresponds to a single texel.\n             mainLoop += `\n                 if (xC >= 0 && xC < inDims[1] && xTexelC${colIndex}Ready == 0) {\n                   xTexelC${colIndex} = getX(batch, xR, xC, d1);\n                   if (xC + 1 >= inDims[1]) {\n                     xTexelC${colIndex}.zw = vec2(0.0);\n                   }\n                   xTexelC${colIndex}Ready = 1;\n                 }\n\n                 xC${colIndex} = xTexelC${colIndex};\n                 `;\n           }\n\n           if (colIndex + 1 < filterWidth) {\n             // If dilation is even, the second entry should match the first\n             // (either both are composed or both are single samples). But if\n             // dilation is odd, then the second entry should be the opposite\n             // of the first (if the first is composed, the second is a single\n             // sample, and vice versa.)\n\n             const nextTexelOffset = padLeft % 2 === 0 ?\n                 util.nearestLargerEven(dilationWidth) :\n                 dilationWidth;\n\n             if ((dilationWidth % 2 === 0 && padLeft % 2 === 1) ||\n                 (dilationWidth % 2 !== 0 && padLeft % 2 !== 1)) {\n               mainLoop += `\n                   xCOffset = xC + imod(pads[1], 2) + ${nextTexelOffset};\n\n                   if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${\n                   colIndex + 1}Ready == 0) {\n                     xTexelC${colIndex + 1} = getX(batch, xR, xCOffset, d1);\n\n                     // Need to manually clear unused channels in case\n                     // we're reading from recycled texture.\n                     if (xCOffset + 1 >= inDims[1]) {\n                       xTexelC${colIndex + 1}.zw = vec2(0.0);\n                     }\n                     xTexelC${colIndex + 1}Ready = 1;\n                   }\n                   `;\n\n               // If dilation > 1 then the xRC's will not be able to share any\n               // values, so each xRC will require two unique calls to getX.\n               if (dilationWidth > 1) {\n                 mainLoop += `\n                     xCOffset -= 2;\n                     if (xCOffset >= 0 && xCOffset < inDims[1]) {\n                      previous = getX(batch, xR, xCOffset, d1);\n                      xC${colIndex + 1} = vec4(previous.zw, xTexelC${\n                        colIndex + 1}.xy);\n                     } else {\n                      xC${colIndex + 1} = vec4(0.0, 0.0, xTexelC${\n                        colIndex + 1}.xy);\n                     }\n                     `;\n               } else {\n                 mainLoop += `\n                     xC${colIndex + 1} = vec4(xTexelC${colIndex}.zw, xTexelC${\n                     colIndex + 1}.xy);\n                     `;\n               }\n\n             } else {\n               // If dilation is 1 and padding is odd, we have already read the\n               // texel when constructing the previous x value. Here we can\n               // simply skip the texture read.\n               if (nextTexelOffset === 1) {\n                 mainLoop += `\n                     xC${colIndex + 1} = xTexelC${colIndex};\n                     `;\n               } else {\n                 mainLoop += `\n                     xCOffset = xC + ${nextTexelOffset};\n\n                     if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${\n                     colIndex + 1}Ready == 0) {\n                       xTexelC${colIndex + 1} = getX(batch, xR, xCOffset, d1);\n                       if (xCOffset + 1 >= inDims[1]) {\n                         xTexelC${colIndex + 1}.zw = vec2(0.0);\n                       }\n                       xTexelC${colIndex + 1}Ready = 1;\n                     }\n\n                     xC${colIndex + 1} = xTexelC${colIndex + 1};\n                     `;\n               }\n             }\n           }\n         }\n       } else {  // stride === 2\n         if (colIndex < filterWidth) {\n           // Depending on whether padLeft is even or odd, we want either the\n           // xy or zw channels from X texels for xC${colIndex}. If padLeft is\n           // even, xC${colIndex +1} is simply the zw channels of texels we've\n           // already sampled. But if padLeft is odd, xC{$c + 1}.zw will\n           // need to come from the xy channels of a new texel, hence the `\n           // vec4\n           // final` initialized below.\n           if (padLeft % 2 === 1) {\n             mainLoop += `\n                 xCOffset = xC + 1 - strides[1];\n                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${\n                 colIndex}Ready == 0) {\n                   xTexelC${colIndex} = getX(batch, xR, xCOffset, d1);\n                   // Need to manually clear unused channels in case\n                   // we're reading from recycled texture.\n                   if (xCOffset + 1 >= inDims[1]) {\n                     xTexelC${colIndex}.zw = vec2(0.0);\n                   }\n                   xTexelC${colIndex}Ready = 1;\n                 }\n\n                 if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${\n                 colIndex + 1}Ready == 0) {\n                   xTexelC${colIndex + 1} = getX(batch, xR, xC + 1, d1);\n                   // Need to manually clear unused channels in case\n                   // we're reading from recycled texture.\n                   if (xC + 2 >= inDims[1]) {\n                     xTexelC${colIndex + 1}.zw = vec2(0.0);\n                   }\n                   xTexelC${colIndex + 1}Ready = 1;\n                 }\n\n                 xC${colIndex} = vec4(xTexelC${colIndex}.zw, xTexelC${\n                 colIndex + 1}.zw);\n               `;\n\n             if (colIndex + 1 < filterWidth) {\n               mainLoop += `\n                   final = vec4(0.0);\n                   xCOffset = xC + 1 + strides[1];\n                   if(xCOffset >= 0 && xCOffset < inDims[1]) {\n                     final = getX(batch, xR, xCOffset, d1);\n                   }\n                   xC${colIndex + 1} = vec4(xTexelC${colIndex + 1}.xy, final.xy);\n                 `;\n             }\n           } else {\n             mainLoop += `\n                 if(xC >= 0 && xC < inDims[1] && xTexelC${colIndex}Ready == 0) {\n                   xTexelC${colIndex} = getX(batch, xR, xC, d1);\n                   if (xC + 1 >= inDims[1]) {\n                     xTexelC${colIndex}.zw = vec2(0.0);\n                   }\n                   xTexelC${colIndex}Ready = 1;\n                 }\n\n                 xCOffset = xC + strides[1];\n                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${\n                 colIndex + 1}Ready == 0) {\n                   xTexelC${colIndex + 1} = getX(batch, xR, xCOffset, d1);\n                   if (xCOffset + 1 >= inDims[1]) {\n                     xTexelC${colIndex + 1}.zw = vec2(0.);\n                   }\n                   xTexelC${colIndex + 1}Ready = 1;\n                 }\n\n                 xC${colIndex} = vec4(\n                   xTexelC${colIndex}.xy, xTexelC${colIndex + 1}.xy);\n               `;\n\n             if (colIndex + 1 < filterWidth) {\n               mainLoop += `\n                   xC${colIndex + 1} = vec4(xTexelC${colIndex}.zw, xTexelC${\n                   colIndex + 1}.zw);\n                 `;\n             }\n           }\n         }\n       }\n\n       // localize the dotProd accumulation within the loop, the theory is for\n       // GPU with limited cache, accumulate sum across large amount of\n       // veriables will cause lots of cache misses. (i.e. 5x5 filter will have\n       // 50 variables)\n       if (colIndex < filterWidth) {\n         mainLoop += `\n             wTexel = getW(r, ${colIndex}, d1, d2);\n             dotProd += xC${colIndex}.xxzz * vec4(wTexel.xy, wTexel.xy);\n             if(d1 + 1 < ${convInfo.inChannels}) {\n               dotProd += xC${colIndex}.yyww * vec4(wTexel.zw, wTexel.zw);\n             }\n           `;\n\n         if (colIndex + 1 < filterWidth) {\n           mainLoop += `\n               wTexel = getW(r, ${colIndex + 1}, d1, d2);\n               dotProd += xC${colIndex + 1}.xxzz * vec4(wTexel.xy, wTexel.xy);\n               if(d1 + 1 < ${convInfo.inChannels}) {\n                 dotProd += xC${colIndex + 1}.yyww * vec4(wTexel.zw, wTexel.zw);\n               }\n             `;\n         }\n       }\n     }\n     mainLoop += `\n     }\n   `;\n   mainLoop += `\n     }\n   `;\n   mainLoop += `\n     }\n   `;\n\n     let activationSnippet = '', applyActivationSnippet = '';\n     if (activation) {\n       if (hasPreluActivation) {\n         activationSnippet = `vec4 activation(vec4 a) {\n           vec4 b = getPreluActivationWeightsAtOutCoords();\n           ${activation}\n         }`;\n       } else if (hasLeakyReluAlpha) {\n         activationSnippet = `vec4 activation(vec4 a) {\n           vec4 b = getLeakyreluAlphaAtOutCoords();\n           ${activation}\n         }`;\n       } else {\n         activationSnippet = `vec4 activation(vec4 x) {\n           ${activation}\n         }`;\n       }\n\n       applyActivationSnippet = `result = activation(result);`;\n     }\n\n     const addBiasSnippet = addBias ? 'result += getBiasAtOutCoords();' : '';\n     if (addBias) {\n       this.variableNames.push('bias');\n     }\n\n     if (hasPreluActivation) {\n       this.variableNames.push('preluActivationWeights');\n     }\n     if (hasLeakyReluAlpha) {\n       this.variableNames.push('leakyreluAlpha');\n     }\n\n     this.userCode = `\n       ${activationSnippet}\n\n       void main() {\n         ivec4 coords = getOutputCoords();\n         int batch = coords.x;\n         ivec2 xRCCorner = coords.yz * strides - pads;\n         int d2 = coords.w;\n         int xRCorner = xRCCorner.x;\n         int xCCorner = xRCCorner.y;\n\n         //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.\n         vec4 dotProd = vec4(0.000000000000001);\n\n         ${mainLoop}\n\n         vec4 result = dotProd - vec4(0.000000000000001);\n         ${addBiasSnippet}\n         ${applyActivationSnippet}\n         setOutput(result);\n       }\n     `;\n   }\n }\n","/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {backend_util} from '@tensorflow/tfjs-core';\nimport {getGlslDifferences} from './glsl_version';\nimport {GPGPUProgram, useShapeUniforms} from './gpgpu_math';\n\nexport class Im2ColPackedProgram implements GPGPUProgram {\n  variableNames = ['A'];\n  packedInputs = true;\n  packedOutput = true;\n  outputShape: number[];\n  userCode: string;\n  enableShapeUniforms: boolean;\n  customUniforms = [\n    {name: 'inputShape', type: 'ivec4' as const },\n    {name: 'pad', type: 'ivec2' as const },\n    {name: 'stride', type: 'ivec2' as const },\n    {name: 'dilation', type: 'ivec2' as const },\n    {name: 'inChannels', type: 'int' as const },\n    {name: 'itemsPerBlockRow', type: 'int' as const },\n    {name: 'outWidth', type: 'int' as const },\n  ];\n\n  constructor(outputShape: number[], convInfo: backend_util.Conv2DInfo) {\n    this.outputShape = outputShape;\n    this.enableShapeUniforms = useShapeUniforms(this.outputShape.length);\n    const {dataFormat} = convInfo;\n    const glsl = getGlslDifferences();\n    const isChannelsLast = dataFormat === 'channelsLast';\n    const rowDim = isChannelsLast ? 1 : 2;\n    const colDim = isChannelsLast ? 2 : 3;\n\n    const boundsCheckingSnippet = this.enableShapeUniforms ?\n        'if(blockIndex < outShape[2] && pos < outShape[1]) {' :\n        `if(blockIndex < ${outputShape[2]} && pos < ${outputShape[1]}) {`;\n    let unrolled = ``;\n\n    for (let row = 0; row <= 1; row++) {\n      for (let col = 0; col <= 1; col++) {\n        unrolled += `\n          blockIndex = rc.z + ${col};\n          pos = rc.y + ${row};\n\n          ${boundsCheckingSnippet}\n            offsetY = int(blockIndex / outWidth) * stride[0] - pad[0];\n            d0 = offsetY + dilation[0] * (pos / itemsPerBlockRow);\n\n            if(d0 < inputShape[${rowDim}] && d0 >= 0) {\n              // Use custom imod instead mod. On Intel GPU, mod may generate\n              // unexpected value.\n              // https://github.com/tensorflow/tfjs/issues/5447\n              offsetX = imod(blockIndex, outWidth) * stride[1] - pad[1];\n              d1 = offsetX + dilation[1] * (imod(pos, itemsPerBlockRow) /\n                  inChannels);\n\n              if(d1 < inputShape[${colDim}] && d1 >= 0) {\n\n                ch = imod(pos, inChannels);\n\n                if (${isChannelsLast}) {\n                  innerDims = vec2(d1, ch);\n                  result[${row * 2 + col}] = getChannel(\n                    getA(rc.x, d0, int(innerDims.x),\n                    int(innerDims.y)), innerDims);\n                } else {\n                  innerDims = vec2(d0, d1);\n                  result[${row * 2 + col}] = getChannel(\n                    getA(rc.x, ch, int(innerDims.x),\n                    int(innerDims.y)), innerDims);\n                }\n              }\n            }\n          }\n        `;\n      }\n    }\n\n    this.userCode = `\n      void main() {\n        ivec3 rc = getOutputCoords();\n\n        vec4 result = vec4(0);\n\n        int blockIndex, pos, offsetY, d0, offsetX, d1, ch;\n        vec2 innerDims;\n\n        ${unrolled}\n\n        ${glsl.output} = result;\n      }\n    `;\n  }\n}\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {backend_util, TensorInfo, util} from '@tensorflow/tfjs-core';\n\n// import {assertAndGetBroadcastShape} from\n// '../../../tfjs-core/src/ops/broadcast_util';\nimport {MathBackendWebGL} from '../backend_webgl';\nimport {Im2ColPackedProgram} from '../im2col_packed_gpu';\nimport {mapActivationToShaderProgram} from '../kernel_utils/kernel_funcs_utils';\nimport {MatMulPackedProgram} from '../mulmat_packed_gpu';\nimport * as webgl_util from '../webgl_util';\n\nimport {batchMatMulImpl, MATMUL_SHARED_DIM_THRESHOLD} from './BatchMatMul_impl';\nimport {identity} from './Identity';\nimport {reshape} from './Reshape';\n\ntype Conv2DConfig = {\n  x: TensorInfo,\n  filter: TensorInfo,\n  convInfo: backend_util.Conv2DInfo,\n  backend: MathBackendWebGL,\n  bias?: TensorInfo,\n  preluActivationWeights?: TensorInfo,\n  leakyreluAlpha?: number,\n  activation?: backend_util.Activation\n};\n\n// Both conv2dByMatMul and conv2dWithIm2Row fuse height and width into one\n// dimension to compute batchMatMul, so bias and activation weights are also\n// supposed to fuse the two dimensions into one.\n//\n// This function computes the target shape for fusing height and width\n// dimensions. Returning null means the shape is already compatible.\n//\n// Even though the bias is not supposed to be a 3-D or a 4-D (including\n// batch) tensor and PReLU activiation weights is not supposed to be a 4-D\n// tensor, we still need to support them, because we haven't disabled\n// them for NHWC format.\n// https://github.com/tensorflow/tfjs/blob/b53bd47e880367ae57493f0ea628abaf08db2d5d/tfjs-core/src/ops/fused/conv2d.ts#L181-L196\nfunction getShapeForBatchMatMul(\n    shape: number[], isChannelsLast: boolean): number[] {\n  const length = shape.length;\n  if (length >= 3) {\n    return isChannelsLast ?\n        [\n          ...shape.slice(0, -3) /* batch */,\n          shape[length - 3] * shape[length - 2] /* height * width */,\n          shape[length - 1] /* channel */\n        ] :\n        [\n          ...shape.slice(0, -3) /* batch */, shape[length - 3] /* channel */,\n          shape[length - 2] * shape[length - 1] /* height * width */\n        ];\n  } else if (!isChannelsLast && length === 1 && shape[0] > 1) {\n    return [shape[0], 1];\n  } else {\n    return null;\n  }\n}\n\n// For 1x1 kernels that iterate through every point in the input, convolution\n// can be expressed as matrix multiplication (without need for memory\n// remapping).\nexport function conv2dByMatMul({\n  x,\n  filter,\n  convInfo,\n  backend,\n  bias = null,\n  preluActivationWeights = null,\n  leakyreluAlpha = 0,\n  activation = null\n}: Conv2DConfig) {\n  // Reshapes conv2D input to 2D tensors, uses matMul and then reshape the\n  // result from 2D to 4D.\n  const xShape = x.shape;\n  const xTexData = backend.texData.get(x.dataId);\n  const sharedMatMulDim = convInfo.inChannels;\n  const outerShapeX = xShape[0] * xShape[1] * xShape[2];\n  const outerShapeFilter = convInfo.outChannels;\n  const isChannelsLast = convInfo.dataFormat === 'channelsLast';\n  const transposeA = false;\n  const transposeB = false;\n\n  let out: TensorInfo;\n  const intermediates: TensorInfo[] = [];\n\n  if (preluActivationWeights != null) {\n    const targetShape =\n        getShapeForBatchMatMul(preluActivationWeights.shape, isChannelsLast);\n    if (targetShape != null) {\n      preluActivationWeights = reshape({\n        inputs: {x: preluActivationWeights},\n        backend,\n        attrs: {shape: targetShape}\n      });\n      intermediates.push(preluActivationWeights);\n    }\n  }\n\n  if (bias != null) {\n    const targetShape = getShapeForBatchMatMul(bias.shape, isChannelsLast);\n    if (targetShape != null) {\n      bias = reshape({inputs: {x: bias}, backend, attrs: {shape: targetShape}});\n      intermediates.push(bias);\n    }\n  }\n\n  // TODO: Once reduction ops are packed, batchMatMul will always be packed\n  // and we can remove this condition.\n  const batchMatMulWillBeUnpacked =\n      (outerShapeX === 1 || outerShapeFilter === 1) &&\n      sharedMatMulDim > MATMUL_SHARED_DIM_THRESHOLD;\n\n  // The algorithm in the if condition assumes (1) the output will be packed,\n  // (2) x is packed, (3) x isChannelsLast, (4)  x's packed texture is already\n  // on GPU, (5) col is odd, (6) the width, height and inChannels are the same\n  // for xTexData.shape and xShape.\n  const canOptimize = !batchMatMulWillBeUnpacked && xTexData.isPacked &&\n      isChannelsLast && xTexData.texture != null && xShape[2] % 2 !== 0 &&\n      util.arraysEqual(xTexData.shape.slice(-3), xShape.slice(-3));\n\n  if (canOptimize) {\n    // We avoid expensive packed 2x2 reshape by padding col count to next,\n    // even number. When col is odd, the result of packed batchMatMul is\n    // the same (has the same texture layout and and values in the texture) as\n    // it is for next even col. We make the odd-cols tensor to look like\n    // even-cols tensor before the operation and, after the batchMatMul,\n    // fix the even-cols result to have odd number of cols.\n    const targetShape = xShape[0] * xShape[1] * (xShape[2] + 1);\n    const xReshaped: TensorInfo = {\n      dataId: x.dataId,\n      shape: [1, targetShape, convInfo.inChannels],\n      dtype: x.dtype\n    };\n    // xTexData.shape gets referenced from GPGPUBinary.inShapeInfos.\n    // Decrementing col count, after batchMatMul->...->compileProgram leads to\n    // invalid col count within the reference in GPGPUBinary.inShapeInfos.\n    // Alternative fix would be to provide a copy to GPGPUBinary.inShapeInfos\n    // in compileProgram method, but that would affect compilation of all\n    // programs - instead, provide a copy here, with even col count, before\n    // calling batchMatMul->...->compileProgram and after that, the original\n    // xTexData.shape is restored.\n    const originalXTexDataShape = xTexData.shape;\n    xTexData.shape = xTexData.shape.slice();\n    xTexData.shape[xTexData.shape.length - 2]++;\n    util.assert(\n        webgl_util.isReshapeFree(xTexData.shape, xReshaped.shape),\n        () => `packed reshape ${xTexData.shape} to ${\n            xReshaped.shape} isn't free`);\n    const filterReshaped = reshape({\n      inputs: {x: filter},\n      backend,\n      attrs: {shape: [1, convInfo.inChannels, convInfo.outChannels]}\n    });\n    intermediates.push(filterReshaped);\n    const pointwiseConv = batchMatMulImpl({\n      a: xReshaped,\n      b: filterReshaped,\n      backend,\n      transposeA,\n      transposeB,\n      bias,\n      activation,\n      preluActivationWeights,\n      leakyreluAlpha\n    });\n\n    const pointwiseConvTexData = backend.texData.get(pointwiseConv.dataId);\n    util.assert(\n        pointwiseConvTexData.isPacked,\n        () => 'batchMatMul result is expected to be packed');\n    // Restore the input shape to original.\n    xTexData.shape = originalXTexDataShape;\n    // Set the output shape - there is no need for expensive reshape as data\n    // layout is already correct.\n    pointwiseConvTexData.shape = convInfo.outShape;\n\n    out = identity({inputs: {x: pointwiseConv}, backend});\n    out.shape = convInfo.outShape;\n\n    intermediates.push(pointwiseConv);\n  } else {\n    const numCols = convInfo.outHeight * convInfo.outWidth;\n    const xReshaped = reshape({\n      inputs: {x},\n      backend,\n      attrs: {\n        shape: isChannelsLast ?\n            [convInfo.batchSize, numCols, convInfo.inChannels] :\n            [convInfo.batchSize, convInfo.inChannels, numCols]\n      }\n    });\n    const filterReshaped = reshape({\n      inputs: {x: filter},\n      backend,\n      attrs: {shape: [1, convInfo.inChannels, convInfo.outChannels]}\n    });\n    const result = batchMatMulImpl({\n      a: isChannelsLast ? xReshaped : filterReshaped,\n      b: isChannelsLast ? filterReshaped : xReshaped,\n      transposeA: !isChannelsLast,\n      transposeB,\n      backend,\n      bias,\n      activation,\n      preluActivationWeights,\n      leakyreluAlpha\n    });\n\n    out = reshape(\n        {inputs: {x: result}, backend, attrs: {shape: convInfo.outShape}});\n\n    intermediates.push(xReshaped);\n    intermediates.push(filterReshaped);\n    intermediates.push(result);\n  }\n\n  for (const i of intermediates) {\n    backend.disposeIntermediateTensorInfo(i);\n  }\n\n  return out;\n}\n\n// Implements the im2row algorithm as outlined in \"High Performance\n// Convolutional Neural Networks for Document Processing\" (Suvisoft, 2006)\nexport function conv2dWithIm2Row({\n  x,\n  filter,\n  convInfo,\n  backend,\n  bias = null,\n  preluActivationWeights = null,\n  leakyreluAlpha = 0,\n  activation = null\n}: Conv2DConfig) {\n  // Rearranges conv2d input so each block to be convolved over forms the\n  // column of a new matrix with shape [filterWidth * filterHeight *\n  // inChannels, outHeight * outWidth]. The filter is also rearranged so each\n  // output channel forms a row of a new matrix with shape [outChannels,\n  // filterWidth * filterHeight * inChannels]. The convolution is then\n  // computed by multiplying these matrices and reshaping the result.\n  const {\n    filterWidth,\n    filterHeight,\n    inChannels,\n    outWidth,\n    outHeight,\n    dataFormat\n  } = convInfo;\n\n  const isChannelsLast = dataFormat === 'channelsLast';\n\n  const sharedDim = filterWidth * filterHeight * inChannels;\n  const numCols = outHeight * outWidth;\n  const x2ColShape = [convInfo.batchSize, sharedDim, numCols];\n  const transposeA = true;\n  const transposeB = false;\n\n  const intermediates: TensorInfo[] = [];\n\n  if (preluActivationWeights != null) {\n    const targetShape =\n        getShapeForBatchMatMul(preluActivationWeights.shape, isChannelsLast);\n    if (targetShape != null) {\n      preluActivationWeights = reshape({\n        inputs: {x: preluActivationWeights},\n        backend,\n        attrs: {shape: targetShape}\n      });\n      intermediates.push(preluActivationWeights);\n    }\n  }\n\n  if (bias != null) {\n    const targetShape = getShapeForBatchMatMul(bias.shape, isChannelsLast);\n    if (targetShape != null) {\n      bias = reshape({inputs: {x: bias}, backend, attrs: {shape: targetShape}});\n      intermediates.push(bias);\n    }\n  }\n\n  const w2Row = reshape({\n    inputs: {x: filter},\n    backend,\n    attrs: {shape: [1, sharedDim, util.sizeFromShape(filter.shape) / sharedDim]}\n  });\n  intermediates.push(w2Row);\n\n  const im2ColProgram = new Im2ColPackedProgram(x2ColShape, convInfo);\n  const customValues = [\n    x.shape, [convInfo.padInfo.top, convInfo.padInfo.left],\n    [convInfo.strideHeight, convInfo.strideWidth],\n    [convInfo.dilationHeight, convInfo.dilationWidth], [convInfo.inChannels],\n    [convInfo.filterWidth * convInfo.inChannels], [convInfo.outWidth]\n  ];\n  const im2Col =\n      backend.runWebGLProgram(im2ColProgram, [x], 'float32', customValues);\n  const im2ColReshaped =\n      reshape({inputs: {x: im2Col}, backend, attrs: {shape: x2ColShape}});\n\n  intermediates.push(im2Col);\n  intermediates.push(im2ColReshaped);\n\n  const hasBias = bias != null;\n  const hasPreluActivationWeights = preluActivationWeights != null;\n  const hasLeakyreluAlpha = activation === 'leakyrelu';\n  const fusedActivation =\n      activation ? mapActivationToShaderProgram(activation, true) : null;\n  const matmulProgram = new MatMulPackedProgram(\n      isChannelsLast ? im2ColReshaped.shape as [number, number, number] :\n                       w2Row.shape as [number, number, number],\n      isChannelsLast ? w2Row.shape as [number, number, number] :\n                       im2ColReshaped.shape as [number, number, number],\n      isChannelsLast ? [convInfo.batchSize, numCols, convInfo.outChannels] :\n                       [convInfo.batchSize, convInfo.outChannels, numCols],\n      transposeA, transposeB, hasBias, fusedActivation,\n      hasPreluActivationWeights, hasLeakyreluAlpha);\n  const inputs: TensorInfo[] =\n      isChannelsLast ? [im2ColReshaped, w2Row] : [w2Row, im2ColReshaped];\n  if (bias) {\n    inputs.push(bias);\n  }\n  if (hasPreluActivationWeights) {\n    inputs.push(preluActivationWeights);\n  }\n  if (hasLeakyreluAlpha) {\n    const $leakyreluAlpha = backend.makeTensorInfo(\n        [], 'float32',\n        util.createScalarValue(leakyreluAlpha as {} as 'float32', 'float32'));\n    inputs.push($leakyreluAlpha);\n    intermediates.push($leakyreluAlpha);\n  }\n  const product = backend.runWebGLProgram(matmulProgram, inputs, 'float32');\n  const out = reshape(\n      {inputs: {x: product}, backend, attrs: {shape: convInfo.outShape}});\n\n  intermediates.push(product);\n  for (const i of intermediates) {\n    backend.disposeIntermediateTensorInfo(i);\n  }\n\n  return out;\n}\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {backend_util, Conv2D, Conv2DAttrs, Conv2DInputs, env, KernelConfig, KernelFunc, TensorInfo} from '@tensorflow/tfjs-core';\n\nimport {MathBackendWebGL} from '../backend_webgl';\nimport {Conv2DProgram} from '../conv_gpu';\nimport {Conv2DPackedProgram} from '../conv_packed_gpu';\nimport {conv2dByMatMul, conv2dWithIm2Row} from './Conv2D_impl';\nimport {reshape} from './Reshape';\n\nexport function conv2d(\n    args:\n        {inputs: Conv2DInputs, attrs: Conv2DAttrs, backend: MathBackendWebGL}) {\n  const {inputs, backend, attrs} = args;\n  const {x, filter} = inputs;\n  const {strides, pad, dataFormat, dilations, dimRoundingMode} = attrs;\n\n  const $dataFormat = backend_util.convertConv2DDataFormat(dataFormat);\n  const convInfo = backend_util.computeConv2DInfo(\n      x.shape as [number, number, number, number],\n      filter.shape as [number, number, number, number], strides, dilations, pad,\n      dimRoundingMode, false /* depthwise */, $dataFormat);\n  let out: TensorInfo;\n\n  if (convInfo.filterHeight === 1 && convInfo.filterWidth === 1 &&\n      convInfo.dilationHeight === 1 && convInfo.dilationWidth === 1 &&\n      convInfo.strideHeight === 1 && convInfo.strideWidth === 1 &&\n      (convInfo.padInfo.type === 'SAME' || convInfo.padInfo.type === 'VALID')) {\n    out = conv2dByMatMul({x, filter, convInfo, backend});\n  } else if (convInfo.strideWidth <= 2 && $dataFormat === 'channelsLast'\n    && env().getBool('WEBGL_EXP_CONV')\n    ) {\n    const program = new Conv2DPackedProgram(convInfo);\n    const customValues = [\n      [convInfo.padInfo.top, convInfo.padInfo.left],\n      [convInfo.strideHeight, convInfo.strideWidth],\n      [convInfo.dilationHeight, convInfo.dilationWidth],\n      [convInfo.inHeight, convInfo.inWidth]\n    ];\n    out =\n        backend.runWebGLProgram(program, [x, filter], 'float32', customValues);\n  } else if (env().getBool('WEBGL_CONV_IM2COL')) {\n    out = conv2dWithIm2Row({x, filter, convInfo, backend});\n  } else {\n    const program = new Conv2DProgram(convInfo);\n    out = backend.runWebGLProgram(program, [x, filter], 'float32');\n  }\n\n  const outReshaped =\n      reshape({inputs: {x: out}, backend, attrs: {shape: convInfo.outShape}});\n  backend.disposeIntermediateTensorInfo(out);\n\n  return outReshaped;\n}\n\nexport const conv2DConfig: KernelConfig = {\n  kernelName: Conv2D,\n  backendName: 'webgl',\n  kernelFunc: conv2d as {} as KernelFunc,\n};\n","/**\n * @license\n * Copyright 2017 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {backend_util} from '@tensorflow/tfjs-core';\nimport {GPGPUProgram} from './gpgpu_math';\n\nexport class Conv2DDerFilterProgram implements GPGPUProgram {\n  variableNames = ['x', 'dy'];\n  outputShape: number[];\n  userCode: string;\n\n  constructor(convInfo: backend_util.Conv2DInfo) {\n    this.outputShape = convInfo.filterShape;\n\n    const strideHeight = convInfo.strideHeight;\n    const strideWidth = convInfo.strideWidth;\n    const padTop = convInfo.padInfo.top;\n    const padLeft = convInfo.padInfo.left;\n    const isChannelsLast = convInfo.dataFormat === 'channelsLast';\n\n    this.userCode = `\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int wR = coords.x;\n        int wC = coords.y;\n        int d1 = coords.z;\n        int d2 = coords.w;\n\n        // Convolve x(?, ?, d1) with dy(:, :, d2) to get dw(wR, wC, d1, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int b = 0; b < ${convInfo.batchSize}; b++) {\n          for (int yR = 0; yR < ${convInfo.outHeight}; yR++) {\n            int xR = wR + yR * ${strideHeight} - ${padTop};\n\n            if (xR < 0 || xR >= ${convInfo.inHeight}) {\n              continue;\n            }\n\n            for (int yC = 0; yC < ${convInfo.outWidth}; yC++) {\n              int xC = wC + yC * ${strideWidth} - ${padLeft};\n\n              if (xC < 0 || xC >= ${convInfo.inWidth}) {\n                continue;\n              }\n\n              if (${isChannelsLast}) {\n                float dyValue = getDy(b, yR, yC, d2);\n                float xValue = getX(b, xR, xC, d1);\n                dotProd += (xValue * dyValue);\n              } else {\n                float dyValue = getDy(b, d2, yR, yC);\n                float xValue = getX(b, d1, xR, xC);\n                dotProd += (xValue * dyValue);\n              }\n\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `;\n  }\n}\n\nexport class Conv2DDerInputProgram implements GPGPUProgram {\n  variableNames = ['dy', 'W'];\n  outputShape: number[];\n  userCode: string;\n\n  constructor(convInfo: backend_util.Conv2DInfo) {\n    this.outputShape = convInfo.inShape;\n\n    const filterHeight = convInfo.filterHeight;\n    const filterWidth = convInfo.filterWidth;\n    const strideHeight = convInfo.strideHeight;\n    const strideWidth = convInfo.strideWidth;\n    const isChannelsLast = convInfo.dataFormat === 'channelsLast';\n\n    const padTop = filterHeight - 1 - convInfo.padInfo.top;\n    const padLeft = filterWidth - 1 - convInfo.padInfo.left;\n\n    const rowDim = isChannelsLast ? 1 : 2;\n    const colDim = isChannelsLast ? 2 : 3;\n    const channelDim = isChannelsLast ? 3 : 1;\n\n    this.userCode = `\n      const ivec2 pads = ivec2(${padTop}, ${padLeft});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[${channelDim}];\n\n        ivec2 dyCorner = ivec2(coords[${rowDim}], coords[${colDim}]) - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${filterHeight}; wR++) {\n          float dyR = float(dyRCorner + wR) / ${strideHeight}.0;\n\n          if (dyR < 0.0 || dyR >= ${convInfo.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          int wRPerm = ${filterHeight} - 1 - wR;\n\n          for (int wC = 0; wC < ${filterWidth}; wC++) {\n            float dyC = float(dyCCorner + wC) / ${strideWidth}.0;\n\n            if (dyC < 0.0 || dyC >= ${convInfo.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            int wCPerm = ${filterWidth} - 1 - wC;\n\n            for (int d2 = 0; d2 < ${convInfo.outChannels}; d2++) {\n\n              if (${isChannelsLast}) {\n                float xValue = getDy(batch, idyR, idyC, d2);\n                float wValue = getW(wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              } else {\n                float xValue = getDy(batch, d2, idyR, idyC);\n                float wValue = getW(wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              }\n\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `;\n  }\n}\n\nexport class Conv3DDerFilterProgram implements GPGPUProgram {\n  variableNames = ['x', 'dy'];\n  outputShape: number[];\n  userCode: string;\n\n  constructor(convInfo: backend_util.Conv3DInfo) {\n    this.outputShape = convInfo.filterShape;\n\n    const strideDepth = convInfo.strideDepth;\n    const strideHeight = convInfo.strideHeight;\n    const strideWidth = convInfo.strideWidth;\n    const padFront = convInfo.padInfo.front;\n    const padTop = convInfo.padInfo.top;\n    const padLeft = convInfo.padInfo.left;\n\n    this.userCode = `\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int wF = coords.x;\n        int wR = coords.y;\n        int wC = coords.z;\n        int d1 = coords.w;\n        int d2 = coords.u;\n\n        float dotProd = 0.0;\n\n        for (int b = 0; b < ${convInfo.batchSize}; b++) {\n          for (int yF = 0; yF < ${convInfo.outDepth}; yF++) {\n            int xF = wF + yF * ${strideDepth} - ${padFront};\n\n            if (xF < 0 || xF >= ${convInfo.inDepth}) {\n              continue;\n            }\n\n            for (int yR = 0; yR < ${convInfo.outHeight}; yR++) {\n              int xR = wR + yR * ${strideHeight} - ${padTop};\n\n              if (xR < 0 || xR >= ${convInfo.inHeight}) {\n                continue;\n              }\n\n              for (int yC = 0; yC < ${convInfo.outWidth}; yC++) {\n                int xC = wC + yC * ${strideWidth} - ${padLeft};\n\n                if (xC < 0 || xC >= ${convInfo.inWidth}) {\n                  continue;\n                }\n\n                float dyValue = getDy(b, yF, yR, yC, d2);\n                float xValue = getX(b, xF, xR, xC, d1);\n                dotProd += (xValue * dyValue);\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `;\n  }\n}\n\nexport class Conv3DDerInputProgram implements GPGPUProgram {\n  variableNames = ['dy', 'W'];\n  outputShape: number[];\n  userCode: string;\n\n  constructor(convInfo: backend_util.Conv3DInfo) {\n    this.outputShape = convInfo.inShape;\n\n    const filterDepth = convInfo.filterDepth;\n    const filterHeight = convInfo.filterHeight;\n    const filterWidth = convInfo.filterWidth;\n    const strideDepth = convInfo.strideDepth;\n    const strideHeight = convInfo.strideHeight;\n    const strideWidth = convInfo.strideWidth;\n\n    const padFront = filterDepth - 1 - convInfo.padInfo.front;\n    const padTop = filterHeight - 1 - convInfo.padInfo.top;\n    const padLeft = filterWidth - 1 - convInfo.padInfo.left;\n\n    this.userCode = `\n      const ivec3 pads = ivec3(${padFront}, ${padTop}, ${padLeft});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int d1 = coords.u;\n\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyFCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        float dotProd = 0.0;\n        for (int wF = 0; wF < ${filterDepth}; wF++) {\n          float dyF = float(dyFCorner + wF) / ${strideDepth}.0;\n\n          if (dyF < 0.0 || dyF >= ${convInfo.outDepth}.0 || fract(dyF) > 0.0) {\n            continue;\n          }\n          int idyF = int(dyF);\n\n          int wFPerm = ${filterDepth} - 1 - wF;\n\n          for (int wR = 0; wR < ${filterHeight}; wR++) {\n            float dyR = float(dyRCorner + wR) / ${strideHeight}.0;\n\n            if (dyR < 0.0 || dyR >= ${convInfo.outHeight}.0 ||\n              fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            int wRPerm = ${filterHeight} - 1 - wR;\n\n            for (int wC = 0; wC < ${filterWidth}; wC++) {\n              float dyC = float(dyCCorner + wC) / ${strideWidth}.0;\n\n              if (dyC < 0.0 || dyC >= ${convInfo.outWidth}.0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              int wCPerm = ${filterWidth} - 1 - wC;\n\n              for (int d2 = 0; d2 < ${convInfo.outChannels}; d2++) {\n                float xValue = getDy(batch, idyF, idyR, idyC, d2);\n                float wValue = getW(wFPerm, wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `;\n  }\n}\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {backend_util, Conv2DBackpropFilter, Conv2DBackpropFilterAttrs, Conv2DBackpropFilterInputs, KernelConfig, KernelFunc} from '@tensorflow/tfjs-core';\n\nimport {MathBackendWebGL} from '../backend_webgl';\nimport {Conv2DDerFilterProgram} from '../conv_backprop_gpu';\n\nexport function conv2DBackpropFilter(args: {\n  inputs: Conv2DBackpropFilterInputs,\n  attrs: Conv2DBackpropFilterAttrs,\n  backend: MathBackendWebGL\n}) {\n  const {inputs, backend, attrs} = args;\n  const {x, dy} = inputs;\n  const {strides, pad, dataFormat, dimRoundingMode, filterShape} = attrs;\n\n  const $dataFormat = backend_util.convertConv2DDataFormat(dataFormat);\n  const convInfo = backend_util.computeConv2DInfo(\n      x.shape as [number, number, number, number], filterShape, strides,\n      1 /* dilations */, pad, dimRoundingMode, false /* depthwise */,\n      $dataFormat);\n\n  const program = new Conv2DDerFilterProgram(convInfo);\n  return backend.runWebGLProgram(program, [x, dy], 'float32');\n}\n\nexport const conv2DBackpropFilterConfig: KernelConfig = {\n  kernelName: Conv2DBackpropFilter,\n  backendName: 'webgl',\n  kernelFunc: conv2DBackpropFilter as {} as KernelFunc,\n};\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {backend_util, Conv2DBackpropInput, Conv2DBackpropInputAttrs, Conv2DBackpropInputInputs, KernelConfig, KernelFunc} from '@tensorflow/tfjs-core';\n\nimport {MathBackendWebGL} from '../backend_webgl';\nimport {Conv2DDerInputProgram} from '../conv_backprop_gpu';\n\nexport function conv2DBackpropInput(args: {\n  inputs: Conv2DBackpropInputInputs,\n  attrs: Conv2DBackpropInputAttrs,\n  backend: MathBackendWebGL\n}) {\n  const {inputs, backend, attrs} = args;\n  const {dy, filter} = inputs;\n  const {inputShape, strides, pad, dataFormat, dimRoundingMode} = attrs;\n\n  const $dataFormat = backend_util.convertConv2DDataFormat(dataFormat);\n  const convInfo = backend_util.computeConv2DInfo(\n      inputShape, filter.shape as [number, number, number, number], strides,\n      1 /* dilations */, pad, dimRoundingMode, false, $dataFormat);\n\n  const program = new Conv2DDerInputProgram(convInfo);\n  return backend.runWebGLProgram(program, [dy, filter], 'float32');\n}\n\nexport const conv2DBackpropInputConfig: KernelConfig = {\n  kernelName: Conv2DBackpropInput,\n  backendName: 'webgl',\n  kernelFunc: conv2DBackpropInput as {} as KernelFunc,\n};\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {backend_util, Conv3D, Conv3DAttrs, Conv3DInputs, KernelConfig, KernelFunc} from '@tensorflow/tfjs-core';\n\nimport {MathBackendWebGL} from '../backend_webgl';\nimport {Conv3DProgram} from '../conv_gpu';\n\nexport function conv3D(\n    args:\n        {inputs: Conv3DInputs, attrs: Conv3DAttrs, backend: MathBackendWebGL}) {\n  const {inputs, backend, attrs} = args;\n  const {x, filter} = inputs;\n  const {strides, pad, dilations} = attrs;\n\n  const convInfo = backend_util.computeConv3DInfo(\n      x.shape as [number, number, number, number, number],\n      filter.shape as [number, number, number, number, number], strides,\n      dilations, pad);\n\n  const program = new Conv3DProgram(convInfo);\n  return backend.runWebGLProgram(program, [x, filter], 'float32');\n}\n\nexport const conv3DConfig: KernelConfig = {\n  kernelName: Conv3D,\n  backendName: 'webgl',\n  kernelFunc: conv3D as {} as KernelFunc,\n};\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {backend_util, Conv3DBackpropFilterV2, Conv3DBackpropFilterV2Attrs, Conv3DBackpropFilterV2Inputs, KernelConfig, KernelFunc} from '@tensorflow/tfjs-core';\n\nimport {MathBackendWebGL} from '../backend_webgl';\nimport {Conv3DDerFilterProgram} from '../conv_backprop_gpu';\n\nexport function conv3DBackpropFilterV2(args: {\n  inputs: Conv3DBackpropFilterV2Inputs,\n  attrs: Conv3DBackpropFilterV2Attrs,\n  backend: MathBackendWebGL\n}) {\n  const {inputs, backend, attrs} = args;\n  const {x, dy} = inputs;\n  const {strides, pad, filterShape} = attrs;\n\n  const convInfo = backend_util.computeConv3DInfo(\n      x.shape as [number, number, number, number, number], filterShape, strides,\n      1 /* dilations */, pad);\n\n  const program = new Conv3DDerFilterProgram(convInfo);\n  return backend.runWebGLProgram(program, [x, dy], 'float32');\n}\n\nexport const conv3DBackpropFilterV2Config: KernelConfig = {\n  kernelName: Conv3DBackpropFilterV2,\n  backendName: 'webgl',\n  kernelFunc: conv3DBackpropFilterV2 as {} as KernelFunc\n};\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {backend_util, Conv3DBackpropInputV2, Conv3DBackpropInputV2Attrs, Conv3DBackpropInputV2Inputs, KernelConfig, KernelFunc} from '@tensorflow/tfjs-core';\n\nimport {MathBackendWebGL} from '../backend_webgl';\nimport {Conv3DDerInputProgram} from '../conv_backprop_gpu';\n\nexport function conv3DBackpropInput(args: {\n  inputs: Conv3DBackpropInputV2Inputs,\n  attrs: Conv3DBackpropInputV2Attrs,\n  backend: MathBackendWebGL\n}) {\n  const {inputs, backend, attrs} = args;\n  const {dy, filter} = inputs;\n  const {pad, strides, inputShape} = attrs;\n\n  const convInfo = backend_util.computeConv3DInfo(\n      inputShape, filter.shape as [number, number, number, number, number],\n      strides, 1 /* dilations */, pad);\n\n  const program = new Conv3DDerInputProgram(convInfo);\n  return backend.runWebGLProgram(program, [dy, filter], 'float32');\n}\n\nexport const conv3DBackpropInputConfig: KernelConfig = {\n  kernelName: Conv3DBackpropInputV2,\n  backendName: 'webgl',\n  kernelFunc: conv3DBackpropInput as {} as KernelFunc,\n};\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {Cos, KernelConfig} from '@tensorflow/tfjs-core';\n\nimport {CHECK_NAN_SNIPPET_UNARY, unaryKernelFunc} from '../kernel_utils/kernel_funcs_utils';\n\nconst COS = CHECK_NAN_SNIPPET_UNARY + `\n  return cos(x);\n`;\n\nexport const cos = unaryKernelFunc({opSnippet: COS});\n\nexport const cosConfig: KernelConfig = {\n  kernelName: Cos,\n  backendName: 'webgl',\n  kernelFunc: cos,\n};\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {Cosh, KernelConfig} from '@tensorflow/tfjs-core';\nimport {unaryKernelFunc} from '../kernel_utils/kernel_funcs_utils';\n\nconst COSH = `\n  float e2x = exp(-x);\n  return (e2x + 1.0 / e2x) / 2.0;\n`;\n\nexport const cosh = unaryKernelFunc({opSnippet: COSH});\n\nexport const coshConfig: KernelConfig = {\n  kernelName: Cosh,\n  backendName: 'webgl',\n  kernelFunc: cosh,\n};\n","/**\n * @license\n * Copyright 2017 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {GPGPUProgram} from './gpgpu_math';\n\nexport class CropAndResizeProgram implements GPGPUProgram {\n  variableNames = ['Image', 'Boxes', 'BoxInd'];\n  outputShape: number[] = [];\n  userCode: string;\n\n  constructor(\n      imageShape: [number, number, number, number], boxShape: [number, number],\n      cropSize: [number, number], method: 'bilinear'|'nearest',\n      extrapolationValue: number) {\n    const [batch, imageHeight, imageWidth, depth] = imageShape;\n    const [numBoxes, ] = boxShape;\n    const [cropHeight, cropWidth] = cropSize;\n    this.outputShape = [numBoxes, cropHeight, cropWidth, depth];\n    const methodId = method === 'bilinear' ? 1 : 0;\n\n    const [inputHeightFloat, inputWidthFloat] =\n        [`${imageHeight - 1}.0`, `${imageWidth - 1}.0`];\n\n    const [heightRatio, heightScale, inY] = cropHeight > 1 ?\n        [\n          `${(imageHeight - 1) / (cropHeight - 1)}`,\n          '(y2-y1) * height_ratio',\n          `y1*${inputHeightFloat} + float(y)*(height_scale)`,\n        ] :\n        [\n          '0.0',\n          '0.0',\n          `0.5 * (y1+y2) * ${inputHeightFloat}`,\n        ];\n    const [widthRatio, widthScale, inX] = cropWidth > 1 ?\n        [\n          `${(imageWidth - 1) / (cropWidth - 1)}`,\n          '(x2-x1) * width_ratio',\n          `x1*${inputWidthFloat} + float(x)*(width_scale)`,\n        ] :\n        [\n          '0.0',\n          '0.0',\n          `0.5 * (x1+x2) * ${inputWidthFloat}`,\n        ];\n\n    // Reference implementation\n    // tslint:disable-next-line:max-line-length\n    // https://github.com/tensorflow/tensorflow/blob/master/tensorflow/core/kernels/crop_and_resize_op_gpu.cu.cc\n    this.userCode = `\n      const float height_ratio = float(${heightRatio});\n      const float width_ratio = float(${widthRatio});\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int y = coords[1];\n        int x = coords[2];\n        int d = coords[3];\n\n        // get box vals\n        float y1 = getBoxes(b,0);\n        float x1 = getBoxes(b,1);\n        float y2 = getBoxes(b,2);\n        float x2 = getBoxes(b,3);\n\n        // get image in batch index\n        int bInd = round(getBoxInd(b));\n        if(bInd < 0 || bInd >= ${batch}) {\n          return;\n        }\n\n        float height_scale = ${heightScale};\n        float width_scale = ${widthScale};\n\n        float in_y = ${inY};\n        if( in_y < 0.0 || in_y > ${inputHeightFloat} ) {\n          setOutput(float(${extrapolationValue}));\n          return;\n        }\n        float in_x = ${inX};\n        if( in_x < 0.0 || in_x > ${inputWidthFloat} ) {\n          setOutput(float(${extrapolationValue}));\n          return;\n        }\n\n        vec2 sourceFracIndexCR = vec2(in_x,in_y);\n        if(${methodId} == 1) {\n          // Compute the four integer indices.\n          ivec2 sourceFloorCR = ivec2(sourceFracIndexCR);\n          ivec2 sourceCeilCR = ivec2(ceil(sourceFracIndexCR));\n\n          float topLeft = getImage(b, sourceFloorCR.y, sourceFloorCR.x, d);\n          float bottomLeft = getImage(b, sourceCeilCR.y, sourceFloorCR.x, d);\n          float topRight = getImage(b, sourceFloorCR.y, sourceCeilCR.x, d);\n          float bottomRight = getImage(b, sourceCeilCR.y, sourceCeilCR.x, d);\n\n          vec2 fracCR = sourceFracIndexCR - vec2(sourceFloorCR);\n\n          float top = topLeft + (topRight - topLeft) * fracCR.x;\n          float bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;\n          float newValue = top + (bottom - top) * fracCR.y;\n          setOutput(newValue);\n        } else {\n          // Compute the coordinators of nearest neighbor point.\n          ivec2 sourceNearestCR = ivec2(floor(\n            sourceFracIndexCR + vec2(0.5,0.5)));\n          float newValue = getImage(b, sourceNearestCR.y, sourceNearestCR.x, d);\n          setOutput(newValue);\n        }\n      }\n    `;\n  }\n}\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {CropAndResize, CropAndResizeAttrs, CropAndResizeInputs, KernelConfig, KernelFunc, TensorInfo} from '@tensorflow/tfjs-core';\n\nimport {MathBackendWebGL} from '../backend_webgl';\nimport {CropAndResizeProgram} from '../crop_and_resize_gpu';\n\nexport const cropAndResize = (args: {\n  inputs: CropAndResizeInputs,\n  backend: MathBackendWebGL,\n  attrs: CropAndResizeAttrs\n}): TensorInfo => {\n  const {inputs, backend, attrs} = args;\n  const {image, boxes, boxInd} = inputs;\n  const {cropSize, method, extrapolationValue} = attrs;\n\n  const program = new CropAndResizeProgram(\n      image.shape as [number, number, number, number],\n      boxes.shape as [number, number], cropSize, method, extrapolationValue);\n  return backend.runWebGLProgram(program, [image, boxes, boxInd], 'float32');\n};\n\nexport const cropAndResizeConfig: KernelConfig = {\n  kernelName: CropAndResize,\n  backendName: 'webgl',\n  kernelFunc: cropAndResize as {} as KernelFunc\n};\n","/**\n * @license\n * Copyright 2022 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport {GPGPUProgram} from './gpgpu_math';\nimport {getCoordsDataType, UniformType} from './shader_compiler';\n\nexport enum CumOpType {\n  Prod = '*',\n  Sum = '+',\n}\n\nexport class CumProgram implements GPGPUProgram {\n  variableNames = ['x'];\n  userCode: string;\n  customUniforms = [{name: 'index', type: 'float' as UniformType}];\n\n  constructor(\n      public op: CumOpType, public outputShape: number[], exclusive: boolean,\n      reverse: boolean) {\n    const rank = this.outputShape.length;\n    const initVal = this.op === CumOpType.Prod ? '1.0' : '0.0';\n    const val =\n        exclusive ? initVal : `getX(${getCoords(rank, 'coords', this.op)})`;\n    const length = this.outputShape[this.outputShape.length - 1];\n    let condition = '';\n    let idxString = '';\n    // When exclusive is set, the cum op becomes roll op that copies the\n    // value from the previous index based on the direction specified by the\n    // reverse flag.\n    if (exclusive) {\n      condition = reverse ? `end != ${length - 1}` : 'end != 0';\n      idxString = reverse ? 'end + 1' : 'end - 1';\n    } else {\n      condition = reverse ? `end + pow2 < ${length}` : 'end >= pow2';\n      idxString = (reverse ? 'end + pow2' : 'end - pow2');\n    }\n\n    this.userCode = `\n      void main() {\n        ${getCoordsDataType(rank)} coords = getOutputCoords();\n        int end = ${getFinalCoord(rank, 'coords', this.op)};\n        float val = ${val};\n        int pow2 = int(pow(2.0, index));\n        if (${condition}) {\n          int idx = ${idxString};\n          ${getFinalCoord(rank, 'coords', this.op)} = idx;\n          val ${this.op}= getX(${getCoords(rank, 'coords', this.op)});\n        }\n        setOutput(val);\n      }\n    `;\n  }\n}\n\nfunction getCoords(rank: number, name: string, op: CumOpType): string {\n  if (rank === 1) {\n    return `${name}`;\n  } else if (rank === 2) {\n    return `${name}.x, ${name}.y`;\n  } else if (rank === 3) {\n    return `${name}.x, ${name}.y, ${name}.z`;\n  } else if (rank === 4) {\n    return `${name}.x, ${name}.y, ${name}.z, ${name}.w`;\n  } else {\n    throw new Error(`Cumulative ${op} for rank ${rank} is not yet supported`);\n  }\n}\n\nfunction getFinalCoord(rank: number, name: string, op: CumOpType): string {\n  if (rank === 1) {\n    return `${name}`;\n  } else if (rank === 2) {\n    return `${name}.y`;\n  } else if (rank === 3) {\n    return `${name}.z`;\n  } else if (rank === 4) {\n    return `${name}.w`;\n  } else {\n    throw new Error(`Cumulative ${op} for rank ${rank} is not yet supported`);\n  }\n}\n","/**\n * @license\n * Copyright 2022 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {backend_util, TensorInfo} from '@tensorflow/tfjs-core';\n\nimport {MathBackendWebGL} from '../backend_webgl';\nimport {CumOpType, CumProgram} from '../cum_gpu';\n\nimport {identity} from './Identity';\nimport {transpose} from './Transpose';\n\nexport function cumImpl(\n    op: CumOpType, x: TensorInfo, backend: MathBackendWebGL, axis: number,\n    exclusive: boolean, reverse: boolean): TensorInfo {\n  const xRank = x.shape.length;\n  const permutation = backend_util.getAxesPermutation([axis], xRank);\n  let permutedX = x;\n  if (permutation != null) {\n    permutedX = transpose({inputs: {x}, backend, attrs: {perm: permutation}});\n  }\n  const permutedAxis = backend_util.getInnerMostAxes(1, xRank)[0];\n\n  if (permutedAxis !== xRank - 1) {\n    throw new Error(\n        `WebGL cumprod shader expects an inner-most axis=${\n            x.shape.length - 1} ` +\n        `but got axis=${axis}`);\n  }\n  const size = permutedX.shape[permutedAxis];\n  let result = identity({inputs: {x: permutedX}, backend});\n  // Use cum parallel algorithm, inspired by:\n  // https://developer.nvidia.com/gpugems/gpugems3/part-vi-gpu-computing/chapter-39-parallel-prefix-sum-scan-cuda\n  // Note: although the algorithm is called sum, it works for any associtative\n  // operator with an identity.\n\n  for (let i = 0; i <= Math.ceil(Math.log2(size)) - 1; i++) {\n    const program = new CumProgram(op, permutedX.shape, false, reverse);\n    const customValues = [[i]];\n    const prevResult = result;\n    result =\n        backend.runWebGLProgram(program, [result], result.dtype, customValues);\n    backend.disposeIntermediateTensorInfo(prevResult);\n  }\n  // For exclusive cum, shift the end result in the direction of product or sum\n  // and add 1 for product or 0 for sum to the front index.\n  if (exclusive) {\n    const program = new CumProgram(op, permutedX.shape, exclusive, reverse);\n    const prevResult = result;\n    result = backend.runWebGLProgram(program, [result], result.dtype);\n    backend.disposeIntermediateTensorInfo(prevResult);\n  }\n\n  if (permutation != null) {\n    const reversePermutation = backend_util.getUndoAxesPermutation(permutation);\n    const reverseTransposedResult = transpose(\n        {inputs: {x: result}, backend, attrs: {perm: reversePermutation}});\n\n    backend.disposeIntermediateTensorInfo(result);\n    backend.disposeIntermediateTensorInfo(permutedX);\n\n    return reverseTransposedResult;\n  }\n\n  return result;\n}\n","/**\n * @license\n * Copyright 2022 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {Cumprod, CumprodAttrs, CumprodInputs, KernelConfig, KernelFunc, TensorInfo} from '@tensorflow/tfjs-core';\n\nimport {MathBackendWebGL} from '../backend_webgl';\nimport {CumOpType} from '../cum_gpu';\nimport {cumImpl} from './Cum_impl';\n\nexport function cumprod(args: {\n  inputs: CumprodInputs,\n  backend: MathBackendWebGL,\n  attrs: CumprodAttrs\n}): TensorInfo {\n  const {inputs, backend, attrs} = args;\n  const {x} = inputs;\n  const {axis, exclusive, reverse} = attrs;\n\n  return cumImpl(CumOpType.Prod, x, backend, axis, exclusive, reverse);\n}\n\nexport const cumprodConfig: KernelConfig = {\n  kernelName: Cumprod,\n  backendName: 'webgl',\n  kernelFunc: cumprod as {} as KernelFunc\n};\n","/**\n * @license\n * Copyright 2022 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {Cumsum, CumsumAttrs, CumsumInputs, KernelConfig, KernelFunc, TensorInfo} from '@tensorflow/tfjs-core';\n\nimport {MathBackendWebGL} from '../backend_webgl';\nimport {CumOpType} from '../cum_gpu';\nimport {cumImpl} from './Cum_impl';\n\nexport function cumsum(\n    args:\n        {inputs: CumsumInputs, backend: MathBackendWebGL, attrs: CumsumAttrs}):\n    TensorInfo {\n  const {inputs, backend, attrs} = args;\n  const {x} = inputs;\n  const {axis, exclusive, reverse} = attrs;\n  return cumImpl(CumOpType.Sum, x, backend, axis, exclusive, reverse);\n}\n\nexport const cumsumConfig: KernelConfig = {\n  kernelName: Cumsum,\n  backendName: 'webgl',\n  kernelFunc: cumsum as {} as KernelFunc\n};\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {DenseBincount, DenseBincountAttrs, DenseBincountInputs, KernelConfig, KernelFunc, Rank, TensorInfo, TypedArray} from '@tensorflow/tfjs-core';\n\nimport {MathBackendWebGL} from '../backend_webgl';\nimport {bincountImplCPU, bincountReduceImplCPU} from '../kernel_utils/shared';\n\nexport function denseBincount(args: {\n  inputs: DenseBincountInputs,\n  backend: MathBackendWebGL,\n  attrs: DenseBincountAttrs\n}): TensorInfo {\n  const {inputs, backend, attrs} = args;\n  const {x, weights} = inputs;\n  const {size, binaryOutput} = attrs;\n\n  if (x.shape.length === 1) {\n    const xVals = backend.readSync(x.dataId) as TypedArray;\n    const weightsVals = backend.readSync(weights.dataId) as TypedArray;\n\n    const outVals =\n        bincountImplCPU(xVals, weightsVals, weights.dtype, weights.shape, size);\n\n    return backend.makeTensorInfo([size], weights.dtype, outVals);\n  } else if (x.shape.length === 2) {\n    const xBuf = backend.bufferSync<Rank, 'float32'>(x);\n    const weightsBuf = backend.bufferSync<Rank, 'float32'>(weights);\n\n    const outBuf = bincountReduceImplCPU(xBuf, weightsBuf, size, binaryOutput);\n\n    return backend.makeTensorInfo(outBuf.shape, weights.dtype, outBuf.values);\n  }\n\n  throw new Error(\n      `Error in denseBincount: input must be at most rank 2, but got rank` +\n      `${x.shape.length}.`);\n}\n\nexport const denseBincountConfig: KernelConfig = {\n  kernelName: DenseBincount,\n  backendName: 'webgl',\n  kernelFunc: denseBincount as {} as KernelFunc\n};\n","/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {GPGPUProgram} from './gpgpu_math';\n\nexport class DepthToSpaceProgram implements GPGPUProgram {\n  variableNames = ['x'];\n  outputShape: number[] = [];\n  userCode: string;\n  blockSize: number;\n  dataFormat: string;\n\n  constructor(\n      outputShape: number[], blockSize: number, dataFormat: 'NHWC'|'NCHW') {\n    this.outputShape = outputShape;\n    this.blockSize = blockSize;\n    this.dataFormat = dataFormat;\n    this.userCode = `\n    void main() {\n      ivec4 coords = getOutputCoords();\n      int b = coords[0];\n      int h = ${this.getHeightCoordString()};\n      int w = ${this.getWidthCoordString()};\n      int d = ${this.getDepthCoordString()};\n\n      int in_h = h / ${blockSize};\n      int offset_h = imod(h, ${blockSize});\n      int in_w = w / ${blockSize};\n      int offset_w = imod(w, ${blockSize});\n      int offset_d = (offset_h * ${blockSize} + offset_w) *\n        ${this.getOutputDepthSize()};\n      int in_d = d + offset_d;\n\n      float result = ${this.getInputSamplingString()};\n      setOutput(result);\n    }\n  `;\n  }\n\n  private getHeightCoordString(): string {\n    if (this.dataFormat === 'NHWC') {\n      return `coords[1]`;\n    } else {\n      return `coords[2]`;\n    }\n  }\n\n  private getWidthCoordString(): string {\n    if (this.dataFormat === 'NHWC') {\n      return `coords[2]`;\n    } else {\n      return `coords[3]`;\n    }\n  }\n\n  private getDepthCoordString(): string {\n    if (this.dataFormat === 'NHWC') {\n      return `coords[3]`;\n    } else {\n      return `coords[1]`;\n    }\n  }\n\n  private getOutputDepthSize(): number {\n    if (this.dataFormat === 'NHWC') {\n      return this.outputShape[3];\n    } else {\n      return this.outputShape[1];\n    }\n  }\n\n  private getInputSamplingString(): string {\n    if (this.dataFormat === 'NHWC') {\n      return `getX(b, in_h, in_w, in_d)`;\n    } else {\n      return `getX(b, in_d, in_h, in_w)`;\n    }\n  }\n}\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {DepthToSpace, DepthToSpaceAttrs, DepthToSpaceInputs, KernelConfig, KernelFunc, TensorInfo} from '@tensorflow/tfjs-core';\n\nimport {MathBackendWebGL} from '../backend_webgl';\nimport {DepthToSpaceProgram} from '../depth_to_space_gpu';\n\nexport function depthToSpace(args: {\n  inputs: DepthToSpaceInputs,\n  backend: MathBackendWebGL,\n  attrs: DepthToSpaceAttrs\n}): TensorInfo {\n  const {inputs, backend, attrs} = args;\n  const {x} = inputs;\n  const {blockSize, dataFormat} = attrs;\n\n  const batchSize = x.shape[0];\n  const inputHeight = (dataFormat === 'NHWC') ? x.shape[1] : x.shape[2];\n  const inputWidth = (dataFormat === 'NHWC') ? x.shape[2] : x.shape[3];\n  const inputDepth = (dataFormat === 'NHWC') ? x.shape[3] : x.shape[1];\n\n  const outputHeight = inputHeight * blockSize;\n  const outputWidth = inputWidth * blockSize;\n  const outputDepth = inputDepth / (blockSize * blockSize);\n\n  const outputShape = (dataFormat === 'NHWC') ?\n      [batchSize, outputHeight, outputWidth, outputDepth] :\n      [batchSize, outputDepth, outputHeight, outputWidth];\n\n  const program = new DepthToSpaceProgram(outputShape, blockSize, dataFormat);\n  return backend.runWebGLProgram(program, [x], x.dtype);\n}\n\nexport const depthToSpaceConfig: KernelConfig = {\n  kernelName: DepthToSpace,\n  backendName: 'webgl',\n  kernelFunc: depthToSpace as {} as KernelFunc\n};\n","/**\n * @license\n * Copyright 2017 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {backend_util} from '@tensorflow/tfjs-core';\nimport {GPGPUProgram, useShapeUniforms} from './gpgpu_math';\n\nexport class DepthwiseConv2DProgram implements GPGPUProgram {\n  variableNames = ['x', 'W'];\n  outputShape: number[];\n  userCode: string;\n  enableShapeUniforms: boolean;\n  customUniforms = [\n    {name: 'pads', type: 'ivec2' as const },\n    {name: 'strides', type: 'ivec2' as const },\n    {name: 'dilations', type: 'ivec2' as const },\n    {name: 'inDims', type: 'ivec2' as const },\n  ];\n\n  constructor(\n      convInfo: backend_util.Conv2DInfo, addBias = false,\n      activation: string = null, hasPreluActivation = false,\n      hasLeakyReluAlpha = false) {\n    this.outputShape = convInfo.outShape;\n    this.enableShapeUniforms = useShapeUniforms(this.outputShape.length);\n\n    const filterHeight = convInfo.filterHeight;\n    const filterWidth = convInfo.filterWidth;\n    const channelMul = convInfo.outChannels / convInfo.inChannels;\n\n    let activationSnippet = '', applyActivationSnippet = '';\n    if (activation) {\n      if (hasPreluActivation) {\n        activationSnippet = `float activation(float a) {\n          float b = getPreluActivationWeightsAtOutCoords();\n          ${activation}\n        }`;\n      } else if (hasLeakyReluAlpha) {\n        activationSnippet = `float activation(float a) {\n          float b = getLeakyreluAlphaAtOutCoords();\n          ${activation}\n        }`;\n      } else {\n        activationSnippet = `\n          float activation(float x) {\n            ${activation}\n          }\n        `;\n      }\n\n      applyActivationSnippet = `result = activation(result);`;\n    }\n\n    const addBiasSnippet = addBias ? 'result += getBiasAtOutCoords();' : '';\n    if (addBias) {\n      this.variableNames.push('bias');\n    }\n\n    if (hasPreluActivation) {\n      this.variableNames.push('preluActivationWeights');\n    }\n    if (hasLeakyReluAlpha) {\n      this.variableNames.push('leakyreluAlpha');\n    }\n\n    this.userCode = `\n      ${activationSnippet}\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int d2 = coords.w;\n        int d1 = d2 / ${channelMul};\n        int q = d2 - d1 * ${channelMul};\n\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // Convolve x(?, ?, d1) with w(:, :, d1, q) to get y(yR, yC, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        // TO DO(dsmilkov): Flatten the two for loops and vec4 the operations.\n        for (int wR = 0; wR < ${filterHeight}; wR++) {\n          int xR = xRCorner + wR * dilations[0];\n\n          if (xR < 0 || xR >= inDims[0]) {\n            continue;\n          }\n\n          for (int wC = 0; wC < ${filterWidth}; wC++) {\n            int xC = xCCorner + wC * dilations[1];\n\n            if (xC < 0 || xC >= inDims[1]) {\n              continue;\n            }\n\n            float xVal = getX(batch, xR, xC, d1);\n            float wVal = getW(wR, wC, d1, q);\n            dotProd += xVal * wVal;\n          }\n        }\n\n        float result = dotProd;\n        ${addBiasSnippet}\n        ${applyActivationSnippet}\n        setOutput(result);\n      }\n    `;\n  }\n}\n","/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {backend_util, util} from '@tensorflow/tfjs-core';\n\nimport {GPGPUProgram, useShapeUniforms} from './gpgpu_math';\n\nexport class DepthwiseConvPacked2DProgram implements GPGPUProgram {\n  variableNames = ['x', 'W'];\n  packedInputs = true;\n  packedOutput = true;\n  outputShape: number[];\n  userCode: string;\n  enableShapeUniforms: boolean;\n  customUniforms = [\n    {name: 'pads', type: 'ivec2' as const },\n    {name: 'strides', type: 'ivec2' as const },\n    {name: 'dilations', type: 'ivec2' as const },\n    {name: 'inDims', type: 'ivec2' as const },\n  ];\n\n  constructor(\n      convInfo: backend_util.Conv2DInfo, addBias = false,\n      activation: string = null, hasPreluActivation = false,\n      hasLeakyReluAlpha = false) {\n    this.outputShape = convInfo.outShape;\n    this.enableShapeUniforms = useShapeUniforms(this.outputShape.length);\n    const channelMul = convInfo.outChannels / convInfo.inChannels;\n    const padLeft = convInfo.padInfo.left;\n    const strideWidth = convInfo.strideWidth;\n    const dilationWidth = convInfo.dilationWidth;\n    const filterHeight = convInfo.filterHeight;\n    const filterWidth = convInfo.filterWidth;\n    const texelsAcross = filterWidth;\n\n    let mainLoop = `\n      int xR; int xC; int xCOffset;\n      vec4 wTexel; vec4 previous; vec4 final;`;\n\n    for (let c = 0; c < filterWidth; c++) {\n      mainLoop += `\n          vec4 xTexelC${c * 2};\n          int xTexelC${c * 2}Ready;\n          vec4 xTexelC${c * 2 + 1};\n          int xTexelC${c * 2 + 1}Ready;\n          vec4 xC${c};`;\n    }\n\n    /**\n     * This vectorized implementation works by gathering the values needed for\n     * each output channel's dot product into vec4's and then multiplying them\n     * all together (this happens in the final double for-loop below). Most of\n     * the main loop consists of constructing these vec4's with the minimum\n     * number of texture2D calls, which means making use of all four returned\n     * values from a texture2D call at once.\n     */\n    mainLoop += `\n    for (int r = 0; r < ${filterHeight}; r++) {\n      `;\n    for (let c = 0; c < filterWidth; c++) {\n      mainLoop += `\n          xTexelC${c * 2} = vec4(0.0);\n          xTexelC${c * 2}Ready = 0;\n          xTexelC${c * 2 + 1} = vec4(0.0);\n          xTexelC${c * 2 + 1}Ready = 0;\n          xC${c} = vec4(0.0);`;\n    }\n    mainLoop += `\n        xR = xRCorner + r * dilations[0];\n        if (xR >=0 && xR < inDims[0]) {\n      `;\n\n    for (let texelC = 0; texelC < (texelsAcross + 1) / 2; texelC++) {\n      const colIndex = texelC * 2;\n\n      mainLoop += `\n          xC = xCCorner + ${colIndex * dilationWidth};\n          `;\n\n      if (strideWidth === 1) {\n        if (colIndex < filterWidth) {\n          // If padding is odd, the outer texels have to be composed.\n          if (padLeft % 2 === 1) {\n            // TODO: Ensure vec4 previous does not result in redundant sample,\n            // and avoid setting xTexelRC's that exceed the boundary in the\n            // first place rather than resetting them to vec4(0)).\n\n            // To compute xCOffset:\n            // - If padding is odd, we must add 1 to ensure we ask for an\n            // even-numbered row.\n            // - We subtract 2 to access the previous texel.\n\n            mainLoop += `\n                xCOffset = xC + 1;\n                if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${\n                colIndex}Ready == 0) {\n                  xTexelC${colIndex} = getX(batch, xR, xCOffset, d1);\n\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if (xCOffset + 1 >= inDims[1]) {\n                    xTexelC${colIndex}.zw = vec2(0.0);\n                  }\n                  xTexelC${colIndex}Ready = 1;\n                }\n              `;\n            // This texel has been read in previous iteration if the dilation\n            // is 1.\n            if (dilationWidth === 1 && colIndex > 0) {\n              mainLoop += `\n                xC${colIndex} = vec4(xTexelC${colIndex - 2}.zw, xTexelC${\n                  colIndex}.xy);\n                `;\n            } else {\n              mainLoop += `\n                  xCOffset = xC + 1 - 2;\n\n                  if (xCOffset >= 0 && xCOffset < inDims[1]) {\n                    previous = getX(batch, xR, xCOffset, d1);\n\n                    // Need to manually clear unused channels in case\n                    // we're reading from recycled texture.\n                    if (xCOffset + 1 >= inDims[1]) {\n                      previous.zw = vec2(0.0);\n                    }\n\n                    xC${colIndex} = vec4(previous.zw, xTexelC${colIndex}.xy);\n                  } else {\n                    xC${colIndex} = vec4(0.0, 0.0, xTexelC${colIndex}.xy);\n                  }\n                  `;\n            }\n          } else {\n            // Padding is even, so xRC corresponds to a single texel.\n            mainLoop += `\n                if (xC >= 0 && xC < inDims[1] && xTexelC${colIndex}Ready == 0) {\n                  xTexelC${colIndex} = getX(batch, xR, xC, d1);\n                  if (xC + 1 >= inDims[1]) {\n                    xTexelC${colIndex}.zw = vec2(0.0);\n                  }\n                  xTexelC${colIndex}Ready = 1;\n                }\n\n                xC${colIndex} = xTexelC${colIndex};\n                `;\n          }\n\n          if (colIndex + 1 < filterWidth) {\n            // If dilation is even, the second entry should match the first\n            // (either both are composed or both are single samples). But if\n            // dilation is odd, then the second entry should be the opposite\n            // of the first (if the first is composed, the second is a single\n            // sample, and vice versa.)\n\n            const nextTexelOffset = padLeft % 2 === 0 ?\n                util.nearestLargerEven(dilationWidth) :\n                dilationWidth;\n\n            if ((dilationWidth % 2 === 0 && padLeft % 2 === 1) ||\n                (dilationWidth % 2 !== 0 && padLeft % 2 !== 1)) {\n              mainLoop += `\n                  xCOffset = xC + imod(pads[1], 2) + ${nextTexelOffset};\n\n                  if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${\n                  colIndex + 1}Ready == 0) {\n                    xTexelC${colIndex + 1} = getX(batch, xR, xCOffset, d1);\n\n                    // Need to manually clear unused channels in case\n                    // we're reading from recycled texture.\n                    if (xCOffset + 1 >= inDims[1]) {\n                      xTexelC${colIndex + 1}.zw = vec2(0.0);\n                    }\n                    xTexelC${colIndex + 1}Ready = 1;\n                  }\n                  `;\n\n              // If dilation > 1 then the xRC's will not be able to share any\n              // values, so each xRC will require two unique calls to getX.\n              if (dilationWidth > 1) {\n                mainLoop += `\n                    xCOffset -= 2;\n                    if (xCOffset >= 0 && xCOffset < inDims[1]) {\n                     previous = getX(batch, xR, xCOffset, d1);\n                     xC${colIndex + 1} = vec4(previous.zw, xTexelC${\n                       colIndex + 1}.xy);\n                    } else {\n                     xC${colIndex + 1} = vec4(0.0, 0.0, xTexelC${\n                       colIndex + 1}.xy);\n                    }\n                    `;\n              } else {\n                mainLoop += `\n                    xC${colIndex + 1} = vec4(xTexelC${colIndex}.zw, xTexelC${\n                    colIndex + 1}.xy);\n                    `;\n              }\n            } else {\n              // If dilation is 1 and padding is odd, we have already read the\n              // texel when constructing the previous x value. Here we can\n              // simply skip the texture read.\n              if (nextTexelOffset === 1) {\n                mainLoop += `\n                    xC${colIndex + 1} = xTexelC${colIndex};\n                    `;\n              } else {\n                mainLoop += `\n                    xCOffset = xC + ${nextTexelOffset};\n\n                    if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${\n                    colIndex + 1}Ready == 0) {\n                      xTexelC${colIndex + 1} = getX(batch, xR, xCOffset, d1);\n                      if (xCOffset + 1 >= inDims[1]) {\n                        xTexelC${colIndex + 1}.zw = vec2(0.0);\n                      }\n                      xTexelC${colIndex + 1}Ready = 1;\n                    }\n\n                    xC${colIndex + 1} = xTexelC${colIndex + 1};\n                    `;\n              }\n            }\n          }\n        }\n      } else {  // stride === 2\n        if (colIndex < filterWidth) {\n          // Depending on whether padLeft is even or odd, we want either the\n          // xy or zw channels from X texels for xC${colIndex}. If padLeft is\n          // even, xC${colIndex +1} is simply the zw channels of texels we've\n          // already sampled. But if padLeft is odd, xC{$c + 1}.zw will\n          // need to come from the xy channels of a new texel, hence the `\n          // vec4\n          // final` initialized below.\n          if (padLeft % 2 === 1) {\n            mainLoop += `\n                xCOffset = xC + 1 - strides[1];\n                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${\n                colIndex}Ready == 0) {\n                  xTexelC${colIndex} = getX(batch, xR, xCOffset, d1);\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if (xCOffset + 1 >= inDims[1]) {\n                    xTexelC${colIndex}.zw = vec2(0.0);\n                  }\n                  xTexelC${colIndex}Ready = 1;\n                }\n\n                if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${\n                colIndex + 1}Ready == 0) {\n                  xTexelC${colIndex + 1} = getX(batch, xR, xC + 1, d1);\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if (xC + 2 >= inDims[1]) {\n                    xTexelC${colIndex + 1}.zw = vec2(0.0);\n                  }\n                  xTexelC${colIndex + 1}Ready = 1;\n                }\n\n                xC${colIndex} = vec4(xTexelC${colIndex}.zw, xTexelC${\n                colIndex + 1}.zw);\n              `;\n\n            if (colIndex + 1 < filterWidth) {\n              mainLoop += `\n                  final = vec4(0.0);\n                  xCOffset = xC + 1 + strides[1];\n                  if(xCOffset >= 0 && xCOffset < inDims[1]) {\n                    final = getX(batch, xR, xCOffset, d1);\n                  }\n                  xC${colIndex + 1} = vec4(xTexelC${colIndex + 1}.xy, final.xy);\n                `;\n            }\n          } else {\n            mainLoop += `\n                if(xC >= 0 && xC < inDims[1] && xTexelC${colIndex}Ready == 0) {\n                  xTexelC${colIndex} = getX(batch, xR, xC, d1);\n                  if (xC + 1 >= inDims[1]) {\n                    xTexelC${colIndex}.zw = vec2(0.0);\n                  }\n                  xTexelC${colIndex}Ready = 1;\n                }\n\n                xCOffset = xC + strides[1];\n                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${\n                colIndex + 1}Ready == 0) {\n                  xTexelC${colIndex + 1} = getX(batch, xR, xCOffset, d1);\n                  if (xCOffset + 1 >= inDims[1]) {\n                    xTexelC${colIndex + 1}.zw = vec2(0.);\n                  }\n                  xTexelC${colIndex + 1}Ready = 1;\n                }\n\n                xC${colIndex} = vec4(\n                  xTexelC${colIndex}.xy, xTexelC${colIndex + 1}.xy);\n              `;\n\n            if (colIndex + 1 < filterWidth) {\n              mainLoop += `\n                  xC${colIndex + 1} = vec4(xTexelC${colIndex}.zw, xTexelC${\n                  colIndex + 1}.zw);\n                `;\n            }\n          }\n        }\n      }\n\n      // localize the dotProd accumulation within the loop, the theory is for\n      // GPU with limited cache, accumulate sum across large amount of\n      // veriables will cause lots of cache misses. (i.e. 5x5 filter will have\n      // 50 variables)\n      if (colIndex < filterWidth) {\n        mainLoop += `\n            wTexel = getW(r, ${colIndex}, d1, q);\n            dotProd += xC${colIndex} * vec4(wTexel.xz, wTexel.xz);\n          `;\n\n        if (colIndex + 1 < filterWidth) {\n          mainLoop += `\n              wTexel = getW(r, ${colIndex + 1}, d1, q);\n              dotProd += xC${colIndex + 1} * vec4(wTexel.xz, wTexel.xz);\n            `;\n        }\n      }\n    }\n    mainLoop += `\n    }\n  `;\n    mainLoop += `\n      }\n    `;\n\n    let activationSnippet = '', applyActivationSnippet = '';\n    if (activation) {\n      if (hasPreluActivation) {\n        activationSnippet = `vec4 activation(vec4 a) {\n          vec4 b = getPreluActivationWeightsAtOutCoords();\n          ${activation}\n        }`;\n      } else if (hasLeakyReluAlpha) {\n        activationSnippet = `vec4 activation(vec4 a) {\n          vec4 b = getLeakyreluAlphaAtOutCoords();\n          ${activation}\n        }`;\n      } else {\n        activationSnippet = `vec4 activation(vec4 x) {\n          ${activation}\n        }`;\n      }\n\n      applyActivationSnippet = `result = activation(result);`;\n    }\n\n    const addBiasSnippet = addBias ? 'result += getBiasAtOutCoords();' : '';\n    if (addBias) {\n      this.variableNames.push('bias');\n    }\n\n    if (hasPreluActivation) {\n      this.variableNames.push('preluActivationWeights');\n    }\n    if (hasLeakyReluAlpha) {\n      this.variableNames.push('leakyreluAlpha');\n    }\n\n    this.userCode = `\n      ${activationSnippet}\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int d2 = coords.w;\n        int d1 = d2 / ${channelMul};\n        int q = d2 - d1 * ${channelMul};\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.\n        vec4 dotProd = vec4(0.000000000000001);\n\n        ${mainLoop}\n\n        vec4 result = dotProd - vec4(0.000000000000001);\n        ${addBiasSnippet}\n        ${applyActivationSnippet}\n        setOutput(result);\n      }\n    `;\n  }\n}\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {backend_util, DepthwiseConv2dNative, DepthwiseConv2dNativeAttrs, DepthwiseConv2dNativeInputs, env, KernelConfig, KernelFunc, util} from '@tensorflow/tfjs-core';\n\nimport {MathBackendWebGL} from '../backend_webgl';\nimport {DepthwiseConv2DProgram} from '../conv_gpu_depthwise';\nimport {DepthwiseConvPacked2DProgram} from '../conv_packed_gpu_depthwise';\n\nexport function depthwiseConv2dNative(args: {\n  inputs: DepthwiseConv2dNativeInputs,\n  attrs: DepthwiseConv2dNativeAttrs,\n  backend: MathBackendWebGL\n}) {\n  const {inputs, backend, attrs} = args;\n  const {x, filter} = inputs;\n  const {strides, pad, dilations, dimRoundingMode} = attrs;\n\n  let $dilations = dilations;\n  if ($dilations == null) {\n    $dilations = [1, 1];\n  }\n\n  util.assert(\n      backend_util.eitherStridesOrDilationsAreOne(strides, $dilations),\n      () => 'Error in depthwiseConv2d: Either strides or dilations must be ' +\n          `1. Got strides ${strides} and dilations '${$dilations}'`);\n\n  const convInfo = backend_util.computeConv2DInfo(\n      x.shape as [number, number, number, number],\n      filter.shape as [number, number, number, number], strides, $dilations,\n      pad, dimRoundingMode, true /* depthwise */);\n\n  let program: DepthwiseConv2DProgram|DepthwiseConvPacked2DProgram;\n  if (env().getBool('WEBGL_PACK_DEPTHWISECONV') && convInfo.strideWidth <= 2 &&\n      convInfo.outChannels / convInfo.inChannels === 1) {\n    program = new DepthwiseConvPacked2DProgram(convInfo);\n  } else {\n    program = new DepthwiseConv2DProgram(convInfo);\n  }\n  const customValues = [\n    [convInfo.padInfo.top, convInfo.padInfo.left],\n    [convInfo.strideHeight, convInfo.strideWidth],\n    [convInfo.dilationHeight, convInfo.dilationWidth],\n    [convInfo.inHeight, convInfo.inWidth]\n  ];\n  return backend.runWebGLProgram(program, [x, filter], 'float32', customValues);\n}\n\nexport const depthwiseConv2dNativeConfig: KernelConfig = {\n  kernelName: DepthwiseConv2dNative,\n  backendName: 'webgl',\n  kernelFunc: depthwiseConv2dNative as {} as KernelFunc,\n};\n","/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {backend_util} from '@tensorflow/tfjs-core';\nimport {GPGPUProgram} from './gpgpu_math';\n\nexport class DepthwiseConv2DDerFilterProgram implements GPGPUProgram {\n  variableNames = ['x', 'dy'];\n  outputShape: number[];\n  userCode: string;\n\n  constructor(convInfo: backend_util.Conv2DInfo) {\n    this.outputShape = convInfo.filterShape;\n\n    const strideHeight = convInfo.strideHeight;\n    const strideWidth = convInfo.strideWidth;\n    const padTop = convInfo.padInfo.top;\n    const padLeft = convInfo.padInfo.left;\n    const channelMul = convInfo.outChannels / convInfo.inChannels;\n\n    this.userCode = `\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int wR = coords.x;\n        int wC = coords.y;\n        int d1 = coords.z;\n        int dm = coords.w;\n        int d2 = d1 * ${channelMul} + dm;\n\n        float dotProd = 0.0;\n\n        // TO DO: Vec4 over the batch size\n        for (int b = 0; b < ${convInfo.batchSize}; b++) {\n          for (int yR = 0; yR < ${convInfo.outHeight}; yR++) {\n            int xR = wR + yR * ${strideHeight} - ${padTop};\n\n            if (xR < 0 || xR >= ${convInfo.inHeight}) {\n              continue;\n            }\n\n            for (int yC = 0; yC < ${convInfo.outWidth}; yC++) {\n              int xC = wC + yC * ${strideWidth} - ${padLeft};\n\n              if (xC < 0 || xC >= ${convInfo.inWidth}) {\n                continue;\n              }\n\n              float dyValue = getDy(b, yR, yC, d2);\n              float xValue = getX(b, xR, xC, d1);\n              dotProd += (xValue * dyValue);\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `;\n  }\n}\n\nexport class DepthwiseConv2DDerInputProgram implements GPGPUProgram {\n  variableNames = ['dy', 'W'];\n  outputShape: number[];\n  userCode: string;\n\n  constructor(convInfo: backend_util.Conv2DInfo) {\n    this.outputShape = convInfo.inShape;\n\n    const filterHeight = convInfo.filterHeight;\n    const filterWidth = convInfo.filterWidth;\n    const strideHeight = convInfo.strideHeight;\n    const strideWidth = convInfo.strideWidth;\n\n    const padTop = filterHeight - 1 - convInfo.padInfo.top;\n    const padLeft = filterWidth - 1 - convInfo.padInfo.left;\n    const channelMul = convInfo.outChannels / convInfo.inChannels;\n\n    this.userCode = `\n      const ivec2 pads = ivec2(${padTop}, ${padLeft});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[3];\n        ivec2 dyCorner = coords.yz - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        float dotProd = 0.0;\n\n        for (int wR = 0; wR < ${filterHeight}; wR++) {\n          float dyR = float(dyRCorner + wR) / ${strideHeight}.0;\n\n          if (dyR < 0.0 || dyR >= ${convInfo.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          int wRPerm = ${filterHeight} - 1 - wR;\n\n          for (int wC = 0; wC < ${filterWidth}; wC++) {\n            float dyC = float(dyCCorner + wC) / ${strideWidth}.0;\n\n            if (dyC < 0.0 || dyC >= ${convInfo.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            int wCPerm = ${filterWidth} - 1 - wC;\n\n            // TO DO: Vec4 over the channelMul\n            for (int dm = 0; dm < ${channelMul}; dm++) {\n              int d2 = d1 * ${channelMul} + dm;\n              float xValue = getDy(batch, idyR, idyC, d2);\n              float wValue = getW(wRPerm, wCPerm, d1, dm);\n              dotProd += xValue * wValue;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `;\n  }\n}\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {backend_util, DepthwiseConv2dNativeBackpropFilter, DepthwiseConv2dNativeBackpropFilterAttrs, DepthwiseConv2dNativeBackpropFilterInputs, KernelConfig, KernelFunc} from '@tensorflow/tfjs-core';\n\nimport {MathBackendWebGL} from '../backend_webgl';\nimport {DepthwiseConv2DDerFilterProgram} from '../conv_backprop_gpu_depthwise';\n\nexport function depthwiseConv2dNativeBackpropFilter(args: {\n  inputs: DepthwiseConv2dNativeBackpropFilterInputs,\n  attrs: DepthwiseConv2dNativeBackpropFilterAttrs,\n  backend: MathBackendWebGL\n}) {\n  const {inputs, backend, attrs} = args;\n  const {x, dy} = inputs;\n  const {strides, dilations, pad, dimRoundingMode, filterShape} = attrs;\n\n  const convInfo = backend_util.computeConv2DInfo(\n      x.shape as [number, number, number, number], filterShape, strides,\n      dilations, pad, dimRoundingMode, true /* depthwise */);\n\n  const program = new DepthwiseConv2DDerFilterProgram(convInfo);\n  return backend.runWebGLProgram(program, [x, dy], 'float32');\n}\n\nexport const depthwiseConv2dNativeBackpropFilterConfig: KernelConfig = {\n  kernelName: DepthwiseConv2dNativeBackpropFilter,\n  backendName: 'webgl',\n  kernelFunc: depthwiseConv2dNativeBackpropFilter as {} as KernelFunc\n};\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {backend_util, DepthwiseConv2dNativeBackpropInput, DepthwiseConv2dNativeBackpropInputAttrs, DepthwiseConv2dNativeBackpropInputInputs, KernelConfig, KernelFunc} from '@tensorflow/tfjs-core';\n\nimport {MathBackendWebGL} from '../backend_webgl';\nimport {DepthwiseConv2DDerInputProgram} from '../conv_backprop_gpu_depthwise';\n\nexport function depthwiseConv2dNativeBackpropInput(args: {\n  inputs: DepthwiseConv2dNativeBackpropInputInputs,\n  attrs: DepthwiseConv2dNativeBackpropInputAttrs,\n  backend: MathBackendWebGL\n}) {\n  const {inputs, backend, attrs} = args;\n  const {dy, filter} = inputs;\n  const {strides, dilations, pad, dimRoundingMode, inputShape} = attrs;\n\n  const convInfo = backend_util.computeConv2DInfo(\n      inputShape, filter.shape as [number, number, number, number], strides,\n      dilations, pad, dimRoundingMode, true /* depthwise */);\n\n  const program = new DepthwiseConv2DDerInputProgram(convInfo);\n  return backend.runWebGLProgram(program, [dy, filter], 'float32');\n}\n\nexport const depthwiseConv2dNativeBackpropInputConfig: KernelConfig = {\n  kernelName: DepthwiseConv2dNativeBackpropInput,\n  backendName: 'webgl',\n  kernelFunc: depthwiseConv2dNativeBackpropInput as {} as KernelFunc\n};\n","/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {GPGPUProgram} from './gpgpu_math';\n\nexport class DiagProgram implements GPGPUProgram {\n  variableNames = ['X'];\n  outputShape: number[];\n  userCode: string;\n\n  constructor(size: number) {\n    this.outputShape = [size, size];\n    this.userCode = `\n      void main() {\n          ivec2 coords = getOutputCoords();\n          float val = coords[0] == coords[1] ? getX(coords[0]) : 0.0;\n          setOutput(val);\n      }\n    `;\n  }\n}\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {Diag, DiagInputs, KernelConfig, KernelFunc, TensorInfo, util} from '@tensorflow/tfjs-core';\n\nimport {MathBackendWebGL} from '../backend_webgl';\nimport {DiagProgram} from '../diag_gpu';\nimport {reshape} from './Reshape';\n\nexport function diag(args: {inputs: DiagInputs, backend: MathBackendWebGL}):\n    TensorInfo {\n  const {inputs, backend} = args;\n  const {x} = inputs;\n\n  const outShape = [...x.shape, ...x.shape];\n  const xSize = util.sizeFromShape(x.shape);\n\n  const flat = reshape({inputs: {x}, backend, attrs: {shape: [xSize]}});\n\n  const program = new DiagProgram(xSize);\n  const res = backend.runWebGLProgram(program, [flat], flat.dtype);\n\n  const out = reshape({inputs: {x: res}, backend, attrs: {shape: outShape}});\n\n  backend.disposeIntermediateTensorInfo(flat);\n  backend.disposeIntermediateTensorInfo(res);\n\n  return out;\n}\n\nexport const diagConfig: KernelConfig = {\n  kernelName: Diag,\n  backendName: 'webgl',\n  kernelFunc: diag as {} as KernelFunc\n};\n","/**\n * @license\n * Copyright 2017 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {backend_util} from '@tensorflow/tfjs-core';\nimport {GPGPUProgram} from './gpgpu_math';\n\nexport class Dilation2DProgram implements GPGPUProgram {\n  variableNames = ['x', 'W'];\n  outputShape: number[];\n  userCode: string;\n\n  constructor(convInfo: backend_util.Conv2DInfo) {\n    this.outputShape = convInfo.outShape;\n\n    const {\n      inHeight,\n      inWidth,\n      padInfo,\n      strideHeight,\n      strideWidth,\n      filterHeight,\n      filterWidth,\n      dilationHeight,\n      dilationWidth\n    } = convInfo;\n\n    const {top: padTop, left: padLeft} = padInfo;\n\n    this.userCode = `\n      const ivec2 strides = ivec2(${strideHeight}, ${strideWidth});\n      const ivec2 pads = ivec2(${padTop}, ${padLeft});\n      const float neg_infinity = -3.4e38;\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        int d1 = coords.w;\n        ivec2 outTopLeftCorner =\n            coords.yz * strides - pads;\n        int hBeg = outTopLeftCorner.x;\n        int wBeg = outTopLeftCorner.y;\n\n        float curVal = neg_infinity;\n        for (int h = 0; h < ${filterHeight}; h++) {\n          int hIn = hBeg + h * ${dilationHeight};\n\n          if (hIn >= 0 && hIn < ${inHeight}) {\n            for (int w = 0; w < ${filterWidth}; w++) {\n              int wIn = wBeg + w * ${dilationWidth};\n\n              if (wIn >= 0 && wIn < ${inWidth}) {\n                float xVal = getX(batch, hIn, wIn, d1);\n                float wVal = getW(h, w, d1);\n\n                float val = xVal + wVal;\n                if (val > curVal) {\n                  curVal = val;\n                }\n              }\n            }\n          }\n        }\n\n        float result = curVal;\n        setOutput(result);\n      }\n    `;\n  }\n}\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {backend_util, Dilation2D, Dilation2DAttrs, Dilation2DInputs, KernelConfig, KernelFunc, TensorInfo} from '@tensorflow/tfjs-core';\n\nimport {MathBackendWebGL} from '../backend_webgl';\nimport {Dilation2DProgram} from '../dilation_gpu';\nimport {reshape} from './Reshape';\n\nexport function dilation2D(args: {\n  inputs: Dilation2DInputs,\n  attrs: Dilation2DAttrs,\n  backend: MathBackendWebGL\n}) {\n  const {inputs, backend, attrs} = args;\n  const {x, filter} = inputs;\n  const {strides, pad, dilations} = attrs;\n\n  const convInfo = backend_util.computeDilation2DInfo(\n      x.shape as [number, number, number, number],\n      filter.shape as [number, number, number], strides, pad,\n      'NHWC' /* dataFormat */, dilations);\n  let out: TensorInfo;\n\n  const program = new Dilation2DProgram(convInfo);\n  out = backend.runWebGLProgram(program, [x, filter], 'float32');\n\n  const outReshaped =\n      reshape({inputs: {x: out}, backend, attrs: {shape: convInfo.outShape}});\n  backend.disposeIntermediateTensorInfo(out);\n\n  return outReshaped;\n}\n\nexport const dilation2DConfig: KernelConfig = {\n  kernelName: Dilation2D,\n  backendName: 'webgl',\n  kernelFunc: dilation2D as {} as KernelFunc,\n};\n","/**\n * @license\n * Copyright 2021 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {backend_util, Einsum, EinsumAttrs, EinsumInputs, KernelConfig, KernelFunc, Tensor, TensorInfo, util} from '@tensorflow/tfjs-core';\n\nimport {MathBackendWebGL} from '../backend_webgl';\n\nimport {multiply} from './Multiply';\nimport {reshape} from './Reshape';\nimport {sum} from './Sum';\nimport {transpose} from './Transpose';\n\nexport function einsum(\n    args:\n        {inputs: EinsumInputs, backend: MathBackendWebGL, attrs: EinsumAttrs}):\n    TensorInfo {\n  const {inputs, backend, attrs} = args;\n  const {equation} = attrs;\n  const tensors = inputs as Tensor[];\n\n  const {allDims, summedDims, idDims} =\n      backend_util.decodeEinsumEquation(equation, tensors.length);\n  backend_util.checkEinsumDimSizes(allDims.length, idDims, tensors);\n  const {path, steps} = backend_util.getEinsumComputePath(summedDims, idDims);\n\n  const nSteps = steps.length;\n  let out: TensorInfo|null = null;\n  let numDimsRemaining = allDims.length;\n  const tensorsToDispose: TensorInfo[] = [];\n  for (let i = 0; i < nSteps; ++i) {\n    for (const idTerm of steps[i]) {\n      const {permutationIndices: perm, expandDims: dimsToExpand} =\n          backend_util.getEinsumPermutation(numDimsRemaining, idDims[idTerm]);\n      let x: TensorInfo;\n      if (backend_util.isIdentityPermutation(perm)) {\n        x = tensors[idTerm];\n      } else {\n        x = transpose({inputs: {x: tensors[idTerm]}, backend, attrs: {perm}});\n        tensorsToDispose.push(x);\n      }\n      const targetShape: number[] = x.shape.slice();\n      for (let k = 0; k < dimsToExpand.length; ++k) {\n        targetShape.splice(dimsToExpand[k], 0, 1);\n      }\n\n      if (!util.arraysEqual(x.shape, targetShape)) {\n        x = reshape({inputs: {x}, backend, attrs: {shape: targetShape}});\n        tensorsToDispose.push(x);\n      }\n      if (out === null) {\n        out = x;\n      } else {\n        // tslint:disable-next-line: no-unnecessary-type-assertion\n        out = multiply({inputs: {a: x, b: out}, backend}) as TensorInfo;\n        tensorsToDispose.push(out);\n      }\n    }\n    if (i < nSteps - 1) {\n      if (path[i] >= 0) {\n        out = sum({\n          inputs: {x: out},\n          backend,\n          attrs: {\n            axis: path[i] - (allDims.length - numDimsRemaining),\n            keepDims: false\n          }\n        });\n        tensorsToDispose.push(out);\n      }\n      numDimsRemaining--;\n    }\n  }\n\n  // Clean up intermediate tensors.\n  for (const tensorInfo of tensorsToDispose) {\n    if (tensorInfo === out) {\n      continue;\n    }\n    backend.disposeIntermediateTensorInfo(tensorInfo);\n  }\n\n  return out;\n}\n\nexport const einsumConfig: KernelConfig = {\n  kernelName: Einsum,\n  backendName: 'webgl',\n  kernelFunc: einsum as {} as KernelFunc\n};\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {Elu, KernelConfig, KernelFunc} from '@tensorflow/tfjs-core';\nimport {unaryKernelFunc} from '../kernel_utils/kernel_funcs_utils';\n\nconst ELU = `return (x >= 0.0) ? x : (exp(x) - 1.0);`;\n\nconst ELU_PACKED = `\n  vec4 result;\n\n  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);\n  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);\n  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);\n  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);\n\n  return result;\n`;\n\nconst elu = unaryKernelFunc({opSnippet: ELU, packedOpSnippet: ELU_PACKED});\n\nexport const eluConfig: KernelConfig = {\n  kernelName: Elu,\n  backendName: 'webgl',\n  kernelFunc: elu as {} as KernelFunc\n};\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {EluGrad, EluGradInputs, env, KernelConfig, KernelFunc, TensorInfo} from '@tensorflow/tfjs-core';\n\nimport {MathBackendWebGL} from '../backend_webgl';\nimport {BinaryOpProgram} from '../binaryop_gpu';\nimport {BinaryOpPackedProgram} from '../binaryop_packed_gpu';\n\nconst ELU_DER = `return (b >= 1.0) ? a : a * (b + 1.0);`;\nconst ELU_DER_PACKED = `\n  vec4 bGTEZero = vec4(greaterThanEqual(b, vec4(0.)));\n  return (bGTEZero * a) + ((vec4(1.0) - bGTEZero) * (a * (b + vec4(1.0))));\n`;\n\nexport const eluGrad =\n    (args: {inputs: EluGradInputs, backend: MathBackendWebGL}): TensorInfo => {\n      const {inputs, backend} = args;\n      const {dy, y} = inputs;\n\n      const program = env().getBool('WEBGL_PACK_BINARY_OPERATIONS') ?\n          new BinaryOpPackedProgram(ELU_DER_PACKED, dy.shape, y.shape) :\n          new BinaryOpProgram(ELU_DER, dy.shape, y.shape);\n      return backend.runWebGLProgram(program, [dy, y], dy.dtype);\n    };\n\nexport const eluGradConfig: KernelConfig = {\n  kernelName: EluGrad,\n  backendName: 'webgl',\n  kernelFunc: eluGrad as {} as KernelFunc\n};\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {Equal, KernelConfig, KernelFunc} from '@tensorflow/tfjs-core';\nimport {binaryKernelFunc} from '../kernel_utils/kernel_funcs_utils';\nimport {equalImplCPU} from '../kernel_utils/shared';\nconst PACKED_EQUAL = `\n  return vec4(equal(a, b));\n`;\n\nconst EQUAL = `return float(a == b);`;\n\nexport const equal = binaryKernelFunc({\n  opSnippet: EQUAL,\n  packedOpSnippet: PACKED_EQUAL,\n  dtype: 'bool',\n  cpuKernelImpl: equalImplCPU,\n});\n\nexport const equalConfig: KernelConfig = {\n  kernelName: Equal,\n  backendName: 'webgl',\n  kernelFunc: equal as {} as KernelFunc\n};\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {backend_util, Erf, KernelConfig} from '@tensorflow/tfjs-core';\n\nimport {unaryKernelFunc} from '../kernel_utils/kernel_funcs_utils';\n\nconst ERF = `\n  // Error function is calculated approximately with elementary function.\n  // See \"Handbook of Mathematical Functions with Formulas,\n  // Graphs, and Mathematical Tables\", Abramowitz and Stegun.\n  float p = ${backend_util.ERF_P};\n  float a1 = ${backend_util.ERF_A1};\n  float a2 = ${backend_util.ERF_A2};\n  float a3 = ${backend_util.ERF_A3};\n  float a4 = ${backend_util.ERF_A4};\n  float a5 = ${backend_util.ERF_A5};\n\n  float sign = sign(x);\n  x = abs(x);\n  float t = 1.0 / (1.0 + p * x);\n  return sign * (1.0 - (((((a5*t + a4)*t) + a3)*t + a2)*t + a1)*t*exp(-x*x));\n`;\n\nexport const erf = unaryKernelFunc({opSnippet: ERF});\n\nexport const erfConfig: KernelConfig = {\n  kernelName: Erf,\n  backendName: 'webgl',\n  kernelFunc: erf,\n};\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {Exp, KernelConfig, KernelFunc} from '@tensorflow/tfjs-core';\n\nimport {CHECK_NAN_SNIPPET_UNARY, unaryKernelFunc} from '../kernel_utils/kernel_funcs_utils';\nimport {expImplCPU} from '../kernel_utils/shared';\n\nexport const EXP = CHECK_NAN_SNIPPET_UNARY + `\n  return exp(x);\n`;\n\nconst EXP_PACKED = `\n  vec4 result = exp(x);\n  bvec4 isNaN = isnan(x);\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n`;\n\nexport const exp = unaryKernelFunc({\n  opSnippet: EXP,\n  packedOpSnippet: EXP_PACKED,\n  cpuKernelImpl: expImplCPU,\n  dtype: 'float32',\n});\n\nexport const expConfig: KernelConfig = {\n  kernelName: Exp,\n  backendName: 'webgl',\n  kernelFunc: exp as {} as KernelFunc\n};\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the License);\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an AS IS BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {ExpandDims, ExpandDimsAttrs, ExpandDimsInputs, KernelConfig, KernelFunc, TensorInfo, util} from '@tensorflow/tfjs-core';\n\nimport {MathBackendWebGL} from '../backend_webgl';\nimport {reshape} from './Reshape';\n\nexport function expandDims(args: {\n  inputs: ExpandDimsInputs,\n  attrs: ExpandDimsAttrs,\n  backend: MathBackendWebGL\n}): TensorInfo {\n  const {inputs, attrs, backend} = args;\n  const {dim} = attrs;\n  const {input} = inputs;\n\n  const inputRank = input.shape.length;\n  const newShape = input.shape.slice();\n  let $dim = dim;\n  if (dim < 0) {\n    // Negative value is counted from the tail of rank.\n    util.assert(\n        -(inputRank + 1) <= dim,\n        () => `Axis must be in the interval [${- (inputRank + 1)}, ${\n            inputRank}]`);\n    $dim = inputRank + dim + 1;\n  }\n  newShape.splice($dim, 0, 1);\n\n  return reshape({inputs: {x: input}, backend, attrs: {shape: newShape}});\n}\n\nexport const expandDimsConfig: KernelConfig = {\n  kernelName: ExpandDims,\n  backendName: 'webgl',\n  kernelFunc: expandDims as {} as KernelFunc,\n};\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {Expm1, KernelConfig, KernelFunc} from '@tensorflow/tfjs-core';\nimport {unaryKernelFunc} from '../kernel_utils/kernel_funcs_utils';\nimport {expm1ImplCPU} from '../kernel_utils/shared';\n\nconst EXPM1 = `return exp(x) - 1.0;`;\n\nexport const expm1 = unaryKernelFunc(\n    {opSnippet: EXPM1, packedOpSnippet: EXPM1, cpuKernelImpl: expm1ImplCPU});\n\nexport const expm1Config: KernelConfig = {\n  kernelName: Expm1,\n  backendName: 'webgl',\n  kernelFunc: expm1 as {} as KernelFunc\n};\n","/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {GPGPUProgram} from './gpgpu_math';\n\nexport class FFTProgram implements GPGPUProgram {\n  variableNames = ['real', 'imag'];\n  outputShape: number[];\n  userCode: string;\n\n  constructor(\n      component: 'real'|'imag', inputShape: [number, number],\n      inverse: boolean) {\n    const innerDim = inputShape[1];\n    this.outputShape = inputShape;\n\n    const exponentMultiplierSnippet =\n        inverse ? `2.0 * ${Math.PI}` : `-2.0 * ${Math.PI}`;\n    const resultDenominator = inverse ? `${innerDim}.0` : '1.0';\n\n    let opString: string;\n    if (component === 'real') {\n      opString = 'return real * expR - imag * expI;';\n    } else if (component === 'imag') {\n      opString = 'return real * expI + imag * expR;';\n    } else {\n      throw new Error(\n          `FFT component must be either \"real\" or \"imag\", got ${component}.`);\n    }\n\n    this.userCode = `\n      const float exponentMultiplier = ${exponentMultiplierSnippet};\n\n      float unaryOpComplex(float real, float expR, float imag, float expI) {\n        ${opString}\n      }\n\n      float mulMatDFT(int batch, int index) {\n        float indexRatio = float(index) / float(${innerDim});\n        float exponentMultiplierTimesIndexRatio =\n            exponentMultiplier * indexRatio;\n\n        float result = 0.0;\n\n        for (int i = 0; i < ${innerDim}; i++) {\n          // x = (-2|2 * PI / N) * index * i;\n          float x = exponentMultiplierTimesIndexRatio * float(i);\n          float expR = cos(x);\n          float expI = sin(x);\n          float real = getReal(batch, i);\n          float imag = getImag(batch, i);\n\n          result +=\n              unaryOpComplex(real, expR, imag, expI) / ${resultDenominator};\n        }\n\n        return result;\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        setOutput(mulMatDFT(coords[0], coords[1]));\n      }\n    `;\n  }\n}\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {TensorInfo, util} from '@tensorflow/tfjs-core';\n\nimport {MathBackendWebGL} from '../backend_webgl';\nimport {FFTProgram} from '../fft_gpu';\n\nimport {complex} from './Complex';\nimport {reshape} from './Reshape';\n\nexport function fftImpl(\n    x: TensorInfo, inverse: boolean, backend: MathBackendWebGL): TensorInfo {\n  const xData = backend.texData.get(x.dataId);\n\n  const inputSize = util.sizeFromShape(x.shape);\n  // Collapse all outer dimensions to a single batch dimension.\n  const innerDimensionSize = x.shape[x.shape.length - 1];\n  const batch = inputSize / innerDimensionSize;\n\n  const input2D = reshape(\n      {inputs: {x}, backend, attrs: {shape: [batch, innerDimensionSize]}});\n\n  const xShape = input2D.shape as [number, number];\n  const realProgram = new FFTProgram('real', xShape, inverse);\n  const imagProgram = new FFTProgram('imag', xShape, inverse);\n\n  const inputs = [\n    {\n      dataId: xData.complexTensorInfos.real.dataId,\n      dtype: xData.complexTensorInfos.real.dtype,\n      shape: xShape\n    },\n    {\n      dataId: xData.complexTensorInfos.imag.dataId,\n      dtype: xData.complexTensorInfos.imag.dtype,\n      shape: xShape\n    }\n  ];\n\n  const realPart = backend.runWebGLProgram(realProgram, inputs, 'float32');\n  const imagPart = backend.runWebGLProgram(imagProgram, inputs, 'float32');\n\n  const complexOutput =\n      complex({inputs: {real: realPart, imag: imagPart}, backend});\n\n  backend.disposeIntermediateTensorInfo(realPart);\n  backend.disposeIntermediateTensorInfo(imagPart);\n\n  const complexOutputReshaped =\n      reshape({inputs: {x: complexOutput}, backend, attrs: {shape: x.shape}});\n\n  backend.disposeIntermediateTensorInfo(input2D);\n  backend.disposeIntermediateTensorInfo(complexOutput);\n  return complexOutputReshaped;\n}\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {FFT, FFTInputs, KernelConfig, TensorInfo} from '@tensorflow/tfjs-core';\n\nimport {MathBackendWebGL} from '../backend_webgl';\n\nimport {fftImpl} from './FFT_impl';\n\nexport function fft(args: {inputs: FFTInputs, backend: MathBackendWebGL}):\n    TensorInfo {\n  const {inputs, backend} = args;\n  const {input} = inputs;\n\n  return fftImpl(input, false /* inverse */, backend);\n}\n\nexport const fftConfig: KernelConfig = {\n  kernelName: FFT,\n  backendName: 'webgl',\n  kernelFunc: fft\n};\n","/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {GPGPUProgram} from './gpgpu_math';\nimport {UniformType} from './shader_compiler';\n\nexport class FillProgram implements GPGPUProgram {\n  variableNames: string[];\n  outputShape: number[] = [];\n  userCode: string;\n  customUniforms = [{name: 'value', type: 'float' as UniformType}];\n\n  constructor(shape: number[], value: number) {\n    this.variableNames = ['x'];\n    this.outputShape = shape;\n\n    this.userCode = `\n      void main() {\n        // Input can be obtained from uniform value.\n        setOutput(value);\n      }\n    `;\n  }\n}\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {Fill, FillAttrs, KernelConfig, KernelFunc, TensorInfo, util} from '@tensorflow/tfjs-core';\n\nimport {MathBackendWebGL} from '../backend_webgl';\nimport {FillProgram} from '../fill_gpu';\n\nexport function fill(args: {backend: MathBackendWebGL, attrs: FillAttrs}):\n    TensorInfo {\n  const {backend, attrs} = args;\n  const {shape, value} = attrs;\n  let {dtype} = attrs;\n\n  dtype = dtype || util.inferDtype(value);\n\n  if (dtype === 'string') {\n    // String type should be handled in CPU memory.\n    const values = util.getArrayFromDType(dtype, util.sizeFromShape(shape));\n    values.fill(value as string);\n    return backend.makeTensorInfo(shape, dtype, values);\n  } else {\n    const program = new FillProgram(shape, value as number);\n    const customValues = [[value as number]];\n    return backend.runWebGLProgram(program, [], dtype, customValues);\n  }\n}\n\nexport const fillConfig: KernelConfig = {\n  kernelName: Fill,\n  backendName: 'webgl',\n  kernelFunc: fill as {} as KernelFunc\n};\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {GPGPUProgram} from './gpgpu_math';\n\nexport class FlipLeftRightProgram implements GPGPUProgram {\n  variableNames = ['Image'];\n  outputShape: number[] = [];\n  userCode: string;\n\n  constructor(imageShape: [number, number, number, number]) {\n    const imageWidth = imageShape[2];\n    this.outputShape = imageShape;\n\n    this.userCode = `\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int x = coords[2];\n\n          int coordX = ${imageWidth} - x - 1;\n          float outputValue;\n          if(coordX >= 0 && coordX < ${imageWidth}) {\n            outputValue = getImage(coords[0], coords[1], coordX, coords[3]);\n          } else {\n            outputValue = getImage(coords[0], coords[1], coords[2], coords[3]);\n          }\n          setOutput(outputValue);\n        }\n    `;\n  }\n}\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {KernelConfig, Tensor4D} from '@tensorflow/tfjs-core';\nimport {FlipLeftRight, FlipLeftRightInputs} from '@tensorflow/tfjs-core';\n\nimport {MathBackendWebGL} from '../backend_webgl';\nimport {FlipLeftRightProgram} from '../flip_left_right_gpu';\n\nexport const flipLeftRightConfig: KernelConfig = {\n  kernelName: FlipLeftRight,\n  backendName: 'webgl',\n  kernelFunc: ({inputs, backend}) => {\n    const {image} = inputs as FlipLeftRightInputs;\n    const webglBackend = backend as MathBackendWebGL;\n\n    const program = new FlipLeftRightProgram((image as Tensor4D).shape);\n    const output = webglBackend.runWebGLProgram(program, [image], image.dtype);\n    return output;\n  }\n};\n","\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {Floor, KernelConfig} from '@tensorflow/tfjs-core';\nimport {unaryKernelFunc} from '../kernel_utils/kernel_funcs_utils';\nimport {floorImplCPU} from '../kernel_utils/shared';\n\nconst FLOOR = `return floor(x);`;\n\nexport const floor = unaryKernelFunc(\n    {opSnippet: FLOOR, packedOpSnippet: FLOOR, cpuKernelImpl: floorImplCPU});\n\nexport const floorConfig: KernelConfig = {\n  kernelName: Floor,\n  backendName: 'webgl',\n  kernelFunc: floor,\n};\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {FloorDiv, KernelConfig, KernelFunc} from '@tensorflow/tfjs-core';\n\nimport {binaryKernelFunc} from '../kernel_utils/kernel_funcs_utils';\n\n// We use native integer division to deal with floating point imprecision. Since\n// we implement floor division and glsl implements truncated division, we\n// correct for this by subtracting 1 from result when the result is negative and\n// there is a remainder.\nconst INT_DIV = `\n  float s = sign(a) * sign(b);\n  int ia = round(a);\n  int ib = round(b);\n  if (ib != 0) {\n    // Windows (D3D) wants guaranteed non-zero int division at compile-time.\n    return float(idiv(ia, ib, s));\n  } else {\n    return NAN;\n  }\n`;\n\nconst INT_DIV_PACKED = `\n  ivec4 ia = round(a);\n  ivec4 ib = round(b);\n  bvec4 cond = notEqual(ib, ivec4(0));\n  ivec4 result = ivec4(0);\n  vec4 s = sign(a) * sign(b);\n\n  // Windows (D3D) wants guaranteed non-zero int division at compile-time.\n  if (cond[0]) {\n    result[0] = idiv(ia[0], ib[0], s[0]);\n  }\n  if (cond[1]) {\n    result[1] = idiv(ia[1], ib[1], s[1]);\n  }\n  if (cond[2]) {\n    result[2] = idiv(ia[2], ib[2], s[2]);\n  }\n  if (cond[3]) {\n    result[3] = idiv(ia[3], ib[3], s[3]);\n  }\n  return vec4(result);\n`;\n\nexport const floorDiv = binaryKernelFunc(\n    {opSnippet: INT_DIV, packedOpSnippet: INT_DIV_PACKED, dtype: 'int32'});\n\nexport const floorDivConfig: KernelConfig = {\n  kernelName: FloorDiv,\n  backendName: 'webgl',\n  kernelFunc: floorDiv as {} as KernelFunc\n};\n","/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {getGlslDifferences} from '../../glsl_version';\nimport {GPGPUProgram} from '../../gpgpu_math';\n\nexport class FromPixelsProgram implements GPGPUProgram {\n  variableNames = ['A'];\n  userCode: string;\n  outputShape: number[];\n\n  constructor(outputShape: number[]) {\n    const glsl = getGlslDifferences();\n    const [height, width, ] = outputShape;\n    this.outputShape = outputShape;\n    this.userCode = `\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int texR = coords[0];\n        int texC = coords[1];\n        int depth = coords[2];\n        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${width}.0, ${height}.0);\n\n        vec4 values = ${glsl.texture2D}(A, uv);\n        float value;\n        if (depth == 0) {\n          value = values.r;\n        } else if (depth == 1) {\n          value = values.g;\n        } else if (depth == 2) {\n          value = values.b;\n        } else if (depth == 3) {\n          value = values.a;\n        }\n\n        setOutput(floor(value * 255.0 + 0.5));\n      }\n    `;\n  }\n}\n","/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {getGlslDifferences} from '../../glsl_version';\nimport {GPGPUProgram} from '../../gpgpu_math';\n\nexport class FromPixelsPackedProgram implements GPGPUProgram {\n  variableNames = ['A'];\n  userCode: string;\n  outputShape: number[];\n  packedInputs = false;\n  packedOutput = true;\n\n  constructor(outputShape: number[]) {\n    const glsl = getGlslDifferences();\n    const [height, width, ] = outputShape;\n    this.outputShape = outputShape;\n    this.userCode = `\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int texR = coords[0];\n        int texC = coords[1];\n        int depth = coords[2];\n\n        vec4 result = vec4(0.);\n\n        for(int row=0; row<=1; row++) {\n          for(int col=0; col<=1; col++) {\n            texC = coords[1] + row;\n            depth = coords[2] + col;\n\n            vec2 uv = (vec2(texC, texR) + halfCR) /\n                       vec2(${width}.0, ${height}.0);\n            vec4 values = ${glsl.texture2D}(A, uv);\n            float value;\n            if (depth == 0) {\n              value = values.r;\n            } else if (depth == 1) {\n              value = values.g;\n            } else if (depth == 2) {\n              value = values.b;\n            } else if (depth == 3) {\n              value = values.a;\n            }\n\n            result[row * 2 + col] = floor(value * 255.0 + 0.5);\n          }\n        }\n\n        ${glsl.output} = result;\n      }\n    `;\n  }\n}\n","/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {env, KernelConfig, KernelFunc, TensorInfo} from '@tensorflow/tfjs-core';\nimport {FromPixels, FromPixelsAttrs, FromPixelsInputs} from '@tensorflow/tfjs-core';\n\nimport {MathBackendWebGL} from '../backend_webgl';\nimport {TextureUsage} from '../tex_util';\n\nimport {FromPixelsProgram} from './FromPixels_utils/from_pixels_gpu';\nimport {FromPixelsPackedProgram} from './FromPixels_utils/from_pixels_packed_gpu';\n\nexport const fromPixelsConfig: KernelConfig = {\n  kernelName: FromPixels,\n  backendName: 'webgl',\n  kernelFunc: fromPixels as {} as KernelFunc,\n};\n\nlet fromPixels2DContext: CanvasRenderingContext2D;\nlet willReadFrequently = env().getBool('CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU');\n\nfunction fromPixels(args: {\n  inputs: FromPixelsInputs,\n  backend: MathBackendWebGL,\n  attrs: FromPixelsAttrs\n}): TensorInfo {\n  const {inputs, backend, attrs} = args;\n  let {pixels} = inputs;\n  const {numChannels} = attrs;\n\n  const isVideo = typeof (HTMLVideoElement) !== 'undefined' &&\n      pixels instanceof HTMLVideoElement;\n  const isImage = typeof (HTMLImageElement) !== 'undefined' &&\n      pixels instanceof HTMLImageElement;\n  const [width, height] = isVideo ?\n      [\n        (pixels as HTMLVideoElement).videoWidth,\n        (pixels as HTMLVideoElement).videoHeight\n      ] :\n      [pixels.width, pixels.height];\n\n  const texShape: [number, number] = [height, width];\n  const outShape = [height, width, numChannels];\n\n  if (isImage || isVideo) {\n    const newWillReadFrequently =\n        env().getBool('CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU');\n    if (fromPixels2DContext == null ||\n        newWillReadFrequently !== willReadFrequently) {\n      willReadFrequently = newWillReadFrequently;\n      fromPixels2DContext =\n          document.createElement('canvas').getContext(\n              '2d', {willReadFrequently});\n    }\n\n    fromPixels2DContext.canvas.width = width;\n    fromPixels2DContext.canvas.height = height;\n    fromPixels2DContext.drawImage(\n        pixels as HTMLVideoElement | HTMLImageElement | ImageBitmap, 0, 0,\n        width, height);\n    pixels = fromPixels2DContext.canvas;\n  }\n\n  const tempPixelHandle = backend.makeTensorInfo(texShape, 'int32');\n  // This is a byte texture with pixels.\n  backend.texData.get(tempPixelHandle.dataId).usage = TextureUsage.PIXELS;\n  backend.gpgpu.uploadPixelDataToTexture(\n      backend.getTexture(tempPixelHandle.dataId), pixels as ImageData);\n  const program = env().getBool('WEBGL_PACK') ?\n      new FromPixelsPackedProgram(outShape) :\n      new FromPixelsProgram(outShape);\n  const res = backend.runWebGLProgram(program, [tempPixelHandle], 'int32');\n  backend.disposeData(tempPixelHandle.dataId);\n  return res;\n}\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {backend_util, env, FusedConv2D, FusedConv2DAttrs, FusedConv2DInputs, KernelConfig, KernelFunc, TensorInfo, util} from '@tensorflow/tfjs-core';\n\nimport {MathBackendWebGL} from '../backend_webgl';\nimport {Conv2DProgram} from '../conv_gpu';\nimport {Conv2DPackedProgram} from '../conv_packed_gpu';\nimport {mapActivationToShaderProgram} from '../kernel_utils/kernel_funcs_utils';\n\nimport {conv2dByMatMul, conv2dWithIm2Row} from './Conv2D_impl';\nimport {reshape} from './Reshape';\n\nexport function fusedConv2d(args: {\n  inputs: FusedConv2DInputs,\n  attrs: FusedConv2DAttrs,\n  backend: MathBackendWebGL\n}) {\n  const {inputs, backend, attrs} = args;\n  const {x, filter, bias, preluActivationWeights} = inputs;\n  const {\n    strides,\n    pad,\n    dataFormat,\n    dilations,\n    dimRoundingMode,\n    activation,\n    leakyreluAlpha\n  } = attrs;\n\n  const $dataFormat = backend_util.convertConv2DDataFormat(dataFormat);\n  const convInfo = backend_util.computeConv2DInfo(\n      x.shape as [number, number, number, number],\n      filter.shape as [number, number, number, number], strides, dilations, pad,\n      dimRoundingMode, false /* depthwise */, $dataFormat);\n  let out: TensorInfo;\n  const intermediates: TensorInfo[] = [];\n\n  const hasBias = bias != null;\n  const hasPreluActivationWeights = preluActivationWeights != null;\n  const hasLeakyreluAlpha = activation === 'leakyrelu';\n\n  const prepareInputs = (): TensorInfo[] => {\n    const inputs: TensorInfo[] = [x, filter];\n\n    // If the input is a 1-D tensor, align it with the channels.\n    //\n    // For fusedConv2d, the inputs (x, W, bias, preluActivationWeights) are\n    // supposed to be aligned with the dataFormat. The 4-D tensor inputs or\n    // scalar inputs are originally aligned, but the 1-D tensor inputs are\n    // supposed to be aligned with the channels (only bias and PReLU activation\n    // weights could be a 1-D tensor).\n    const alignInputWithDataFormat =\n        (input: TensorInfo, dataFormat: 'NHWC'|'NCHW'): TensorInfo => {\n          if (dataFormat === 'NCHW' && input.shape.length === 1 &&\n              input.shape[0] !== 1) {\n            const alignedInput = reshape({\n              inputs: {x: input},\n              backend,\n              attrs: {shape: [input.shape[0], 1, 1]}\n            });\n            intermediates.push(alignedInput);\n            return alignedInput;\n          }\n          return input;\n        };\n\n    if (hasBias) {\n      inputs.push(alignInputWithDataFormat(bias, dataFormat));\n    }\n\n    if (hasPreluActivationWeights) {\n      inputs.push(alignInputWithDataFormat(preluActivationWeights, dataFormat));\n    }\n\n    if (hasLeakyreluAlpha) {\n      const $leakyreluAlpha = backend.makeTensorInfo(\n          [], 'float32',\n          util.createScalarValue(leakyreluAlpha as {} as 'float32', 'float32'));\n      inputs.push($leakyreluAlpha);\n      intermediates.push($leakyreluAlpha);\n    }\n    return inputs;\n  };\n\n  if (convInfo.filterHeight === 1 && convInfo.filterWidth === 1 &&\n      convInfo.dilationHeight === 1 && convInfo.dilationWidth === 1 &&\n      convInfo.strideHeight === 1 && convInfo.strideWidth === 1 &&\n      (convInfo.padInfo.type === 'SAME' || convInfo.padInfo.type === 'VALID')) {\n    out = conv2dByMatMul({\n      x,\n      filter,\n      convInfo,\n      backend,\n      bias,\n      activation,\n      preluActivationWeights,\n      leakyreluAlpha\n    });\n  } else if (convInfo.strideWidth <= 2 && $dataFormat === 'channelsLast'\n    && env().getBool('WEBGL_EXP_CONV')\n    ) {\n      const fusedActivation =\n          activation ? mapActivationToShaderProgram(activation, true) : null;\n    const program = new Conv2DPackedProgram(\n      convInfo, hasBias, fusedActivation, hasPreluActivationWeights,\n      hasLeakyreluAlpha);\n    const customValues = [\n      [convInfo.padInfo.top, convInfo.padInfo.left],\n      [convInfo.strideHeight, convInfo.strideWidth],\n      [convInfo.dilationHeight, convInfo.dilationWidth],\n      [convInfo.inHeight, convInfo.inWidth]\n    ];\n    const inputs = prepareInputs();\n    out = backend.runWebGLProgram(program, inputs, 'float32', customValues);\n  } else if (env().getBool('WEBGL_CONV_IM2COL')) {\n    out = conv2dWithIm2Row({\n      x,\n      filter,\n      convInfo,\n      backend,\n      bias,\n      activation,\n      preluActivationWeights,\n      leakyreluAlpha\n    });\n  } else {\n    const fusedActivation =\n        activation ? mapActivationToShaderProgram(activation, false) : null;\n    const program = new Conv2DProgram(\n        convInfo, hasBias, fusedActivation, hasPreluActivationWeights,\n        hasLeakyreluAlpha);\n\n    const inputs = prepareInputs();\n    out = backend.runWebGLProgram(program, inputs, 'float32');\n  }\n\n  const outReshaped =\n      reshape({inputs: {x: out}, backend, attrs: {shape: convInfo.outShape}});\n\n  intermediates.push(out);\n  intermediates.forEach(t => backend.disposeIntermediateTensorInfo(t));\n\n  return outReshaped;\n}\n\nexport const fusedConv2DConfig: KernelConfig = {\n  kernelName: FusedConv2D,\n  backendName: 'webgl',\n  kernelFunc: fusedConv2d as {} as KernelFunc,\n};\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {backend_util, env, FusedDepthwiseConv2D, FusedDepthwiseConv2DAttrs, FusedDepthwiseConv2DInputs, KernelConfig, KernelFunc, TensorInfo, util} from '@tensorflow/tfjs-core';\n\nimport {MathBackendWebGL} from '../backend_webgl';\nimport {DepthwiseConv2DProgram} from '../conv_gpu_depthwise';\nimport {DepthwiseConvPacked2DProgram} from '../conv_packed_gpu_depthwise';\nimport {mapActivationToShaderProgram} from '../kernel_utils/kernel_funcs_utils';\n\nexport function fusedDepthwiseConv2D(args: {\n  inputs: FusedDepthwiseConv2DInputs,\n  attrs: FusedDepthwiseConv2DAttrs,\n  backend: MathBackendWebGL\n}) {\n  const {inputs, backend, attrs} = args;\n  const {x, filter, bias, preluActivationWeights} = inputs;\n  const {strides, pad, dilations, dimRoundingMode, activation, leakyreluAlpha} =\n      attrs;\n\n  const intermediates: TensorInfo[] = [];\n\n  let $dilations = dilations;\n  if ($dilations == null) {\n    $dilations = [1, 1];\n  }\n\n  util.assert(\n      backend_util.eitherStridesOrDilationsAreOne(strides, $dilations),\n      () => 'Error in depthwiseConv2d: Either strides or dilations must be ' +\n          `1. Got strides ${strides} and dilations '${$dilations}'`);\n\n  const convInfo = backend_util.computeConv2DInfo(\n      x.shape as [number, number, number, number],\n      filter.shape as [number, number, number, number], strides, $dilations,\n      pad, dimRoundingMode, true /* depthwise */);\n\n  const shouldPackDepthwiseConv = env().getBool('WEBGL_PACK_DEPTHWISECONV') &&\n      convInfo.strideWidth <= 2 &&\n      convInfo.outChannels / convInfo.inChannels === 1;\n  const fusedActivation = activation ?\n      mapActivationToShaderProgram(activation, shouldPackDepthwiseConv) :\n      null;\n  const programInputs: TensorInfo[] = [x, filter];\n\n  const hasBias = bias != null;\n  const hasPreluActivationWeights = preluActivationWeights != null;\n  const hasLeakyreluAlpha = activation === 'leakyrelu';\n\n  if (hasBias) {\n    programInputs.push(bias);\n  }\n  if (hasPreluActivationWeights) {\n    programInputs.push(preluActivationWeights);\n  }\n  if (hasLeakyreluAlpha) {\n    const $leakyreluAlpha = backend.makeTensorInfo(\n        [], 'float32',\n        util.createScalarValue(leakyreluAlpha as {} as 'float32', 'float32'));\n    programInputs.push($leakyreluAlpha);\n    intermediates.push($leakyreluAlpha);\n  }\n\n  let program: DepthwiseConv2DProgram|DepthwiseConvPacked2DProgram;\n  if (shouldPackDepthwiseConv) {\n    program = new DepthwiseConvPacked2DProgram(\n        convInfo, hasBias, fusedActivation, hasPreluActivationWeights,\n        hasLeakyreluAlpha);\n  } else {\n    program = new DepthwiseConv2DProgram(\n        convInfo, hasBias, fusedActivation, hasPreluActivationWeights,\n        hasLeakyreluAlpha);\n  }\n  const customValues = [\n    [convInfo.padInfo.top, convInfo.padInfo.left],\n    [convInfo.strideHeight, convInfo.strideWidth],\n    [convInfo.dilationHeight, convInfo.dilationWidth],\n    [convInfo.inHeight, convInfo.inWidth]\n  ];\n  const result =\n      backend.runWebGLProgram(program, programInputs, 'float32', customValues);\n\n  intermediates.forEach(t => backend.disposeIntermediateTensorInfo(t));\n\n  return result;\n}\n\nexport const fusedDepthwiseConv2DConfig: KernelConfig = {\n  kernelName: FusedDepthwiseConv2D,\n  backendName: 'webgl',\n  kernelFunc: fusedDepthwiseConv2D as {} as KernelFunc,\n};\n","/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport {GPGPUProgram} from './gpgpu_math';\nimport {getCoordsDataType} from './shader_compiler';\n\nexport class GatherNDProgram implements GPGPUProgram {\n  variableNames = ['x', 'indices'];\n  outputShape: number[];\n  userCode: string;\n  constructor(\n      private sliceDim: number, private strides: number[], shape: number[],\n      private paramsShape: number[]) {\n    this.outputShape = shape;\n    const dtype = getCoordsDataType(shape.length);\n\n    let mainLoop = `\n    int index;`;\n    for (let j = 0; j < this.sliceDim; j++) {\n      mainLoop += `\n          index = round(getIndices(coords[0], ${j}));\n          out_of_bounds = out_of_bounds || index < 0;\n          out_of_bounds = out_of_bounds || index >= ${this.paramsShape[j]};\n          flattenIndex += index * ${this.strides[j]};`;\n    }\n\n    this.userCode = `\n         void main() {\n          ${dtype} coords = getOutputCoords();\n          int flattenIndex = 0;\n          bool out_of_bounds = false;\n\n          ${mainLoop}\n\n          setOutput(out_of_bounds ? 0.0 : getX(flattenIndex, coords[1]));\n        }\n      `;\n  }\n}\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {backend_util, GatherNd, GatherNdInputs, KernelConfig, KernelFunc, Rank, TensorInfo, TypedArray, util} from '@tensorflow/tfjs-core';\n\nimport {MathBackendWebGL} from '../backend_webgl';\nimport {GatherNDProgram} from '../gather_nd_gpu';\nimport {gatherNdImplCPU} from '../kernel_utils/shared';\n\nimport {reshape} from './Reshape';\n\nexport function gatherNd(\n    args: {inputs: GatherNdInputs, backend: MathBackendWebGL}): TensorInfo {\n  const {inputs, backend} = args;\n  const {params, indices} = inputs;\n\n  const indicesShape = indices.shape;\n  const sliceRank = indicesShape[indicesShape.length - 1];\n  const paramsSize = util.sizeFromShape(params.shape);\n\n  const [resultShape, numSlices, sliceSize, strides] =\n      backend_util.prepareAndValidate(params, indices);\n\n  const flattenIndices = reshape(\n      {inputs: {x: indices}, backend, attrs: {shape: [numSlices, sliceRank]}});\n  const flattenX = reshape({\n    inputs: {x: params},\n    backend,\n    attrs: {shape: [(util.sizeFromShape(params.shape) / sliceSize), sliceSize]}\n  });\n\n  if (backend.shouldExecuteOnCPU([params, indices]) ||\n      params.dtype === 'string') {\n    const indicesData = backend.readSync(indices.dataId) as TypedArray;\n    const paramsBuf = backend.bufferSync<Rank, 'float32'>(params);\n    const outValue = gatherNdImplCPU(\n        indicesData, paramsBuf, params.dtype, numSlices, sliceRank, sliceSize,\n        strides, params.shape, paramsSize);\n\n    return backend.makeTensorInfo(resultShape, params.dtype, outValue.values);\n  }\n  const program =\n      new GatherNDProgram(sliceRank, strides, [numSlices, sliceSize], \n        params.shape);\n  const res = backend.runWebGLProgram(\n      program, [flattenX, flattenIndices], flattenX.dtype);\n\n  const reshaped =\n      reshape({inputs: {x: res}, backend, attrs: {shape: resultShape}});\n\n  backend.disposeIntermediateTensorInfo(flattenIndices);\n  backend.disposeIntermediateTensorInfo(flattenX);\n  backend.disposeIntermediateTensorInfo(res);\n\n  return reshaped;\n}\n\nexport const gatherNdConfig: KernelConfig = {\n  kernelName: GatherNd,\n  backendName: 'webgl',\n  kernelFunc: gatherNd as {} as KernelFunc\n};\n","/**\n * @license\n * Copyright 2017 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {GPGPUProgram} from './gpgpu_math';\nimport {getCoordsDataType} from './shader_compiler';\n\nexport type GatherShape = [number, number, number, number];\n\nexport class GatherProgram implements GPGPUProgram {\n  variableNames = ['A', 'indices'];\n  outputShape: number[];\n  userCode: string;\n  rank: number;\n\n  constructor(aShape: GatherShape, outputShape: GatherShape) {\n    this.outputShape = outputShape;\n    this.rank = outputShape.length;\n    const dtype = getCoordsDataType(this.rank);\n    const sourceCoords = getSourceCoords(aShape, 2);\n\n    this.userCode = `\n      void main() {\n        ${dtype} resRC = getOutputCoords();\n        int index = int(getIndices(resRC.x, resRC.z));\n        float inBounds = (index >= 0) && (index < ${aShape[2]}) ? 1.0 : 0.0;\n        setOutput(inBounds * getA(${sourceCoords}));\n      }\n    `;\n  }\n}\n\n// The input and output are always flattened into rank 4 tensors.\nfunction getSourceCoords(aShape: GatherShape, axis: number): string {\n  const currentCoords = ['resRC.x', 'resRC.y', 'resRC.z', 'resRC.w'];\n\n  const sourceCoords = [];\n  for (let i = 0; i < aShape.length; i++) {\n    if (i === 2) {\n      sourceCoords.push('index');\n    } else {\n      sourceCoords.push(`${currentCoords[i]}`);\n    }\n  }\n  return sourceCoords.join();\n}\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {backend_util, GatherV2, GatherV2Attrs, GatherV2Inputs, KernelConfig, KernelFunc, TensorInfo, TypedArray, util, env} from '@tensorflow/tfjs-core';\n\nimport {MathBackendWebGL} from '../backend_webgl';\nimport {GatherProgram, GatherShape} from '../gather_gpu';\nimport {gatherV2ImplCPU} from '../kernel_utils/shared';\n\nimport {reshape} from './Reshape';\n\nexport function gatherV2(args: {\n  inputs: GatherV2Inputs,\n  backend: MathBackendWebGL,\n  attrs: GatherV2Attrs\n}): TensorInfo {\n  const {inputs, backend, attrs} = args;\n  const {x, indices} = inputs;\n  const {axis, batchDims} = attrs;\n\n  const parsedAxis = util.parseAxisParam(axis, x.shape)[0];\n  if (env().get('DEBUG')) {\n    // In debug mode, throw error when any index is out of bound.\n    // Otherwise, just fill out of bounds with zeroes.\n    const indicesVals = backend.readSync(indices.dataId) as TypedArray;\n    const axisDim = x.shape[parsedAxis];\n    for (let i = 0; i < indicesVals.length; ++i) {\n      const index = indicesVals[i];\n      util.assert(\n        index <= axisDim - 1 && index >= 0,\n        () =>\n          `GatherV2: the index value ${index} is not in [0, ${axisDim - 1}]`);\n    }\n  }\n\n  const shapeInfo = backend_util.segment_util.collectGatherOpShapeInfo(\n      x, indices, parsedAxis, batchDims);\n\n  const indicesSize = util.sizeFromShape(indices.shape);\n\n  const toDispose = [];\n\n  const flattenX = reshape({\n    inputs: {x},\n    backend,\n    attrs: {\n      shape: [\n        shapeInfo.batchSize, shapeInfo.outerSize, shapeInfo.dimSize,\n        shapeInfo.sliceSize\n      ]\n    }\n  });\n\n  const flattenIndex = reshape({\n    inputs: {x: indices},\n    backend,\n    attrs: {shape: [shapeInfo.batchSize, indicesSize / shapeInfo.batchSize]}\n  });\n\n  toDispose.push(flattenX);\n  toDispose.push(flattenIndex);\n\n  const flattenOutputShape = [\n    shapeInfo.batchSize, shapeInfo.outerSize, indicesSize / shapeInfo.batchSize,\n    shapeInfo.sliceSize\n  ];\n\n  if (backend.shouldExecuteOnCPU([x, indices]) || x.dtype === 'string') {\n    const indicesBuf = backend.bufferSync(flattenIndex);\n    const xBuf = backend.bufferSync(flattenX);\n    const outBuf = gatherV2ImplCPU(xBuf, indicesBuf, flattenOutputShape);\n\n    toDispose.forEach(t => backend.disposeIntermediateTensorInfo(t));\n\n    return backend.makeTensorInfo(\n        shapeInfo.outputShape, outBuf.dtype, outBuf.values as TypedArray);\n  }\n\n  const program = new GatherProgram(flattenX.shape as GatherShape,\n                                    flattenOutputShape as GatherShape);\n  const res = backend.runWebGLProgram(\n      program, [flattenX, flattenIndex], flattenX.dtype);\n  toDispose.push(res);\n\n  const reshaped = reshape(\n      {inputs: {x: res}, backend, attrs: {shape: shapeInfo.outputShape}});\n  toDispose.forEach(t => backend.disposeIntermediateTensorInfo(t));\n  return reshaped;\n}\n\nexport const gatherV2Config: KernelConfig = {\n  kernelName: GatherV2,\n  backendName: 'webgl',\n  kernelFunc: gatherV2 as {} as KernelFunc\n};\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {Greater, KernelConfig, KernelFunc} from '@tensorflow/tfjs-core';\n\nimport {binaryKernelFunc} from '../kernel_utils/kernel_funcs_utils';\nimport {greaterImplCPU} from '../kernel_utils/shared';\n\nconst GREATER = `return float(a > b);`;\nconst GREATER_PACKED = `\n  return vec4(greaterThan(a, b));\n`;\n\nexport const greater = binaryKernelFunc({\n  opSnippet: GREATER,\n  packedOpSnippet: GREATER_PACKED,\n  cpuKernelImpl: greaterImplCPU,\n  dtype: 'bool'\n});\n\nexport const greaterConfig: KernelConfig = {\n  kernelName: Greater,\n  backendName: 'webgl',\n  kernelFunc: greater as {} as KernelFunc\n};\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {GreaterEqual, KernelConfig, KernelFunc} from '@tensorflow/tfjs-core';\nimport {binaryKernelFunc} from '../kernel_utils/kernel_funcs_utils';\nimport {greaterEqualImplCPU} from '../kernel_utils/shared';\n\nconst GREATER_EQUAL = `return float(a >= b);`;\nconst GREATER_EQUAL_PACKED = `\n  return vec4(greaterThanEqual(a, b));\n`;\n\nexport const greaterEqual = binaryKernelFunc({\n  opSnippet: GREATER_EQUAL,\n  packedOpSnippet: GREATER_EQUAL_PACKED,\n  dtype: 'bool',\n  cpuKernelImpl: greaterEqualImplCPU\n});\n\nexport const greaterEqualConfig: KernelConfig = {\n  kernelName: GreaterEqual,\n  backendName: 'webgl',\n  kernelFunc: greaterEqual as {} as KernelFunc\n};\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {IFFT, IFFTInputs, KernelConfig, TensorInfo} from '@tensorflow/tfjs-core';\n\nimport {MathBackendWebGL} from '../backend_webgl';\n\nimport {fftImpl} from './FFT_impl';\n\nexport function ifft(args: {inputs: IFFTInputs, backend: MathBackendWebGL}):\n    TensorInfo {\n  const {inputs, backend} = args;\n  const {input} = inputs;\n\n  return fftImpl(input, true /* inverse */, backend);\n}\n\nexport const ifftConfig: KernelConfig = {\n  kernelName: IFFT,\n  backendName: 'webgl',\n  kernelFunc: ifft\n};\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {IsFinite, KernelConfig} from '@tensorflow/tfjs-core';\nimport {unaryKernelFunc} from '../kernel_utils/kernel_funcs_utils';\n\nconst IS_FINITE = `return float(!isnan(x) && !isinf(x));`;\n\nexport const isFinite = unaryKernelFunc({opSnippet: IS_FINITE, dtype: 'bool'});\n\nexport const isFiniteConfig: KernelConfig = {\n  kernelName: IsFinite,\n  backendName: 'webgl',\n  kernelFunc: isFinite,\n};\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {IsInf, KernelConfig} from '@tensorflow/tfjs-core';\nimport {unaryKernelFunc} from '../kernel_utils/kernel_funcs_utils';\n\nconst IS_INF = `return float(isinf(x));`;\n\nexport const isInf = unaryKernelFunc({opSnippet: IS_INF, dtype: 'bool'});\n\nexport const isInfConfig: KernelConfig = {\n  kernelName: IsInf,\n  backendName: 'webgl',\n  kernelFunc: isInf,\n};\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {IsNan, KernelConfig} from '@tensorflow/tfjs-core';\nimport {unaryKernelFunc} from '../kernel_utils/kernel_funcs_utils';\n\nconst IS_NAN = `return float(isnan(x));`;\n\nexport const isNaN = unaryKernelFunc({opSnippet: IS_NAN, dtype: 'bool'});\n\nexport const isNaNConfig: KernelConfig = {\n  kernelName: IsNan,\n  backendName: 'webgl',\n  kernelFunc: isNaN,\n};\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {KernelConfig, KernelFunc, Less} from '@tensorflow/tfjs-core';\n\nimport {binaryKernelFunc} from '../kernel_utils/kernel_funcs_utils';\nimport {lessImplCPU} from '../kernel_utils/shared';\n\nconst LESS = `return float(a < b);`;\nconst LESS_PACKED = `\n  return vec4(lessThan(a, b));\n`;\n\nexport const less = binaryKernelFunc({\n  opSnippet: LESS,\n  packedOpSnippet: LESS_PACKED,\n  cpuKernelImpl: lessImplCPU,\n  dtype: 'bool'\n});\n\nexport const lessConfig: KernelConfig = {\n  kernelName: Less,\n  backendName: 'webgl',\n  kernelFunc: less as {} as KernelFunc\n};\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {KernelConfig, KernelFunc, LessEqual} from '@tensorflow/tfjs-core';\n\nimport {binaryKernelFunc} from '../kernel_utils/kernel_funcs_utils';\nimport {lessEqualImplCPU} from '../kernel_utils/shared';\n\nexport const LESS_EQUAL = `return float(a <= b);`;\nexport const LESS_EQUAL_PACKED = `\n  return vec4(lessThanEqual(a, b));\n`;\n\nexport const lessEqual = binaryKernelFunc({\n  opSnippet: LESS_EQUAL,\n  packedOpSnippet: LESS_EQUAL_PACKED,\n  cpuKernelImpl: lessEqualImplCPU,\n  dtype: 'bool'\n});\n\nexport const lessEqualConfig: KernelConfig = {\n  kernelName: LessEqual,\n  backendName: 'webgl',\n  kernelFunc: lessEqual as {} as KernelFunc\n};\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {KernelConfig, KernelFunc, LinSpace, LinSpaceAttrs, TensorInfo} from '@tensorflow/tfjs-core';\n\nimport {MathBackendWebGL} from '../backend_webgl';\nimport {linSpaceImplCPU} from '../kernel_utils/shared';\n\nexport function linSpace(\n    args: {backend: MathBackendWebGL, attrs: LinSpaceAttrs}): TensorInfo {\n  const {backend, attrs} = args;\n  const {start, stop, num} = attrs;\n\n  // TODO: Use CPU implementation due to the precision problem in Safari.\n  const outVals = linSpaceImplCPU(start, stop, num);\n  return backend.makeTensorInfo([outVals.length], 'float32', outVals);\n}\n\nexport const linSpaceConfig: KernelConfig = {\n  kernelName: LinSpace,\n  backendName: 'webgl',\n  kernelFunc: linSpace as {} as KernelFunc\n};\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {KernelConfig, KernelFunc, Log} from '@tensorflow/tfjs-core';\n\nimport {CHECK_NAN_SNIPPET_UNARY, unaryKernelFunc} from '../kernel_utils/kernel_funcs_utils';\nimport {logImplCPU} from '../kernel_utils/shared';\n\n// Windows chrome return 0 if the input is negative value. We will specifically\n// return NaN if the input is 0 to solve compatiblity issue.\nconst LOG = CHECK_NAN_SNIPPET_UNARY + `\n  return x < 0.0 ? 0./0. : log(x);\n`;\n\nconst LOG_PACKED = `\n  vec4 result = log(x);\n  bvec4 isNaN = isnan(x);\n  result.r = isNaN.r ? x.r : (x.r < 0.0 ? 0./0. : result.r);\n  result.g = isNaN.g ? x.g : (x.g < 0.0 ? 0./0. : result.g);\n  result.b = isNaN.b ? x.b : (x.b < 0.0 ? 0./0. : result.b);\n  result.a = isNaN.a ? x.a : (x.a < 0.0 ? 0./0. : result.a);\n  return result;\n`;\n\nexport const log = unaryKernelFunc(\n    {opSnippet: LOG, packedOpSnippet: LOG_PACKED, cpuKernelImpl: logImplCPU});\n\nexport const logConfig: KernelConfig = {\n  kernelName: Log,\n  backendName: 'webgl',\n  kernelFunc: log as {} as KernelFunc\n};\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {KernelConfig, Log1p} from '@tensorflow/tfjs-core';\n\nimport {CHECK_NAN_SNIPPET_UNARY, unaryKernelFunc} from '../kernel_utils/kernel_funcs_utils';\n\nconst LOG1P = CHECK_NAN_SNIPPET_UNARY + `\n  return log(1.0 + x);\n`;\n\nexport const log1p = unaryKernelFunc({opSnippet: LOG1P});\n\nexport const log1pConfig: KernelConfig = {\n  kernelName: Log1p,\n  backendName: 'webgl',\n  kernelFunc: log1p,\n};\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {KernelConfig, KernelFunc, LogicalAnd} from '@tensorflow/tfjs-core';\n\nimport {binaryKernelFunc} from '../kernel_utils/kernel_funcs_utils';\n\nconst LOGICAL_AND = `return float(a >= 1.0 && b >= 1.0);`;\nconst LOGICAL_AND_PACKED = `\n  return vec4(\n    vec4(greaterThanEqual(a, vec4(1.0))) *\n    vec4(greaterThanEqual(b, vec4(1.0))));\n`;\n\nexport const logicalAnd = binaryKernelFunc({\n  opSnippet: LOGICAL_AND,\n  packedOpSnippet: LOGICAL_AND_PACKED,\n  dtype: 'bool'\n});\n\nexport const logicalAndConfig: KernelConfig = {\n  kernelName: LogicalAnd,\n  backendName: 'webgl',\n  kernelFunc: logicalAnd as {} as KernelFunc\n};\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {KernelConfig, LogicalNot} from '@tensorflow/tfjs-core';\nimport {unaryKernelFunc} from '../kernel_utils/kernel_funcs_utils';\n\nconst LOGICAL_NOT = `return float(!(x >= 1.0));`;\n\nexport const logicalNot = unaryKernelFunc({opSnippet: LOGICAL_NOT});\n\nexport const logicalNotConfig: KernelConfig = {\n  kernelName: LogicalNot,\n  backendName: 'webgl',\n  kernelFunc: logicalNot,\n};\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {KernelConfig, KernelFunc, LogicalOr} from '@tensorflow/tfjs-core';\n\nimport {binaryKernelFunc} from '../kernel_utils/kernel_funcs_utils';\n\nconst LOGICAL_OR = `return float(a >= 1.0 || b >= 1.0);`;\nconst LOGICAL_OR_PACKED = `\n  return min(\n    vec4(greaterThanEqual(a, vec4(1.0))) +\n    vec4(greaterThanEqual(b, vec4(1.0))),\n    vec4(1.0));\n`;\n\nexport const logicalOr = binaryKernelFunc(\n    {opSnippet: LOGICAL_OR, packedOpSnippet: LOGICAL_OR_PACKED, dtype: 'bool'});\n\nexport const logicalOrConfig: KernelConfig = {\n  kernelName: LogicalOr,\n  backendName: 'webgl',\n  kernelFunc: logicalOr as {} as KernelFunc\n};\n","/**\n * @license\n * Copyright 2017 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {GPGPUProgram} from './gpgpu_math';\n\nexport class LRNProgram implements GPGPUProgram {\n  variableNames = ['x'];\n  outputShape: number[] = [];\n  userCode: string;\n\n  constructor(\n      xShape: number[], radius: number, bias: number, alpha: number,\n      beta: number) {\n    const rad = radius;\n    const maxD = xShape[3] - 1;\n    this.outputShape = xShape;\n\n    // optimize pow(bias + alpha * sum, -beta)\n    // src: https://github.com/tensorflow/tensorflow/..\n    // blob/26033a1644a9c4a5fbe3170ab2e864b6a4ccd4ca/..\n    // tensorflow/core/kernels/mkl_lrn_op.cc#L320\n    let powOperator;\n    const basis = `float(${bias}) + float(${alpha}) * sum`;\n    if (beta === 0.5) {\n      powOperator = `inversesqrt(${basis})`;\n    } else if (beta === 1.0) {\n      powOperator = `1.0/(${basis})`;\n    } else {\n      powOperator = `exp(log(${basis}) * float(-${beta}));`;\n    }\n\n    this.userCode = `\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int r = coords[1];\n        int c = coords[2];\n        int d = coords[3];\n        float x = getX(b, r, c, d);\n        float sum = 0.0;\n        for (int j = -${rad}; j <= ${rad}; j++) {\n          int idx = d + j;\n          if (idx >= 0 && idx <=  ${maxD}) {\n            float z = getX(b, r, c, idx);\n            sum += z * z;\n          }\n        }\n        float val = x * ${powOperator};\n        setOutput(val);\n      }\n    `;\n  }\n}\n","/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {GPGPUProgram} from './gpgpu_math';\n\nexport class LRNPackedProgram implements GPGPUProgram {\n  variableNames = ['x'];\n  outputShape: number[] = [];\n  userCode: string;\n  packedInputs = true;\n  packedOutput = true;\n\n  constructor(\n      xShape: number[], radius: number, bias: number, alpha: number,\n      beta: number) {\n    const rad = radius;\n    const maxD = xShape[3] - 1;\n    this.outputShape = xShape;\n\n    // optimize pow(bias + alpha * sum, -beta)\n    // src: https://github.com/tensorflow/tensorflow/..\n    // blob/26033a1644a9c4a5fbe3170ab2e864b6a4ccd4ca/..\n    // tensorflow/core/kernels/mkl_lrn_op.cc#L320\n    let powOperator;\n    const basis = `float(${bias}) + float(${alpha}) * sum`;\n    if (beta === 0.5) {\n      powOperator = `inversesqrt(${basis})`;\n    } else if (beta === 1.0) {\n      powOperator = `1.0/(${basis})`;\n    } else {\n      powOperator = `exp(log(${basis}) * float(-${beta}));`;\n    }\n\n    this.userCode = `\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords.x;\n        int r = coords.y;\n        int c = coords.z;\n        int d = coords.w;\n\n        bool hasNextCol = d < ${this.outputShape[3]};\n        bool hasNextRow = c < ${this.outputShape[2]};\n\n        vec4 sum = vec4(0.);\n        vec4 xFragAtOutputCoords = getX(b, r, c, d);\n\n        vec4 xAtOutputCoords = vec4(\n          getChannel(xFragAtOutputCoords, vec2(c, d)),\n          hasNextCol ?\n            getChannel(xFragAtOutputCoords, vec2(c, d + 1)) : 0.0,\n          hasNextRow ?\n            getChannel(xFragAtOutputCoords , vec2(c + 1, d)) : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getChannel(xFragAtOutputCoords, vec2(c + 1, d + 1)) : 0.0\n        );\n\n        int firstChannel = d - ${rad};\n        vec2 cache = vec2(0.);\n        if(firstChannel >= 0){\n          vec4 firstChannelFrag = getX(b, r, c, firstChannel);\n          cache.x = getChannel(firstChannelFrag, vec2(c, firstChannel));\n            if(hasNextRow){\n              cache.y = getChannel(firstChannelFrag, vec2(c + 1, firstChannel));\n            }\n        }\n\n        ivec2 depth = ivec2(d, d + 1);\n        for (int j = - ${rad}; j <= ${rad}; j++) {\n          ivec2 idx = depth + j;\n          bvec2 aboveLowerBound = greaterThanEqual(idx, ivec2(0));\n          bvec2 belowUpperBound = lessThanEqual(idx, ivec2(${maxD}));\n\n          bool depthInRange = aboveLowerBound.x && belowUpperBound.x;\n          bool depthPlusOneInRange = aboveLowerBound.y && belowUpperBound.y;\n\n          if(depthInRange || depthPlusOneInRange){\n            vec4 z = vec4(0.);\n            vec4 xFragAtCurrentDepth;\n            z.xz = cache.xy;\n            if(depthPlusOneInRange && hasNextCol){\n              xFragAtCurrentDepth = idx.y != d ?\n                getX(b, r, c, idx.y) : xFragAtOutputCoords;\n              z.y = getChannel(xFragAtCurrentDepth, vec2(c, idx.y));\n              if(hasNextRow){\n                z.w = getChannel(xFragAtCurrentDepth, vec2(c + 1, idx.y));\n              }\n            }\n            cache.xy = z.yw;\n            sum += z * z;\n          }\n        }\n        vec4 result = xAtOutputCoords * ${powOperator};\n        setOutput(result);\n      }\n    `;\n  }\n}\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {env, KernelConfig, KernelFunc, LRN, LRNAttrs, LRNInputs, TensorInfo} from '@tensorflow/tfjs-core';\n\nimport {MathBackendWebGL} from '../backend_webgl';\nimport {LRNProgram} from '../lrn_gpu';\nimport {LRNPackedProgram} from '../lrn_packed_gpu';\n\nexport const lrn =\n    (args: {inputs: LRNInputs, backend: MathBackendWebGL, attrs: LRNAttrs}):\n        TensorInfo => {\n          const {inputs, backend, attrs} = args;\n          const {x} = inputs;\n          const {depthRadius, bias, alpha, beta} = attrs;\n\n          const program = env().getBool('WEBGL_PACK_NORMALIZATION') ?\n              new LRNPackedProgram(x.shape, depthRadius, bias, alpha, beta) :\n              new LRNProgram(x.shape, depthRadius, bias, alpha, beta);\n          return backend.runWebGLProgram(program, [x], x.dtype);\n        };\n\n// tslint:disable-next-line: variable-name\nexport const LRNConfig: KernelConfig = {\n  kernelName: LRN,\n  backendName: 'webgl',\n  kernelFunc: lrn as {} as KernelFunc\n};\n","/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {GPGPUProgram} from './gpgpu_math';\n\nexport class LRNGradProgram implements GPGPUProgram {\n  variableNames = ['inputImage', 'outputImage', 'dy'];\n  outputShape: number[] = [];\n  userCode: string;\n  depthRadius: number;\n  bias: number;\n  alpha: number;\n  beta: number;\n  depth: number;\n\n  constructor(\n      inputShape: number[], depthRadius: number, bias: number, alpha: number,\n      beta: number) {\n    this.outputShape = inputShape;\n    this.depth = inputShape[3];\n    this.depthRadius = depthRadius;\n    this.bias = bias;\n    this.alpha = alpha;\n    this.beta = beta;\n    this.userCode = `\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int r = coords[1];\n        int c = coords[2];\n\n        float result = 0.0;\n        for (int d = 0; d < ${this.depth}; ++d) {\n          int depthBegin = int(max(0.0, float(d - ${depthRadius})));\n          int depthEnd = int(min(float(${this.depth}),\n              float(d + ${depthRadius} + 1)));\n\n          const int MIN_DEPTH_BEGIN = 0;\n          const int MAX_DEPTH_END = ${this.depth};\n\n          float norm = 0.0;\n          for (int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k) {\n            if (k < depthBegin){\n              continue;\n            }\n            else if (k >= depthBegin && k < depthEnd) {\n              norm += getInputImage(b, r, c, k) * getInputImage(b, r, c, k);\n            }\n            else {\n              break;\n            }\n          }\n\n          norm = float(${alpha}) * norm + float(${bias});\n\n          for(int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k){\n            if (k < depthBegin){\n              continue;\n            }\n            else if (k >= depthBegin && k < depthEnd){\n              float dyi = -2.0 * float(${alpha})\n                * float(${beta})\n                * getInputImage(b ,r ,c, k) * getOutputImage(b, r, c, d)\n                / norm;\n              if (k == d) {\n                dyi += pow(norm, -1.0 * ${beta});\n              }\n              if (k == coords[3]) {\n                dyi *= getDy(b, r, c, d);\n                result += dyi;\n              }\n            }\n            else {\n              break;\n            }\n          }\n      }\n      setOutput(result);\n      }\n    `;\n  }\n}\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {KernelConfig, KernelFunc, LRNGrad, LRNGradAttrs, LRNGradInputs, TensorInfo} from '@tensorflow/tfjs-core';\n\nimport {MathBackendWebGL} from '../backend_webgl';\nimport {LRNGradProgram} from '../lrn_grad_gpu';\n\nexport const lrnGrad = (args: {\n  inputs: LRNGradInputs,\n  backend: MathBackendWebGL,\n  attrs: LRNGradAttrs\n}): TensorInfo => {\n  const {inputs, backend, attrs} = args;\n  const {x, y, dy} = inputs;\n  const {depthRadius, bias, alpha, beta} = attrs;\n\n  const program = new LRNGradProgram(x.shape, depthRadius, bias, alpha, beta);\n  return backend.runWebGLProgram(program, [x, y, dy], x.dtype);\n};\n\n// tslint:disable-next-line: variable-name\nexport const LRNGradConfig: KernelConfig = {\n  kernelName: LRNGrad,\n  backendName: 'webgl',\n  kernelFunc: lrnGrad as {} as KernelFunc\n};\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {KernelFunc, Max, MaxAttrs, MaxInputs, TensorInfo} from '@tensorflow/tfjs-core';\nimport {backend_util, KernelConfig, TypedArray, util} from '@tensorflow/tfjs-core';\n\nimport {MathBackendWebGL} from '../backend_webgl';\nimport {maxImplCPU} from '../kernel_utils/shared';\n\nimport {maxImpl} from './Max_impl';\nimport {transposeImpl, transposeImplCPU} from './Transpose_impl';\n\nexport function max(\n    args: {inputs: MaxInputs, backend: MathBackendWebGL, attrs: MaxAttrs}):\n    TensorInfo {\n  const {inputs, backend, attrs} = args;\n  const {x} = inputs;\n  const {reductionIndices, keepDims} = attrs;\n\n  const xRank = x.shape.length;\n\n  const origAxes = util.parseAxisParam(reductionIndices, x.shape);\n  let axes = origAxes;\n  const permutedAxes = backend_util.getAxesPermutation(axes, xRank);\n  const maxInputIsTransposed = permutedAxes != null;\n  const shouldExecuteOnCPU = backend.shouldExecuteOnCPU([x]);\n\n  let maxInput = x;\n  if (maxInputIsTransposed) {\n    if (shouldExecuteOnCPU) {\n      const xTexData = backend.texData.get(maxInput.dataId);\n      const values = xTexData.values as TypedArray;\n\n      const newShape: number[] = new Array(xRank);\n      for (let i = 0; i < newShape.length; i++) {\n        newShape[i] = x.shape[permutedAxes[i]];\n      }\n      const maxInputValues =\n          transposeImplCPU(values, x.shape, x.dtype, permutedAxes, newShape);\n\n      maxInput = backend.makeTensorInfo(newShape, x.dtype);\n      const maxInputData = backend.texData.get(maxInput.dataId);\n      maxInputData.values = maxInputValues;\n    } else {\n      maxInput = transposeImpl(x, permutedAxes, backend);\n    }\n\n    axes = backend_util.getInnerMostAxes(axes.length, xRank);\n  }\n\n  backend_util.assertAxesAreInnerMostDims('max', axes, xRank);\n  const [maxOutShape, reduceShape] =\n      backend_util.computeOutAndReduceShapes(maxInput.shape, axes);\n\n  let outShape = maxOutShape;\n  if (keepDims) {\n    // rather than reshape at the end, set the target shape here.\n    outShape = backend_util.expandShapeToKeepDim(maxOutShape, origAxes);\n  }\n\n  let out;\n  if (shouldExecuteOnCPU) {\n    const xTexData = backend.texData.get(maxInput.dataId);\n    const values = xTexData.values as TypedArray;\n\n    const outValues =\n        maxImplCPU(values, util.sizeFromShape(reduceShape), outShape, x.dtype);\n\n    out = backend.makeTensorInfo(outShape, x.dtype);\n    const outData = backend.texData.get(out.dataId);\n    outData.values = outValues;\n  } else {\n    out = maxImpl(maxInput, reduceShape, outShape, backend);\n  }\n\n  if (maxInputIsTransposed) {\n    backend.disposeIntermediateTensorInfo(maxInput);\n  }\n\n  return out;\n}\n\nexport const maxConfig: KernelConfig = {\n  kernelName: Max,\n  backendName: 'webgl',\n  kernelFunc: max as {} as KernelFunc\n};\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {TensorInfo, util} from '@tensorflow/tfjs-core';\n\nimport {MathBackendWebGL} from '../backend_webgl';\nimport {reduce} from '../kernel_utils/reduce';\nimport {reshape} from '../kernels/Reshape';\n\nexport function maxImpl(\n    x: TensorInfo, reduceShape: number[], outShape: number[],\n    backend: MathBackendWebGL): TensorInfo {\n  const inSize = util.sizeFromShape(reduceShape);\n  const xSize = util.sizeFromShape(x.shape);\n  const batchSize = xSize / inSize;\n  const reshapedInput =\n      reshape({inputs: {x}, attrs: {shape: [batchSize, inSize]}, backend});\n\n  const reduced = reduce(reshapedInput, x.dtype, 'max', backend);\n  const reshapedOutput =\n      reshape({inputs: {x: reduced}, attrs: {shape: outShape}, backend});\n\n  backend.disposeIntermediateTensorInfo(reshapedInput);\n  backend.disposeIntermediateTensorInfo(reduced);\n\n  return reshapedOutput;\n}\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {KernelConfig, KernelFunc, Maximum} from '@tensorflow/tfjs-core';\n\nimport {CHECK_NAN_SNIPPET} from '../binaryop_gpu';\nimport {CHECK_NAN_SNIPPET_PACKED} from '../binaryop_packed_gpu';\nimport {binaryKernelFunc} from '../kernel_utils/kernel_funcs_utils';\nimport {maximumImplCPU} from '../kernel_utils/shared';\n\nconst MAXIMUM = CHECK_NAN_SNIPPET + `\n  return max(a, b);\n`;\n\nconst MAXIMUM_PACKED = `\n  vec4 result = vec4(max(a, b));\n  bvec4 isNaNA = isnan(a);\n  bvec4 isNaNB = isnan(b);\n  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);\n  ` +\n    CHECK_NAN_SNIPPET_PACKED + `\n  return result;\n`;\n\nexport const maximum = binaryKernelFunc({\n  opSnippet: MAXIMUM,\n  packedOpSnippet: MAXIMUM_PACKED,\n  cpuKernelImpl: maximumImplCPU\n});\n\nexport const maximumConfig: KernelConfig = {\n  kernelName: Maximum,\n  backendName: 'webgl',\n  kernelFunc: maximum as {} as KernelFunc\n};\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport {backend_util, KernelConfig, KernelFunc, MaxPool, MaxPoolAttrs, MaxPoolInputs, TensorInfo, util} from '@tensorflow/tfjs-core';\n\nimport {MathBackendWebGL} from '../backend_webgl';\nimport {Pool2DProgram} from '../pool_gpu';\nimport {assertNotComplex} from '../webgl_util';\nimport {identity} from './Identity';\n\nexport function maxPool(args: {\n  inputs: MaxPoolInputs,\n  backend: MathBackendWebGL,\n  attrs: MaxPoolAttrs\n}): TensorInfo {\n  const {inputs, backend, attrs} = args;\n  const {x} = inputs;\n  assertNotComplex(x, 'maxPool');\n  const {filterSize, strides, pad, dimRoundingMode} = attrs;\n  const dilations = 1;\n\n  util.assert(\n      backend_util.eitherStridesOrDilationsAreOne(strides, dilations),\n      () => 'Error in maxPool: Either strides or dilations must be 1. ' +\n          `Got strides ${strides} and dilations '${dilations}'`);\n\n  const convInfo = backend_util.computePool2DInfo(\n      x.shape as [number, number, number, number], filterSize, strides,\n      dilations, pad, dimRoundingMode);\n  if (convInfo.filterWidth === 1 && convInfo.filterHeight === 1 &&\n      util.arraysEqual(convInfo.inShape, convInfo.outShape)) {\n    return identity({inputs: {x}, backend});\n  }\n  const maxPoolProgram = new Pool2DProgram(convInfo, 'max', false);\n  return backend.runWebGLProgram(maxPoolProgram, [x], x.dtype);\n}\n\nexport const maxPoolConfig: KernelConfig = {\n  kernelName: MaxPool,\n  backendName: 'webgl',\n  kernelFunc: maxPool as {} as KernelFunc\n};\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport {backend_util, KernelConfig, KernelFunc, MaxPool3D, MaxPool3DAttrs, MaxPool3DInputs, TensorInfo} from '@tensorflow/tfjs-core';\n\nimport {MathBackendWebGL} from '../backend_webgl';\nimport {Pool3DProgram} from '../pool_gpu';\n\nexport function maxPool3d(args: {\n  inputs: MaxPool3DInputs,\n  backend: MathBackendWebGL,\n  attrs: MaxPool3DAttrs\n}): TensorInfo {\n  const {inputs, backend, attrs} = args;\n  const {x} = inputs;\n  const {filterSize, strides, pad, dataFormat, dimRoundingMode} = attrs;\n  const dilations: [number, number, number] = [1, 1, 1];\n\n  const convInfo = backend_util.computePool3DInfo(\n      x.shape as [number, number, number, number, number], filterSize, strides,\n      dilations, pad, dimRoundingMode, dataFormat);\n  const maxPoolProgram = new Pool3DProgram(convInfo, 'max', false);\n  return backend.runWebGLProgram(maxPoolProgram, [x], x.dtype);\n}\n\nexport const maxPool3DConfig: KernelConfig = {\n  kernelName: MaxPool3D,\n  backendName: 'webgl',\n  kernelFunc: maxPool3d as {} as KernelFunc\n};\n","/**\n * @license\n * Copyright 2017 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {backend_util} from '@tensorflow/tfjs-core';\nimport {GPGPUProgram} from './gpgpu_math';\n\nexport class MaxPool2DBackpropProgram implements GPGPUProgram {\n  variableNames = ['dy', 'maxPos'];\n  outputShape: number[];\n  userCode: string;\n\n  constructor(convInfo: backend_util.Conv2DInfo) {\n    this.outputShape = convInfo.inShape;\n    const strideHeight = convInfo.strideHeight;\n    const strideWidth = convInfo.strideWidth;\n    const dilationHeight = convInfo.dilationHeight;\n    const effectiveFilterHeight = convInfo.effectiveFilterHeight;\n    const effectiveFilterWidth = convInfo.effectiveFilterWidth;\n\n    const padTop = effectiveFilterHeight - 1 - convInfo.padInfo.top;\n    const padLeft = effectiveFilterWidth - 1 - convInfo.padInfo.left;\n\n    const lastIndex = effectiveFilterHeight * effectiveFilterWidth - 1;\n    this.userCode = `\n      const ivec2 pads = ivec2(${padTop}, ${padLeft});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n\n        ivec2 dyRCCorner = coords.yz - pads;\n        int dyRCorner = dyRCCorner.x;\n        int dyCCorner = dyRCCorner.y;\n\n        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${effectiveFilterHeight};\n          wR += ${dilationHeight}) {\n          float dyR = float(dyRCorner + wR) / ${strideHeight}.0;\n\n          if (dyR < 0.0 || dyR >= ${convInfo.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          for (int wC = 0; wC < ${effectiveFilterWidth}; wC++) {\n            float dyC = float(dyCCorner + wC) / ${strideWidth}.0;\n\n            if (dyC < 0.0 || dyC >= ${convInfo.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            float dyValue = getDy(b, idyR, idyC, d);\n            int maxPosValue = ${lastIndex} - int(getMaxPos(b, idyR, idyC, d));\n\n            // Get the current value, check it against the value from the\n            // position matrix.\n            int curPosValue = wR * ${effectiveFilterWidth} + wC;\n            float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);\n\n            dotProd += dyValue * mask;\n          }\n        }\n        setOutput(dotProd);\n      }\n    `;\n  }\n}\n\nexport class MaxPool3DBackpropProgram implements GPGPUProgram {\n  variableNames = ['dy', 'maxPos'];\n  outputShape: number[];\n  userCode: string;\n\n  constructor(convInfo: backend_util.Conv3DInfo) {\n    this.outputShape = convInfo.inShape;\n    const strideDepth = convInfo.strideDepth;\n    const strideHeight = convInfo.strideHeight;\n    const strideWidth = convInfo.strideWidth;\n    const dilationDepth = convInfo.dilationDepth;\n    const dilationHeight = convInfo.dilationHeight;\n    const dilationWidth = convInfo.dilationWidth;\n    const effectiveFilterDepth = convInfo.effectiveFilterDepth;\n    const effectiveFilterHeight = convInfo.effectiveFilterHeight;\n    const effectiveFilterWidth = convInfo.effectiveFilterWidth;\n\n    const padFront = effectiveFilterDepth - 1 - convInfo.padInfo.front;\n    const padTop = effectiveFilterHeight - 1 - convInfo.padInfo.top;\n    const padLeft = effectiveFilterWidth - 1 - convInfo.padInfo.left;\n\n    const lastIndex =\n        effectiveFilterDepth * effectiveFilterHeight * effectiveFilterWidth - 1;\n    this.userCode = `\n      const ivec3 pads = ivec3(${padFront}, ${padTop}, ${padLeft});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyDCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        // Convolve dy(?, ?, ?, ch) with pos mask(:, :, :, d) to get\n        // dx(xD, xR, xC, ch).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int wD = 0; wD < ${effectiveFilterDepth};\n           wD += ${dilationDepth}) {\n          float dyD = float(dyDCorner + wD) / ${strideDepth}.0;\n\n          if (dyD < 0.0 || dyD >= ${convInfo.outDepth}.0 || fract(dyD) > 0.0) {\n            continue;\n          }\n          int idyD = int(dyD);\n\n          for (int wR = 0; wR < ${effectiveFilterHeight};\n              wR += ${dilationHeight}) {\n            float dyR = float(dyRCorner + wR) / ${strideHeight}.0;\n\n            if (dyR < 0.0 || dyR >= ${convInfo.outHeight}.0 ||\n                fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            for (int wC = 0; wC < ${effectiveFilterWidth};\n                wC += ${dilationWidth}) {\n              float dyC = float(dyCCorner + wC) / ${strideWidth}.0;\n\n              if (dyC < 0.0 || dyC >= ${convInfo.outWidth}.0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              float dyValue = getDy(batch, idyD, idyR, idyC, ch);\n              int maxPosValue = ${lastIndex} -\n                  int(getMaxPos(batch, idyD, idyR, idyC, ch));\n\n              // Get the current value, check it against the value from the\n              // position matrix.\n              int curPosValue =\n                  wD * ${effectiveFilterHeight} * ${effectiveFilterWidth} +\n                  wR * ${effectiveFilterWidth} + wC;\n              float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);\n\n              dotProd += dyValue * mask;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `;\n  }\n}\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport {backend_util, KernelConfig, KernelFunc, MaxPool3DGrad, MaxPool3DGradAttrs, MaxPool3DGradInputs, TensorInfo} from '@tensorflow/tfjs-core';\n\nimport {MathBackendWebGL} from '../backend_webgl';\nimport {MaxPool3DBackpropProgram} from '../max_pool_backprop_gpu';\nimport {Pool3DProgram} from '../pool_gpu';\n\nexport function maxPool3DGrad(args: {\n  inputs: MaxPool3DGradInputs,\n  backend: MathBackendWebGL,\n  attrs: MaxPool3DGradAttrs\n}): TensorInfo {\n  const {inputs, backend, attrs} = args;\n  const {dy, input} = inputs;\n  const x = input;\n  const {filterSize, strides, pad, dimRoundingMode} = attrs;\n  const dilations: [number, number, number] = [1, 1, 1];\n\n  const convInfo = backend_util.computePool3DInfo(\n      x.shape as [number, number, number, number, number], filterSize, strides,\n      dilations, pad, dimRoundingMode);\n\n  const maxPool3dPositionsProgram =\n      new Pool3DProgram(convInfo, 'max', true /* get positions */);\n  const maxPool3dPositions =\n      backend.runWebGLProgram(maxPool3dPositionsProgram, [x], x.dtype);\n  const maxPoolBackpropProgram = new MaxPool3DBackpropProgram(convInfo);\n  const result = backend.runWebGLProgram(\n      maxPoolBackpropProgram, [dy, maxPool3dPositions], x.dtype);\n  backend.disposeIntermediateTensorInfo(maxPool3dPositions);\n  return result;\n}\n\nexport const maxPool3DGradConfig: KernelConfig = {\n  kernelName: MaxPool3DGrad,\n  backendName: 'webgl',\n  kernelFunc: maxPool3DGrad as {} as KernelFunc\n};\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport {backend_util, KernelConfig, KernelFunc, MaxPoolGrad, MaxPoolGradAttrs, MaxPoolGradInputs, TensorInfo} from '@tensorflow/tfjs-core';\n\nimport {MathBackendWebGL} from '../backend_webgl';\nimport {MaxPool2DBackpropProgram} from '../max_pool_backprop_gpu';\nimport {Pool2DProgram} from '../pool_gpu';\nimport {assertNotComplex} from '../webgl_util';\n\nexport function maxPoolGrad(args: {\n  inputs: MaxPoolGradInputs,\n  backend: MathBackendWebGL,\n  attrs: MaxPoolGradAttrs\n}): TensorInfo {\n  const {inputs, backend, attrs} = args;\n  const {dy, input, output} = inputs;\n  const x = input;\n  assertNotComplex([input, output], 'maxPoolGrad');\n  const {filterSize, strides, pad, dimRoundingMode} = attrs;\n\n  const convInfo = backend_util.computePool2DInfo(\n      x.shape as [number, number, number, number], filterSize, strides,\n      1 /* dilations */, pad, dimRoundingMode);\n  const getPositions = true;\n  const maxPoolPositionsProgram =\n      new Pool2DProgram(convInfo, 'max', getPositions);\n  const maxPoolPositions: TensorInfo =\n      backend.runWebGLProgram(maxPoolPositionsProgram, [x], x.dtype);\n\n  const maxPoolBackPropProgram = new MaxPool2DBackpropProgram(convInfo);\n  const result = backend.runWebGLProgram(\n      maxPoolBackPropProgram, [dy, maxPoolPositions], x.dtype);\n  backend.disposeIntermediateTensorInfo(maxPoolPositions);\n  return result;\n}\n\nexport const maxPoolGradConfig: KernelConfig = {\n  kernelName: MaxPoolGrad,\n  backendName: 'webgl',\n  kernelFunc: maxPoolGrad as {} as KernelFunc\n};\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {MaxPoolWithArgmax, MaxPoolWithArgmaxAttrs, MaxPoolWithArgmaxInputs} from '@tensorflow/tfjs-core';\nimport {backend_util, KernelConfig, util} from '@tensorflow/tfjs-core';\n\nimport {MathBackendWebGL} from '../backend_webgl';\n\nimport {maxPoolWithArgmaxImpl} from './MaxPoolWithArgmax_impl';\n\nexport const maxPoolWithArgmaxConfig: KernelConfig = {\n  kernelName: MaxPoolWithArgmax,\n  backendName: 'webgl',\n  kernelFunc: ({inputs, attrs, backend}) => {\n    const {x} = inputs as MaxPoolWithArgmaxInputs;\n    const {filterSize, strides, pad, includeBatchInIndex} =\n        attrs as {} as MaxPoolWithArgmaxAttrs;\n    const webglBackend = backend as MathBackendWebGL;\n\n    util.assert(\n        x.shape.length === 4,\n        () => `Error in maxPool: input must be rank 4 but got rank ${\n            x.shape.length}.`);\n    const dilations: [number, number] = [1, 1];\n    util.assert(\n        backend_util.eitherStridesOrDilationsAreOne(strides, dilations),\n        () => 'Error in maxPool: Either strides or dilations must be 1. ' +\n            `Got strides ${strides} and dilations '${dilations}'`);\n\n    const convInfo = backend_util.computePool2DInfo(\n        x.shape as [number, number, number, number], filterSize, strides,\n        dilations, pad);\n\n    const [result, indexes] =\n        maxPoolWithArgmaxImpl(x, includeBatchInIndex, convInfo, webglBackend);\n    return [result, indexes];\n  }\n};\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {backend_util, TensorInfo} from '@tensorflow/tfjs-core';\n\nimport {MathBackendWebGL} from '../backend_webgl';\nimport {Pool2DProgram} from '../pool_gpu';\n\nexport function maxPoolWithArgmaxImpl(\n    x: TensorInfo, includeBatchInIndex: boolean,\n    convInfo: backend_util.Conv2DInfo,\n    backend: MathBackendWebGL): TensorInfo[] {\n  let program = new Pool2DProgram(convInfo, 'max', false);\n  const poolOutput = backend.runWebGLProgram(program, [x], 'float32');\n\n  program = new Pool2DProgram(convInfo, 'max', true, true, includeBatchInIndex);\n  const indexOutput = backend.runWebGLProgram(program, [x], 'float32');\n  return [poolOutput, indexOutput];\n}\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {backend_util, KernelConfig, Mean, MeanAttrs, MeanInputs, TensorInfo, TypedArray, util} from '@tensorflow/tfjs-core';\n\nimport {MathBackendWebGL} from '../backend_webgl';\n\nimport {meanImpl} from './Mean_impl';\nimport {transposeImpl, transposeImplCPU} from './Transpose_impl';\n\nexport const meanConfig: KernelConfig = {\n  kernelName: Mean,\n  backendName: 'webgl',\n  kernelFunc: ({inputs, attrs, backend}) => {\n    const {x} = inputs as MeanInputs;\n    const {keepDims, axis} = attrs as {} as MeanAttrs;\n    const webglBackend = backend as MathBackendWebGL;\n\n    const xRank = x.shape.length;\n    const origAxes = util.parseAxisParam(axis, x.shape);\n\n    let axes = origAxes;\n    const permutedAxes = backend_util.getAxesPermutation(axes, xRank);\n    const meanInputIsTransposed = permutedAxes != null;\n    const shouldExecuteOnCPU = webglBackend.shouldExecuteOnCPU([x]);\n\n    const intermediates: TensorInfo[] = [];\n\n    let meanInput = x;\n    if (meanInputIsTransposed) {\n      if (shouldExecuteOnCPU) {\n        const xTexData = webglBackend.texData.get(meanInput.dataId);\n        const values = xTexData.values as TypedArray;\n\n        const newShape: number[] = new Array(xRank);\n        for (let i = 0; i < newShape.length; i++) {\n          newShape[i] = x.shape[permutedAxes[i]];\n        }\n        const meanInputValues =\n            transposeImplCPU(values, x.shape, x.dtype, permutedAxes, newShape);\n\n        meanInput = webglBackend.makeTensorInfo(newShape, x.dtype);\n        const meanInputData = webglBackend.texData.get(meanInput.dataId);\n        meanInputData.values = meanInputValues;\n      } else {\n        meanInput = transposeImpl(x, permutedAxes, webglBackend);\n      }\n\n      intermediates.push(meanInput);\n      axes = backend_util.getInnerMostAxes(axes.length, xRank);\n    }\n\n    backend_util.assertAxesAreInnerMostDims('sum', axes, xRank);\n    const [meanOutShape, reduceShape] =\n        backend_util.computeOutAndReduceShapes(meanInput.shape, axes);\n\n    let outShape = meanOutShape;\n    if (keepDims) {\n      // rather than reshape at the end, set the target shape here.\n      outShape = backend_util.expandShapeToKeepDim(meanOutShape, origAxes);\n    }\n\n    const out = meanImpl(meanInput, reduceShape, outShape, webglBackend);\n    for (const i of intermediates) {\n      webglBackend.disposeIntermediateTensorInfo(i);\n    }\n\n    return out;\n  }\n};\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {TensorInfo, util} from '@tensorflow/tfjs-core';\n\nimport {MathBackendWebGL} from '../backend_webgl';\nimport {reduce} from '../kernel_utils/reduce';\nimport {reshape} from '../kernels/Reshape';\n\nexport function meanImpl(\n    x: TensorInfo, reduceShape: number[], outShape: number[],\n    backend: MathBackendWebGL): TensorInfo {\n  const inSize = util.sizeFromShape(reduceShape);\n  const xSize = util.sizeFromShape(x.shape);\n  const batchSize = xSize / inSize;\n  const reshapedInput =\n      reshape({inputs: {x}, attrs: {shape: [batchSize, inSize]}, backend});\n\n  const reduced = reduce(reshapedInput, 'float32', 'mean', backend);\n  const reshapedOutput =\n      reshape({inputs: {x: reduced}, attrs: {shape: outShape}, backend});\n\n  backend.disposeIntermediateTensorInfo(reshapedInput);\n  backend.disposeIntermediateTensorInfo(reduced);\n\n  return reshapedOutput;\n}\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {backend_util, KernelConfig, KernelFunc, Min, MinAttrs, MinInputs, TensorInfo, util} from '@tensorflow/tfjs-core';\n\nimport {MathBackendWebGL} from '../backend_webgl';\nimport {reduce} from '../kernel_utils/reduce';\n\nimport {reshape} from './Reshape';\nimport {transpose} from './Transpose';\n\nexport function min(\n    args: {inputs: MinInputs, backend: MathBackendWebGL, attrs: MinAttrs}):\n    TensorInfo {\n  const {inputs, backend, attrs} = args;\n  const {x} = inputs;\n  const {axis, keepDims} = attrs;\n\n  const xRank = x.shape.length;\n\n  const origAxes = util.parseAxisParam(axis, x.shape);\n  let axes = origAxes;\n  const permutedAxes = backend_util.getAxesPermutation(axes, xRank);\n  let permutedX = x;\n  if (permutedAxes != null) {\n    permutedX = transpose({inputs: {x}, backend, attrs: {perm: permutedAxes}});\n    axes = backend_util.getInnerMostAxes(axes.length, x.shape.length);\n  }\n\n  backend_util.assertAxesAreInnerMostDims('min', axes, xRank);\n  const [outShape, reduceShape] =\n      backend_util.computeOutAndReduceShapes(permutedX.shape, axes);\n  const inSize = util.sizeFromShape(reduceShape);\n  const a2D =\n      reshape({inputs: {x: permutedX}, backend, attrs: {shape: [-1, inSize]}});\n  const reduced = reduce(a2D, a2D.dtype, 'min', backend);\n\n  let res;\n  if (keepDims) {\n    const newShape = backend_util.expandShapeToKeepDim(outShape, origAxes);\n    res = reshape({inputs: {x: reduced}, backend, attrs: {shape: newShape}});\n  } else {\n    res = reshape({inputs: {x: reduced}, backend, attrs: {shape: outShape}});\n  }\n\n  backend.disposeIntermediateTensorInfo(a2D);\n  backend.disposeIntermediateTensorInfo(reduced);\n\n  if (permutedAxes != null) {\n    backend.disposeIntermediateTensorInfo(permutedX);\n  }\n\n  return res;\n}\n\nexport const minConfig: KernelConfig = {\n  kernelName: Min,\n  backendName: 'webgl',\n  kernelFunc: min as {} as KernelFunc\n};\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {KernelConfig, KernelFunc, Minimum} from '@tensorflow/tfjs-core';\n\nimport {CHECK_NAN_SNIPPET} from '../binaryop_gpu';\nimport {CHECK_NAN_SNIPPET_PACKED} from '../binaryop_packed_gpu';\nimport {binaryKernelFunc} from '../kernel_utils/kernel_funcs_utils';\nimport {minimumImplCPU} from '../kernel_utils/shared';\n\nconst MINIMUM = CHECK_NAN_SNIPPET + `\n  return min(a, b);\n`;\n\nconst MINIMUM_PACKED = `\n  vec4 result = vec4(min(a, b));\n  bvec4 isNaNA = isnan(a);\n  bvec4 isNaNB = isnan(b);\n  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);\n  ` +\n    CHECK_NAN_SNIPPET_PACKED + `\n  return result;\n`;\n\nexport const minimum = binaryKernelFunc({\n  opSnippet: MINIMUM,\n  packedOpSnippet: MINIMUM_PACKED,\n  cpuKernelImpl: minimumImplCPU\n});\n\nexport const minimumConfig: KernelConfig = {\n  kernelName: Minimum,\n  backendName: 'webgl',\n  kernelFunc: minimum as {} as KernelFunc\n};\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {GPGPUProgram} from './gpgpu_math';\nimport {getCoordsDataType} from './shader_compiler';\n\nexport class MirrorPadProgram implements GPGPUProgram {\n  variableNames = ['x'];\n  outputShape: number[];\n  userCode: string;\n\n  constructor(\n      xShape: number[], paddings: Array<[number, number]>,\n      mode: 'reflect'|'symmetric') {\n    this.outputShape = paddings.map(\n        (p, i) => p[0] /* beforePad */ + xShape[i] + p[1] /* afterPad */);\n    const rank = xShape.length;\n    const dtype = getCoordsDataType(rank);\n\n    const start = paddings.map(p => p[0]).join(',');\n    const end = paddings.map((p, i) => p[0] + xShape[i]).join(',');\n    const unpackedCoords =\n        ['coords[0]', 'coords[1]', 'coords[2]', 'coords[3]'].slice(0, rank);\n    const offset = mode === 'reflect' ? 0 : 1;\n\n    if (rank === 1) {\n      this.userCode = `\n        int start = ${start};\n        int end = ${end};\n\n        void main() {\n          int outC = getOutputCoords();\n          if (outC < start) {\n            outC = start * 2 - outC - ${offset};\n          } else if(outC >= end) {\n            outC = (end - 1) * 2 - outC + ${offset};\n          }\n          setOutput(getX(outC - start));\n        }\n      `;\n      return;\n    }\n    this.userCode = `\n      ${dtype} start = ${dtype}(${start});\n      ${dtype} end = ${dtype}(${end});\n\n      void main() {\n        ${dtype} outC = getOutputCoords();\n        for (int i = 0; i < ${rank}; i++) {\n          if (outC[i] < start[i]) {\n            outC[i] = start[i] * 2 - outC[i] - ${offset};\n          } else if(outC[i] >= end[i]) {\n            outC[i] = (end[i] - 1) * 2 - outC[i] + ${offset};\n          }\n        }\n        ${dtype} coords = outC - start;\n        setOutput(getX(${unpackedCoords}));\n      }\n    `;\n  }\n}\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {GPGPUProgram} from './gpgpu_math';\nimport {getChannels} from './packing_util';\nimport {getCoordsDataType} from './shader_compiler';\n\n/**\n * Example shader code for\n * `mirrorPad(tf.tensor1d([1, 2, 3], 'int32'), [[2, 2]], 'reflect')`\n * ```\n *    const int start = int(2);\n *    const int end = int(5);\n *\n *    void main() {\n *       int outputLoc = getOutputCoords();\n *       vec4 result = vec4(0.);\n *\n *       int rc = outputLoc;\n *\n *       int source = rc;\n *       if (source < start) {\n *         source = start * 2 - source - 0;\n *       } else if (source >= end) {\n *         source = (end - 1) * 2 - source + 0;\n *       }\n *       source -= start;\n *\n *       result[0] = getChannel(getX(source), source);\n *       rc += 1;\n *       if(rc < 6) {\n *          int source = rc;\n *          if (source < start) {\n *            source = start * 2 - source - 0;\n *          } else if (source >= end) {\n *            source = (end - 1) * 2 - source + 0;\n *          }\n *          source -= start;\n *\n *         result[1] = getChannel(getX(source), source);\n *       }\n *\n *       setOutput(result);\n *     }\n * ```\n */\nexport class MirrorPadPackedProgram implements GPGPUProgram {\n  variableNames = ['x'];\n  packedInputs = true;\n  packedOutput = true;\n  outputShape: number[];\n  userCode: string;\n\n  constructor(\n      xShape: number[], paddings: Array<[number, number]>,\n      mode: 'reflect'|'symmetric') {\n    this.outputShape = paddings.map(\n        (p, i) => p[0] /* beforePad */ + xShape[i] + p[1] /* afterPad */);\n    const rank = xShape.length;\n    const dtype = getCoordsDataType(rank);\n\n    const start = paddings.map(p => p[0]).join(',');\n    const end = paddings.map((p, i) => p[0] + xShape[i]).join(',');\n    const coords = getChannels('rc', rank);\n    const source = getChannels('source', rank);\n    const cLimit = `${coords[rank - 1]} < ${this.outputShape[rank - 1]}`;\n    const innerDims =\n        rank === 1 ? 'source' : `vec2(${source.slice(-2).join()})`;\n    const offset = mode === 'reflect' ? 0 : 1;\n\n    let mainLoop = '';\n    if (rank === 1) {\n      const padSetup = `\n        ${dtype} source = rc;\n        if (source < start) {\n          source = start * 2 - source - ${offset};\n        } else if (source >= end) {\n          source = (end - 1) * 2 - source + ${offset};\n        }\n        source -= start;\n      `;\n      mainLoop = `\n        ${dtype} rc = outputLoc;\n        ${padSetup}\n        result[0] = getChannel(getX(${source.join()}), ${innerDims});\n        ${coords[rank - 1]} += 1;\n        if(${cLimit}) {\n          ${padSetup}\n          result[1] = getChannel(getX(${source.join()}), ${innerDims});\n        }\n      `;\n    } else {\n      const padSetup = `\n        ${dtype} source = rc;\n        ${dtype} lt = ${dtype}(lessThan(source, start));\n        ${dtype} gte = ${dtype}(greaterThanEqual(source, end));\n        ${dtype} orig = 1 - (lt + gte);\n        source = orig * source +\n                lt * (start * 2 - source - ${offset}) +\n                gte * ((end - 1) * 2 - source + ${offset});\n        source -= start;\n      `;\n\n      mainLoop = `\n        ${dtype} rc = outputLoc;\n        ${padSetup}\n        result[0] = getChannel(getX(${source.join()}), ${innerDims});\n        ${coords[rank - 1]} += 1;\n        if(${cLimit}) {\n          ${padSetup}\n          result[1] = getChannel(getX(${source.join()}), ${innerDims});\n        }\n        rc = outputLoc;\n        ${coords[rank - 2]} += 1;\n        if(${coords[rank - 2]} < ${this.outputShape[rank - 2]}) {\n          ${padSetup}\n          result[2] = getChannel(getX(${source.join()}), ${innerDims});\n          ${coords[rank - 1]} += 1;\n          if(${cLimit}) {\n            ${padSetup}\n            result[3] = getChannel(getX(${source.join()}), ${innerDims});\n          }\n        }\n      `;\n    }\n\n    this.userCode = `\n      const ${dtype} start = ${dtype}(${start});\n      const ${dtype} end = ${dtype}(${end});\n\n      void main() {\n        ${dtype} outputLoc = getOutputCoords();\n        vec4 result = vec4(0.);\n        ${mainLoop}\n        setOutput(result);\n      }\n    `;\n  }\n}\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {env, KernelConfig, KernelFunc, MirrorPad, MirrorPadAttrs, MirrorPadInputs, TensorInfo} from '@tensorflow/tfjs-core';\n\nimport {MathBackendWebGL} from '../backend_webgl';\nimport {MirrorPadProgram} from '../mirror_pad_gpu';\nimport {MirrorPadPackedProgram} from '../mirror_pad_packed_gpu';\n\nexport const mirrorPadKernelFunc: (params: {\n  inputs: MirrorPadInputs,\n  backend: MathBackendWebGL,\n  attrs: MirrorPadAttrs\n}) => TensorInfo = ({inputs, backend, attrs}) => {\n  const {x} = inputs;\n  const {paddings, mode} = attrs;\n\n  const program = env().getBool('WEBGL_PACK_ARRAY_OPERATIONS') ?\n      new MirrorPadPackedProgram(x.shape, paddings, mode) :\n      new MirrorPadProgram(x.shape, paddings, mode);\n\n  const output = backend.runWebGLProgram(program, [x], x.dtype);\n\n  return output;\n};\n\nexport const mirrorPadConfig: KernelConfig = {\n  kernelName: MirrorPad,\n  backendName: 'webgl',\n  kernelFunc: mirrorPadKernelFunc as {} as KernelFunc,\n};\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {KernelConfig, KernelFunc, Mod} from '@tensorflow/tfjs-core';\n\nimport {CHECK_NAN_SNIPPET_PACKED} from '../binaryop_packed_gpu';\nimport {binaryKernelFunc} from '../kernel_utils/kernel_funcs_utils';\n\nconst MOD = `if (b == 0.0) return NAN;\n  return mod(a, b);`;\n\nconst MOD_PACKED = `\n  vec4 result = mod(a, b);\n  bvec4 isNaN = equal(b, vec4(0.0));\n  ` +\n    CHECK_NAN_SNIPPET_PACKED + `\n  return result;\n`;\n\nexport const mod = binaryKernelFunc({\n  opSnippet: MOD,\n  packedOpSnippet: MOD_PACKED,\n});\n\nexport const modConfig: KernelConfig = {\n  kernelName: Mod,\n  backendName: 'webgl',\n  kernelFunc: mod as {} as KernelFunc\n};\n","/**\n * @license\n * Copyright 2017 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {GPGPUProgram} from './gpgpu_math';\nimport {UniformType} from './shader_compiler';\n\nexport class MultinomialProgram implements GPGPUProgram {\n  variableNames = ['probs'];\n  outputShape: number[];\n  userCode: string;\n  customUniforms = [{name: 'seed', type: 'float' as UniformType}];\n\n  constructor(batchSize: number, numOutcomes: number, numSamples: number) {\n    this.outputShape = [batchSize, numSamples];\n\n    this.userCode = `\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n\n        float r = random(seed);\n        float cdf = 0.0;\n\n        for (int i = 0; i < ${numOutcomes - 1}; i++) {\n          cdf += getProbs(batch, i);\n\n          if (r < cdf) {\n            setOutput(float(i));\n            return;\n          }\n        }\n\n        // If no other event happened, last event happened.\n        setOutput(float(${numOutcomes - 1}));\n      }\n    `;\n  }\n}\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {RealDiv} from '@tensorflow/tfjs-core';\nimport {KernelConfig} from '@tensorflow/tfjs-core';\nimport {binaryKernelFunc} from '../kernel_utils/kernel_funcs_utils';\n\n// Without the equality check div produces 0.9999 for a = b, which when\n// floored can cause errors.\nconst DIV = `\nif (a == b) {\n  return 1.0;\n};\nreturn a / b;`;\n\n// We do the same as in ./binaryop_gpu, with vec4 and ivec4.\n// On Linux, the vectorized implementation produces NaNs when a and b are 0.\nconst DIV_PACKED = `\n  // vec4 one = vec4(equal(a, b));\n  // return one + (vec4(1.0) - one) * a / b;\n  vec4 result = a / b;\n  if(a.x == b.x) {\n    result.x = 1.;\n  }\n  if(a.y == b.y) {\n    result.y = 1.;\n  }\n  if(a.z == b.z) {\n    result.z = 1.;\n  }\n  if(a.w == b.w) {\n    result.w = 1.;\n  }\n\n  return result;\n`;\n\nexport const realDiv = binaryKernelFunc(\n    {opSnippet: DIV, packedOpSnippet: DIV_PACKED, checkOutOfBounds: true});\n\nexport const realDivConfig: KernelConfig = {\n  kernelName: RealDiv,\n  backendName: 'webgl',\n  kernelFunc: realDiv,\n};\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {KernelConfig, Sub} from '@tensorflow/tfjs-core';\n\nimport {binaryKernelFunc} from '../kernel_utils/kernel_funcs_utils';\nimport {subImplCPU as cpuSub} from '../kernel_utils/shared';\n\nconst SUB = 'return a - b;';\n\nexport const sub = binaryKernelFunc({\n  opSnippet: SUB,\n  packedOpSnippet: SUB,\n  supportsComplex: true,\n  cpuKernelImpl: cpuSub\n});\n\nexport const subConfig: KernelConfig = {\n  kernelName: Sub,\n  backendName: 'webgl',\n  kernelFunc: sub\n};\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {backend_util, KernelConfig, KernelFunc, Softmax, SoftmaxAttrs, SoftmaxInputs, TensorInfo, util} from '@tensorflow/tfjs-core';\n\nimport {MathBackendWebGL} from '../backend_webgl';\n\nimport {exp} from './Exp';\nimport {max} from './Max';\nimport {realDiv} from './RealDiv';\nimport {reshape} from './Reshape';\nimport {sub} from './Sub';\nimport {sum} from './Sum';\n\nexport function softmax(args: {\n  inputs: SoftmaxInputs,\n  backend: MathBackendWebGL,\n  attrs: SoftmaxAttrs\n}): TensorInfo {\n  const {inputs, backend, attrs} = args;\n  const {logits} = inputs;\n  const {dim} = attrs;\n\n  const axes = util.parseAxisParam([dim], logits.shape);\n\n  const maxLogit = max({\n    inputs: {x: logits},\n    backend,\n    attrs: {reductionIndices: axes, keepDims: false}\n  });\n\n  const expandedShape = backend_util.expandShapeToKeepDim(maxLogit.shape, axes);\n\n  const maxLogitsReshaped =\n      reshape({inputs: {x: maxLogit}, backend, attrs: {shape: expandedShape}});\n  const a =\n      sub({inputs: {a: logits, b: maxLogitsReshaped}, backend}) as TensorInfo;\n  const b = exp({inputs: {x: a}, backend}) as TensorInfo;\n  const sumExp =\n      sum({inputs: {x: b}, backend, attrs: {axis: axes, keepDims: false}});\n  const sumExpReshaped =\n      reshape({inputs: {x: sumExp}, backend, attrs: {shape: expandedShape}});\n\n  const res =\n      realDiv({inputs: {a: b, b: sumExpReshaped}, backend}) as TensorInfo;\n\n  backend.disposeIntermediateTensorInfo(maxLogit);\n  backend.disposeIntermediateTensorInfo(maxLogitsReshaped);\n  backend.disposeIntermediateTensorInfo(a);\n  backend.disposeIntermediateTensorInfo(b);\n  backend.disposeIntermediateTensorInfo(sumExp);\n  backend.disposeIntermediateTensorInfo(sumExpReshaped);\n\n  return res;\n}\n\nexport const softmaxConfig: KernelConfig = {\n  kernelName: Softmax,\n  backendName: 'webgl',\n  kernelFunc: softmax as {} as KernelFunc\n};\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {KernelConfig, KernelFunc, Multinomial, MultinomialAttrs, MultinomialInputs, TensorInfo} from '@tensorflow/tfjs-core';\n\nimport {MathBackendWebGL} from '../backend_webgl';\nimport {MultinomialProgram} from '../multinomial_gpu';\n\nimport {softmax} from './Softmax';\n\nexport function multinomial(args: {\n  inputs: MultinomialInputs,\n  backend: MathBackendWebGL,\n  attrs: MultinomialAttrs\n}): TensorInfo {\n  const {inputs, backend, attrs} = args;\n  const {logits} = inputs;\n  const {numSamples, seed, normalized} = attrs;\n\n  const probs = normalized ?\n      logits :\n      softmax(\n          {inputs: {logits}, backend, attrs: {dim: logits.shape.length - 1}});\n  const batchSize = probs.shape[0];\n  const numOutcomes = probs.shape[1];\n  const program = new MultinomialProgram(batchSize, numOutcomes, numSamples);\n  const customValues = [[seed]];\n  const res = backend.runWebGLProgram(program, [probs], 'int32', customValues);\n  if (!normalized) {\n    backend.disposeIntermediateTensorInfo(probs);\n  }\n  return res;\n}\n\nexport const multinomialConfig: KernelConfig = {\n  kernelName: Multinomial,\n  backendName: 'webgl',\n  kernelFunc: multinomial as {} as KernelFunc\n};\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {env, KernelConfig, KernelFunc, Neg, NegInputs, TensorInfo, TypedArray} from '@tensorflow/tfjs-core';\n\nimport {MathBackendWebGL} from '../backend_webgl';\nimport {negImplCPU} from '../kernel_utils/shared';\nimport {CHECK_NAN_SNIPPET, UnaryOpProgram} from '../unaryop_gpu';\nimport {UnaryOpPackedProgram} from '../unaryop_packed_gpu';\n\nconst NEG = CHECK_NAN_SNIPPET + `\n  return -x;\n`;\n\nconst NEG_PACKED = `\n  vec4 result = -x;\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n`;\n\n// This doesn't use unaryKernelFunc because negImplCPU is not of type\n// SimpleUnaryKernelImplCPU.\nexport function neg(args: {inputs: NegInputs, backend: MathBackendWebGL}):\n    TensorInfo {\n  const {inputs, backend} = args;\n  const {x} = inputs;\n\n  if (backend.shouldExecuteOnCPU([x])) {\n    const xData = backend.texData.get(x.dataId);\n    const [outValues, newShape] =\n        negImplCPU(xData.values as TypedArray, x.shape, x.dtype);\n    return backend.makeTensorInfo(newShape, x.dtype, outValues);\n  }\n\n  let program: UnaryOpProgram|UnaryOpPackedProgram;\n  if (env().getBool('WEBGL_PACK_UNARY_OPERATIONS')) {\n    program = new UnaryOpPackedProgram(x.shape, NEG_PACKED);\n  } else {\n    program = new UnaryOpProgram(x.shape, NEG);\n  }\n\n  return backend.runWebGLProgram(program, [x], x.dtype);\n}\n\nexport const negConfig: KernelConfig = {\n  kernelName: Neg,\n  backendName: 'webgl',\n  kernelFunc: neg as {} as KernelFunc\n};\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {backend_util, kernel_impls, KernelConfig, KernelFunc, NonMaxSuppressionV3, NonMaxSuppressionV3Attrs, NonMaxSuppressionV3Inputs, TypedArray} from '@tensorflow/tfjs-core';\n\nconst nonMaxSuppressionV3Impl = kernel_impls.nonMaxSuppressionV3Impl;\nimport {MathBackendWebGL} from '../backend_webgl';\n\nexport function nonMaxSuppressionV3(args: {\n  inputs: NonMaxSuppressionV3Inputs,\n  backend: MathBackendWebGL,\n  attrs: NonMaxSuppressionV3Attrs\n}) {\n  backend_util.warn(\n      'tf.nonMaxSuppression() in webgl locks the UI thread. ' +\n      'Call tf.nonMaxSuppressionAsync() instead');\n\n  const {inputs, backend, attrs} = args;\n  const {boxes, scores} = inputs;\n  const {maxOutputSize, iouThreshold, scoreThreshold} = attrs;\n\n  const boxesVals = backend.readSync(boxes.dataId) as TypedArray;\n  const scoresVals = backend.readSync(scores.dataId) as TypedArray;\n\n  const {selectedIndices} = nonMaxSuppressionV3Impl(\n      boxesVals, scoresVals, maxOutputSize, iouThreshold, scoreThreshold);\n\n  return backend.makeTensorInfo(\n      [selectedIndices.length], 'int32', new Int32Array(selectedIndices));\n}\n\nexport const nonMaxSuppressionV3Config: KernelConfig = {\n  kernelName: NonMaxSuppressionV3,\n  backendName: 'webgl',\n  kernelFunc: nonMaxSuppressionV3 as {} as KernelFunc\n};\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {backend_util, kernel_impls, KernelConfig, KernelFunc, NonMaxSuppressionV4, NonMaxSuppressionV4Attrs, NonMaxSuppressionV4Inputs, TensorInfo, TypedArray} from '@tensorflow/tfjs-core';\nconst nonMaxSuppressionV4Impl = kernel_impls.nonMaxSuppressionV4Impl;\n\nimport {MathBackendWebGL} from '../backend_webgl';\n\nexport function nonMaxSuppressionV4(args: {\n  inputs: NonMaxSuppressionV4Inputs,\n  backend: MathBackendWebGL,\n  attrs: NonMaxSuppressionV4Attrs\n}): [TensorInfo, TensorInfo] {\n  backend_util.warn(\n      'tf.nonMaxSuppression() in webgl locks the UI thread. ' +\n      'Call tf.nonMaxSuppressionAsync() instead');\n\n  const {inputs, backend, attrs} = args;\n  const {boxes, scores} = inputs;\n  const {maxOutputSize, iouThreshold, scoreThreshold, padToMaxOutputSize} =\n      attrs;\n\n  const boxesVals = backend.readSync(boxes.dataId) as TypedArray;\n  const scoresVals = backend.readSync(scores.dataId) as TypedArray;\n\n  const {selectedIndices, validOutputs} = nonMaxSuppressionV4Impl(\n      boxesVals, scoresVals, maxOutputSize, iouThreshold, scoreThreshold,\n      padToMaxOutputSize);\n\n  return [\n    backend.makeTensorInfo(\n        [selectedIndices.length], 'int32', new Int32Array(selectedIndices)),\n    backend.makeTensorInfo([], 'int32', new Int32Array([validOutputs]))\n  ];\n}\n\nexport const nonMaxSuppressionV4Config: KernelConfig = {\n  kernelName: NonMaxSuppressionV4,\n  backendName: 'webgl',\n  kernelFunc: nonMaxSuppressionV4 as {} as KernelFunc\n};\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {backend_util, kernel_impls, KernelConfig, KernelFunc, NonMaxSuppressionV5, NonMaxSuppressionV5Attrs, NonMaxSuppressionV5Inputs, TensorInfo, TypedArray} from '@tensorflow/tfjs-core';\n\nconst nonMaxSuppressionV5Impl = kernel_impls.nonMaxSuppressionV5Impl;\nimport {MathBackendWebGL} from '../backend_webgl';\n\nexport function nonMaxSuppressionV5(args: {\n  inputs: NonMaxSuppressionV5Inputs,\n  backend: MathBackendWebGL,\n  attrs: NonMaxSuppressionV5Attrs\n}): [TensorInfo, TensorInfo] {\n  backend_util.warn(\n      'tf.nonMaxSuppression() in webgl locks the UI thread. ' +\n      'Call tf.nonMaxSuppressionAsync() instead');\n\n  const {inputs, backend, attrs} = args;\n  const {boxes, scores} = inputs;\n  const {maxOutputSize, iouThreshold, scoreThreshold, softNmsSigma} = attrs;\n\n  const boxesVals = backend.readSync(boxes.dataId) as TypedArray;\n  const scoresVals = backend.readSync(scores.dataId) as TypedArray;\n\n  const maxOutputSizeVal = maxOutputSize;\n  const iouThresholdVal = iouThreshold;\n  const scoreThresholdVal = scoreThreshold;\n  const softNmsSigmaVal = softNmsSigma;\n\n  const {selectedIndices, selectedScores} = nonMaxSuppressionV5Impl(\n      boxesVals, scoresVals, maxOutputSizeVal, iouThresholdVal,\n      scoreThresholdVal, softNmsSigmaVal);\n\n  return [\n    backend.makeTensorInfo(\n        [selectedIndices.length], 'int32', new Int32Array(selectedIndices)),\n    backend.makeTensorInfo(\n        [selectedScores.length], 'float32', new Float32Array(selectedScores))\n  ];\n}\n\nexport const nonMaxSuppressionV5Config: KernelConfig = {\n  kernelName: NonMaxSuppressionV5,\n  backendName: 'webgl',\n  kernelFunc: nonMaxSuppressionV5 as {} as KernelFunc\n};\n","/**\n * @license\n * Copyright 2017 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {GPGPUProgram} from './gpgpu_math';\n\nexport class OneHotProgram implements GPGPUProgram {\n  variableNames = ['indices'];\n  outputShape: number[];\n  userCode: string;\n\n  // Caching uniform location for speed.\n  seedLoc: WebGLUniformLocation;\n\n  constructor(\n      numIndices: number, depth: number, onValue: number, offValue: number) {\n    this.outputShape = [numIndices, depth];\n\n    this.userCode = `\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int index = round(getIndices(coords.x));\n        setOutput(mix(float(${offValue}), float(${onValue}),\n                      float(index == coords.y)));\n      }\n    `;\n  }\n}\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {KernelConfig, KernelFunc, OneHot, OneHotAttrs, OneHotInputs, TensorInfo, util} from '@tensorflow/tfjs-core';\n\nimport {MathBackendWebGL} from '../backend_webgl';\nimport {OneHotProgram} from '../onehot_gpu';\nimport {reshape} from './Reshape';\n\nexport const oneHot = (args: {\n  inputs: OneHotInputs,\n  backend: MathBackendWebGL,\n  attrs: OneHotAttrs\n}): TensorInfo => {\n  const {inputs, backend, attrs} = args;\n  const {indices} = inputs;\n  const {dtype, depth, onValue, offValue} = attrs;\n\n  const indicesSize = util.sizeFromShape(indices.shape);\n  const program = new OneHotProgram(indicesSize, depth, onValue, offValue);\n  const reshaped =\n      reshape({inputs: {x: indices}, backend, attrs: {shape: [indicesSize]}});\n  const result = backend.runWebGLProgram(program, [reshaped], dtype);\n  backend.disposeIntermediateTensorInfo(reshaped);\n\n  const outShape = [...indices.shape, depth];\n  const out = reshape({inputs: {x: result}, backend, attrs: {shape: outShape}});\n  backend.disposeIntermediateTensorInfo(result);\n  return out;\n};\n\nexport const oneHotConfig: KernelConfig = {\n  kernelName: OneHot,\n  backendName: 'webgl',\n  kernelFunc: oneHot as {} as KernelFunc\n};\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {KernelConfig, KernelFunc, TensorInfo, ZerosLike, ZerosLikeInputs} from '@tensorflow/tfjs-core';\n\nimport {MathBackendWebGL} from '../backend_webgl';\n\nimport {complex} from './Complex';\nimport {fill} from './Fill';\nimport {imag} from './Imag';\nimport {real} from './Real';\n\nexport function zerosLike(\n    args: {inputs: ZerosLikeInputs, backend: MathBackendWebGL}): TensorInfo {\n  const {inputs, backend} = args;\n  const {x} = inputs;\n\n  if (x.dtype === 'complex64') {\n    const realPart = real({inputs: {input: x}, backend});\n    const r = zerosLike({inputs: {x: realPart}, backend});\n    const imagPart = imag({inputs: {input: x}, backend});\n    const i = zerosLike({inputs: {x: imagPart}, backend});\n\n    const result = complex({inputs: {real: r, imag: i}, backend});\n\n    backend.disposeIntermediateTensorInfo(realPart);\n    backend.disposeIntermediateTensorInfo(r);\n    backend.disposeIntermediateTensorInfo(imagPart);\n    backend.disposeIntermediateTensorInfo(i);\n\n    return result;\n  } else {\n    return fill({\n      attrs: {\n        shape: x.shape,\n        dtype: x.dtype,\n        value: x.dtype === 'string' ? '' : 0\n      },\n      backend\n    });\n  }\n}\n\nexport const zerosLikeConfig: KernelConfig = {\n  kernelName: ZerosLike,\n  backendName: 'webgl',\n  kernelFunc: zerosLike as {} as KernelFunc\n};\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {KernelConfig, KernelFunc, OnesLike, OnesLikeInputs, TensorInfo} from '@tensorflow/tfjs-core';\n\nimport {MathBackendWebGL} from '../backend_webgl';\n\nimport {complex} from './Complex';\nimport {fill} from './Fill';\nimport {imag} from './Imag';\nimport {real} from './Real';\nimport {zerosLike} from './ZerosLike';\n\nexport function onesLike(\n    args: {inputs: OnesLikeInputs, backend: MathBackendWebGL}): TensorInfo {\n  const {inputs, backend} = args;\n  const {x} = inputs;\n\n  if (x.dtype === 'string') {\n    throw new Error('onesLike is not supported under string dtype');\n  } else if (x.dtype === 'complex64') {\n    const realPart = real({inputs: {input: x}, backend});\n    const r = onesLike({inputs: {x: realPart}, backend});\n    const imagPart = imag({inputs: {input: x}, backend});\n    const i = zerosLike({inputs: {x: imagPart}, backend});\n\n    const result = complex({inputs: {real: r, imag: i}, backend});\n\n    backend.disposeIntermediateTensorInfo(realPart);\n    backend.disposeIntermediateTensorInfo(r);\n    backend.disposeIntermediateTensorInfo(imagPart);\n    backend.disposeIntermediateTensorInfo(i);\n\n    return result;\n  } else {\n    // TODO(cais, smilkov): Add WebGL shader for onesLike:\n    //   https://github.com/tensorflow/tfjs/issues/1293\n    return fill({attrs: {shape: x.shape, dtype: x.dtype, value: 1}, backend});\n  }\n}\n\nexport const onesLikeConfig: KernelConfig = {\n  kernelName: OnesLike,\n  backendName: 'webgl',\n  kernelFunc: onesLike as {} as KernelFunc\n};\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {KernelConfig, KernelFunc, Pack, PackAttrs, PackInputs, TensorInfo, util} from '@tensorflow/tfjs-core';\n\nimport {MathBackendWebGL} from '../backend_webgl';\nimport {concat} from './Concat';\nimport {expandDims} from './ExpandDims';\n\nexport function pack(\n    args: {inputs: PackInputs, backend: MathBackendWebGL, attrs: PackAttrs}):\n    TensorInfo {\n  const {inputs, backend, attrs} = args;\n  const {axis} = attrs;\n\n  if (inputs.length === 1) {\n    return expandDims(\n        {inputs: {input: inputs[0]}, backend, attrs: {dim: axis}});\n  }\n\n  const shape = inputs[0].shape;\n  const dtype = inputs[0].dtype;\n\n  inputs.forEach(t => {\n    util.assertShapesMatch(\n        shape, t.shape,\n        'All tensors passed to stack must have matching shapes');\n    util.assert(\n        dtype === t.dtype,\n        () => 'All tensors passed to stack must have matching dtypes');\n  });\n\n  const intermediateTensorInfos: TensorInfo[] = [];\n  const expandedTensors = inputs.map(t => {\n    const expandedT =\n        expandDims({inputs: {input: t}, backend, attrs: {dim: axis}});\n    intermediateTensorInfos.push(expandedT);\n    return expandedT;\n  });\n\n  const result = concat({inputs: expandedTensors, backend, attrs: {axis}});\n\n  intermediateTensorInfos.forEach(\n      t => backend.disposeIntermediateTensorInfo(t));\n\n  return result;\n}\n\nexport const packConfig: KernelConfig = {\n  kernelName: Pack,\n  backendName: 'webgl',\n  kernelFunc: pack as {} as KernelFunc\n};\n","/**\n * @license\n * Copyright 2017 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {GPGPUProgram} from './gpgpu_math';\nimport {getCoordsDataType, UniformType} from './shader_compiler';\n\nexport class PadProgram implements GPGPUProgram {\n  variableNames = ['x'];\n  outputShape: number[];\n  userCode: string;\n  customUniforms = [{name: 'value', type: 'float' as UniformType}];\n\n  constructor(\n      xShape: number[], paddings: Array<[number, number]>,\n      constantValue: number) {\n    this.outputShape = paddings.map(\n        (p, i) => p[0] /* beforePad */ + xShape[i] + p[1] /* afterPad */);\n    const rank = xShape.length;\n    const type = getCoordsDataType(rank);\n\n    const start = paddings.map(p => p[0]).join(',');\n    const end = paddings.map((p, i) => p[0] + xShape[i]).join(',');\n    const unpackedCoords =\n        ['coords[0]', 'coords[1]', 'coords[2]', 'coords[3]'].slice(0, rank);\n\n    if (rank === 1) {\n      this.userCode = `\n        int start = ${start};\n        int end = ${end};\n\n        void main() {\n          int outC = getOutputCoords();\n          if (outC < start || outC >= end) {\n            setOutput(value);\n          } else {\n            setOutput(getX(outC - start));\n          }\n        }\n      `;\n      return;\n    }\n    this.userCode = `\n      ${type} start = ${type}(${start});\n      ${type} end = ${type}(${end});\n\n      void main() {\n        ${type} outC = getOutputCoords();\n        if (any(lessThan(outC, start)) || any(greaterThanEqual(outC, end))) {\n          setOutput(value);\n        } else {\n          ${type} coords = outC - start;\n          setOutput(getX(${unpackedCoords}));\n        }\n      }\n    `;\n  }\n}\n","/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {GPGPUProgram} from './gpgpu_math';\nimport {getChannels} from './packing_util';\nimport {getCoordsDataType, UniformType} from './shader_compiler';\n\nexport class PadPackedProgram implements GPGPUProgram {\n  variableNames = ['x'];\n  packedInputs = true;\n  packedOutput = true;\n  outputShape: number[];\n  userCode: string;\n  customUniforms = [{name: 'value', type: 'float' as UniformType}];\n\n  constructor(\n      xShape: number[], paddings: Array<[number, number]>,\n      constantValue: number) {\n    this.outputShape = paddings.map(\n        (p, i) => p[0] /* beforePad */ + xShape[i] + p[1] /* afterPad */);\n    const rank = xShape.length;\n    const dtype = getCoordsDataType(rank);\n\n    const start = paddings.map(p => p[0]).join(',');\n    const end = paddings.map((p, i) => p[0] + xShape[i]).join(',');\n    const coords = getChannels('rc', rank);\n    const source = getChannels('source', rank);\n    const cLimit = `${coords[rank - 1]} < ${this.outputShape[rank - 1]}`;\n    const innerDims =\n        rank === 1 ? 'source' : `vec2(${source.slice(-2).join()})`;\n\n    const componentSetup = [\n      `${dtype} rc = outputLoc;`, `${coords[rank - 1]} += 1;\n       if(${cLimit}) {\n      `,\n      rank === 1 ? '' : `}\n       rc = outputLoc;\n       ${coords[rank - 2]} += 1;\n       if(${coords[rank - 2]} < ${this.outputShape[rank - 2]}) {`,\n      rank === 1 ? '' : `  ${coords[rank - 1]} += 1;\n         if(${cLimit}) {`\n    ];\n\n    const paddingArea = rank === 1 ?\n        'rc < start || rc >= end' :\n        'any(lessThan(rc, start)) || any(greaterThanEqual(rc, end))';\n    let mainLoop = '';\n    for (let i = 0, j = rank === 1 ? 2 : 4; i < j; i++) {\n      mainLoop += `\n        ${componentSetup[i]}\n        if (${paddingArea}) {\n          result[${i}] = float(value);\n        } else {\n          ${dtype} source = rc - start;\n          result[${i}] = getChannel(getX(${source.join()}), ${innerDims});\n        }\n      `;\n    }\n    mainLoop += (rank === 1 ? `} ` : `}}`);\n\n    this.userCode = `\n      const ${dtype} start = ${dtype}(${start});\n      const ${dtype} end = ${dtype}(${end});\n\n      void main() {\n        ${dtype} outputLoc = getOutputCoords();\n        vec4 result = vec4(0.);\n        ${mainLoop}\n        setOutput(result);\n      }\n    `;\n  }\n}\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {env, KernelConfig, KernelFunc, PadV2, PadV2Attrs, PadV2Inputs, TensorInfo, util} from '@tensorflow/tfjs-core';\n\nimport {MathBackendWebGL} from '../backend_webgl';\nimport {PadProgram} from '../pad_gpu';\nimport {PadPackedProgram} from '../pad_packed_gpu';\nimport {fill} from './Fill';\n\nexport const padV2 =\n    (args: {inputs: PadV2Inputs, backend: MathBackendWebGL, attrs: PadV2Attrs}):\n        TensorInfo => {\n          const {inputs, backend, attrs} = args;\n          const {x} = inputs;\n          const {paddings, constantValue} = attrs;\n\n          if (util.sizeFromShape(x.shape) === 0) {\n            // Short-circuit the computation, since x doesn't have value, only\n            // the shape is used to compute output shape to pad.\n            const outputShape = paddings.map(\n                (p, i) =>\n                    p[0] /* beforePad */ + x.shape[i] + p[1] /* afterPad */);\n            return fill({\n              backend,\n              attrs: {shape: outputShape, value: constantValue, dtype: x.dtype}\n            });\n          }\n\n          const program = env().getBool('WEBGL_PACK_ARRAY_OPERATIONS') ?\n              new PadPackedProgram(x.shape, paddings, constantValue) :\n              new PadProgram(x.shape, paddings, constantValue);\n          const customValues = [[constantValue]];\n          return backend.runWebGLProgram(program, [x], x.dtype, customValues);\n        };\n\nexport const padV2Config: KernelConfig = {\n  kernelName: PadV2,\n  backendName: 'webgl',\n  kernelFunc: padV2 as {} as KernelFunc\n};\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {KernelConfig, KernelFunc, Pow} from '@tensorflow/tfjs-core';\n\nimport {CHECK_NAN_SNIPPET_PACKED} from '../binaryop_packed_gpu';\nimport {binaryKernelFunc} from '../kernel_utils/kernel_funcs_utils';\n\nconst POW = `\n  if(a < 0.0 && floor(b) < b){\n    return NAN;\n  }\n  if (b == 0.0) {\n    return 1.0;\n  }\n  return (round(mod(b, 2.0)) != 1) ?\n      pow(abs(a), b) : sign(a) * pow(abs(a), b);\n`;\n\nconst POW_PACKED = `\n  // isModRound1 has 1 for components with round(mod(b, 2.0)) == 1, 0 otherwise.\n  vec4 isModRound1 = vec4(equal(round(mod(b, 2.0)), ivec4(1)));\n  vec4 multiplier = sign(a) * isModRound1 + (vec4(1.0) - isModRound1);\n  vec4 result = multiplier * pow(abs(a), b);\n\n  // Ensure that a^0 = 1, including 0^0 = 1 as this correspond to TF and JS\n  bvec4 isExpZero = equal(b, vec4(0.0));\n  result.r = isExpZero.r ? 1.0 : result.r;\n  result.g = isExpZero.g ? 1.0 : result.g;\n  result.b = isExpZero.b ? 1.0 : result.b;\n  result.a = isExpZero.a ? 1.0 : result.a;\n\n  bvec4 isNaN1 = lessThan(a, vec4(0.0));\n  bvec4 isNaN2 = lessThan(floor(b), b);\n  bvec4 isNaN = bvec4(isNaN1.x && isNaN2.x, isNaN1.y && isNaN2.y, isNaN1.z && isNaN2.z, isNaN1.w && isNaN2.w);\n  ` +\n    CHECK_NAN_SNIPPET_PACKED + `\n  return result;\n`;\n\nexport const pow =\n    binaryKernelFunc({opSnippet: POW, packedOpSnippet: POW_PACKED});\n\nexport const powConfig: KernelConfig = {\n  kernelName: Pow,\n  backendName: 'webgl',\n  kernelFunc: pow as {} as KernelFunc\n};\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {backend_util, KernelConfig, KernelFunc, Prod, ProdAttrs, ProdInputs, sumOutType, TensorInfo, TypedArray, util} from '@tensorflow/tfjs-core';\n\nimport {MathBackendWebGL} from '../backend_webgl';\nimport {reduce} from '../kernel_utils/reduce';\nimport {prodImplCPU} from '../kernel_utils/shared';\n\nimport {reshape} from './Reshape';\nimport {transpose} from './Transpose';\n\nexport function prod(\n    args: {inputs: ProdInputs, backend: MathBackendWebGL, attrs: ProdAttrs}):\n    TensorInfo {\n  const {inputs, backend, attrs} = args;\n  const {x} = inputs;\n  const {axis, keepDims} = attrs;\n\n  const xRank = x.shape.length;\n  const toDispose = [];\n\n  const origAxes = util.parseAxisParam(axis, x.shape);\n  let axes = origAxes;\n  const permutedAxes = backend_util.getAxesPermutation(axes, xRank);\n  let permutedX = x;\n  if (permutedAxes != null) {\n    permutedX = transpose({inputs: {x}, backend, attrs: {perm: permutedAxes}});\n    axes = backend_util.getInnerMostAxes(axes.length, xRank);\n    toDispose.push(permutedX);\n  }\n\n  backend_util.assertAxesAreInnerMostDims('prod', axes, xRank);\n\n  let res;\n  if (backend.shouldExecuteOnCPU([permutedX])) {\n    const xVals = backend.texData.get(permutedX.dataId).values as TypedArray;\n    const {outVals, outShape, outDtype} =\n        prodImplCPU(permutedX.shape, permutedX.dtype, xVals, axes);\n    res = backend.makeTensorInfo(outShape, outDtype, outVals);\n  } else {\n    const [outShape, reduceShape] =\n        backend_util.computeOutAndReduceShapes(permutedX.shape, axes);\n    const inSize = util.sizeFromShape(reduceShape);\n    const a2D = reshape(\n        {inputs: {x: permutedX}, backend, attrs: {shape: [-1, inSize]}});\n    const outputDType = sumOutType(x.dtype);\n    const reduced = reduce(a2D, outputDType, 'prod', backend);\n    res = reshape({inputs: {x: reduced}, backend, attrs: {shape: outShape}});\n\n    toDispose.push(a2D);\n    toDispose.push(reduced);\n  }\n\n  if (keepDims) {\n    toDispose.push(res);\n    const newShape = backend_util.expandShapeToKeepDim(res.shape, origAxes);\n    res = reshape({inputs: {x: res}, backend, attrs: {shape: newShape}});\n  }\n\n  toDispose.forEach(t => backend.disposeIntermediateTensorInfo(t));\n\n  return res;\n}\n\nexport const prodConfig: KernelConfig = {\n  kernelName: Prod,\n  backendName: 'webgl',\n  kernelFunc: prod as {} as KernelFunc\n};\n","/**\n * @license\n * Copyright 2022 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {KernelConfig, KernelFunc, RaggedGather, RaggedGatherAttrs, RaggedGatherInputs, TensorInfo, TypedArray} from '@tensorflow/tfjs-core';\n\nimport {MathBackendWebGL} from '../backend_webgl';\nimport {raggedGatherImplCPU} from '../kernel_utils/shared';\n\nexport function raggedGather(args: {\n  inputs: RaggedGatherInputs,\n  backend: MathBackendWebGL,\n  attrs: RaggedGatherAttrs\n}): TensorInfo[] {\n  const {inputs, backend, attrs} = args;\n  const {paramsNestedSplits, paramsDenseValues, indices} = inputs;\n  const {outputRaggedRank} = attrs;\n\n  const $paramsNestedSplits =\n      paramsNestedSplits.map(t => backend.readSync(t.dataId) as TypedArray);\n  const $paramsNestedSplitsShapes = paramsNestedSplits.map(t => t.shape);\n  const $paramsDenseValues =\n      backend.readSync(paramsDenseValues.dataId) as TypedArray;\n  const $indices = backend.readSync(indices.dataId) as TypedArray;\n\n  const [outputNestedSplits, outputDenseValues, outputDenseValuesShape] =\n      raggedGatherImplCPU(\n          $paramsNestedSplits, $paramsNestedSplitsShapes, $paramsDenseValues,\n          paramsDenseValues.shape, paramsDenseValues.dtype, $indices,\n          indices.shape, outputRaggedRank);\n\n  const outputNestedSplitsTensors = outputNestedSplits.map(\n      (splits) => backend.makeTensorInfo([splits.length], 'int32', splits));\n\n  const outputDenseValuesTensor = backend.makeTensorInfo(\n      outputDenseValuesShape, paramsDenseValues.dtype, outputDenseValues);\n\n  return outputNestedSplitsTensors.concat([outputDenseValuesTensor]);\n}\n\nexport const raggedGatherConfig: KernelConfig = {\n  kernelName: RaggedGather,\n  backendName: 'webgl',\n  kernelFunc: raggedGather as {} as KernelFunc,\n};\n","/**\n * @license\n * Copyright 2022 Google LLC.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {KernelConfig, KernelFunc, RaggedRange, RaggedRangeInputs, TensorInfo, TypedArray} from '@tensorflow/tfjs-core';\n\nimport {MathBackendWebGL} from '../backend_webgl';\nimport {raggedRangeImplCPU} from '../kernel_utils/shared';\n\nexport function raggedRange(\n    args: {inputs: RaggedRangeInputs, backend: MathBackendWebGL}):\n    [TensorInfo, TensorInfo] {\n  const {inputs, backend} = args;\n  const {starts, limits, deltas} = inputs;\n\n  const $starts = backend.readSync(starts.dataId) as TypedArray;\n  const $limits = backend.readSync(limits.dataId) as TypedArray;\n  const $deltas = backend.readSync(deltas.dataId) as TypedArray;\n\n  const [rtNestedSplitsData, rtDenseValuesData] = raggedRangeImplCPU(\n      $starts, starts.shape, starts.dtype, $limits, limits.shape, $deltas,\n      deltas.shape);\n\n  const rtNestedSplits = backend.makeTensorInfo(\n      [rtNestedSplitsData.length], 'int32', rtNestedSplitsData);\n  const rtDenseValues = backend.makeTensorInfo(\n      [rtDenseValuesData.length], starts.dtype, rtDenseValuesData);\n\n  return [rtNestedSplits, rtDenseValues];\n}\n\nexport const raggedRangeConfig: KernelConfig = {\n  kernelName: RaggedRange,\n  backendName: 'webgl',\n  kernelFunc: raggedRange as {} as KernelFunc,\n};\n","/**\n * @license\n * Copyright 2022 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {KernelConfig, KernelFunc, RaggedTensorToTensor, RaggedTensorToTensorAttrs, RaggedTensorToTensorInputs, TensorInfo, TypedArray} from '@tensorflow/tfjs-core';\n\nimport {MathBackendWebGL} from '../backend_webgl';\nimport {raggedTensorToTensorImplCPU} from '../kernel_utils/shared';\n\nexport function raggedTensorToTensor(args: {\n  inputs: RaggedTensorToTensorInputs,\n  backend: MathBackendWebGL,\n  attrs: RaggedTensorToTensorAttrs\n}): TensorInfo {\n  const {inputs, backend, attrs} = args;\n  const {shape, values, defaultValue, rowPartitionTensors} = inputs;\n  const {rowPartitionTypes} = attrs;\n\n  const $shape = backend.readSync(shape.dataId) as TypedArray;\n  const $values = backend.readSync(values.dataId) as TypedArray;\n  const $defaultValue = backend.readSync(defaultValue.dataId) as TypedArray;\n  const $rowPartitionValues =\n      rowPartitionTensors.map(t => backend.readSync(t.dataId) as TypedArray);\n  const rowPartitionValuesShapes = rowPartitionTensors.map(t => t.shape);\n\n  const [outputShape, output] = raggedTensorToTensorImplCPU(\n      $shape, shape.shape, $values, values.shape, values.dtype, $defaultValue,\n      defaultValue.shape, $rowPartitionValues, rowPartitionValuesShapes,\n      rowPartitionTypes);\n  return backend.makeTensorInfo(outputShape, values.dtype, output);\n}\n\nexport const raggedTensorToTensorConfig: KernelConfig = {\n  kernelName: RaggedTensorToTensor,\n  backendName: 'webgl',\n  kernelFunc: raggedTensorToTensor as {} as KernelFunc,\n};\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {KernelConfig, KernelFunc, Range, RangeAttrs, TensorInfo} from '@tensorflow/tfjs-core';\n\nimport {MathBackendWebGL} from '../backend_webgl';\nimport {rangeImplCPU} from '../kernel_utils/shared';\n\nexport const range =\n    (args: {backend: MathBackendWebGL, attrs: RangeAttrs}): TensorInfo => {\n      const {backend, attrs} = args;\n      const {start, stop, step, dtype} = attrs;\n      const values = rangeImplCPU(start, stop, step, dtype);\n      return backend.makeTensorInfo([values.length], dtype, values);\n    };\n\nexport const rangeConfig: KernelConfig = {\n  kernelName: Range,\n  backendName: 'webgl',\n  kernelFunc: range as {} as KernelFunc\n};\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {KernelConfig, Reciprocal} from '@tensorflow/tfjs-core';\nimport {unaryKernelFunc} from '../kernel_utils/kernel_funcs_utils';\n\nconst RECIPROCAL = `return 1.0 / x;`;\n\nexport const reciprocal = unaryKernelFunc({opSnippet: RECIPROCAL});\n\nexport const reciprocalConfig: KernelConfig = {\n  kernelName: Reciprocal,\n  backendName: 'webgl',\n  kernelFunc: reciprocal,\n};\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {KernelConfig, KernelFunc, Relu} from '@tensorflow/tfjs-core';\nimport {unaryKernelFunc} from '../kernel_utils/kernel_funcs_utils';\nimport {CHECK_NAN_SNIPPET} from '../unaryop_gpu';\n\nconst RELU = CHECK_NAN_SNIPPET + `\n  return (x < 0.0) ? 0.0 : x;\n`;\n\nconst RELU_PACKED = `\n  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n`;\n\nexport const relu =\n    unaryKernelFunc({opSnippet: RELU, packedOpSnippet: RELU_PACKED});\n\nexport const reluConfig: KernelConfig = {\n  kernelName: Relu,\n  backendName: 'webgl',\n  kernelFunc: relu as {} as KernelFunc\n};\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {KernelConfig, KernelFunc, Relu6} from '@tensorflow/tfjs-core';\nimport {unaryKernelFunc} from '../kernel_utils/kernel_funcs_utils';\nimport {CHECK_NAN_SNIPPET} from '../unaryop_gpu';\n\nconst RELU6 = CHECK_NAN_SNIPPET + `\n  return (x < 0.0) ? 0.0 : min(6.0, x);\n`;\n\nconst RELU6_PACKED = `\n  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n`;\n\nexport const relu6 =\n    unaryKernelFunc({opSnippet: RELU6, packedOpSnippet: RELU6_PACKED});\n\nexport const relu6Config: KernelConfig = {\n  kernelName: Relu6,\n  backendName: 'webgl',\n  kernelFunc: relu6 as {} as KernelFunc\n};\n","/**\n * @license\n * Copyright 2017 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {GPGPUProgram} from './gpgpu_math';\n\nexport class ResizeBilinearProgram implements GPGPUProgram {\n  variableNames = ['A'];\n  outputShape: number[] = [];\n  userCode: string;\n\n  constructor(\n      inputShape: [number, number, number, number], newHeight: number,\n      newWidth: number, alignCorners: boolean, halfPixelCenters: boolean) {\n    const [batch, oldHeight, oldWidth, depth] = inputShape;\n    this.outputShape = [batch, newHeight, newWidth, depth];\n\n    const effectiveInSize: [number, number] = [\n      (alignCorners && newHeight > 1) ? oldHeight - 1 : oldHeight,\n      (alignCorners && newWidth > 1) ? oldWidth - 1 : oldWidth\n    ];\n\n    const effectiveOutSize: [number, number] = [\n      (alignCorners && newHeight > 1) ? newHeight - 1 : newHeight,\n      (alignCorners && newWidth > 1) ? newWidth - 1 : newWidth\n    ];\n\n    let sourceFracIndexRC: string;\n    if (halfPixelCenters) {\n      sourceFracIndexRC =\n          `(vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC` +\n          ` - vec2(0.5)`;\n    } else {\n      sourceFracIndexRC = `vec2(yRC) * effectiveInputOverOutputRatioRC`;\n    }\n\n    this.userCode = `\n      const vec2 effectiveInputOverOutputRatioRC = vec2(\n          ${effectiveInSize[0] / effectiveOutSize[0]},\n          ${effectiveInSize[1] / effectiveOutSize[1]});\n      const vec2 inputShapeRC = vec2(${oldHeight}.0, ${oldWidth}.0);\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        ivec2 yRC = coords.yz;\n\n        // Fractional source index.\n        vec2 sourceFracIndexRC = ${sourceFracIndexRC};\n\n        // Compute the four integer indices.\n        ivec2 sourceFloorRC = ivec2(max(sourceFracIndexRC, vec2(0.0)));\n        ivec2 sourceCeilRC = ivec2(\n          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));\n\n        float topLeft = getA(b, sourceFloorRC.x, sourceFloorRC.y, d);\n        float bottomLeft = getA(b, sourceCeilRC.x, sourceFloorRC.y, d);\n        float topRight = getA(b, sourceFloorRC.x, sourceCeilRC.y, d);\n        float bottomRight = getA(b, sourceCeilRC.x, sourceCeilRC.y, d);\n\n        vec2 fracRC = sourceFracIndexRC - vec2(sourceFloorRC);\n\n        float top = topLeft + (topRight - topLeft) * fracRC.y;\n        float bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;\n        float newValue = top + (bottom - top) * fracRC.x;\n\n        setOutput(newValue);\n      }\n    `;\n  }\n}\n","/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {GPGPUProgram} from './gpgpu_math';\n\nexport class ResizeBilinearPackedProgram implements GPGPUProgram {\n  variableNames = ['A'];\n  packedInputs = true;\n  packedOutput = true;\n  outputShape: number[] = [];\n  userCode: string;\n\n  constructor(\n      inputShape: [number, number, number, number], newHeight: number,\n      newWidth: number, alignCorners: boolean, halfPixelCenters: boolean) {\n    const [batch, oldHeight, oldWidth, depth] = inputShape;\n    this.outputShape = [batch, newHeight, newWidth, depth];\n\n    const effectiveInSize: [number, number] = [\n      (alignCorners && newHeight > 1) ? oldHeight - 1 : oldHeight,\n      (alignCorners && newWidth > 1) ? oldWidth - 1 : oldWidth\n    ];\n\n    const effectiveOutSize: [number, number] = [\n      (alignCorners && newHeight > 1) ? newHeight - 1 : newHeight,\n      (alignCorners && newWidth > 1) ? newWidth - 1 : newWidth\n    ];\n\n    let sourceFracIndexRC: string;\n    if (halfPixelCenters) {\n      sourceFracIndexRC = `(vec3(yRC) + vec3(0.5)) * ` +\n          `effectiveInputOverOutputRatioRC - vec3(0.5)`;\n    } else {\n      sourceFracIndexRC = `vec3(yRC) * effectiveInputOverOutputRatioRC`;\n    }\n\n    this.userCode = `\n      const vec3 effectiveInputOverOutputRatioRC = vec3(\n          ${effectiveInSize[0] / effectiveOutSize[0]},\n          ${effectiveInSize[1] / effectiveOutSize[1]},\n          ${effectiveInSize[1] / effectiveOutSize[1]});\n      const vec3 inputShapeRC = vec3(${oldHeight}.0, ${oldWidth}.0,\n                                     ${oldWidth}.0);\n\n      float getAValue(int b, int r, int c, int d) {\n        return getChannel(getA(b, r, c, d), vec2(c, d));\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        // Calculate values for next column in yRC.z.\n        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);\n\n        // Fractional source index.\n        vec3 sourceFracIndexRC = ${sourceFracIndexRC};\n\n        // Compute the four integer indices.\n        ivec3 sourceFloorRC = ivec3(max(sourceFracIndexRC, vec3(0.0)));\n        ivec3 sourceCeilRC = ivec3(\n          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));\n\n        // Should we calculate next column and row elements in 2x2 packed cell.\n        bool hasNextCol = d < ${depth - 1};\n        bool hasNextRow = coords.z < ${newWidth - 1};\n\n        // In parallel, construct four corners for all four components in\n        // packed 2x2 cell.\n        vec4 topLeft = vec4(\n          getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d),\n          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d + 1) : 0.0);\n\n        vec4 bottomLeft = vec4(\n          getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d),\n          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d + 1) : 0.0);\n\n        vec4 topRight = vec4(\n          getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d),\n          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d + 1) : 0.0);\n\n        vec4 bottomRight = vec4(\n          getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d),\n          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d + 1) : 0.0);\n\n        vec3 fracRC = sourceFracIndexRC - vec3(sourceFloorRC);\n\n        vec4 top = mix(topLeft, topRight, fracRC.yyzz);\n        vec4 bottom = mix(bottomLeft, bottomRight, fracRC.yyzz);\n        vec4 newValue = mix(top, bottom, fracRC.x);\n\n        setOutput(newValue);\n      }\n    `;\n  }\n}\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {env, KernelConfig, KernelFunc, ResizeBilinear, ResizeBilinearAttrs, ResizeBilinearInputs, TensorInfo} from '@tensorflow/tfjs-core';\n\nimport {MathBackendWebGL} from '../backend_webgl';\nimport {ResizeBilinearProgram} from '../resize_bilinear_gpu';\nimport {ResizeBilinearPackedProgram} from '../resize_bilinear_packed_gpu';\n\nexport function resizeBilinear(args: {\n  inputs: ResizeBilinearInputs,\n  backend: MathBackendWebGL,\n  attrs: ResizeBilinearAttrs\n}): TensorInfo {\n  const {inputs, backend, attrs} = args;\n  const {images} = inputs;\n  const {alignCorners, halfPixelCenters, size} = attrs;\n\n  const [newHeight, newWidth] = size;\n\n  const program = env().getBool('WEBGL_PACK_IMAGE_OPERATIONS') ?\n      new ResizeBilinearPackedProgram(\n          images.shape as [number, number, number, number], newHeight, newWidth,\n          alignCorners, halfPixelCenters) :\n      new ResizeBilinearProgram(\n          images.shape as [number, number, number, number], newHeight, newWidth,\n          alignCorners, halfPixelCenters);\n  return backend.runWebGLProgram(program, [images], 'float32');\n}\n\nexport const resizeBilinearConfig: KernelConfig = {\n  kernelName: ResizeBilinear,\n  backendName: 'webgl',\n  kernelFunc: resizeBilinear as {} as KernelFunc\n};\n","/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {GPGPUProgram} from './gpgpu_math';\n\nexport class ResizeBilinearBackpropProgram implements GPGPUProgram {\n  variableNames = ['dy'];\n  outputShape: number[] = [];\n  userCode: string;\n\n  constructor(\n      dyShape: [number, number, number, number],\n      inputShape: [number, number, number, number], alignCorners: boolean) {\n    this.outputShape = inputShape;\n    const [, xHeight, xWidth, ] = inputShape;\n    const [, yHeight, yWidth] = dyShape;\n\n    // In the backwards pass, we want to find the pixels that were generated for\n    // each pixel in the input image the forward pass and add the corresponding\n    // coefficient from dy to the gradient (with some interpolation).\n\n    const effectiveXSize: [number, number] = [\n      (alignCorners && yHeight > 1) ? xHeight - 1 : xHeight,\n      (alignCorners && yWidth > 1) ? xWidth - 1 : xWidth\n    ];\n\n    const effectiveYSize: [number, number] = [\n      (alignCorners && yHeight > 1) ? yHeight - 1 : yHeight,\n      (alignCorners && yWidth > 1) ? yWidth - 1 : yWidth\n    ];\n\n    const heightScale = effectiveXSize[0] / effectiveYSize[0];\n    const widthScale = effectiveXSize[1] / effectiveYSize[1];\n\n    const invHeightScale = 1 / heightScale;\n    const invWidthScale = 1 / widthScale;\n\n    // This defines the size of the window of values around a particular\n    // index in dy that we want to search for contributions to dx.\n    const winHeight = (Math.ceil(invHeightScale) * 2) + 2;\n    const winWidth = (Math.ceil(invWidthScale) * 2) + 2;\n\n    this.userCode = `\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        int r = coords[1];\n        int c = coords[2];\n\n        float accumulator = 0.0;\n\n        const float heightScale = float(${heightScale});\n        const float widthScale = float(${widthScale});\n\n        const float invHeightScale = float(${invHeightScale});\n        const float invWidthScale = float(${invWidthScale});\n\n        const int winHeight = int(${winHeight});\n        const int winWidth = int(${winWidth});\n\n        // Compute bounds for where in dy we will look\n        float startRLerp = floor(float(r) * invHeightScale);\n        int startDyR = int(startRLerp - float(winHeight / 2));\n\n        float startCLerp = floor(float(c) * invWidthScale);\n        int startDyC = int(startCLerp - float(winWidth / 2));\n\n        // Loop over dy\n        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {\n          int dyR = dyROffset + startDyR;\n\n          // Guard against the window exceeding the bounds of dy\n          if (dyR < 0 || dyR >= ${yHeight}) {\n            continue;\n          }\n\n          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {\n            int dyC = dyCOffset + startDyC;\n\n            // Guard against the window exceeding the bounds of dy\n            if (dyC < 0 || dyC >= ${yWidth}) {\n              continue;\n            }\n\n            float dxR = float(dyR) * heightScale;\n            int topDxRIndex = int(floor(dxR));\n            int bottomDxRIndex = int(min(ceil(dxR), ${xHeight - 1}.0));\n            float dxRLerp = dxR - float(topDxRIndex);\n            float inverseDxRLerp = 1.0 - dxRLerp;\n\n            float dxC = float(dyC) * widthScale;\n            int leftDxCIndex = int(floor(dxC));\n            int rightDxCIndex = int(min(ceil(dxC), ${xWidth - 1}.0));\n            float dxCLerp = dxC - float(leftDxCIndex);\n            float inverseDxCLerp = 1.0 - dxCLerp;\n\n            if (r == topDxRIndex && c == leftDxCIndex) {\n              // topLeft\n              accumulator +=\n                getDy(b, dyR, dyC, d) * inverseDxRLerp * inverseDxCLerp;\n            }\n\n            if (r == topDxRIndex && c == rightDxCIndex) {\n              // topRight\n              accumulator += getDy(b, dyR, dyC, d) * inverseDxRLerp * dxCLerp;\n            }\n\n            if (r == bottomDxRIndex && c == leftDxCIndex) {\n              // bottomLeft\n              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * inverseDxCLerp;\n            }\n\n            if (r == bottomDxRIndex && c == rightDxCIndex) {\n              // bottomRight\n              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * dxCLerp;\n            }\n          }\n        }\n        // End loop over dy\n\n        setOutput(accumulator);\n      }\n    `;\n  }\n}\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {KernelConfig, KernelFunc, ResizeBilinearGrad, ResizeBilinearGradAttrs, ResizeBilinearGradInputs, TensorInfo} from '@tensorflow/tfjs-core';\n\nimport {MathBackendWebGL} from '../backend_webgl';\nimport {ResizeBilinearBackpropProgram} from '../resize_bilinear_backprop_gpu';\n\nexport function resizeBilinearGrad(args: {\n  inputs: ResizeBilinearGradInputs,\n  backend: MathBackendWebGL,\n  attrs: ResizeBilinearGradAttrs\n}): TensorInfo {\n  const {inputs, backend, attrs} = args;\n  const {images, dy} = inputs;\n  const {alignCorners} = attrs;\n\n  const program = new ResizeBilinearBackpropProgram(\n      dy.shape as [number, number, number, number],\n      images.shape as [number, number, number, number], alignCorners);\n\n  return backend.runWebGLProgram(program, [dy], dy.dtype);\n}\n\nexport const resizeBilinearGradConfig: KernelConfig = {\n  kernelName: ResizeBilinearGrad,\n  backendName: 'webgl',\n  kernelFunc: resizeBilinearGrad as {} as KernelFunc\n};\n","/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {GPGPUProgram} from './gpgpu_math';\n\nexport class ResizeNearestNeighborProgram implements GPGPUProgram {\n  variableNames = ['A'];\n  outputShape: number[] = [];\n  userCode: string;\n\n  constructor(\n      inputShape: [number, number, number, number], newHeight: number,\n      newWidth: number, alignCorners: boolean, halfPixelCenters: boolean) {\n    const [batch, oldHeight, oldWidth, depth] = inputShape;\n    this.outputShape = [batch, newHeight, newWidth, depth];\n\n    const effectiveInSize: [number, number] = [\n      (alignCorners && newHeight > 1) ? oldHeight - 1 : oldHeight,\n      (alignCorners && newWidth > 1) ? oldWidth - 1 : oldWidth\n    ];\n\n    const effectiveOutSize: [number, number] = [\n      (alignCorners && newHeight > 1) ? newHeight - 1 : newHeight,\n      (alignCorners && newWidth > 1) ? newWidth - 1 : newWidth\n    ];\n\n    // When align corners is false, we rounds the value with floor.\n    const roundBase = alignCorners ? '0.5' : '0.0';\n\n    let sourceFracIndexRC: string;\n    if (halfPixelCenters) {\n      sourceFracIndexRC =\n          `max((vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC` +\n          `, vec2(0.0))`;\n    } else {\n      sourceFracIndexRC = `vec2(yRC) * effectiveInputOverOutputRatioRC`;\n    }\n    this.userCode = `\n      const vec2 effectiveInputOverOutputRatioRC = vec2(\n          ${effectiveInSize[0] / effectiveOutSize[0]},\n          ${effectiveInSize[1] / effectiveOutSize[1]});\n      const vec2 inputShapeRC = vec2(${oldHeight}.0, ${oldWidth}.0);\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        ivec2 yRC = coords.yz;\n\n        // Fractional source index.\n        vec2 sourceFracIndexRC = ${sourceFracIndexRC};\n\n        // Compute the coordinators of nearest neighbor point.\n        ivec2 sourceNearestRC = ivec2(\n          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${roundBase})));\n        float newValue = getA(b, sourceNearestRC.x, sourceNearestRC.y, d);\n\n        setOutput(newValue);\n      }\n    `;\n  }\n}\n","/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {GPGPUProgram} from './gpgpu_math';\n\nexport class ResizeNearestNeighborPackedProgram implements GPGPUProgram {\n  variableNames = ['A'];\n  packedInputs = true;\n  packedOutput = true;\n  outputShape: number[] = [];\n  userCode: string;\n\n  constructor(\n      inputShape: [number, number, number, number], newHeight: number,\n      newWidth: number, alignCorners: boolean, halfPixelCenters: boolean) {\n    const [batch, oldHeight, oldWidth, depth] = inputShape;\n    this.outputShape = [batch, newHeight, newWidth, depth];\n\n    const effectiveInSize: [number, number] = [\n      (alignCorners && newHeight > 1) ? oldHeight - 1 : oldHeight,\n      (alignCorners && newWidth > 1) ? oldWidth - 1 : oldWidth\n    ];\n\n    const effectiveOutSize: [number, number] = [\n      (alignCorners && newHeight > 1) ? newHeight - 1 : newHeight,\n      (alignCorners && newWidth > 1) ? newWidth - 1 : newWidth\n    ];\n\n    // When align corners is false, we rounds the value with floor.\n    const roundBase = alignCorners ? '0.5' : '0.0';\n    let sourceFracIndexRC: string;\n    if (halfPixelCenters) {\n      sourceFracIndexRC = `max((vec3(yRC) + vec3(0.5)) * ` +\n          `effectiveInputOverOutputRatioRC, vec3(0.0))`;\n    } else {\n      sourceFracIndexRC = `vec3(yRC) * effectiveInputOverOutputRatioRC`;\n    }\n\n    this.userCode = `\n      const vec3 effectiveInputOverOutputRatioRC = vec3(\n          ${effectiveInSize[0] / effectiveOutSize[0]},\n          ${effectiveInSize[1] / effectiveOutSize[1]},\n          ${effectiveInSize[1] / effectiveOutSize[1]});\n      const vec3 inputShapeRC = vec3(${oldHeight}.0, ${oldWidth}.0,\n                                     ${oldWidth}.0);\n\n      float getAValue(int b, int r, int c, int d) {\n        return getChannel(getA(b, r, c, d), vec2(c, d));\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        // Calculate values for next column in yRC.z.\n        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);\n\n        // Fractional source index.\n        vec3 sourceFracIndexRC = ${sourceFracIndexRC};\n\n        // Compute the coordinators of nearest neighbor point.\n        ivec3 sourceNearestRC = ivec3(\n          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${roundBase})));\n\n        // Should we calculate next column and row elements in 2x2 packed cell.\n        bool hasNextCol = d < ${depth - 1};\n        bool hasNextRow = coords.z < ${newWidth - 1};\n\n        vec4 newValue = vec4(\n          getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d),\n          hasNextCol ? getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d + 1) : 0.0);\n\n        setOutput(newValue);\n      }\n    `;\n  }\n}\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {env, KernelConfig, KernelFunc, ResizeNearestNeighbor, ResizeNearestNeighborAttrs, ResizeNearestNeighborInputs, TensorInfo} from '@tensorflow/tfjs-core';\n\nimport {MathBackendWebGL} from '../backend_webgl';\nimport {ResizeNearestNeighborProgram} from '../resize_nearest_neighbor_gpu';\nimport {ResizeNearestNeighborPackedProgram} from '../resize_nearest_neighbor_packed_gpu';\n\nexport function resizeNearestNeighbor(args: {\n  inputs: ResizeNearestNeighborInputs,\n  backend: MathBackendWebGL,\n  attrs: ResizeNearestNeighborAttrs\n}): TensorInfo {\n  const {inputs, backend, attrs} = args;\n  const {images} = inputs;\n  const {alignCorners, halfPixelCenters, size} = attrs;\n\n  const [newHeight, newWidth] = size;\n\n  const program = env().getBool('WEBGL_PACK_IMAGE_OPERATIONS') ?\n      new ResizeNearestNeighborPackedProgram(\n          images.shape as [number, number, number, number], newHeight, newWidth,\n          alignCorners, halfPixelCenters) :\n      new ResizeNearestNeighborProgram(\n          images.shape as [number, number, number, number], newHeight, newWidth,\n          alignCorners, halfPixelCenters);\n  return backend.runWebGLProgram(program, [images], images.dtype);\n}\n\nexport const resizeNearestNeighborConfig: KernelConfig = {\n  kernelName: ResizeNearestNeighbor,\n  backendName: 'webgl',\n  kernelFunc: resizeNearestNeighbor as {} as KernelFunc\n};\n","/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {GPGPUProgram} from './gpgpu_math';\n\nexport class ResizeNearestNeigborBackpropProgram implements GPGPUProgram {\n  variableNames = ['dy'];\n  outputShape: number[] = [];\n  userCode: string;\n\n  constructor(\n      dyShape: [number, number, number, number],\n      inputShape: [number, number, number, number], alignCorners: boolean) {\n    this.outputShape = inputShape;\n    const [, xHeight, xWidth, ] = inputShape;\n    const [, yHeight, yWidth] = dyShape;\n\n    // In the backwards pass, we want to find the pixels that were generated for\n    // each pixel in the input image the forward pass and add the corresponding\n    // coefficient from dy to the gradient (with some interpolation).\n\n    const effectiveXSize: [number, number] = [\n      (alignCorners && yHeight > 1) ? xHeight - 1 : xHeight,\n      (alignCorners && yWidth > 1) ? xWidth - 1 : xWidth\n    ];\n\n    const effectiveYSize: [number, number] = [\n      (alignCorners && yHeight > 1) ? yHeight - 1 : yHeight,\n      (alignCorners && yWidth > 1) ? yWidth - 1 : yWidth\n    ];\n\n    const heightScale = effectiveXSize[0] / effectiveYSize[0];\n    const widthScale = effectiveXSize[1] / effectiveYSize[1];\n\n    const invHeightScale = 1 / heightScale;\n    const invWidthScale = 1 / widthScale;\n\n    // This defines the size of the window of values around a particular\n    // index in dy that we want to search for contributions to dx.\n    const winHeight = (Math.ceil(invHeightScale) * 2) + 2;\n    const winWidth = (Math.ceil(invWidthScale) * 2) + 2;\n\n    this.userCode = `\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        int r = coords[1];\n        int c = coords[2];\n\n        float accumulator = 0.0;\n\n        const float heightScale = float(${heightScale});\n        const float widthScale = float(${widthScale});\n\n        const float invHeightScale = float(${invHeightScale});\n        const float invWidthScale = float(${invWidthScale});\n\n        const int winHeight = int(${winHeight});\n        const int winWidth = int(${winWidth});\n\n        // Compute bounds for where in dy we will look\n        float startRLerp = floor(float(r) * invHeightScale);\n        int startDyR = int(floor(startRLerp - float(winHeight / 2)));\n\n        float startCLerp = floor(float(c) * invWidthScale);\n        int startDyC = int(floor(startCLerp - float(winWidth / 2)));\n\n        // Loop over dy\n        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {\n          int dyR = dyROffset + startDyR;\n\n          // Guard against the window exceeding the bounds of dy\n          if (dyR < 0 || dyR >= ${yHeight}) {\n            continue;\n          }\n\n          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {\n            int dyC = dyCOffset + startDyC;\n\n            // Guard against the window exceeding the bounds of dy\n            if (dyC < 0 || dyC >= ${yWidth}) {\n              continue;\n            }\n\n            float sourceFracRow =\n              float(${effectiveXSize[0]}) *\n                (float(dyR) / float(${effectiveYSize[0]}));\n\n            float sourceFracCol =\n                float(${effectiveXSize[1]}) *\n                  (float(dyC) / float(${effectiveYSize[1]}));\n\n            int sourceNearestRow = int(min(\n                float(int(${xHeight}) - 1),\n                ${alignCorners} ? float(round(sourceFracRow)) :\n                                  float(floor(sourceFracRow))));\n\n            int sourceNearestCol = int(min(\n                float(int(${xWidth}) - 1),\n                ${alignCorners} ? float(round(sourceFracCol)) :\n                                  float(floor(sourceFracCol))));\n\n            if (r == sourceNearestRow && c == sourceNearestCol) {\n              accumulator += getDy(b, dyR, dyC, d);\n            }\n          }\n        }\n        // End loop over dy\n\n        setOutput(accumulator);\n      }\n    `;\n  }\n}\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {KernelConfig, KernelFunc, ResizeNearestNeighborGrad, ResizeNearestNeighborGradAttrs, ResizeNearestNeighborGradInputs, TensorInfo} from '@tensorflow/tfjs-core';\n\nimport {MathBackendWebGL} from '../backend_webgl';\nimport {ResizeNearestNeigborBackpropProgram} from '../resize_nearest_neighbor_backprop_gpu';\n\nexport function resizeNearestNeighborGrad(args: {\n  inputs: ResizeNearestNeighborGradInputs,\n  backend: MathBackendWebGL,\n  attrs: ResizeNearestNeighborGradAttrs\n}): TensorInfo {\n  const {inputs, backend, attrs} = args;\n  const {images, dy} = inputs;\n  const {alignCorners} = attrs;\n\n  const program = new ResizeNearestNeigborBackpropProgram(\n      dy.shape as [number, number, number, number],\n      images.shape as [number, number, number, number], alignCorners);\n  return backend.runWebGLProgram(program, [dy], dy.dtype);\n}\n\nexport const resizeNearestNeighborGradConfig: KernelConfig = {\n  kernelName: ResizeNearestNeighborGrad,\n  backendName: 'webgl',\n  kernelFunc: resizeNearestNeighborGrad as {} as KernelFunc\n};\n","/**\n * @license\n * Copyright 2017 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {GPGPUProgram} from './gpgpu_math';\nimport {getCoordsDataType} from './shader_compiler';\n\nexport class ReverseProgram implements GPGPUProgram {\n  variableNames = ['x'];\n  outputShape: number[];\n  userCode: string;\n\n  constructor(xShape: number[], axis: number[]) {\n    const rank = xShape.length;\n    if (rank > 4) {\n      throw new Error(\n          `WebGL backend: Reverse of rank-${rank} tensor is not yet supported`);\n    }\n    this.outputShape = xShape;\n\n    if (rank === 1) {\n      this.userCode = `\n        void main() {\n          int coord = getOutputCoords();\n          setOutput(getX(${xShape[0]} - coord - 1));\n        }\n      `;\n      return;\n    }\n    const getInCoord = (i: number) => {\n      if (axis.indexOf(i) !== -1 && xShape[i] !== 1) {\n        return `${xShape[i]} - coords[${i}] - 1`;\n      }\n      return `coords[${i}]`;\n    };\n    const inCoords = xShape.map((_, i) => getInCoord(i)).join(',');\n    const type = getCoordsDataType(rank);\n\n    this.userCode = `\n      void main() {\n        ${type} coords = getOutputCoords();\n        setOutput(getX(${inCoords}));\n      }\n    `;\n  }\n}\n","/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {GPGPUProgram} from './gpgpu_math';\nimport {getChannels} from './packing_util';\nimport {getCoordsDataType} from './shader_compiler';\n\nexport class ReversePackedProgram implements GPGPUProgram {\n  variableNames = ['x'];\n  outputShape: number[];\n  userCode: string;\n  packedInputs = true;\n  packedOutput = true;\n\n  constructor(xShape: number[], axis: number[]) {\n    const rank = xShape.length;\n    if (rank > 4) {\n      throw new Error(\n          `WebGL backend: Reverse of rank-${rank} tensor is not yet supported`);\n    }\n    this.outputShape = xShape;\n    const channels = getChannels('rc', rank);\n    const nextColumn =\n        `${channels[rank - 1]} + 1 < ${this.outputShape[rank - 1]}`;\n    const nextRow = `${channels[rank - 2]} + 1 < ${this.outputShape[rank - 2]}`;\n    const type = getCoordsDataType(rank);\n    if (rank === 1) {\n      this.userCode = `\n        void main(){\n          int rc = getOutputCoords();\n          vec4 result = vec4(0.);\n          result.r = getChannel(getX(${xShape[0]} - rc - 1),\n            ${xShape[0]} - rc - 1);\n          if(${nextColumn}){\n              result.g = getChannel(getX(${xShape[0]} - (rc  + 1) - 1),\n                ${xShape[0]} - (rc  + 1) - 1);\n          }\n          setOutput(result);\n        }\n      `;\n    } else {\n      this.userCode = `\n        void main() {\n          ${type} rc = getOutputCoords();\n          vec4 result = vec4(0.);\n          result.r = ${getR(channels.slice())};\n          if(${nextColumn}){\n            result.g = ${getG(channels.slice())};\n          }\n          if(${nextRow}) {\n            result.b = ${getB(channels.slice())};\n            if(${nextColumn}) {\n              result.a = ${getA(channels.slice())};\n            }\n          }\n          setOutput(result);\n        }\n    `;\n    }\n\n    function getR(channels: string[]): string {\n      return getChannel(channels);\n    }\n\n    function getG(channels: string[]): string {\n      channels[rank - 1] = '(' + channels[rank - 1] + ` + 1)`;\n      return getChannel(channels);\n    }\n\n    function getB(channels: string[]): string {\n      channels[rank - 2] = '(' + channels[rank - 2] + ` + 1)`;\n      return getChannel(channels);\n    }\n\n    function getA(channels: string[]): string {\n      channels[rank - 1] = '(' + channels[rank - 1] + ` + 1)`;\n      channels[rank - 2] = '(' + channels[rank - 2] + ` + 1)`;\n      return getChannel(channels);\n    }\n\n    function getChannel(channels: string[]): string {\n      const inCoordsArray = xShape.map((_, i) => getInCoord(i, channels));\n      const inCoords = inCoordsArray.join(',');\n      const innerDims = inCoordsArray.slice(-2).join(',');\n      return `getChannel(getX(${inCoords}), vec2(${innerDims}))`;\n    }\n\n    function getInCoord(i: number, channels1: string[]): string {\n      if (axis.indexOf(i) !== -1 && xShape[i] !== 1) {\n        return `${xShape[i]} - ${channels1[i]} - 1`;\n      } else {\n        return `${channels1[i]}`;\n      }\n    }\n  }\n}\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {env, KernelConfig, KernelFunc, Reverse, ReverseAttrs, ReverseInputs, TensorInfo, util} from '@tensorflow/tfjs-core';\n\nimport {MathBackendWebGL} from '../backend_webgl';\nimport {ReverseProgram} from '../reverse_gpu';\nimport {ReversePackedProgram} from '../reverse_packed_gpu';\n\nimport {identity} from './Identity';\n\nexport function reverse(args: {\n  inputs: ReverseInputs,\n  backend: MathBackendWebGL,\n  attrs: ReverseAttrs\n}): TensorInfo {\n  const {inputs, backend, attrs} = args;\n  const {x} = inputs;\n  const {dims} = attrs;\n\n  const xRank = x.shape.length;\n\n  const $dims = util.parseAxisParam(dims, x.shape);\n  if (xRank === 0) {\n    return identity({inputs: {x}, backend});\n  }\n\n  const program = env().getBool('WEBGL_PACK_ARRAY_OPERATIONS') ?\n      new ReversePackedProgram(x.shape, $dims) :\n      new ReverseProgram(x.shape, $dims);\n\n  return backend.runWebGLProgram(program, [x], x.dtype);\n}\n\nexport const reverseConfig: KernelConfig = {\n  kernelName: Reverse,\n  backendName: 'webgl',\n  kernelFunc: reverse as {} as KernelFunc\n};\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {GPGPUProgram} from './gpgpu_math';\nimport {UniformType} from './shader_compiler';\n\nexport class RotateProgram implements GPGPUProgram {\n  variableNames = ['Image'];\n  outputShape: number[] = [];\n  userCode: string;\n  customUniforms = [{name: 'params', type: 'vec4' as UniformType}];\n  constructor(\n      imageShape: [number, number, number, number],\n      fillValue: number|[number, number, number]) {\n    const imageHeight = imageShape[1];\n    const imageWidth = imageShape[2];\n    this.outputShape = imageShape;\n\n    let fillSnippet = '';\n    if (typeof fillValue === 'number') {\n      fillSnippet = `float outputValue = ${fillValue.toFixed(2)};`;\n    } else {\n      fillSnippet = `\n        vec3 fill = vec3(${fillValue.join(',')});\n        float outputValue = fill[coords[3]];`;\n    }\n\n    this.userCode = `\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int x = coords[2];\n          int y = coords[1];\n          float coordXFloat = (float(x) - params[0]) * params[3] -\n            (float(y) - params[1]) * params[2];\n          float coordYFloat = (float(x) - params[0]) * params[2] +\n            (float(y) - params[1]) * params[3];\n          int coordX = int(round(coordXFloat + params[0]));\n          int coordY = int(round(coordYFloat + params[1]));\n          ${fillSnippet}\n          if(coordX >= 0 && coordX < ${imageWidth} && coordY >= 0 && coordY < ${\n        imageHeight}) {\n            outputValue = getImage(coords[0], coordY, coordX, coords[3]);\n          }\n          setOutput(outputValue);\n        }\n    `;\n  }\n}\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {backend_util, KernelConfig, Tensor4D} from '@tensorflow/tfjs-core';\nimport {RotateWithOffset, RotateWithOffsetAttrs, RotateWithOffsetInputs} from '@tensorflow/tfjs-core';\n\nimport {MathBackendWebGL} from '../backend_webgl';\nimport {RotateProgram} from '../rotate_gpu';\n\nexport const rotateWithOffsetConfig: KernelConfig = {\n  kernelName: RotateWithOffset,\n  backendName: 'webgl',\n  kernelFunc: ({inputs, attrs, backend}) => {\n    const {image} = inputs as RotateWithOffsetInputs;\n    const {radians, fillValue, center} = attrs as {} as RotateWithOffsetAttrs;\n    const webglBackend = backend as MathBackendWebGL;\n\n    const program = new RotateProgram((image as Tensor4D).shape, fillValue);\n    const [centerX, centerY] =\n        backend_util.getImageCenter(center, image.shape[1], image.shape[2]);\n    const customValues =\n        [[centerX, centerY, Math.sin(radians), Math.cos(radians)]];\n    const output = webglBackend.runWebGLProgram(\n        program, [image], image.dtype, customValues);\n    return output;\n  }\n};\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {KernelConfig, Round} from '@tensorflow/tfjs-core';\nimport {unaryKernelFunc} from '../kernel_utils/kernel_funcs_utils';\n\nconst ROUND = `\n  // OpenGL ES does not support round function.\n  // The algorithm is based on banker's rounding.\n  float base = floor(x);\n  if ((x - base) < 0.5) {\n    return floor(x);\n  } else if ((x - base) > 0.5) {\n    return ceil(x);\n  } else {\n    if (mod(base, 2.0) == 0.0) {\n      return base;\n    } else {\n      return base + 1.0;\n    }\n  }\n`;\n\nexport const round = unaryKernelFunc({opSnippet: ROUND});\n\nexport const roundConfig: KernelConfig = {\n  kernelName: Round,\n  backendName: 'webgl',\n  kernelFunc: round,\n};\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {KernelConfig, KernelFunc, Rsqrt} from '@tensorflow/tfjs-core';\nimport {unaryKernelFunc} from '../kernel_utils/kernel_funcs_utils';\nimport {rsqrtImplCPU} from '../kernel_utils/shared';\n\nconst RSQRT = `return inversesqrt(x);`;\n\nexport const rsqrt =\n    unaryKernelFunc({opSnippet: RSQRT, cpuKernelImpl: rsqrtImplCPU});\n\nexport const rsqrtConfig: KernelConfig = {\n  kernelName: Rsqrt,\n  backendName: 'webgl',\n  kernelFunc: rsqrt as {} as KernelFunc\n};\n","/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {GPGPUProgram} from './gpgpu_math';\nimport {getCoordsDataType} from './shader_compiler';\n\nexport class ScatterProgram implements GPGPUProgram {\n  variableNames = ['updates', 'indices', 'defaultValue'];\n  outputShape: number[];\n  userCode: string;\n\n  constructor(\n      updateSize: number, sliceDim: number, indicesRank: number,\n      updatesRank: number, strides: number[], shape: number[],\n      summingDupeIndex = true) {\n    this.outputShape = shape;\n    const stridesType = getCoordsDataType(strides.length);\n    const dtype = getCoordsDataType(shape.length);\n    let indicesString = '';\n    if (indicesRank === 1) {\n      indicesString = 'i';\n    } else if (indicesRank === 2) {\n      indicesString = 'i, j';\n    }\n    const indicesSnippet = `getIndices(${indicesString})`;\n\n    let updatesString = '';\n    if (updatesRank === 1) {\n      updatesString = 'i';\n    } else if (updatesRank === 2) {\n      updatesString = 'i, coords[1]';\n    }\n    const updatesSnippet = `getUpdates(${updatesString})`;\n\n    const strideString = sliceDim > 1 ? 'strides[j]' : 'strides';\n    this.userCode = `\n        ${stridesType} strides = ${stridesType}(${strides});\n\n        void main() {\n          ${dtype} coords = getOutputCoords();\n          float sum = 0.0;\n          bool found = false;\n          for (int i = 0; i < ${updateSize}; i++) {\n            int flattenedIndex = 0;\n            for (int j = 0; j < ${sliceDim}; j++) {\n              int index = round(${indicesSnippet});\n              flattenedIndex += index * ${strideString};\n            }\n            if (flattenedIndex == coords[0]) {\n              sum += ${updatesSnippet};\n              found = true;\n            }\n          }\n          setOutput(mix(getDefaultValue(), sum, float(found)));\n        }\n      `;\n  }\n}\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {backend_util, KernelConfig, KernelFunc, ScatterNd, ScatterNdAttrs, ScatterNdInputs, TensorInfo} from '@tensorflow/tfjs-core';\n\nimport {MathBackendWebGL} from '../backend_webgl';\nimport {ScatterProgram} from '../scatter_gpu';\nimport {reshape} from './Reshape';\n\nexport function scatterNd(args: {\n  inputs: ScatterNdInputs,\n  backend: MathBackendWebGL,\n  attrs: ScatterNdAttrs\n}): TensorInfo {\n  const {inputs, backend, attrs} = args;\n  const {indices, updates} = inputs;\n  const {shape} = attrs;\n\n  const {sliceRank, numUpdates, sliceSize, strides, outputSize} =\n      backend_util.calculateShapes(updates, indices, shape);\n\n  const flattenShape = [outputSize / sliceSize, sliceSize];\n\n  if (outputSize === 0) {\n    return backend.makeTensorInfo(shape, indices.dtype);\n  }\n\n  const flattenIndices = reshape(\n      {inputs: {x: indices}, backend, attrs: {shape: [numUpdates, sliceRank]}});\n  const flattenX = reshape(\n      {inputs: {x: updates}, backend, attrs: {shape: [numUpdates, sliceSize]}});\n\n  const defaultValue = backend.makeTensorInfo(\n      [], 'float32', new Float32Array([0]));  // scalar(0)\n  const program = new ScatterProgram(\n      numUpdates, sliceRank, flattenIndices.shape.length, flattenX.shape.length,\n      strides, flattenShape);\n  const res = backend.runWebGLProgram(\n      program, [flattenX, flattenIndices, defaultValue], flattenX.dtype);\n\n  const reshaped = reshape({inputs: {x: res}, backend, attrs: {shape}});\n\n  backend.disposeIntermediateTensorInfo(flattenIndices);\n  backend.disposeIntermediateTensorInfo(flattenX);\n  backend.disposeIntermediateTensorInfo(res);\n  backend.disposeIntermediateTensorInfo(defaultValue);\n\n  return reshaped;\n}\n\nexport const scatterNdConfig: KernelConfig = {\n  kernelName: ScatterNd,\n  backendName: 'webgl',\n  kernelFunc: scatterNd as {} as KernelFunc\n};\n","/**\n * @license\n * Copyright 2022 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {env} from '@tensorflow/tfjs-core';\nimport {GPGPUProgram} from './gpgpu_math';\nimport {UniformType} from './shader_compiler';\n\nexport class SearchSortedProgram implements GPGPUProgram {\n  variableNames = ['sortedSequence', 'values'];\n  outputShape: number[];\n  userCode: string;\n  customUniforms = [{name: 'numInputs', type: 'int' as UniformType}];\n\n  constructor(\n      batchSize: number, numInputs: number, numValues: number,\n      side: 'left'|'right') {\n    this.outputShape = [batchSize, numValues];\n\n    const webGL2LoopHead = 'while (left < right) {';\n    // WebGL1 doesn't accept non constant loop conditions, so upper bound loop\n    // iterations.\n    const webGL1LoopHead = `for (int i = 0; i < ${\n        Math.ceil(Math.log2(numInputs + 1))}; ++i) { if (left >= right) break;`;\n    const loopHead = env().getNumber('WEBGL_VERSION') === 2 ? webGL2LoopHead :\n                                                              webGL1LoopHead;\n\n    // left corresponds to lower bound and right to upper bound.\n    const boundComparator = side === 'left' ? '<' : '<=';\n    this.userCode = `\n       int findBound(int batch, float value) {\n         int left = 0;\n         int right = numInputs;\n         int mid;\n         ${loopHead}\n           mid = (left + right) / 2;\n           if (getSortedSequence(batch, mid) ${boundComparator} value) {\n             left = mid + 1;\n           } else {\n             right = mid;\n           }\n         }\n         return right;\n       }\n\n       void main() {\n         ivec2 coords = getOutputCoords();\n         int batch = coords[0];\n         int valueIndex = coords[1];\n\n         float value = getValues(batch, valueIndex);\n\n         setOutput(float(findBound(batch, value)));\n       }\n     `;\n  }\n}\n","/**\n * @license\n * Copyright 2022 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {KernelConfig, KernelFunc, SearchSorted, SearchSortedAttrs, SearchSortedInputs, TensorInfo} from '@tensorflow/tfjs-core';\n\nimport {MathBackendWebGL} from '../backend_webgl';\nimport {SearchSortedProgram} from '../search_sorted_gpu';\n\nexport function searchSorted(args: {\n  inputs: SearchSortedInputs,\n  backend: MathBackendWebGL,\n  attrs: SearchSortedAttrs\n}): TensorInfo {\n  const {inputs, backend, attrs} = args;\n  const {sortedSequence, values} = inputs;\n  const {side} = attrs;\n\n  const program = new SearchSortedProgram(\n      sortedSequence.shape[0], sortedSequence.shape[1], values.shape[1], side);\n  const customValues = [[sortedSequence.shape[1]]];\n  return backend.runWebGLProgram(\n      program, [sortedSequence, values], 'int32', customValues);\n}\n\nexport const searchSortedConfig: KernelConfig = {\n  kernelName: SearchSorted,\n  backendName: 'webgl',\n  kernelFunc: searchSorted as {} as KernelFunc,\n};\n","/**\n * @license\n * Copyright 2017 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {GPGPUProgram} from './gpgpu_math';\nimport {getCoordsDataType} from './shader_compiler';\n\nexport class SelectProgram implements GPGPUProgram {\n  variableNames = ['c', 'a', 'b'];\n  outputShape: number[];\n  userCode: string;\n\n  constructor(cRank: number, shape: number[], rank: number) {\n    this.outputShape = shape;\n\n    let cCoords;\n    let abCoords;\n    if (rank > 4) {\n      throw Error(`Where for rank ${rank} is not yet supported`);\n    }\n\n    if (rank === 1) {\n      abCoords = `resRC`;\n      cCoords = `resRC`;\n    } else {\n      const currentCoords = ['resRC.x', 'resRC.y', 'resRC.z', 'resRC.w'];\n      const cCoordVars = [];\n      const abCoordVars = [];\n      for (let i = 0; i < shape.length; i++) {\n        abCoordVars.push(`${currentCoords[i]}`);\n        if (i < cRank) {\n          cCoordVars.push(`${currentCoords[i]}`);\n        }\n      }\n      cCoords = cCoordVars.join();\n      abCoords = abCoordVars.join();\n    }\n\n    const dtype = getCoordsDataType(rank);\n\n    this.userCode = `\n      void main() {\n        ${dtype} resRC = getOutputCoords();\n        float cVal = getC(${cCoords});\n        if (cVal >= 1.0) {\n          setOutput(getA(${abCoords}));\n        } else {\n          setOutput(getB(${abCoords}));\n        }\n      }\n    `;\n  }\n}\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {KernelConfig, KernelFunc, Select, SelectInputs, TensorInfo, upcastType} from '@tensorflow/tfjs-core';\n\nimport {MathBackendWebGL} from '../backend_webgl';\nimport {SelectProgram} from '../select_gpu';\n\nexport function select(args: {inputs: SelectInputs, backend: MathBackendWebGL}):\n    TensorInfo {\n  const {inputs, backend} = args;\n  const {condition, t, e} = inputs;\n\n  const program =\n      new SelectProgram(condition.shape.length, t.shape, t.shape.length);\n  return backend.runWebGLProgram(\n      program, [condition, t, e], upcastType(t.dtype, e.dtype));\n}\n\nexport const selectConfig: KernelConfig = {\n  kernelName: Select,\n  backendName: 'webgl',\n  kernelFunc: select as {} as KernelFunc\n};\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {backend_util, KernelConfig, Selu} from '@tensorflow/tfjs-core';\n\nimport {unaryKernelFunc} from '../kernel_utils/kernel_funcs_utils';\n\nconst SELU = `\n  // Stable and Attracting Fixed Point (0, 1) for Normalized Weights.\n  // see: https://arxiv.org/abs/1706.02515\n  float scaleAlpha = ${backend_util.SELU_SCALEALPHA};\n  float scale = ${backend_util.SELU_SCALE};\n  return (x >= 0.0) ? scale * x : scaleAlpha * (exp(x) - 1.0);\n`;\n\nexport const selu = unaryKernelFunc({opSnippet: SELU});\n\nexport const seluConfig: KernelConfig = {\n  kernelName: Selu,\n  backendName: 'webgl',\n  kernelFunc: selu,\n};\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {KernelConfig, Sigmoid} from '@tensorflow/tfjs-core';\n\nimport {CHECK_NAN_SNIPPET_UNARY, unaryKernelFunc} from '../kernel_utils/kernel_funcs_utils';\nimport {sigmoidImplCPU} from '../kernel_utils/shared';\n\nconst SIGMOID = CHECK_NAN_SNIPPET_UNARY + `\n  return 1.0 / (1.0 + exp(-1.0 * x));\n`;\n\nconst SIGMOID_PACKED = `\n  vec4 result = 1.0 / (1.0 + exp(-1.0 * x));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n`;\nexport const sigmoid = unaryKernelFunc({\n  opSnippet: SIGMOID,\n  packedOpSnippet: SIGMOID_PACKED,\n  cpuKernelImpl: sigmoidImplCPU\n});\n\nexport const sigmoidConfig: KernelConfig = {\n  kernelName: Sigmoid,\n  backendName: 'webgl',\n  kernelFunc: sigmoid,\n};\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {KernelConfig, Sign} from '@tensorflow/tfjs-core';\n\nimport {unaryKernelFunc} from '../kernel_utils/kernel_funcs_utils';\n\n// Sign does not propagate NANs.\nconst SIGN = `\n  if (isnan(x)) { return 0.0; }\n  return sign(x);\n`;\n\nexport const sign = unaryKernelFunc({opSnippet: SIGN});\n\nexport const signConfig: KernelConfig = {\n  kernelName: Sign,\n  backendName: 'webgl',\n  kernelFunc: sign,\n};\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {KernelConfig, Sin} from '@tensorflow/tfjs-core';\n\nimport {CHECK_NAN_SNIPPET_UNARY, unaryKernelFunc} from '../kernel_utils/kernel_funcs_utils';\n\nconst SIN = CHECK_NAN_SNIPPET_UNARY + `\n  return sin(x);\n`;\n\nexport const sin = unaryKernelFunc({opSnippet: SIN});\n\nexport const sinConfig: KernelConfig = {\n  kernelName: Sin,\n  backendName: 'webgl',\n  kernelFunc: sin,\n};\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {KernelConfig, Sinh} from '@tensorflow/tfjs-core';\nimport {unaryKernelFunc} from '../kernel_utils/kernel_funcs_utils';\n\nconst SINH = `\n  float e2x = exp(x);\n  return (e2x - 1.0 / e2x) / 2.0;\n`;\n\nexport const sinh = unaryKernelFunc({opSnippet: SINH});\n\nexport const sinhConfig: KernelConfig = {\n  kernelName: Sinh,\n  backendName: 'webgl',\n  kernelFunc: sinh,\n};\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {KernelConfig, Softplus} from '@tensorflow/tfjs-core';\nimport {unaryKernelFunc} from '../kernel_utils/kernel_funcs_utils';\n\nconst SOFTPLUS = `\n  float epsilon = 1.1920928955078125e-7;\n  float threshold = log(epsilon) + 2.0;\n\n  bool too_large = x > -threshold;\n  bool too_small = x < threshold;\n\n  float result;\n  float exp_x = exp(x);\n\n  if (too_large){\n    result = x;\n  }\n  else if (too_small){\n    result = exp_x;\n  }\n  else{\n    result = log(exp_x + 1.0);\n  }\n  return result;\n`;\n\nexport const softplus = unaryKernelFunc({opSnippet: SOFTPLUS});\n\nexport const softplusConfig: KernelConfig = {\n  kernelName: Softplus,\n  backendName: 'webgl',\n  kernelFunc: softplus,\n};\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {backend_util, KernelConfig, KernelFunc, SpaceToBatchND, SpaceToBatchNDAttrs, SpaceToBatchNDInputs, TensorInfo, util} from '@tensorflow/tfjs-core';\n\nimport {MathBackendWebGL} from '../backend_webgl';\n\nimport {padV2} from './PadV2';\nimport {reshape} from './Reshape';\nimport {transpose} from './Transpose';\n\nexport const spaceToBatchND = (args: {\n  inputs: SpaceToBatchNDInputs,\n  backend: MathBackendWebGL,\n  attrs: SpaceToBatchNDAttrs\n}): TensorInfo => {\n  const {inputs, backend, attrs} = args;\n  const {x} = inputs;\n  const {blockShape, paddings} = attrs;\n\n  util.assert(\n      x.shape.length <= 4,\n      () => 'spaceToBatchND for rank > 4 with a WebGL backend not ' +\n          'implemented yet');\n\n  const prod = blockShape.reduce((a, b) => a * b);\n\n  const completePaddings: Array<[number, number]> = [[0, 0]];\n  completePaddings.push(...paddings as Array<[number, number]>);\n  for (let i = 1 + blockShape.length; i < x.shape.length; ++i) {\n    completePaddings.push([0, 0]);\n  }\n\n  const toDispose = [];\n\n  const paddedX = padV2({\n    inputs: {x},\n    backend,\n    attrs: {paddings: completePaddings, constantValue: 0}\n  });\n\n  const reshapedPaddedShape =\n      backend_util.getReshaped(paddedX.shape, blockShape, prod, false);\n\n  const permutedReshapedPaddedPermutation = backend_util.getPermuted(\n      reshapedPaddedShape.length, blockShape.length, false);\n\n  const flattenShape =\n      backend_util.getReshapedPermuted(paddedX.shape, blockShape, prod, false);\n\n  const reshapedPaddedX = reshape(\n      {inputs: {x: paddedX}, backend, attrs: {shape: reshapedPaddedShape}});\n\n  const paddedXT = transpose({\n    inputs: {x: reshapedPaddedX},\n    backend,\n    attrs: {perm: permutedReshapedPaddedPermutation}\n  });\n\n  const result =\n      reshape({inputs: {x: paddedXT}, backend, attrs: {shape: flattenShape}});\n\n  toDispose.push(paddedX);\n  toDispose.push(reshapedPaddedX);\n  toDispose.push(paddedXT);\n\n  toDispose.forEach(t => backend.disposeIntermediateTensorInfo(t));\n\n  return result;\n};\n\nexport const spaceToBatchNDConfig: KernelConfig = {\n  kernelName: SpaceToBatchND,\n  backendName: 'webgl',\n  kernelFunc: spaceToBatchND as {} as KernelFunc\n};\n","/**\n * @license\n * Copyright 2021 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {KernelConfig, KernelFunc, SparseFillEmptyRows, SparseFillEmptyRowsInputs, TensorInfo, TypedArray} from '@tensorflow/tfjs-core';\n\nimport {MathBackendWebGL} from '../backend_webgl';\nimport {sparseFillEmptyRowsImplCPU} from '../kernel_utils/shared';\n\nexport function sparseFillEmptyRows(args: {\n  inputs: SparseFillEmptyRowsInputs,\n  backend: MathBackendWebGL\n}): [TensorInfo, TensorInfo, TensorInfo, TensorInfo] {\n  const {inputs, backend} = args;\n  const {indices, values, denseShape, defaultValue} = inputs;\n  if (denseShape.shape.length !== 1) {\n    throw new Error(`Dense shape must be a vector, saw:\n         ${denseShape.shape}`);\n  }\n  if (indices.shape.length !== 2) {\n    throw new Error(`Indices must be a matrix, saw:\n         ${indices.shape}`);\n  }\n  if (values.shape.length !== 1) {\n    throw new Error(`Values must be a vector, saw:\n         ${values.shape}`);\n  }\n  if (defaultValue.shape.length !== 0) {\n    throw new Error(`Default value must be a scalar, saw:\n        ${defaultValue.shape}`);\n  }\n\n  const $indices = backend.readSync(indices.dataId) as TypedArray;\n  const $values = backend.readSync(values.dataId) as TypedArray;\n  const $denseShape = backend.readSync(denseShape.dataId) as TypedArray;\n  const $defaultValue =\n      backend.readSync(defaultValue.dataId)[0] as number;\n\n  const [outputIndices, outputIndicesShape, outputValues,\n         emptyRowIndicator, reverseIndexMap] =\n      sparseFillEmptyRowsImplCPU(\n          $indices, indices.shape, indices.dtype, $values, values.dtype,\n          $denseShape, $defaultValue);\n  return [\n    backend.makeTensorInfo(outputIndicesShape, indices.dtype, outputIndices),\n    backend.makeTensorInfo(\n        [outputIndicesShape[0]], values.dtype, outputValues),\n    backend.makeTensorInfo(\n        [emptyRowIndicator.length], 'bool',\n        new Uint8Array(\n            emptyRowIndicator.map((value: boolean) => Number(value)))),\n    backend.makeTensorInfo(\n        [reverseIndexMap.length], indices.dtype,\n        new Int32Array(reverseIndexMap)),\n  ];\n}\n\nexport const sparseFillEmptyRowsConfig: KernelConfig = {\n  kernelName: SparseFillEmptyRows,\n  backendName: 'webgl',\n  kernelFunc: sparseFillEmptyRows as {} as KernelFunc,\n};\n","/**\n * @license\n * Copyright 2021 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {KernelConfig, SparseReshape, SparseReshapeInputs, TensorInfo, TypedArray} from '@tensorflow/tfjs-core';\n\nimport {MathBackendWebGL} from '../backend_webgl';\nimport {sparseReshapeImplCPU} from '../kernel_utils/shared';\n\nexport function sparseReshape(\n    args: {inputs: SparseReshapeInputs, backend: MathBackendWebGL}):\n    [TensorInfo, TensorInfo] {\n  const {inputs, backend} = args;\n  const {inputIndices, inputShape, newShape} = inputs;\n  if (inputIndices.shape.length !== 2) {\n    throw new Error(`Input indices should be a matrix but received shape ${\n        inputIndices.shape}`);\n  }\n  if (inputShape.shape.length !== 1) {\n    throw new Error(`Input shape should be a vector but received shape ${\n        inputShape.shape}`);\n  }\n\n  if (newShape.shape.length !== 1) {\n    throw new Error(\n        `Target shape should be a vector but received shape ${newShape.shape}`);\n  }\n\n  const $inputShape =\n      Array.from(backend.readSync(inputShape.dataId) as TypedArray);\n  const $inputIndices = backend.readSync(inputIndices.dataId) as TypedArray;\n  const targetShape =\n      Array.from(backend.readSync(newShape.dataId) as TypedArray);\n\n  const [newIndices, indicesShape, outputShape] = sparseReshapeImplCPU(\n      $inputIndices, inputIndices.shape, inputIndices.dtype, $inputShape,\n      targetShape);\n  return [\n    backend.makeTensorInfo(indicesShape, inputIndices.dtype, newIndices),\n    backend.makeTensorInfo(\n        [outputShape.length], newShape.dtype, new Int32Array(outputShape)),\n  ];\n}\n\nexport const sparseReshapeConfig: KernelConfig = {\n  kernelName: SparseReshape,\n  backendName: 'webgl',\n  kernelFunc: sparseReshape,\n};\n","/**\n * @license\n * Copyright 2021 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {KernelConfig, KernelFunc, SparseSegmentMean, SparseSegmentMeanInputs, TensorInfo, TypedArray} from '@tensorflow/tfjs-core';\n\nimport {MathBackendWebGL} from '../backend_webgl';\nimport {sparseSegmentReductionImplCPU} from '../kernel_utils/shared';\n\nexport function sparseSegmentMean(\n    args: {inputs: SparseSegmentMeanInputs, backend: MathBackendWebGL}):\n    TensorInfo {\n  const {inputs, backend} = args;\n  const {data, indices, segmentIds} = inputs;\n  if (data.shape.length < 1) {\n    throw new Error(\n        `Data should be at least 1 dimensional but received scalar`);\n  }\n  if (indices.shape.length !== 1) {\n    throw new Error(`Indices should be a vector but received shape\n              ${indices.shape}`);\n  }\n  if (segmentIds.shape.length !== 1) {\n    throw new Error(`Segment ids should be a vector but received shape\n              ${segmentIds.shape}`);\n  }\n\n  const $data = backend.readSync(data.dataId) as TypedArray;\n  const $indices = backend.readSync(indices.dataId) as TypedArray;\n  const $segmentIds = backend.readSync(segmentIds.dataId) as TypedArray;\n\n  const [outputData, outputDataShape] = sparseSegmentReductionImplCPU(\n      $data, data.shape, data.dtype, $indices, $segmentIds, true);\n  return backend.makeTensorInfo(outputDataShape, data.dtype, outputData);\n}\n\nexport const sparseSegmentMeanConfig: KernelConfig = {\n  kernelName: SparseSegmentMean,\n  backendName: 'webgl',\n  kernelFunc: sparseSegmentMean as {} as KernelFunc,\n};\n","/**\n * @license\n * Copyright 2021 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {KernelConfig, KernelFunc, SparseSegmentSum, SparseSegmentSumInputs, TensorInfo, TypedArray} from '@tensorflow/tfjs-core';\n\nimport {MathBackendWebGL} from '../backend_webgl';\nimport {sparseSegmentReductionImplCPU} from '../kernel_utils/shared';\n\nexport function sparseSegmentSum(\n    args: {inputs: SparseSegmentSumInputs, backend: MathBackendWebGL}):\n    TensorInfo {\n  const {inputs, backend} = args;\n  const {data, indices, segmentIds} = inputs;\n  if (data.shape.length < 1) {\n    throw new Error(\n        `Data should be at least 1 dimensional but received scalar`);\n  }\n  if (indices.shape.length !== 1) {\n    throw new Error(`Indices should be a vector but received shape\n             ${indices.shape}`);\n  }\n  if (segmentIds.shape.length !== 1) {\n    throw new Error(`Segment ids should be a vector but received shape\n             ${segmentIds.shape}`);\n  }\n\n  const $data = backend.readSync(data.dataId) as TypedArray;\n  const $indices = backend.readSync(indices.dataId) as TypedArray;\n  const $segmentIds = backend.readSync(segmentIds.dataId) as TypedArray;\n\n  const [outputData, outputDataShape] = sparseSegmentReductionImplCPU(\n      $data, data.shape, data.dtype, $indices, $segmentIds);\n  return backend.makeTensorInfo(outputDataShape, data.dtype, outputData);\n}\n\nexport const sparseSegmentSumConfig: KernelConfig = {\n  kernelName: SparseSegmentSum,\n  backendName: 'webgl',\n  kernelFunc: sparseSegmentSum as {} as KernelFunc,\n};\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {backend_util, KernelConfig, KernelFunc, Rank, SparseToDense, SparseToDenseAttrs, SparseToDenseInputs, TensorInfo, util} from '@tensorflow/tfjs-core';\n\nimport {MathBackendWebGL} from '../backend_webgl';\nimport {scatterImplCPU} from '../kernel_utils/shared';\nimport {ScatterProgram} from '../scatter_gpu';\n\nimport {reshape} from './Reshape';\n\nexport function sparseToDense(args: {\n  inputs: SparseToDenseInputs,\n  backend: MathBackendWebGL,\n  attrs: SparseToDenseAttrs\n}): TensorInfo {\n  const {inputs, backend, attrs} = args;\n  const {sparseIndices, sparseValues, defaultValue} = inputs;\n  const {outputShape} = attrs;\n\n  const {sliceRank, numUpdates, sliceSize, strides, outputSize} =\n      backend_util.calculateShapes(sparseValues, sparseIndices, outputShape);\n  const sumDupeIndices = false;\n\n  if (sparseValues.dtype === 'string') {\n    const indicesBuf = backend.bufferSync<Rank, 'int32'>(sparseIndices);\n    const updatesBuf = backend.bufferSync<Rank, 'string'>(sparseValues);\n    const $defaultValue = util.decodeString(\n        backend.readSync(defaultValue.dataId)[0] as Uint8Array);\n    const outBuf = scatterImplCPU(\n        indicesBuf, updatesBuf, outputShape, outputSize, sliceSize, numUpdates,\n        sliceRank, strides, $defaultValue, sumDupeIndices);\n    return backend.makeTensorInfo(outputShape, outBuf.dtype, outBuf.values);\n  }\n  const program = new ScatterProgram(\n      numUpdates, sliceRank, sparseIndices.shape.length,\n      sparseValues.shape.length, strides, [outputSize, 1], sumDupeIndices);\n\n  const res = backend.runWebGLProgram(\n      program, [sparseValues, sparseIndices, defaultValue], sparseValues.dtype);\n\n  const reshaped =\n      reshape({inputs: {x: res}, backend, attrs: {shape: outputShape}});\n\n  backend.disposeIntermediateTensorInfo(res);\n  return reshaped;\n}\n\nexport const sparseToDenseConfig: KernelConfig = {\n  kernelName: SparseToDense,\n  backendName: 'webgl',\n  kernelFunc: sparseToDense as {} as KernelFunc\n};\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {backend_util, KernelConfig, KernelFunc, SplitV, SplitVAttrs, SplitVInputs, TensorInfo, util} from '@tensorflow/tfjs-core';\n\nimport {MathBackendWebGL} from '../backend_webgl';\nimport {slice} from './Slice';\n\nexport function splitV(\n    args:\n        {inputs: SplitVInputs, backend: MathBackendWebGL, attrs: SplitVAttrs}):\n    TensorInfo[] {\n  const {inputs, backend, attrs} = args;\n  const {x} = inputs;\n  const {numOrSizeSplits, axis} = attrs;\n\n  const $axis = util.parseAxisParam(axis, x.shape)[0];\n  const splitSizes = backend_util.prepareSplitSize(x, numOrSizeSplits, $axis);\n\n  const xRank = x.shape.length;\n  const begin = new Array(xRank).fill(0);\n  const size = x.shape.slice();\n\n  return splitSizes.map(s => {\n    const sliceSize = [...size];\n    sliceSize[$axis] = s;\n    const sliceT =\n        slice({inputs: {x}, backend, attrs: {begin, size: sliceSize}});\n    begin[$axis] += s;\n    return sliceT;\n  });\n}\n\nexport const splitVConfig: KernelConfig = {\n  kernelName: SplitV,\n  backendName: 'webgl',\n  kernelFunc: splitV as {} as KernelFunc\n};\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {KernelConfig, KernelFunc, Sqrt} from '@tensorflow/tfjs-core';\n\nimport {unaryKernelFunc} from '../kernel_utils/kernel_funcs_utils';\nimport {sqrtImplCPU} from '../kernel_utils/shared';\n\nconst SQRT = `return sqrt(x);`;\n\nexport const sqrt = unaryKernelFunc(\n    {opSnippet: SQRT, packedOpSnippet: SQRT, cpuKernelImpl: sqrtImplCPU});\n\nexport const sqrtConfig: KernelConfig = {\n  kernelName: Sqrt,\n  backendName: 'webgl',\n  kernelFunc: sqrt as {} as KernelFunc\n};\n","/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {KernelConfig, Square} from '@tensorflow/tfjs-core';\n\nimport {unaryKernelFunc} from '../kernel_utils/kernel_funcs_utils';\n\nconst SQUARE = `return x * x;`;\n\nexport const square = unaryKernelFunc({opSnippet: SQUARE});\n\nexport const squareConfig: KernelConfig = {\n  kernelName: Square,\n  backendName: 'webgl',\n  kernelFunc: square,\n};\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {KernelConfig, SquaredDifference} from '@tensorflow/tfjs-core';\n\nimport {binaryKernelFunc} from '../kernel_utils/kernel_funcs_utils';\n\nconst SQUARED_DIFFERENCE = 'return (a - b) * (a - b);';\n\nexport const squaredDifference = binaryKernelFunc(\n    {opSnippet: SQUARED_DIFFERENCE, packedOpSnippet: SQUARED_DIFFERENCE});\n\nexport const squaredDifferenceConfig: KernelConfig = {\n  kernelName: SquaredDifference,\n  backendName: 'webgl',\n  kernelFunc: squaredDifference,\n};\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {KernelConfig, KernelFunc, Step, StepAttrs, TensorInfo, UnaryInputs} from '@tensorflow/tfjs-core';\n\nimport {MathBackendWebGL} from '../backend_webgl';\nimport {CHECK_NAN_SNIPPET, UnaryOpProgram} from '../unaryop_gpu';\n\nexport function step(\n    {inputs, attrs, backend}:\n        {inputs: UnaryInputs, attrs: StepAttrs, backend: MathBackendWebGL}):\n    TensorInfo {\n  const {x} = inputs;\n  const opSnippet = CHECK_NAN_SNIPPET + `\n    return x > 0.0 ? 1.0 : float(${attrs.alpha});\n  `;\n\n  const program = new UnaryOpProgram(x.shape, opSnippet);\n\n  return backend.runWebGLProgram(program, [x], x.dtype);\n}\n\nexport const stepConfig: KernelConfig = {\n  kernelName: Step,\n  backendName: 'webgl',\n  kernelFunc: step as {} as KernelFunc,\n};\n","/**\n * @license\n * Copyright 2017 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {GPGPUProgram} from './gpgpu_math';\nimport {getCoordsDataType} from './shader_compiler';\n\nexport class StridedSliceProgram implements GPGPUProgram {\n  variableNames = ['x'];\n  outputShape: number[];\n  userCode: string;\n\n  constructor(begin: number[], strides: number[], size: number[]) {\n    this.outputShape = size;\n    const rank = size.length;\n    const inputDtype = getCoordsDataType(size.length);\n    const dtype = getCoordsDataType(size.length);\n\n    let newCoords = '';\n    if (rank === 1) {\n      newCoords = 'coords * strides + begin';\n    } else {\n      let outputAxis = 0;\n      newCoords =\n          size.map((_, i) => {\n                outputAxis++;\n                return size.length === 1 ?\n                    `coords * strides[${i}] + begin[${i}]` :\n                    `coords[${outputAxis - 1}] * strides[${i}] + begin[${i}]`;\n              })\n              .join(',');\n    }\n\n    this.userCode = `\n      ${inputDtype} begin = ${inputDtype}(${begin});\n      ${inputDtype} strides = ${inputDtype}(${strides});\n\n      void main() {\n        ${dtype} coords = getOutputCoords();\n        setOutput(getX(${newCoords}));\n      }\n    `;\n  }\n}\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {buffer, KernelConfig, KernelFunc, Rank, slice_util, StridedSlice, StridedSliceAttrs, StridedSliceInputs, TensorBuffer, TensorInfo, TypedArray, util} from '@tensorflow/tfjs-core';\n\nimport {MathBackendWebGL} from '../backend_webgl';\nimport {stridedSliceImplCPU} from '../kernel_utils/shared';\nimport {StridedSliceProgram} from '../strided_slice_gpu';\n\nimport {reshape} from './Reshape';\nimport {slice} from './Slice';\n\nexport function stridedSlice(args: {\n  inputs: StridedSliceInputs,\n  backend: MathBackendWebGL,\n  attrs: StridedSliceAttrs\n}): TensorInfo {\n  const {inputs, backend, attrs} = args;\n  const {x} = inputs;\n  const {\n    begin,\n    end,\n    strides,\n    beginMask,\n    endMask,\n    ellipsisMask,\n    newAxisMask,\n    shrinkAxisMask\n  } = attrs;\n\n  const {\n    finalShapeSparse,\n    finalShape,\n    isIdentity,\n    sliceDim0,\n    isSimpleSlice,\n    begin: $begin,\n    end: $end,\n    strides: $strides\n  } =\n      slice_util.sliceInfo(\n          x.shape, begin, end, strides, beginMask, endMask, ellipsisMask,\n          newAxisMask, shrinkAxisMask);\n\n  let result;\n\n  if (isIdentity) {\n    // Optimization #1, slice is a no-op plus reshape\n    result = reshape({inputs: {x}, backend, attrs: {shape: finalShape}});\n  } else if (sliceDim0 || isSimpleSlice) {\n    // Optimization #2, slice is memory contiguous (only occurs in dim 0)\n    util.assert(\n        x.shape.length >= 1,\n        () => `Input must have rank at least 1, got: ${x.shape.length}`);\n\n    const size = slice_util.computeOutShape($begin, $end, $strides);\n    // To tolerate begin[0] > end[0] (a 0-output slice), we min(begin, end).\n    const sliced = slice({inputs: {x}, backend, attrs: {begin: $begin, size}});\n    result =\n        reshape({inputs: {x: sliced}, backend, attrs: {shape: finalShape}});\n    backend.disposeIntermediateTensorInfo(sliced);\n  } else {\n    const shouldExecuteOnCPU = backend.shouldExecuteOnCPU([x]);\n    if (shouldExecuteOnCPU) {\n      // tslint:disable-next-line: no-unnecessary-type-assertion\n      const values = backend.readSync(x.dataId) as TypedArray;\n      // tslint:disable-next-line: no-unnecessary-type-assertion\n      const xBuf = buffer(x.shape, x.dtype, values) as TensorBuffer<Rank>;\n      const resultValues =\n          stridedSliceImplCPU(finalShapeSparse, xBuf, $strides, $begin);\n      result = backend.makeTensorInfo(finalShape, x.dtype, resultValues.values);\n    } else {\n      const program =\n          new StridedSliceProgram($begin, $strides, finalShapeSparse);\n      result = backend.runWebGLProgram(program, [x], x.dtype);\n    }\n  }\n\n  const resultReshaped =\n      reshape({inputs: {x: result}, backend, attrs: {shape: finalShape}});\n\n  backend.disposeIntermediateTensorInfo(result);\n\n  return resultReshaped;\n}\n\nexport const stridedSliceConfig: KernelConfig = {\n  kernelName: StridedSlice,\n  backendName: 'webgl',\n  kernelFunc: stridedSlice as {} as KernelFunc\n};\n","/**\n * @license\n * Copyright 2021 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {KernelConfig, KernelFunc, StringNGrams, StringNGramsAttrs, StringNGramsInputs, TensorInfo} from '@tensorflow/tfjs-core';\n\nimport {MathBackendWebGL} from '../backend_webgl';\nimport {stringNGramsImplCPU} from '../kernel_utils/shared';\n\nexport function stringNGrams(args: {\n  inputs: StringNGramsInputs,\n  backend: MathBackendWebGL,\n  attrs: StringNGramsAttrs\n}): [TensorInfo, TensorInfo] {\n  const {inputs, backend, attrs} = args;\n  const {\n    separator,\n    nGramWidths,\n    leftPad,\n    rightPad,\n    padWidth,\n    preserveShortSequences\n  } = attrs;\n  const {data, dataSplits} = inputs;\n  const $data = backend.readSync(data.dataId) as Uint8Array[];\n  const $dataSplits = backend.readSync(dataSplits.dataId) as Int32Array;\n\n  const [nGrams, nGramsSplits] = stringNGramsImplCPU(\n      $data, $dataSplits, separator, nGramWidths, leftPad, rightPad, padWidth,\n      preserveShortSequences);\n  return [\n    backend.makeTensorInfo([nGrams.length], 'string', nGrams),\n    backend.makeTensorInfo(dataSplits.shape, 'int32', nGramsSplits),\n  ];\n}\n\nexport const stringNGramsConfig: KernelConfig = {\n  kernelName: StringNGrams,\n  backendName: 'webgl',\n  kernelFunc: stringNGrams as {} as KernelFunc,\n};\n","/**\n * @license\n * Copyright 2021 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {KernelConfig, KernelFunc, StringSplit, StringSplitAttrs, StringSplitInputs, TensorInfo} from '@tensorflow/tfjs-core';\n\nimport {MathBackendWebGL} from '../backend_webgl';\nimport {stringSplitImplCPU} from '../kernel_utils/shared';\n\nexport function stringSplit(args: {\n  inputs: StringSplitInputs,\n  backend: MathBackendWebGL,\n  attrs: StringSplitAttrs\n}): [TensorInfo, TensorInfo, TensorInfo] {\n  const {inputs, backend, attrs} = args;\n  const {skipEmpty} = attrs;\n  const {input, delimiter} = inputs;\n\n  if (input.dtype !== 'string') {\n    throw new Error('Input must be of datatype string');\n  }\n  if (input.shape.length !== 1) {\n    throw new Error(`Input must be a vector, got shape: ${input.shape}`);\n  }\n  if (delimiter.shape.length !== 0) {\n    throw new Error(\n        `Delimiter must be a scalar, got shape: ${delimiter.shape}`);\n  }\n\n  const $input = backend.readSync(input.dataId) as Uint8Array[];\n  const $delimiter = backend.readSync(delimiter.dataId)[0] as Uint8Array;\n\n  const [indices, values, shape] =\n      stringSplitImplCPU($input, $delimiter, skipEmpty);\n  const outputSize = values.length;\n  return [\n    backend.makeTensorInfo([outputSize, 2], 'int32', indices),\n    backend.makeTensorInfo([outputSize], 'string', values),\n    backend.makeTensorInfo([2], 'int32', new Int32Array(shape))\n  ];\n}\n\nexport const stringSplitConfig: KernelConfig = {\n  kernelName: StringSplit,\n  backendName: 'webgl',\n  kernelFunc: stringSplit as {} as KernelFunc,\n};\n","/**\n * @license\n * Copyright 2021 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {KernelConfig, KernelFunc, StringToHashBucketFast, StringToHashBucketFastAttrs, StringToHashBucketFastInputs, TensorInfo} from '@tensorflow/tfjs-core';\n\nimport {MathBackendWebGL} from '../backend_webgl';\nimport {stringToHashBucketFastImplCPU} from '../kernel_utils/shared';\n\nexport function stringToHashBucketFast(args: {\n  inputs: StringToHashBucketFastInputs,\n  backend: MathBackendWebGL,\n  attrs: StringToHashBucketFastAttrs\n}): TensorInfo {\n  const {inputs, backend, attrs} = args;\n  const {numBuckets} = attrs;\n  const {input} = inputs;\n\n  if (input.dtype !== 'string') {\n    throw new Error('Input must be of datatype string');\n  }\n  if (numBuckets <= 0) {\n    throw new Error(`Number of buckets must be at least 1`);\n  }\n\n  const $input = backend.readSync(input.dataId) as Uint8Array[];\n\n  const output = stringToHashBucketFastImplCPU($input, numBuckets);\n  return backend.makeTensorInfo(input.shape, 'int32', output);\n}\n\nexport const stringToHashBucketFastConfig: KernelConfig = {\n  kernelName: StringToHashBucketFast,\n  backendName: 'webgl',\n  kernelFunc: stringToHashBucketFast as {} as KernelFunc,\n};\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {KernelConfig, Tan} from '@tensorflow/tfjs-core';\n\nimport {unaryKernelFunc} from '../kernel_utils/kernel_funcs_utils';\n\nconst TAN = `return tan(x);`;\n\nexport const tan = unaryKernelFunc({opSnippet: TAN});\n\nexport const tanConfig: KernelConfig = {\n  kernelName: Tan,\n  backendName: 'webgl',\n  kernelFunc: tan,\n};\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {KernelConfig, Tanh} from '@tensorflow/tfjs-core';\nimport {unaryKernelFunc} from '../kernel_utils/kernel_funcs_utils';\n\nconst TANH = `\n  float e2x = exp(-2.0 * abs(x));\n  return sign(x) * (1.0 - e2x) / (1.0 + e2x);\n`;\n\nexport const tanh = unaryKernelFunc({opSnippet: TANH});\n\nexport const tanhConfig: KernelConfig = {\n  kernelName: Tanh,\n  backendName: 'webgl',\n  kernelFunc: tanh,\n};\n","/**\n * @license\n * Copyright 2017 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {GPGPUProgram} from './gpgpu_math';\nimport {getCoordsDataType} from './shader_compiler';\n\nexport class TileProgram implements GPGPUProgram {\n  variableNames = ['A'];\n  outputShape: number[];\n  userCode: string;\n  rank: number;\n\n  constructor(aShape: number[], reps: number[]) {\n    const outputShape: number[] = new Array(aShape.length);\n    for (let i = 0; i < outputShape.length; i++) {\n      outputShape[i] = aShape[i] * reps[i];\n    }\n    this.outputShape = outputShape;\n    this.rank = outputShape.length;\n    const dtype = getCoordsDataType(this.rank);\n    const sourceCoords = getSourceCoords(aShape);\n\n    this.userCode = `\n      void main() {\n        ${dtype} resRC = getOutputCoords();\n        setOutput(getA(${sourceCoords}));\n      }\n    `;\n  }\n}\n\nfunction getSourceCoords(aShape: number[]): string {\n  const rank = aShape.length;\n  if (rank > 5) {\n    throw Error(`Tile for rank ${rank} is not yet supported`);\n  }\n  if (rank === 1) {\n    return `imod(resRC, ${aShape[0]})`;\n  }\n\n  const currentCoords = ['resRC.x', 'resRC.y', 'resRC.z', 'resRC.w', 'resRC.u'];\n\n  const sourceCoords = [];\n  for (let i = 0; i < aShape.length; i++) {\n    sourceCoords.push(`imod(${currentCoords[i]}, ${aShape[i]})`);\n  }\n  return sourceCoords.join();\n}\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {buffer, KernelConfig, KernelFunc, TensorInfo, Tile, TileAttrs, TileInputs, TypedArray, util} from '@tensorflow/tfjs-core';\n\nimport {MathBackendWebGL} from '../backend_webgl';\nimport {tileImplCPU} from '../kernel_utils/shared';\nimport {TileProgram} from '../tile_gpu';\n\nexport function tile(\n    params: {inputs: TileInputs, backend: MathBackendWebGL, attrs: TileAttrs}):\n    TensorInfo {\n  const {inputs, backend, attrs} = params;\n  const {x} = inputs;\n  const {reps} = attrs;\n\n  // tile gpu program cannot handle rank > 5 case.\n  if (x.dtype === 'string' || x.shape.length > 5) {\n    // Even thought string tensor is always on CPU, just to be consistent on how\n    // to access tensor data.\n    const data = backend.readSync(x.dataId);\n    const value = x.dtype === 'string' ?\n        (data as Uint8Array[]).map(d => util.decodeString(d)) :\n        data as TypedArray;\n    const buf = buffer(x.shape, x.dtype, value);\n    const outBuf = tileImplCPU(buf, reps);\n    return backend.makeTensorInfo(outBuf.shape, outBuf.dtype, outBuf.values);\n  }\n\n  const program = new TileProgram(x.shape, reps);\n  const output = backend.runWebGLProgram(program, [x], x.dtype);\n\n  return output;\n}\n\nexport const tileConfig: KernelConfig = {\n  kernelName: Tile,\n  backendName: 'webgl',\n  kernelFunc: tile as {} as KernelFunc,\n};\n","/**\n * @license\n * Copyright 2021 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport {GPGPUProgram} from './gpgpu_math';\nimport {UniformType} from './shader_compiler';\n\n// Based on Algorithm 2 of Bitonic Top K, ref:\n// https://anilshanbhag.in/static/papers/gputopk_sigmod18.pdf\n// The original algorithm is based on computing the top K only, however\n// since for TFJS we require the indices of the top K values as well then the\n// algorithm found here is a bit modified. Rather than producing the values\n// at each step, the indices containing the top K are generated instead.\n// The output values are not generated to reduce the number of outputs in the\n// GPU, the values can easily be retrieved from the indices using a gather\n// op.\nexport class SwapProgram implements GPGPUProgram {\n  variableNames = ['x', 'indices'];\n  outputShape: number[];\n  userCode: string;\n  // |n| Size of the original input of TopK.\n  // |firstPass|indicates if this is the first time swap is being used which\n  // means no indices input containing the top K is present yet.\n  // |inc| Swaps pairs of indices (0, inc), (1, inc + 1), (2, inc + 2) ...\n  customUniforms = [\n    {name: 'n', type: 'int' as UniformType},\n    {name: 'firstPass', type: 'int' as UniformType},\n    {name: 'negativeInf', type: 'float' as UniformType},\n    {name: 'dir', type: 'int' as UniformType},\n    {name: 'inc', type: 'int' as UniformType}\n  ];\n\n  /**\n   * @param shape desired output shape (can be larger than input shape, output\n   *                                    will be padded with -Infinity)\n   */\n  constructor(shape: number[]) {\n    this.outputShape = shape;\n\n    this.userCode = `\n       void main() {\n         ivec2 coords = getOutputCoords();\n         int batch = coords[0];\n         int elemIdx = coords[1];\n\n         // We compare elements pair-wise within a group of size 2 * inc.\n         // The comparing rule for each group alternates between ascending\n         // and descending. Within each group, we compare each pair at\n         // positions i and i+inc. To decide whether an element at position i\n         // is x0 or x1, we mod it by 2 * inc, if the result is smaller than\n         // inc, it is in the first half of the group, we denote it as x0,\n         // otherwise we denote it as x1.\n         // For example, as shown in the Bitonic top K paper referenced above,\n         // Figure5(a) shows that element[1] is in the\n         // second half of the group when group size is 2, but it is in the\n         // first half of the group when group size is 4.\n\n         bool isFirstInPair = imod(elemIdx, 2 * inc) < inc;\n         int i = isFirstInPair ? elemIdx : elemIdx - inc;\n\n         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));\n         int i1 = firstPass == 1 ? i + inc : int(getIndices(batch, i + inc));\n         float x0 = i0 < n ? getX(batch, i0) : negativeInf;\n         float x1 = i1 < n ? getX(batch, i1) : negativeInf;\n\n         // Denotes which direction indices are in (ascending or descending).\n         bool reverse = imod(elemIdx, 2 * dir) >= dir;\n         bool isGreater = x0 > x1 || (x0 == x1 && i1 > i0);\n         if (reverse == isGreater) { // Elements in opposite order of direction\n           int iTemp = i0;\n           i0 = i1;\n           i1 = iTemp;\n         }\n         if (isFirstInPair) {\n            setOutput(float(i0));\n         } else {\n            setOutput(float(i1));\n         }\n       }\n     `;\n  }\n}\n\nexport class MergeProgram implements GPGPUProgram {\n  variableNames = ['x', 'indices'];\n  outputShape: number[];\n  userCode: string;\n  // |n| Size of the original input of TopK\n  // |firstPass| indicates if this is the first time swap is being used which\n  // means no indices input containing the top K is present yet.\n  // |k| Top k elements desired\n  customUniforms = [\n    {name: 'n', type: 'int' as UniformType},\n    {name: 'firstPass', type: 'int' as UniformType},\n    {name: 'k', type: 'int' as UniformType}\n  ];\n\n  /**\n   * @param shape desired output shape (must be half of the input size)\n   */\n  constructor(shape: number[]) {\n    this.outputShape = shape;\n\n    this.userCode = `\n    void main() {\n         // Takes max of indices (0, k), (1, k + 1), (2, k + 2) ...\n         ivec2 coords = getOutputCoords();\n         int batch = coords[0];\n         int elemIdx = coords[1];\n\n         // The output size is half of the previous size.\n         // If the previous sequence is | | | | _ _ _ _  | | | |  _ _ _ _ (k=4),\n         // we only need to output the indices at positions |, the indices at\n         // positions _ can be thrown away, see Figure5(b) After Phase 2\n         // (Merge phase) in the Bitonic Top K paper referenced above.\n         // For example, the paper shows we only need to output the orange bars.\n         // The output sequence should look like this | | | | | | | |.\n         // Because the sequence is halved, to map the output index back\n         // to the previous sequence to find the corresponding value,\n         // we need to double the index. When we double the index,\n         // we basically interpolate a position, so 2i looks like\n         // | _ | _ | _ | _ | _ | _ | _. We move the | to the first k position\n         // of each 2k positions by - elemIdx % k. E.g. for output at\n         // index 4,5,6,7, we want to get the corresponding element at\n         // original index 8,9,10,11, for output at index 8,9,10,11,\n         // we want to get the corresponding element at original index\n         // 16,17,18,19, so on and so forth.\n\n         int i = elemIdx < k ? elemIdx : (elemIdx * 2 - imod(elemIdx, k));\n         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));\n         int i1 = firstPass == 1 ? i + k : int(getIndices(batch, i + k));\n\n         float x0 = getX(batch, i0);\n         float x1 = i1 < n ? getX(batch, i1) : x0;\n\n         setOutput(x0 >= x1 ? float(i0) : float(i1));\n       }\n     `;\n  }\n}\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {env, KernelConfig, KernelFunc, NumericDataType, TensorInfo, TopK, TopKAttrs, TopKInputs, TypedArray, util} from '@tensorflow/tfjs-core';\n\nimport {MathBackendWebGL} from '../backend_webgl';\nimport {topKImplCPU} from '../kernel_utils/shared';\nimport {MergeProgram, SwapProgram} from '../top_k_gpu';\nimport {fill} from './Fill';\nimport {gatherV2} from './GatherV2';\nimport {reshape} from './Reshape';\nimport {slice} from './Slice';\n\nfunction disposeIntermediateTensorInfoOrNull(\n    backend: MathBackendWebGL, tensorInfo: TensorInfo) {\n  if (tensorInfo !== null) {\n    backend.disposeIntermediateTensorInfo(tensorInfo);\n  }\n}\n\nfunction roundUpToPow2(num: number) {\n  let pow2 = 1;\n  while (pow2 < num) {\n    pow2 *= 2;\n  }\n  return pow2;\n}\n\n// Based on Algorithm 2 of Bitonic Top K, ref:\n// https://anilshanbhag.in/static/papers/gputopk_sigmod18.pdf\nexport function topK(\n    args: {inputs: TopKInputs, backend: MathBackendWebGL, attrs: TopKAttrs}):\n    TensorInfo[] {\n  const {inputs, backend, attrs} = args;\n  const {x} = inputs;\n  const {k, sorted} = attrs;\n\n  // Empirically determined constant used to determine last dim threshold for\n  // handing off execution to the CPU.\n  const TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD =\n      env().getNumber('TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD');\n\n  // Empirically determined constant used to determine k threshold for handing\n  // off execution to the CPU.\n  const TOPK_K_CPU_HANDOFF_THRESHOLD =\n      env().getNumber('TOPK_K_CPU_HANDOFF_THRESHOLD');\n\n  const xShape = x.shape;\n  const lastDim = xShape[xShape.length - 1];\n\n  if (backend.shouldExecuteOnCPU([x]) ||\n      lastDim < TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD ||\n      k > TOPK_K_CPU_HANDOFF_THRESHOLD) {\n    const xVals = backend.readSync(x.dataId) as TypedArray;\n    const [allTopKVals, allTopKIndices] =\n        topKImplCPU(xVals, xShape, x.dtype as NumericDataType, k, sorted);\n\n    return [\n      backend.makeTensorInfo(\n          allTopKVals.shape, allTopKVals.dtype, allTopKVals.values),\n      backend.makeTensorInfo(\n          allTopKIndices.shape, allTopKIndices.dtype, allTopKIndices.values)\n    ];\n  }\n\n  if (k === 0) {\n    xShape[xShape.length - 1] = 0;\n    return [\n      backend.makeTensorInfo(xShape, x.dtype, []),\n      backend.makeTensorInfo(xShape, 'int32', [])\n    ];\n  }\n\n  if (lastDim === 1 /* firstPass */) {\n    return [\n      x, fill({attrs: {shape: xShape, dtype: 'int32', value: 0}, backend})\n    ];\n  }\n\n  // Eagerly unpack x input since it is passed in to all the shaders which\n  // require unpacked inputs.\n  const xtexData = backend.texData.get(x.dataId);\n  const xIsPacked = xtexData !== null && xtexData.isPacked;\n  const xUnPacked = xIsPacked ? backend.unpackTensor(x) : x;\n\n  // Reshape into a 2d tensor [batch, lastDim] and compute topk along lastDim.\n  const xSize = util.sizeFromShape(xShape);\n  const batch = xSize / lastDim;\n  const x2D = reshape(\n      {inputs: {x: xUnPacked}, attrs: {shape: [batch, lastDim]}, backend});\n\n  if (xIsPacked) {\n    disposeIntermediateTensorInfoOrNull(backend, xUnPacked);\n  }\n\n  const kPow2 = roundUpToPow2(k);\n  const lastDimPow2 = roundUpToPow2(lastDim);\n\n  // Only the indices containing the top K are kept at every step to reduce\n  // number of outputs in the GPU algorithms, so once the final set of indices\n  // is computed then gather is used to grab the corresponding values\n  // from the original input.\n  let indices: TensorInfo = null;\n\n  // GPU algorithm always takes in an indices input but this input is not used\n  // on the first run of a GPU algorithm, therefore if indices is null we simply\n  // pass in x2D instead of it but the value will not actually be used\n  const getInputs = () => indices === null ? [x2D, x2D] : [x2D, indices];\n\n  const runSwap = (dir: number, inc: number, shape: number[]) => {\n    const inputs = getInputs();\n    const program = new SwapProgram(shape);\n    const fistPass = indices === null ? 1 : 0;\n    const customValues =\n        [[lastDim], [fistPass], [Number.NEGATIVE_INFINITY], [dir], [inc]];\n    const prevIndices = indices;\n    indices = backend.runWebGLProgram(program, inputs, 'int32', customValues);\n    disposeIntermediateTensorInfoOrNull(backend, prevIndices);\n  };\n\n  // Step 1: local sort\n  for (let len = 1; len < kPow2; len *= 2) {\n    const dir = len * 2;\n    for (let inc = len; inc >= 1; inc /= 2) {\n      runSwap(dir, inc, [batch, lastDimPow2]);\n    }\n  }\n\n  // Step 2: merge\n  for (let indicesSize = lastDimPow2; indicesSize > kPow2; indicesSize /= 2) {\n    const inputs = getInputs();\n    const mergeProgram = new MergeProgram([batch, indicesSize / 2]);\n    const firstPass = indices === null ? 1 : 0;\n    const customValues = [[lastDim], [firstPass], [kPow2]];\n    const prevIndices = indices;\n    indices =\n        backend.runWebGLProgram(mergeProgram, inputs, 'int32', customValues);\n    disposeIntermediateTensorInfoOrNull(backend, prevIndices);\n\n    // Step 3: rebuild\n    const len = kPow2 / 2;\n    const dir = len * 2;\n    for (let inc = len; inc >= 1; inc /= 2) {\n      runSwap(dir, inc, indices.shape);\n    }\n  }\n\n  // Keep only the requested top K results instead of kPow2\n  let prevIndices = indices;\n  indices = slice(\n      {inputs: {x: indices}, backend, attrs: {begin: 0, size: [batch, k]}});\n  disposeIntermediateTensorInfoOrNull(backend, prevIndices);\n\n  // Gather values on last dimension\n  let values = gatherV2(\n      {inputs: {x: x2D, indices}, backend, attrs: {axis: 1, batchDims: 1}});\n  disposeIntermediateTensorInfoOrNull(backend, x2D);\n\n  // Reshape back to the original input shape, except that the last\n  // dimension is k.\n  const newShape = xShape.slice(0, -1);\n  newShape.push(k);\n\n  prevIndices = indices;\n  indices = reshape({inputs: {x: indices}, attrs: {shape: newShape}, backend});\n  disposeIntermediateTensorInfoOrNull(backend, prevIndices);\n\n  const prevValues = values;\n  values = reshape({inputs: {x: values}, attrs: {shape: newShape}, backend});\n  disposeIntermediateTensorInfoOrNull(backend, prevValues);\n\n  return [values, indices];\n}\n\nexport const topKConfig: KernelConfig = {\n  kernelName: TopK,\n  backendName: 'webgl',\n  kernelFunc: topK as {} as KernelFunc\n};\n","/**\n * @license\n * Copyright 2021 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {GPGPUProgram} from './gpgpu_math';\n\nexport class TransformProgram implements GPGPUProgram {\n  variableNames = ['Image', 'Transforms'];\n  outputShape: number[];\n  userCode: string;\n\n  constructor(\n      imageHeight: number, imageWidth: number,\n      interpolation: 'nearest'|'bilinear',\n      fillMode: 'constant'|'reflect'|'wrap'|'nearest', fillValue: number,\n      outShape: [number, number, number, number]) {\n    this.outputShape = outShape;\n    const interpolationModeId = interpolation === 'nearest' ? 1 : 2;\n    let fillModeId;\n    switch (fillMode) {\n      case 'constant':\n        fillModeId = 1;\n        break;\n      case 'reflect':\n        fillModeId = 2;\n        break;\n      case 'wrap':\n        fillModeId = 3;\n        break;\n      case 'nearest':\n        fillModeId = 4;\n        break;\n      default:\n        fillModeId = 1;\n        break;\n    }\n    this.userCode = `\n            float mapCoord(float outCoord, float len) {\n              float inCoord = outCoord;\n              if(${fillModeId} == 2) {\n                if (inCoord < 0.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz2 = 2.0 * len;\n                    if (inCoord < sz2) {\n                      inCoord = sz2 * float(int(float(-inCoord / sz2))) +\n                      inCoord;\n                    }\n                    inCoord = inCoord < -len ? inCoord + sz2 : -inCoord - 1.0;\n                  }\n                } else if (inCoord > len - 1.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz2 = 2.0 * len;\n                    inCoord -= sz2 * float(int(float(inCoord / sz2)));\n                    if (inCoord >= len) {\n                      inCoord = sz2 - inCoord - 1.0;\n                    }\n                  }\n                }\n                return clamp(inCoord, 0.0, len - 1.0);\n              } else if (${fillModeId} == 3) {\n                if (inCoord < 0.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz = len - 1.0;\n                    inCoord += len * (float(int(float(-inCoord / sz))) + 1.0);\n                  }\n                } else if (inCoord > len - 1.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz = len - 1.0;\n                    inCoord -= len * float(int(float(inCoord / sz)));\n                  }\n                }\n                return clamp(inCoord, 0.0, len - 1.0);\n              } else if (${fillModeId} == 4) {\n                return clamp(outCoord, 0.0, len - 1.0);\n              } else {\n                return outCoord;\n              }\n            }\n\n            float readWithFillValue(int batch, int coordY, int coordX,\n              int channel) {\n              float outputValue;\n              if (0 <= coordY && coordY < ${\n        imageHeight} && 0 <= coordX && coordX < ${imageWidth}) {\n                  outputValue = getImage(batch, coordY, coordX, channel);\n              } else {\n                outputValue = float(${fillValue});\n              }\n              return outputValue;\n            }\n\n            void main() {\n              ivec4 coords = getOutputCoords();\n              float outputValue;\n              int batch = coords[0];\n              int x = coords[2];\n              int y = coords[1];\n              int channel = coords[3];\n              float xf = float(x);\n              float yf = float(y);\n              float a1 = getTransforms(batch, 0);\n              float a2 = getTransforms(batch, 1);\n              float a3 = getTransforms(batch, 2);\n              float b1 = getTransforms(batch, 3);\n              float b2 = getTransforms(batch, 4);\n              float b3 = getTransforms(batch, 5);\n              float c1 = getTransforms(batch, 6);\n              float c2 = getTransforms(batch, 7);\n              float projection = c1 * xf + c2 * yf + 1.0;\n              if (projection == 0.0) {\n                outputValue = float(${fillValue});\n              } else {\n                float inX = (a1 * xf + a2 * yf + a3) / projection;\n                float inY = (b1 * xf + b2 * yf + b3) / projection;\n                float mapX = mapCoord(inX, float(${imageWidth}));\n                float mapY = mapCoord(inY, float(${imageHeight}));\n\n                if (${interpolationModeId} == 1) {\n                  int coordY = int(round(mapY));\n                  int coordX = int(round(mapX));\n                  outputValue = readWithFillValue(batch, coordY, coordX,\n                    channel);\n                } else {\n                  float yFloor = floor(mapY);\n                  float xFloor = floor(mapX);\n                  float yCeil = yFloor + 1.0;\n                  float xCeil = xFloor + 1.0;\n                  float valueYFloor = (xCeil - mapX) *\n                  readWithFillValue(batch, int(yFloor), int(xFloor), channel) +\n                  (mapX - xFloor) *\n                  readWithFillValue(batch, int(yFloor), int(xCeil), channel);\n                  float valueYCeil = (xCeil - mapX) *\n                  readWithFillValue(batch, int(yCeil), int(xFloor), channel) +\n                  (mapX - xFloor) *\n                  readWithFillValue(batch, int(yCeil), int(xCeil), channel);\n                  outputValue = (yCeil - mapY) * valueYFloor +\n                  (mapY - yFloor) * valueYCeil;\n                }\n              }\n              setOutput(outputValue);\n            }\n        `;\n  }\n}\n","/**\n * @license\n * Copyright 2021 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {KernelConfig, KernelFunc, TensorInfo, Transform, TransformAttrs, TransformInputs} from '@tensorflow/tfjs-core';\n\nimport {MathBackendWebGL} from '../backend_webgl';\nimport {TransformProgram} from '../transform_gpu';\n\nexport function transform(args: {\n  inputs: TransformInputs,\n  backend: MathBackendWebGL,\n  attrs: TransformAttrs\n}): TensorInfo {\n  const {inputs, backend, attrs} = args;\n  const {image, transforms} = inputs;\n  const {interpolation, fillMode, fillValue, outputShape} = attrs;\n\n  const [batch, imageHeight, imageWidth, numChannels] = image.shape;\n  const [outHeight, outWidth] =\n      outputShape != null ? outputShape : [imageHeight, imageWidth];\n  const outShape =\n      [batch, outHeight, outWidth,\n       numChannels] as [number, number, number, number];\n\n  const program = new TransformProgram(\n      imageHeight, imageWidth, interpolation, fillMode, fillValue, outShape);\n  return backend.runWebGLProgram(program, [image, transforms], 'float32');\n}\n\nexport const transformConfig: KernelConfig = {\n  kernelName: Transform,\n  backendName: 'webgl',\n  kernelFunc: transform as {} as KernelFunc\n};\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the License);\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an AS IS BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {KernelConfig, KernelFunc, TensorInfo, Unique, UniqueAttrs, UniqueInputs} from '@tensorflow/tfjs-core';\n\nimport {MathBackendWebGL} from '../backend_webgl';\nimport {uniqueImplCPU} from '../kernel_utils/shared';\nimport {assertNotComplex} from '../webgl_util';\n\nexport function unique(\n    args:\n        {inputs: UniqueInputs, attrs: UniqueAttrs, backend: MathBackendWebGL}):\n    TensorInfo[] {\n  const {inputs, attrs, backend} = args;\n  const {axis} = attrs;\n  const {x} = inputs;\n  assertNotComplex(x, 'unique');\n\n  // For now, always forward calculation to the CPU backend.\n  console.warn(\n      'WARNING: ',\n      'UI might be locked temporarily as data is being downloaded');\n  const values = backend.readSync(x.dataId);\n  const {outputValues, outputShape, indices} =\n      uniqueImplCPU(values, axis, x.shape, x.dtype);\n  return [\n    backend.makeTensorInfo(outputShape, x.dtype, outputValues),\n    backend.makeTensorInfo([indices.length], 'int32', indices),\n  ];\n}\n\nexport const uniqueConfig: KernelConfig = {\n  kernelName: Unique,\n  backendName: 'webgl',\n  kernelFunc: unique as {} as KernelFunc,\n};\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {KernelConfig, KernelFunc, TensorInfo, Unpack, UnpackAttrs, UnpackInputs} from '@tensorflow/tfjs-core';\n\nimport {MathBackendWebGL} from '../backend_webgl';\n\nimport {reshape} from './Reshape';\nimport {slice} from './Slice';\n\nexport function unpack(\n    args:\n        {inputs: UnpackInputs, backend: MathBackendWebGL, attrs: UnpackAttrs}):\n    TensorInfo[] {\n  const {inputs, backend, attrs} = args;\n  const {value} = inputs;\n  let {axis} = attrs;\n\n  if (axis < 0) {\n    axis += value.shape.length;\n  }\n\n  const x = value;\n  const xRank = x.shape.length;\n\n  const num = value.shape[axis];\n  const outShape: number[] = new Array(xRank - 1);\n  let outIndex = 0;\n  for (let i = 0; i < xRank; i++) {\n    if (i !== axis) {\n      outShape[outIndex++] = x.shape[i];\n    }\n  }\n\n  const toDispose = [];\n\n  const begin = new Array(xRank).fill(0);\n  const size = x.shape.slice();\n  size[axis] = 1;\n  const res: TensorInfo[] = new Array(num);\n  for (let i = 0; i < res.length; i++) {\n    begin[axis] = i;\n    const sliced = slice({inputs: {x}, backend, attrs: {begin, size}});\n    const reshaped =\n        reshape({inputs: {x: sliced}, backend, attrs: {shape: outShape}});\n    res[i] = reshaped;\n\n    toDispose.push(sliced);\n  }\n\n  toDispose.forEach(t => backend.disposeIntermediateTensorInfo(t));\n  return res;\n}\n\nexport const unpackConfig: KernelConfig = {\n  kernelName: Unpack,\n  backendName: 'webgl',\n  kernelFunc: unpack as {} as KernelFunc\n};\n","/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {backend_util} from '@tensorflow/tfjs-core';\nimport {GPGPUProgram} from './gpgpu_math';\n\nexport class SegmentOpProgram implements GPGPUProgram {\n  variableNames = ['x', 'segmentIds'];\n  outputShape: number[];\n  userCode: string;\n\n  constructor(\n      segOpInfo: backend_util.segment_util.SegOpInfo,\n      segOpType: 'unsortedSegmentSum') {\n    const windowSize = segOpInfo.windowSize;\n    const batchSize = segOpInfo.batchSize;\n    const inSize = segOpInfo.inSize;\n    const numSegments = segOpInfo.numSegments;\n    const outSize = numSegments * Math.ceil(inSize / windowSize);\n    this.outputShape = [batchSize, outSize];\n\n    const initializationValue = '0.0';\n    const returnValue = `sumValue`;\n\n    const windowSizeNearestVec4 = Math.floor(windowSize / 4) * 4;\n    const windowSizeVec4Remainder = windowSize % 4;\n\n    const updateSnippet = `\n        sumValue += dot(values, segFilter);\n    `;\n\n    let checkValueOutOfBounds = '';\n    if (inSize % windowSize > 0) {\n      checkValueOutOfBounds = `\n        if (inIdx < 0 || inIdx >= ${inSize}) {\n          return initializationValue;\n        }\n      `;\n    }\n\n    let checkSegmentIdOutOfBounds = '';\n    if (inSize % windowSize > 0) {\n      checkSegmentIdOutOfBounds = `\n        if (inIdx < 0 || inIdx >= ${inSize}) {\n          return -1.0;\n        }\n      `;\n    }\n\n    this.userCode = `\n      const float initializationValue = ${initializationValue};\n\n      float getValue(int batch, int inIdx) {\n        ${checkValueOutOfBounds}\n        return getX(batch, inIdx);\n      }\n\n      float getSegmentIdAtIndex(int inIdx) {\n        ${checkSegmentIdOutOfBounds}\n        return getSegmentIds(inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = int(floor(float(outIdx) / float(\n          ${numSegments})) * float(${windowSize}));\n        int currentSeg = int(mod(float(outIdx), float(${numSegments})));\n\n        float sumValue = 0.0;\n\n        for (int i = 0; i < ${windowSizeNearestVec4}; i += 4) {\n          int inIdx = inOffset + i;\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 3)) == currentSeg ? 1 : 0\n          );\n\n          ${updateSnippet}\n        }\n\n        int inIdx = inOffset + ${windowSizeNearestVec4};\n        if (${windowSizeVec4Remainder === 1}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            initializationValue,\n            initializationValue,\n            initializationValue\n          );\n\n          int inIdxSeg = int(getSegmentIdAtIndex(inIdx));\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            0,\n            0,\n            0\n          );\n\n          ${updateSnippet}\n        } else if (${windowSizeVec4Remainder === 2}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            initializationValue,\n            initializationValue\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n              0,\n              0\n          );\n\n          ${updateSnippet}\n        } else if (${windowSizeVec4Remainder === 3}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            initializationValue\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,\n            0\n          );\n\n          ${updateSnippet}\n        }\n        setOutput(${returnValue});\n      }\n    `;\n  }\n}\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {backend_util, DataType, KernelConfig, KernelFunc, sumOutType, TensorInfo, UnsortedSegmentSum, UnsortedSegmentSumAttrs, UnsortedSegmentSumInputs, util} from '@tensorflow/tfjs-core';\n\nimport {MathBackendWebGL} from '../backend_webgl';\nimport {SegmentOpProgram} from '../segment_gpu';\n\nimport {range} from './Range';\nimport {reshape} from './Reshape';\nimport {tile} from './Tile';\nimport {transpose} from './Transpose';\n\nexport function unsortedSegmentSum(args: {\n  inputs: UnsortedSegmentSumInputs,\n  backend: MathBackendWebGL,\n  attrs: UnsortedSegmentSumAttrs\n}): TensorInfo {\n  const {inputs, backend, attrs} = args;\n  const {x, segmentIds} = inputs;\n  const {numSegments} = attrs;\n\n  const xRank = x.shape.length;\n\n  const toDispose = [];\n\n  let axis = 0;\n  const permutation = backend_util.getAxesPermutation([axis], xRank);\n  let permutedX = x;\n  if (permutation != null) {\n    permutedX = transpose({inputs: {x}, backend, attrs: {perm: permutation}});\n    toDispose.push(permutedX);\n    axis = backend_util.getInnerMostAxes(1, xRank)[0];\n  }\n\n  const outShape = backend_util.segment_util.computeOutShape(\n      permutedX.shape, axis, numSegments);\n  const inSize = util.sizeFromShape([permutedX.shape[axis]]);\n  const a2D =\n      reshape({inputs: {x: permutedX}, backend, attrs: {shape: [-1, inSize]}});\n  toDispose.push(a2D);\n\n  const outputDType = sumOutType(x.dtype);\n\n  const segOpCompute =\n      (x: TensorInfo, segOpType: 'unsortedSegmentSum', segmentIds: TensorInfo,\n       dtype: DataType, numSegments: number): TensorInfo => {\n        const batchSize = x.shape[0];\n        const inSize = x.shape[1];\n        const windowSize =\n            backend_util.segment_util.segOpComputeOptimalWindowSize(\n                inSize, numSegments);\n        const segOpInfo = {windowSize, inSize, batchSize, numSegments};\n        const program = new SegmentOpProgram(segOpInfo, segOpType);\n        const output = backend.compileAndRun(program, [x, segmentIds], dtype);\n        toDispose.push(output);\n        // No need to run another GPGPU program.\n        if (output.shape[1] === numSegments) {\n          return output;\n        }\n        const rangeInfo = range({\n          backend,\n          attrs: {start: 0, stop: numSegments, step: 1, dtype: 'float32'}\n        });\n        const tileInfo = tile({\n          inputs: {x: rangeInfo},\n          backend,\n          attrs: {reps: [inSize / windowSize]}\n        });\n\n        toDispose.push(rangeInfo);\n        toDispose.push(tileInfo);\n\n        const result =\n            segOpCompute(output, segOpType, tileInfo, dtype, numSegments);\n        return result;\n      };\n\n  const segOpResult = segOpCompute(\n      a2D, 'unsortedSegmentSum', segmentIds, outputDType, numSegments);\n\n  const reshaped =\n      reshape({inputs: {x: segOpResult}, backend, attrs: {shape: outShape}});\n\n  let result = reshaped;\n  if (permutation != null) {\n    toDispose.push(reshaped);\n    const perm = backend_util.getUndoAxesPermutation(permutation);\n    result = transpose({inputs: {x: result}, backend, attrs: {perm}});\n  }\n\n  toDispose.forEach(t => backend.disposeIntermediateTensorInfo(t));\n  return result;\n}\n\nexport const unsortedSegmentSumConfig: KernelConfig = {\n  kernelName: UnsortedSegmentSum,\n  backendName: 'webgl',\n  kernelFunc: unsortedSegmentSum as {} as KernelFunc\n};\n","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport {KernelConfig, registerKernel} from '@tensorflow/tfjs-core';\n\nimport {_fusedMatMulConfig} from './kernels/_FusedMatMul';\nimport {absConfig} from './kernels/Abs';\nimport {acosConfig} from './kernels/Acos';\nimport {acoshConfig} from './kernels/Acosh';\nimport {addConfig} from './kernels/Add';\nimport {addNConfig} from './kernels/AddN';\nimport {allConfig} from './kernels/All';\nimport {anyConfig} from './kernels/Any';\nimport {argMaxConfig} from './kernels/ArgMax';\nimport {argMinConfig} from './kernels/ArgMin';\nimport {asinConfig} from './kernels/Asin';\nimport {asinhConfig} from './kernels/Asinh';\nimport {atanConfig} from './kernels/Atan';\nimport {atan2Config} from './kernels/Atan2';\nimport {atanhConfig} from './kernels/Atanh';\nimport {avgPoolConfig} from './kernels/AvgPool';\nimport {avgPool3DConfig} from './kernels/AvgPool3D';\nimport {avgPool3DGradConfig} from './kernels/AvgPool3DGrad';\nimport {avgPoolGradConfig} from './kernels/AvgPoolGrad';\nimport {batchMatMulConfig} from './kernels/BatchMatMul';\nimport {batchNormConfig} from './kernels/BatchNorm';\nimport {batchToSpaceNDConfig} from './kernels/BatchToSpaceND';\nimport {bincountConfig} from './kernels/Bincount';\nimport {broadcastArgsConfig} from './kernels/BroadcastArgs';\nimport {castConfig} from './kernels/Cast';\nimport {ceilConfig} from './kernels/Ceil';\nimport {clipByValueConfig} from './kernels/ClipByValue';\nimport {complexConfig} from './kernels/Complex';\nimport {complexAbsConfig} from './kernels/ComplexAbs';\nimport {concatConfig} from './kernels/Concat';\nimport {conv2DConfig} from './kernels/Conv2D';\nimport {conv2DBackpropFilterConfig} from './kernels/Conv2DBackpropFilter';\nimport {conv2DBackpropInputConfig} from './kernels/Conv2DBackpropInput';\nimport {conv3DConfig} from './kernels/Conv3D';\nimport {conv3DBackpropFilterV2Config} from './kernels/Conv3DBackpropFilterV2';\nimport {conv3DBackpropInputConfig} from './kernels/Conv3DBackpropInputV2';\nimport {cosConfig} from './kernels/Cos';\nimport {coshConfig} from './kernels/Cosh';\nimport {cropAndResizeConfig} from './kernels/CropAndResize';\nimport {cumprodConfig} from './kernels/Cumprod';\nimport {cumsumConfig} from './kernels/Cumsum';\nimport {denseBincountConfig} from './kernels/DenseBincount';\nimport {depthToSpaceConfig} from './kernels/DepthToSpace';\nimport {depthwiseConv2dNativeConfig} from './kernels/DepthwiseConv2dNative';\nimport {depthwiseConv2dNativeBackpropFilterConfig} from './kernels/DepthwiseConv2dNativeBackpropFilter';\nimport {depthwiseConv2dNativeBackpropInputConfig} from './kernels/DepthwiseConv2dNativeBackpropInput';\nimport {diagConfig} from './kernels/Diag';\nimport {dilation2DConfig} from './kernels/Dilation2D';\nimport {einsumConfig} from './kernels/Einsum';\nimport {eluConfig} from './kernels/Elu';\nimport {eluGradConfig} from './kernels/EluGrad';\nimport {equalConfig} from './kernels/Equal';\nimport {erfConfig} from './kernels/Erf';\nimport {expConfig} from './kernels/Exp';\nimport {expandDimsConfig} from './kernels/ExpandDims';\nimport {expm1Config} from './kernels/Expm1';\nimport {fftConfig} from './kernels/FFT';\nimport {fillConfig} from './kernels/Fill';\nimport {flipLeftRightConfig} from './kernels/FlipLeftRight';\nimport {floorConfig} from './kernels/Floor';\nimport {floorDivConfig} from './kernels/FloorDiv';\nimport {fromPixelsConfig} from './kernels/FromPixels';\nimport {fusedConv2DConfig} from './kernels/FusedConv2D';\nimport {fusedDepthwiseConv2DConfig} from './kernels/FusedDepthwiseConv2D';\nimport {gatherNdConfig} from './kernels/GatherNd';\nimport {gatherV2Config} from './kernels/GatherV2';\nimport {greaterConfig} from './kernels/Greater';\nimport {greaterEqualConfig} from './kernels/GreaterEqual';\nimport {identityConfig} from './kernels/Identity';\nimport {ifftConfig} from './kernels/IFFT';\nimport {imagConfig} from './kernels/Imag';\nimport {isFiniteConfig} from './kernels/IsFinite';\nimport {isInfConfig} from './kernels/IsInf';\nimport {isNaNConfig} from './kernels/IsNaN';\nimport {leakyReluConfig} from './kernels/LeakyRelu';\nimport {lessConfig} from './kernels/Less';\nimport {lessEqualConfig} from './kernels/LessEqual';\nimport {linSpaceConfig} from './kernels/LinSpace';\nimport {logConfig} from './kernels/Log';\nimport {log1pConfig} from './kernels/Log1p';\nimport {logicalAndConfig} from './kernels/LogicalAnd';\nimport {logicalNotConfig} from './kernels/LogicalNot';\nimport {logicalOrConfig} from './kernels/LogicalOr';\nimport {LRNConfig} from './kernels/LRN';\nimport {LRNGradConfig} from './kernels/LRNGrad';\nimport {maxConfig} from './kernels/Max';\nimport {maximumConfig} from './kernels/Maximum';\nimport {maxPoolConfig} from './kernels/MaxPool';\nimport {maxPool3DConfig} from './kernels/MaxPool3D';\nimport {maxPool3DGradConfig} from './kernels/MaxPool3DGrad';\nimport {maxPoolGradConfig} from './kernels/MaxPoolGrad';\nimport {maxPoolWithArgmaxConfig} from './kernels/MaxPoolWithArgmax';\nimport {meanConfig} from './kernels/Mean';\nimport {minConfig} from './kernels/Min';\nimport {minimumConfig} from './kernels/Minimum';\nimport {mirrorPadConfig} from './kernels/MirrorPad';\nimport {modConfig} from './kernels/Mod';\nimport {multinomialConfig} from './kernels/Multinomial';\nimport {multiplyConfig} from './kernels/Multiply';\nimport {negConfig} from './kernels/Neg';\nimport {nonMaxSuppressionV3Config} from './kernels/NonMaxSuppressionV3';\nimport {nonMaxSuppressionV4Config} from './kernels/NonMaxSuppressionV4';\nimport {nonMaxSuppressionV5Config} from './kernels/NonMaxSuppressionV5';\nimport {notEqualConfig} from './kernels/NotEqual';\nimport {oneHotConfig} from './kernels/OneHot';\nimport {onesLikeConfig} from './kernels/OnesLike';\nimport {packConfig} from './kernels/Pack';\nimport {padV2Config} from './kernels/PadV2';\nimport {powConfig} from './kernels/Pow';\nimport {preluConfig} from './kernels/Prelu';\nimport {prodConfig} from './kernels/Prod';\nimport {raggedGatherConfig} from './kernels/RaggedGather';\nimport {raggedRangeConfig} from './kernels/RaggedRange';\nimport {raggedTensorToTensorConfig} from './kernels/RaggedTensorToTensor';\nimport {rangeConfig} from './kernels/Range';\nimport {realConfig} from './kernels/Real';\nimport {realDivConfig} from './kernels/RealDiv';\nimport {reciprocalConfig} from './kernels/Reciprocal';\nimport {reluConfig} from './kernels/Relu';\nimport {relu6Config} from './kernels/Relu6';\nimport {reshapeConfig} from './kernels/Reshape';\nimport {resizeBilinearConfig} from './kernels/ResizeBilinear';\nimport {resizeBilinearGradConfig} from './kernels/ResizeBilinearGrad';\nimport {resizeNearestNeighborConfig} from './kernels/ResizeNearestNeighbor';\nimport {resizeNearestNeighborGradConfig} from './kernels/ResizeNearestNeighborGrad';\nimport {reverseConfig} from './kernels/Reverse';\nimport {rotateWithOffsetConfig} from './kernels/RotateWithOffset';\nimport {roundConfig} from './kernels/Round';\nimport {rsqrtConfig} from './kernels/Rsqrt';\nimport {scatterNdConfig} from './kernels/ScatterNd';\nimport {searchSortedConfig} from './kernels/SearchSorted';\nimport {selectConfig} from './kernels/Select';\nimport {seluConfig} from './kernels/Selu';\nimport {sigmoidConfig} from './kernels/Sigmoid';\nimport {signConfig} from './kernels/Sign';\nimport {sinConfig} from './kernels/Sin';\nimport {sinhConfig} from './kernels/Sinh';\nimport {sliceConfig} from './kernels/Slice';\nimport {softmaxConfig} from './kernels/Softmax';\nimport {softplusConfig} from './kernels/Softplus';\nimport {spaceToBatchNDConfig} from './kernels/SpaceToBatchND';\nimport {sparseFillEmptyRowsConfig} from './kernels/SparseFillEmptyRows';\nimport {sparseReshapeConfig} from './kernels/SparseReshape';\nimport {sparseSegmentMeanConfig} from './kernels/SparseSegmentMean';\nimport {sparseSegmentSumConfig} from './kernels/SparseSegmentSum';\nimport {sparseToDenseConfig} from './kernels/SparseToDense';\nimport {splitVConfig} from './kernels/SplitV';\nimport {sqrtConfig} from './kernels/Sqrt';\nimport {squareConfig} from './kernels/Square';\nimport {squaredDifferenceConfig} from './kernels/SquaredDifference';\nimport {stepConfig} from './kernels/Step';\nimport {stridedSliceConfig} from './kernels/StridedSlice';\nimport {stringNGramsConfig} from './kernels/StringNGrams';\nimport {stringSplitConfig} from './kernels/StringSplit';\nimport {stringToHashBucketFastConfig} from './kernels/StringToHashBucketFast';\nimport {subConfig} from './kernels/Sub';\nimport {sumConfig} from './kernels/Sum';\nimport {tanConfig} from './kernels/Tan';\nimport {tanhConfig} from './kernels/Tanh';\nimport {tileConfig} from './kernels/Tile';\nimport {topKConfig} from './kernels/TopK';\nimport {transformConfig} from './kernels/Transform';\nimport {transposeConfig} from './kernels/Transpose';\nimport {uniqueConfig} from './kernels/Unique';\nimport {unpackConfig} from './kernels/Unpack';\nimport {unsortedSegmentSumConfig} from './kernels/UnsortedSegmentSum';\nimport {zerosLikeConfig} from './kernels/ZerosLike';\n\n// List all kernel configs here\nconst kernelConfigs: KernelConfig[] = [\n  _fusedMatMulConfig,\n  absConfig,\n  acosConfig,\n  acoshConfig,\n  addConfig,\n  addNConfig,\n  allConfig,\n  anyConfig,\n  argMaxConfig,\n  argMinConfig,\n  asinConfig,\n  asinhConfig,\n  atanConfig,\n  atan2Config,\n  atanhConfig,\n  avgPoolConfig,\n  avgPool3DConfig,\n  avgPool3DGradConfig,\n  avgPoolGradConfig,\n  batchMatMulConfig,\n  batchNormConfig,\n  batchToSpaceNDConfig,\n  bincountConfig,\n  broadcastArgsConfig,\n  castConfig,\n  ceilConfig,\n  clipByValueConfig,\n  complexConfig,\n  complexAbsConfig,\n  concatConfig,\n  conv2DConfig,\n  conv2DBackpropFilterConfig,\n  conv2DBackpropInputConfig,\n  conv3DConfig,\n  conv3DBackpropFilterV2Config,\n  conv3DBackpropInputConfig,\n  cosConfig,\n  coshConfig,\n  cropAndResizeConfig,\n  cumprodConfig,\n  cumsumConfig,\n  denseBincountConfig,\n  depthToSpaceConfig,\n  depthwiseConv2dNativeConfig,\n  depthwiseConv2dNativeBackpropFilterConfig,\n  depthwiseConv2dNativeBackpropInputConfig,\n  diagConfig,\n  dilation2DConfig,\n  einsumConfig,\n  eluConfig,\n  eluGradConfig,\n  equalConfig,\n  erfConfig,\n  expConfig,\n  expandDimsConfig,\n  expm1Config,\n  fftConfig,\n  fillConfig,\n  flipLeftRightConfig,\n  floorConfig,\n  floorDivConfig,\n  fromPixelsConfig,\n  fusedConv2DConfig,\n  fusedDepthwiseConv2DConfig,\n  gatherNdConfig,\n  gatherV2Config,\n  greaterConfig,\n  greaterEqualConfig,\n  identityConfig,\n  ifftConfig,\n  imagConfig,\n  isFiniteConfig,\n  isInfConfig,\n  isNaNConfig,\n  leakyReluConfig,\n  lessConfig,\n  lessEqualConfig,\n  linSpaceConfig,\n  logConfig,\n  log1pConfig,\n  logicalAndConfig,\n  logicalNotConfig,\n  logicalOrConfig,\n  LRNConfig,\n  LRNGradConfig,\n  maxConfig,\n  maximumConfig,\n  maxPoolConfig,\n  maxPool3DConfig,\n  maxPool3DGradConfig,\n  maxPoolGradConfig,\n  maxPoolWithArgmaxConfig,\n  meanConfig,\n  minConfig,\n  minimumConfig,\n  mirrorPadConfig,\n  modConfig,\n  multinomialConfig,\n  multiplyConfig,\n  negConfig,\n  nonMaxSuppressionV3Config,\n  nonMaxSuppressionV4Config,\n  nonMaxSuppressionV5Config,\n  notEqualConfig,\n  oneHotConfig,\n  onesLikeConfig,\n  packConfig,\n  padV2Config,\n  powConfig,\n  preluConfig,\n  prodConfig,\n  raggedGatherConfig,\n  raggedRangeConfig,\n  raggedTensorToTensorConfig,\n  rangeConfig,\n  realConfig,\n  realDivConfig,\n  reciprocalConfig,\n  reluConfig,\n  relu6Config,\n  reshapeConfig,\n  resizeBilinearConfig,\n  resizeBilinearGradConfig,\n  resizeNearestNeighborConfig,\n  resizeNearestNeighborGradConfig,\n  reverseConfig,\n  rotateWithOffsetConfig,\n  roundConfig,\n  rsqrtConfig,\n  scatterNdConfig,\n  searchSortedConfig,\n  selectConfig,\n  seluConfig,\n  sigmoidConfig,\n  signConfig,\n  sinConfig,\n  sinhConfig,\n  sliceConfig,\n  softmaxConfig,\n  softplusConfig,\n  spaceToBatchNDConfig,\n  sparseFillEmptyRowsConfig,\n  sparseReshapeConfig,\n  sparseSegmentMeanConfig,\n  sparseSegmentSumConfig,\n  sparseToDenseConfig,\n  splitVConfig,\n  sqrtConfig,\n  squareConfig,\n  squaredDifferenceConfig,\n  stepConfig,\n  stridedSliceConfig,\n  stringNGramsConfig,\n  stringSplitConfig,\n  stringToHashBucketFastConfig,\n  subConfig,\n  sumConfig,\n  tanConfig,\n  tanhConfig,\n  tileConfig,\n  topKConfig,\n  transformConfig,\n  transposeConfig,\n  uniqueConfig,\n  unpackConfig,\n  unsortedSegmentSumConfig,\n  zerosLikeConfig\n];\n\nfor (const kernelConfig of kernelConfigs) {\n  registerKernel(kernelConfig);\n}\n"],"names":["contexts","WEBGL_ATTRIBUTES","alpha","antialias","premultipliedAlpha","preserveDrawingBuffer","depth","stencil","failIfMajorPerformanceCaveat","getWebGLContext","webGLVersion","customCanvas","newCtx","Error","canvas","OffscreenCanvas","document","createElement","createCanvas","addEventListener","ev","preventDefault","env","getBool","getContext","getWebGLRenderingContext","console","log","gl","isContextLost","disable","DEPTH_TEST","STENCIL_TEST","BLEND","DITHER","POLYGON_OFFSET_FILL","SAMPLE_COVERAGE","enable","SCISSOR_TEST","CULL_FACE","cullFace","BACK","PackingScheme","TextureUsage","PhysicalTextureType","getUnpackedMatrixTextureShapeWidthHeight","rows","columns","getDenseTexShape","shape","size","util","texelsNeeded","Math","ceil","getPackedMatrixTextureShapeWidthHeight","max","getTextureConfig","textureHalfFloatExtension","glany","internalFormatFloat","internalFormatHalfFloat","internalFormatPackedHalfFloat","internalFormatPackedFloat","textureFormatFloat","downloadTextureFormat","downloadUnpackNumChannels","defaultNumChannels","textureTypeHalfFloat","textureTypeFloat","getNumber","R32F","R16F","RGBA16F","RGBA32F","RED","HALF_FLOAT","FLOAT","RGBA8","RGBA","HALF_FLOAT_OES","callAndCheck","func","returnValue","error","getError","NO_ERROR","status","INVALID_ENUM","INVALID_VALUE","INVALID_OPERATION","INVALID_FRAMEBUFFER_OPERATION","OUT_OF_MEMORY","CONTEXT_LOST_WEBGL","getWebGLErrorMessage","checkWebGLError","MIN_FLOAT16","MAX_FLOAT16","canBeRepresented","num","abs","getExtensionOrThrow","extensionName","throwIfNull","getExtension","lineNumberRegex","logShaderSourceAndInfoLog","shaderSource","shaderInfoLog","lineNumberRegexResult","exec","lineNumber","shaderLines","split","pad","length","toString","linesWithLineNumbers","map","line","maxLineLength","i","beforeErrorLines","slice","errorLine","afterErrorLines","join","validateProgram","program","getProgramParameter","VALIDATE_STATUS","getProgramInfoLog","bindVertexBufferToProgramAttribute","attribute","buffer","arrayEntriesPerItem","itemStrideInBytes","itemOffsetInBytes","loc","getAttribLocation","bindBuffer","ARRAY_BUFFER","vertexAttribPointer","enableVertexAttribArray","bindTextureToProgramUniformSampler","texture","uniformSamplerLocation","textureUnit","validateTextureUnit","activeTexture","TEXTURE0","bindTexture","TEXTURE_2D","bindTextureUnit","uniform1i","bindColorTextureToFramebuffer","framebuffer","bindFramebuffer","FRAMEBUFFER","framebufferTexture2D","COLOR_ATTACHMENT0","unbindColorTextureFromFramebuffer","validateFramebuffer","checkFramebufferStatus","FRAMEBUFFER_COMPLETE","FRAMEBUFFER_INCOMPLETE_ATTACHMENT","FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT","FRAMEBUFFER_INCOMPLETE_DIMENSIONS","FRAMEBUFFER_UNSUPPORTED","getFramebufferErrorMessage","returnTOrNull","failureMessage","tOrNull","maxTextureUnit","MAX_COMBINED_TEXTURE_IMAGE_UNITS","glTextureUnit","textureUnitRange","getBatchDim","dimsToSkip","getRowsCols","getShapeAs3D","shapeAs3D","isEven","n","isReshapeFree","shape1","shape2","shape1Cols","shape2Cols","MAX_TEXTURE_SIZE","MAX_TEXTURES_IN_SHADER","hasExtension","isWebGLVersionEnabled","e","isDownloadFloatTextureEnabled","createFloatTextureAndBindToFramebuffer","COLOR_BUFFER_HALF_FLOAT","texConfig","createTexture","width","height","texImage2D","frameBuffer","createFramebuffer","isFrameBufferComplete","deleteTexture","deleteFramebuffer","createHalfFloatTextureAndBindToFramebuffer","assertNotComplex","tensor","opName","Array","isArray","forEach","t","dtype","ENV","getGlslDifferences","version","varyingVs","varyingFs","texture2D","output","defineOutput","defineSpecialNaN","defineSpecialInf","defineRound","getLogicalCoordinatesFromFlatIndex","coords","index","strides","stride","line1","line2","getOutputLogicalCoordinatesFromFlatIndexByUniform","_","getLogicalCoordinatesFromFlatIndexByUniform","variableName","indicesArr","numCoords","d","symbolicallyComputeStrides","getFlatIndexFrom3D","registerFlag","get","getParameter","getWebGLMaxTextureSize","MAX_TEXTURE_IMAGE_UNITS","min","getMaxTexturesInShader","queryTimerVersion","getWebGLDisjointQueryTimerVersion","device_util","isCapableOfRenderingToFloatTexture","isWebGLFenceEnabled","fenceSync","threshold","Infinity","ENCODE_FLOAT_SNIPPET","getBroadcastDims","backend_util","makeShader","inputsInfo","outputShape","prefixSnippets","x","shapeInfo","logicalShape","isUniform","push","name","enableShapeUniforms","uniformShape","getUniformInfoFromShape","packedInputs","texShape","customUniforms","type","arrayIndex","inputPrefixSnippet","inputSamplingSnippet","inInfo","outShapeInfo","usesPackedTextures","res","getPackedSamplerFromInInfo","getSamplerFromInInfo","inShape","outShape","inputInfo","texName","texFuncSnippet","charAt","toUpperCase","funcName","inRank","outRank","broadcastDims","getCoordsDataType","rankDiff","coordsSnippet","fields","unpackedCoordsSnippet","s","isInputScalar","outSize","isOutputScalar","cols","indexOf","getPackedSamplerAtOutputCoords","outTexShape","inTexShape","flatOffset","getSamplerAtOutputCoords","getInputSamplingSnippet","glsl","floatTextureSampleSnippet","getFloatTextureSampleSnippet","outputSamplingSnippet","floatTextureSetOutputSnippet","shaderPrefix","SHADER_PREFIX","SAMPLE_1D_SNIPPET","SAMPLE_2D_SNIPPET","SAMPLE_3D_SNIPPET","getShaderPrefix","isPacked","packedTexShape","getOutputPacked1DCoords","texelsInLogicalRow","getOutputPacked2DCoords","texelsInBatch","getOutputPacked3DCoords","texelsInBatchN","batches","b","getOutputPackedNDCoords","getPackedOutputSamplingSnippet","getFloatTextureSetRGBASnippet","getOutput1DCoords","getOutput2DCoords","coordsFromIndexSnippet","shader_util","getOutput3DCoords","getOutput4DCoords","getOutput5DCoords","getOutput6DCoords","getOutputSamplingSnippet","getFloatTextureSetRSnippet","SHADER_PACKED_PREFIX","userCode","texNumR","texNumC","offset","getFlatOffsetUniformName","tNumR","tNumC","getSamplerScalar","getUniformSampler","getSampler1D","newShape","keptDims","squeezedShape","newInputInfo","squeezeInputInfo","params","getSqueezedParams","getSampler2D","stride0","stride1","getSampler3D","stride2","stride2Str","stride1Str","stride0Str","getSampler4D","stride3","getSampler5D","stride4","getSampler6D","getPackedSamplerScalar","getPackedSampler1D","valuesPerRow","getPackedSampler2D","getPackedSampler3D","rank","getPackedSamplerND","inSize","useSqueezePackedShape","squeezeShape","useSqueezeShape","JSON","parse","stringify","compileProgram","gpgpu","inputs","inputInfos","input","texData","variableNames","inShapeInfos","source","shader_compiler","fragmentShader","fragmentShaderSource","createShader","FRAGMENT_SHADER","compileShader","getShaderParameter","COMPILE_STATUS","getShaderInfoLog","createFragmentShader","webGLProgram","createProgram","uniformLocations","customUniformLocations","infLoc","nanLoc","inShapesLocations","inTexShapesLocations","outShapeLocation","outShapeStridesLocation","outTexShapeLocation","getUniformLocations","getUniformLocation","shouldThrow","varName","validateBinaryAndProgram","shapeInfos","shapeA","shapeB","texShapeA","texShapeB","useShapeUniforms","DecodeMatrixProgram","constructor","packedOutput","outPackingScheme","DENSE","this","DecodeMatrixPackedProgram","EncodeFloatProgram","outTexUsage","DOWNLOAD","EncodeFloatPackedProgram","CHANNEL_CHAR_TO_INDEX_MAP","EncodeMatrixProgram","inputIsUnsignedByte","usedChannels","mainLoop","usedChannelIndex","curChannel","EncodeMatrixPackedProgram","row","col","channel","createVertexShader","vertexShaderSource","vertexShader","VERTEX_SHADER","webgl_util","createVertexBuffer","data","createBuffer","bufferData","STATIC_DRAW","Float32Array","createIndexBuffer","ELEMENT_ARRAY_BUFFER","Uint16Array","createAndConfigureTexture","internalFormat","textureFormat","textureType","maxTextureSize","requested","tex2d","texParameteri","TEXTURE_WRAP_S","CLAMP_TO_EDGE","TEXTURE_WRAP_T","TEXTURE_MIN_FILTER","NEAREST","TEXTURE_MAG_FILTER","texStorage2D","getInternalFormatForFloat32MatrixTexture","textureConfig","getInternalFormatForFloat16MatrixTexture","getInternalFormatForUnsignedBytesMatrixTexture","getInternalFormatForPackedMatrixTexture","getInternalFormatForFloat16PackedMatrixTexture","downloadPackedMatrixFromBuffer","batch","physicalRows","physicalCols","gl2","downloadTarget","w","h","tex_util","PIXEL_PACK_BUFFER","getBufferSubData","GPGPUContext","outputTexture","disposed","itemsToPoll","glVersion","setWebGLContext","createVertexArray","bindVertexArray","vao","deleteVertexArray","getVertexArray","VERTEX_ARRAY_BINDING","ext","createVertexArrayOES","bindVertexArrayOES","deleteVertexArrayOES","VERTEX_ARRAY_BINDING_OES","COLOR_BUFFER_FLOAT","parallelCompilationExtension","TEXTURE_FLOAT","TEXTURE_HALF_FLOAT","textureFloatExtension","colorBufferFloatExtension","colorBufferHalfFloatExtension","vertexBuffer","gpgpu_util","indexBuffer","debug","dispose","warn","finish","deleteBuffer","createFloat32MatrixTexture","throwIfDisposed","createFloat16MatrixTexture","createUnsignedBytesMatrixTexture","UNSIGNED_BYTE","uploadPixelDataToTexture","pixels","Uint8Array","texSubImage2D","uploadDenseMatrixToTexture","dataForUpload","texelDataType","set","createFloat16PackedMatrixTexture","createPackedMatrixTexture","deleteMatrixTexture","downloadByteEncodedFloatMatrixFromOutputTexture","downloadMatrixDriver","readPixels","downloadFloat32MatrixFromBuffer","createBufferFromTexture","bindTextureToFrameBuffer","result","bufferSizeBytes","bytesPerFloat","STREAM_READ","unbindTextureToFrameBuffer","createAndWaitForFence","fenceContext","createFence","pollFence","query","isFencePassed","sync","SYNC_GPU_COMMANDS_COMPLETE","flush","clientWaitSync","ALREADY_SIGNALED","CONDITION_SATISFIED","beginQuery","endQuery","isQueryAvailable","downloadMatrixFromPackedTexture","packedRGBA","program2","attachShader","linkProgram","LINK_STATUS","Object","assign","assert","setProgram","deleteProgram","useProgram","uniformName","getAttributeLocation","getUniformLocationNoThrow","setInputMatrixTexture","inputMatrixTexture","uniformLocation","throwIfNoProgram","setOutputMatrixTexture","outputMatrixTexture","setOutputMatrixTextureDriver","setOutputPackedMatrixTexture","outputPackedMatrixTexture","setOutputMatrixWriteRegion","startRow","numRows","startColumn","numColumns","setOutputMatrixWriteRegionDriver","setOutputPackedMatrixWriteRegion","debugValidate","executeProgram","boundVao","drawElements","TRIANGLES","UNSIGNED_SHORT","blockUntilAllProgramsCompleted","getQueryTimerExtension","disjointQueryTimerExtension","getQueryTimerExtensionWebGL2","getQueryTimerExtensionWebGL1","createQuery","TIME_ELAPSED_EXT","createQueryEXT","beginQueryEXT","endQueryEXT","async","getQueryTime","getQueryParameter","QUERY_RESULT","getQueryObjectEXT","QUERY_RESULT_EXT","available","QUERY_RESULT_AVAILABLE","disjoint","GPU_DISJOINT_EXT","QUERY_RESULT_AVAILABLE_EXT","Promise","resolve","addItemToPoll","pollItems","arr","linearSearchLastTrue","isDoneFn","resolveFn","scheduleFn","platform","setTimeoutCustom","bind","downloadAndDecode","outputMatrixTextureMaybePacked","viewport","scissor","y","simpleAbsImpl","vals","resultValues","Abs","createSimpleBinaryKernelImpl","op","aShape","bShape","aVals","bVals","resultRank","resultStrides","resultSize","aRank","bRank","aStrides","bStrides","aBroadcastDims","bBroadcastDims","aLoc","aIndex","bLoc","bIndex","complex","args","backend","real","imag","realVals","dataId","values","imagVals","complexInfo","makeTensorInfo","complexTensorInfos","Complex","zeros","identity","incRef","Identity","realVal","Real","castImpl","inputType","Int32Array","from","zero","resultData","resultShape","a","cast","attrs","zerosTensorInfo","floatX","disposeIntermediateTensorInfo","realPart","resultType","Cast","binaryKernelFunc","simpleImpl","complexImpl","cpuBackend","decodedAVals","decodedBVals","$dtype","$aComplex","$aComplexVals","aReal","aImag","aRealVals","aImagVals","$bComplex","$bComplexVals","bReal","bImag","bRealVals","bImagVals","resultRealData","resultImagData","resultReal","resultImag","createComplexBinaryKernelImpl","resultRealVals","resultImagVals","aIdx","bIdx","opResult","addImpl","addComplexImpl","Add","bincountImpl","xVals","weightsVals","weightsDtype","weightsShape","weightsSize","outVals","value","bincountReduceImpl","xBuf","weightsBuf","binaryOutput","numCols","outBuf","j","createSimpleUnaryImpl","newValues","unaryKernelFunc","xSize","unaryKernelFuncFromImpl","unaryImpl","ceilImpl","xi","Ceil","concatImpl","simplyConcat","colOffset","decodedData","tIdx","resIdx","equalImpl","expImpl","Equal","exp","expm1Impl","Exp","expm1","floorImpl","Expm1","floor","Floor","gatherNdImpl","indicesData","paramsBuf","numSlices","sliceRank","sliceSize","paramsShape","paramsSize","flattenIndex","dim","k","indexToLoc","gatherV2Impl","indicesBuf","flattenOutputShape","originalLoc","batchIdx","indicesIdx","indicesIndex","locToIndex","originalIndex","greaterImpl","greaterEqualImpl","Greater","lessImpl","GreaterEqual","lessEqualImpl","Less","LessEqual","linSpaceImpl","start","stop","step","logImpl","Log","maxImpl","reduceSize","Number","isNaN","maximumImpl","aValue","bValue","minimumImpl","Maximum","multiplyImpl","Minimum","multiplyComplexImpl","Multiply","negImpl","xShape","xDtype","minusOne","Neg","notEqualImpl","NotEqual","transposeImpl","perm","xRank","xStrides","newStrides","newLoc","Transpose","prodImpl","reductionAxes","reduceShape","outDtype","upcastType","prod","Prod","makeSplits","indices","indicesShape","paramsNestedSplits","numParamsDenseValues","valueSlices","numValues","numSplits","outSplits","fill","splits","lastSplit","validateSplits","nrows","rowLength","limit","outDim","outSplitsOutDim","delta","computeFlatOuterDims","orig","numOutDims","outDims","inDim","getValues","paramsDenseValues","paramsDenseValuesShape","paramsDenseValuesDType","valuesShape","valuesOut","numElements","valueSize","denseM","valuesM","outPos","writeValueSlices","raggedGatherImpl","paramsNestedSplitsShapes","outputRaggedRank","numParams","locString","validateIndices","outputNestedSplits","splitsOut","getSplits","outputDenseValues","INT32_MAX","raggedRangeImpl","starts","startsShape","startsDType","limits","limitsShape","deltas","deltasShape","broadcastStarts","broadcastLimits","broadcastDeltas","inSizes","nRows","rtNestedSplits","nVals","rtDenseValues","valueIndex","rowSize","RowPartitionType","RaggedTensorToTensorOp","shapeShape","valuesDType","defaultValue","defaultValueShape","rowPartitionValues","rowPartitionValuesShapes","rowPartitionTypeStrings","rowPartitionTypes","raggedRank","getRowPartitionTypeByDimension","dimension","FIRST_DIM_SIZE","getRowPartitionTensor","getMaxWidth","rowPartitionTensor","VALUE_ROWIDS","getMaxWidthValueRowID","ROW_SPLITS","getMaxWidthRowSplit","static","rowSplit","tensorLength","maxWidth","currentWidth","valueRowIds","indexLength","firstEqualIndex","firstEqualIndexValue","tensorShapeFromTensor","tShape","isPartial","makeShape","calculateOutputSize","firstDim","valueShape","calculateFirstParentOutputIndex","firstDimension","outputIndexMultiplier","firstDimensionOutput","minDimension","currentOutputIndex","calculateOutputIndexRowSplit","parentOutputIndex","outputSize","rowSplitSize","realLength","parentOutputIndexCurrent","calculateOutputIndexValueRowID","indexSize","currentOutputColumn","currentValueRowId","nextValueRowId","calculateOutputIndex","partitionType","getFirstDimensionSize","firstPartitionTensor","firstPartitionType","compute","multiplier","outputTensor","outputIndex","setOutput","valuesBase","outputBase","elementShape","valueElementSize","outputIndexSize","srcShape","tidy","defaultValueTensor","reshape","bCastDefault","broadcastTo","dataSync","srcStart","dstStart","dstEnd","srcI","dstI","src","subarray","copyArray","dst","out","raggedTensorToTensorImpl","shapesShape","rangeImpl","rsqrtImpl","sqrt","Rsqrt","scatterImpl","updates","numUpdates","sumDupeIndices","flattenShape","updatesData","sigmoidImpl","Sigmoid","sliceImpl","begin","isContinous","slice_util","inBuf","outLoc","inLoc","idx","Slice","sparseFillEmptyRowsImpl","indicesDType","denseShape","indicesCount","denseRows","emptyRowIndicator","reverseIndexMap","rowsAreOrdered","lastIndicesRow","csrOffset","allRowsFull","rowEmpty","outputIndices","outputValues","fullIndicesCount","filledCount","outputI","startingIndex","sparseReshapeImpl","inputIndices","inputIndicesShape","inputDType","inputShape","targetShape","denseSize","nnz","outputRank","product","unknownIndex","missing","trunc","inputRank","inputStrides","outputStrides","newIndices","id","sparseSegmentReductionImpl","segmentIds","isMean","numIndices","inputFlat","numCol","outputRows","outputLength","reduce","end","uninitializedIndex","outIndex","nextIndex","sqrtImpl","squaredDifferenceImpl","Sqrt","diff","SquaredDifference","stridedSliceImpl","StringNGramsOp","separator","nGramWidths","leftPad","rightPad","padWidth","preserveShortSequences","preserveShort","getPadWidth","nGramWidth","getNumNGrams","createNGrams","splitIndex","outputStartIndex","numNGrams","nGramIndex","leftPadding","rightPadding","numTokens","dataStartIndex","nGramSize","nGram","nextNGramIndex","appendToNGram","str","inputDataSize","splitsSize","prevSplit","validSplits","numBatchItems","nGramsSplits","empty","nGrams","outputStartIdx","dataLength","stringNGramsImpl","dataSplits","delimiters","skipEmpty","delimiter","f","token","tokenStart","stringSplitImpl","batchSize","tokens","maxNumEntries","prevTokensLength","nEntries","c","stringToHashBucketFastImpl","numBuckets","modulo","getLowBitsUnsigned","subImpl","subComplexImpl","Sub","tileImpl","reps","comparePair","valueDiff","select","array","left","right","z","sd","sign","topKImpl","sorted","lastDim","allTopKVals","allTopKIndices","valAndInd","sort","outOffset","topKVals","topKIndices","uniqueImpl","axis","$axis","uniqueElements","inputBuffer","TensorBuffer","uniqueIndices","is1DTensor","element","axisValues","m","undefined","uniqueIndex","keys","outputTmpShape","outputBuffer","uniqueElementIndex","addImplCPU","bincountImplCPU","bincountReduceImplCPU","castImplCPU","ceilImplCPU","concatImplCPU","equalImplCPU","expImplCPU","expm1ImplCPU","floorImplCPU","gatherNdImplCPU","gatherV2ImplCPU","greaterImplCPU","greaterEqualImplCPU","lessImplCPU","lessEqualImplCPU","linSpaceImplCPU","logImplCPU","maxImplCPU","maximumImplCPU","minimumImplCPU","multiplyImplCPU","negImplCPU","notEqualImplCPU","prodImplCPU","raggedGatherImplCPU","raggedRangeImplCPU","raggedTensorToTensorImplCPU","rangeImplCPU","rsqrtImplCPU","scatterImplCPU","sigmoidImplCPU","simpleAbsImplCPU","sliceImplCPU","sparseFillEmptyRowsImplCPU","sparseReshapeImplCPU","sparseSegmentReductionImplCPU","sqrtImplCPU","stridedSliceImplCPU","stringNGramsImplCPU","stringSplitImplCPU","stringToHashBucketFastImplCPU","subImplCPU","tileImplCPU","topKImplCPU","transposeImplCPU","uniqueImplCPU","shared","getVecChannels","getChannels","PackProgram","channels","outOfBoundsCondition","getOutOfBoundsCondition","setup","getSetup","getOutput","getSourceCoordsArr","dims","coord","cond","innerDims","sourceCoords","ReshapePackedProgram","thisRC","getReshapedInputCoords","TextureManager","numUsedTextures","numFreeTextures","_numBytesAllocated","_numBytesFree","freeTextures","logEnabled","usedTextures","acquireTexture","shapeRC","usage","physicalTexType","getPhysicalFromLogicalTextureType","shapeKey","getKeyFromTextureShape","texBytes","computeBytes","newTexture","shift","PACKED_2X2_FLOAT32","PACKED_2X2_FLOAT16","UNPACKED_FLOAT32","UNPACKED_FLOAT16","PACKED_4X1_UNSIGNED_BYTE","releaseTexture","logicalTexType","deleteTexThreshold","texList","texIndex","splice","total","freeRatio","round","numBytesAllocated","numBytesFree","getNumUsedTextures","getNumFreeTextures","tex","internalFormatForPhysicalTexType","packedWidth","packedHeight","bytesPerElement","numBytesForInternalFormat","UPLOAD","RENDER","getPhysicalTextureForRendering","PIXELS","shapeRowsCol","UnaryOpProgram","opSnippet","CHECK_NAN_SNIPPET","LINEAR","ABS","ELU","RELU","RELU6","CLONE","SIGMOID","UnaryOpPackedProgram","UnpackProgram","getSourceCoords","whereImpl","kernel_impls","binaryCaches","CPU_HANDOFF_SIZE_THRESHOLD","BEFORE_PAGING_CONSTANT","MathBackendWebGL","KernelBackend","gpuResource","super","pendingRead","WeakMap","pendingDisposal","WeakSet","dataRefCount","numBytesInGPU","uploadWaitMs","downloadWaitMs","lastGlFlushTime","warnedAboutMemory","pendingDeletes","newGPGPU","binaryCache","gpgpuCreatedLocally","textureManager","numMBBeforeWarning","global","screen","window","devicePixelRatio","DataStorage","engine","nextDataId","numDataIds","writeTexture","texHeight","texWidth","inData","runWebGLProgram","write","checkNumericalProblems","refCount","has","decRef","move","tensorInfo","disposeData","readSync","unary_op","convertAndCacheOnCPU","shouldTimeProgram","activeTimers","realValues","imagValues","getValuesFromTexture","subscribers","read","tmpDownloadTarget","decode","tmpData","ps","all","dTypeVals","delete","removeDataId","readToGPU","options","gpuResouorce","tmpTarget","customTexShape","tensorRef","makeTensorFromTensorInfo","bufferSync","strings","shouldUsePackedProgram","timerAvailable","time","oldActiveTimers","newActiveTimers","outerMostTime","programTimersStack","flattenedActiveTimerQueries","filter","flattenedActiveTimerNames","kernelMs","wallMs","ms","memory","unreliable","numBytesInGPUAllocated","numBytesInGPUFree","startTimer","startMs","endMs","endTimer","waitForQueryAndGetTime","timerQuery","force","add","releaseGPUData","key","origDataId","getTexture","uploadToGPU","getDataInfo","shouldExecuteOnCPU","sizeThreshold","every","getGPGPUContext","where","condition","condVals","packedUnaryOp","outInfo","compileAndRun","outValues","makeOutput","encodedValues","unpackTensor","packTensor","packedReshape","afterShape","input3DShape","input3D","afterShapeAs3D","customValues","texSize","outputDtype","customUniformValues","preventEagerUnpackingOfOutput","outData","texelShape","dataToDispose","inputsData","uniformValues","savedInput","outputData","keyInputs","concat","hasOffset","xTexShape","rank1","rank2","rank34","isLogicalShapTexShapeEqual","isScalar","isInOutTexShapeEqual","isTexShapeGreaterThanOne","keyUserCode","gpgpu_math","binary","getAndSaveBinary","outTex","uniform1f","NaN","varLoc","varOffsetLoc","varShapeLoc","varTexShapeLoc","uniform1iv","uniform2iv","uniform3iv","uniform4iv","uniform2i","uniform1fv","outShapeLoc","customLoc","customValue","uniform2fv","uniform3fv","uniform4fv","info","glFlushThreshold","unpacked","getBinary","getTextureManager","HTMLCanvasElement","remove","floatPrecision","floatPrecisionValue","debugFlag","underflowCheckValue","scalar","epsilon","logShape","maxTexSize","maxSizeForNarrowTex","squeezeResult","textureShape","isLongNarrowTex","batchDim","isByteArray","Uint8ClampedArray","tempDenseInputTexShape","tempDenseInputHandle","tempDenseInputTexData","preventEagerUnpacking","encodedOutputTarget","outputTexData","float32Values","float32ToTypedArray","texType","mb","toFixed","checkCompileCompletion","entries","checkCompletion_","checkCompletionAsync_","p","COMPLETION_STATUS_KHR","nextFrame","createTensorFromTexture","isTexture","makeTensorFromDataId","registerBackend","BinaryOpProgram","CHECK_NAN_SNIPPET_PACKED","BinaryOpPackedProgram","checkOutOfBounds","supportsBroadcasting","checkOutOfBoundsString","identityConfig","kernelName","backendName","kernelFunc","realTensorInfo","imagTensorInfo","complexConfig","LEAKYRELU","LEAKYRELU_PACKED","leakyReluConfig","LeakyRelu","$alpha","PRELU","PRELU_PACKED","preluConfig","Prelu","CHECK_NAN_SNIPPET_UNARY","packedOpSnippet","cpuKernelImpl","webglBackend","xData","supportsComplex","aData","bData","complexParts","aPart","bPart","aHandle","bHandle","complexOutput","mapActivationToShaderProgram","activation","packed","unary_packed_op","MatMulPackedProgram","transposeA","transposeB","addBias","hasPreluActivation","hasLeakyreluActivation","sharedDim","sharedDimensionPacked","aSample","bSample","aSwizzle","bSwizzle","activationSnippet","applyActivationSnippet","addBiasSnippet","batchASnippet","batchBSnippet","COMPLEX_MULTIPLY","REAL","IMAG","BinaryOpComplexProgram","MUL","multiply","realProgram","binaryop_complex_gpu","imagProgram","imagPart","cpuMultiply","multiplyConfig","$shape","$xSize","xTexData","reshapeConfig","Reshape","MeanProgram","reduceInfo","divisor","windowSize","windowSizeNearestVec4","windowSizeVec4Remainder","updateSnippet","denominator","toPrecision","ReduceProgram","reduceType","initializationValue","compareOp","vecType","reductionType","reductionStages","stages","getReductionStages","previousResult","TransposeProgram","newDim","switched","originalOrder","switchedCoords","getSwitchedCoords","TransposePackedProgram","outputOrder","switchedOrder","nextColumn","getc","sum","keepDims","reductionIndices","origAxes","axes","permutedAxes","sumInputIsTransposed","sumInput","sumOutShape","reshapedInput","reduced","sumOutType","sumImpl","sumConfig","Sum","transpose","cpuTranspose","transposeConfig","MATMUL_SHARED_DIM_THRESHOLD","batchMatMulImpl","bias","preluActivationWeights","leakyreluAlpha","innerShapeA","innerShapeB","outerShapeA","outerShapeB","outerDimsA","outerDimsB","batchDimA","batchDimB","broadcast_util","a3dShape","b3dShape","a3d","b3d","intermediates","hasBias","hasPreluActivationWeights","hasLeakyreluAlpha","fusedActivation","aVec","bVec","shouldReshapeB","aVec3d","bVec3d","$leakyreluAlpha","outReshaped","_fusedMatMulConfig","_FusedMatMul","absConfig","acos","acosConfig","Acos","acosh","acoshConfig","Acosh","ADD","addKernelFunc","cpuAdd","addConfig","AddNProgram","shapes","snippets","variable","operation","AddNPackedProgram","addNConfig","AddN","addN","tensors","midIndex","leftSide","rightSide","d1","d2","allConfig","All","permutedX","a2D","anyConfig","Any","ArgMinMaxProgram","firstPass","compOp","indexSnippet","ArgMinMaxPackedProgram","sourceLocSetup","sourceRank","sourceLocDType","inChannel","intChannels","srcRCoords","srcGCoords","srcBCoords","srcACoords","fetchCandidateIdx","fetchValue","getBestIndicesAChannelSnippet","argReduce","bestIndicesA","argReducePacked","argMinMaxReduce","intermediateTensorInfos","xtexData","xUnPacked","reshaped","argMaxConfig","ArgMax","$x","argMinConfig","ArgMin","asin","asinConfig","Asin","asinh","asinhConfig","Asinh","atan","atanConfig","Atan","atan2","atan2Config","Atan2","atanh","atanhConfig","Atanh","Pool2DProgram","convInfo","poolType","computePositions","flattenPositions","includeBatchInIndex","filterWidth","strideHeight","strideWidth","dilationHeight","dilationWidth","effectiveFilterHeight","effectiveFilterWidth","padTop","padInfo","top","padLeft","isAvgPool","batchFlattenPositionStr","inHeight","inWidth","inChannels","flattenPositionStr","filterWidthNearestVec4","filterWidthVec4Remainder","Pool3DProgram","strideDepth","dilationDepth","effectiveFilterDepth","padFront","front","inDepth","avgPoolConfig","AvgPool","filterSize","dimRoundingMode","filterHeight","avgPoolProgram","avgPool3DConfig","AvgPool3D","dataFormat","AvgPool2DBackpropProgram","avgMultiplier","outHeight","outWidth","AvgPool3DBackpropProgram","filterDepth","outDepth","avgPool3DGradConfig","AvgPool3DGrad","dy","avgPoolBackpropProgram","avgPoolGradConfig","AvgPoolGrad","batchMatMulConfig","BatchMatMul","BatchNormProgram","meanShape","varianceShape","offsetShape","scaleShape","varianceEpsilon","offsetSnippet","scaleSnippet","BatchNormPackedProgram","batchNormConfig","FusedBatchNorm","mean","variance","scale","finalInputs","SliceProgram","destSize","getCoords","body","coordSum","SlicePackedProgram","sourceLoc","getChannel","upperRow","lowerRow","$begin","$size","newTexData","shallowSlice","sliceConfig","batchToSpaceNDConfig","BatchToSpaceND","blockShape","crops","permuted","reshapedPermuted","sliceBeginCoords","toDispose","reshapedIntermediate","transposedIntermediate","reshapedIntermediate2","sliced","bincountConfig","Bincount","weights","broadcastArgsConfig","BroadcastArgs","s0","s1","s0Vals","s1Vals","broadcastShape","notEqual","notEqualConfig","realConfig","TO_INT","castConfig","zerosTensor","tf","int","CEIL","ceilConfig","ClipProgram","ClipPackedProgram","clipByValueConfig","ClipByValue","clipValueMin","clipValueMax","ComplexAbsProgram","makeComplexComponentTensorInfo","complexTensor","complexPart","complexAbsConfig","ComplexAbs","programInputs","ConcatProgram","offsets","lastIndex","lastShift","ConcatPackedProgram","lastChannels","allChannels","getValueSnippet","shiftedChannels","channelIdx","imagConfig","Imag","reals","imags","realConcated","imagConcated","r","runOnCpu","tensors2D","innerSize","inputsValShapes","finalOutShape","$inputs","shouldPack","maxTexturesInShader","reducedInputs","subArray","computeTensors2D","reshapedResult","concatConfig","Concat","Conv2DProgram","inputDepthNearestVec4","inputDepthVec4Remainder","isChannelsLast","rowDim","colDim","channelDim","Conv3DProgram","Conv2DPackedProgram","hasLeakyReluAlpha","texelsAcross","texelC","colIndex","nextTexelOffset","Im2ColPackedProgram","boundsCheckingSnippet","unrolled","getShapeForBatchMatMul","conv2dByMatMul","sharedMatMulDim","outerShapeX","outerShapeFilter","outChannels","xReshaped","originalXTexDataShape","filterReshaped","pointwiseConv","pointwiseConvTexData","conv2dWithIm2Row","x2ColShape","w2Row","im2ColProgram","im2Col","im2ColReshaped","matmulProgram","conv2DConfig","Conv2D","dilations","$dataFormat","Conv2DDerFilterProgram","filterShape","Conv2DDerInputProgram","Conv3DDerFilterProgram","Conv3DDerInputProgram","conv2DBackpropFilterConfig","Conv2DBackpropFilter","conv2DBackpropInputConfig","Conv2DBackpropInput","conv3DConfig","Conv3D","conv3DBackpropFilterV2Config","Conv3DBackpropFilterV2","conv3DBackpropInputConfig","Conv3DBackpropInputV2","cos","cosConfig","Cos","cosh","coshConfig","Cosh","CropAndResizeProgram","imageShape","boxShape","cropSize","method","extrapolationValue","imageHeight","imageWidth","numBoxes","cropHeight","cropWidth","methodId","inputHeightFloat","inputWidthFloat","heightRatio","heightScale","inY","widthRatio","widthScale","inX","cropAndResizeConfig","CropAndResize","image","boxes","boxInd","CumOpType","CumProgram","exclusive","reverse","initVal","val","idxString","getFinalCoord","cumImpl","permutation","permutedAxis","log2","prevResult","reverseTransposedResult","cumprodConfig","Cumprod","cumsumConfig","Cumsum","denseBincountConfig","DenseBincount","DepthToSpaceProgram","blockSize","getHeightCoordString","getWidthCoordString","getDepthCoordString","getOutputDepthSize","getInputSamplingString","depthToSpaceConfig","DepthToSpace","outputHeight","outputWidth","outputDepth","DepthwiseConv2DProgram","channelMul","DepthwiseConvPacked2DProgram","depthwiseConv2dNativeConfig","DepthwiseConv2dNative","$dilations","DepthwiseConv2DDerFilterProgram","DepthwiseConv2DDerInputProgram","depthwiseConv2dNativeBackpropFilterConfig","DepthwiseConv2dNativeBackpropFilter","depthwiseConv2dNativeBackpropInputConfig","DepthwiseConv2dNativeBackpropInput","DiagProgram","diagConfig","Diag","flat","Dilation2DProgram","dilation2DConfig","Dilation2D","einsumConfig","Einsum","equation","allDims","summedDims","idDims","path","steps","nSteps","numDimsRemaining","tensorsToDispose","idTerm","permutationIndices","expandDims","dimsToExpand","elu","eluConfig","Elu","eluGradConfig","EluGrad","equal","equalConfig","erf","erfConfig","Erf","expConfig","$dim","expandDimsConfig","ExpandDims","EXPM1","expm1Config","FFTProgram","component","inverse","innerDim","exponentMultiplierSnippet","PI","resultDenominator","opString","fftImpl","inputSize","innerDimensionSize","input2D","complexOutputReshaped","fftConfig","FFT","FillProgram","fillConfig","Fill","FlipLeftRightProgram","flipLeftRightConfig","FlipLeftRight","FLOOR","floorConfig","floorDiv","floorDivConfig","FloorDiv","FromPixelsProgram","FromPixelsPackedProgram","fromPixelsConfig","FromPixels","numChannels","isVideo","HTMLVideoElement","isImage","HTMLImageElement","videoWidth","videoHeight","newWillReadFrequently","fromPixels2DContext","willReadFrequently","drawImage","tempPixelHandle","fusedConv2DConfig","FusedConv2D","prepareInputs","alignInputWithDataFormat","alignedInput","fusedDepthwiseConv2DConfig","FusedDepthwiseConv2D","shouldPackDepthwiseConv","GatherNDProgram","sliceDim","gatherNdConfig","GatherNd","flattenIndices","flattenX","outValue","GatherProgram","currentCoords","gatherV2","batchDims","parsedAxis","indicesVals","axisDim","indicesSize","outerSize","dimSize","gatherV2Config","GatherV2","greater","greaterConfig","greaterEqual","greaterEqualConfig","ifftConfig","IFFT","isFinite","isFiniteConfig","IsFinite","isInf","isInfConfig","IsInf","isNaNConfig","IsNan","less","lessConfig","lessEqual","lessEqualConfig","linSpaceConfig","LinSpace","logConfig","log1p","log1pConfig","Log1p","logicalAnd","logicalAndConfig","LogicalAnd","logicalNot","logicalNotConfig","LogicalNot","logicalOr","logicalOrConfig","LogicalOr","LRNProgram","radius","beta","rad","maxD","powOperator","basis","LRNPackedProgram","LRNConfig","LRN","depthRadius","LRNGradProgram","LRNGradConfig","LRNGrad","maxInputIsTransposed","maxInput","maxInputValues","maxOutShape","reshapedOutput","maxConfig","Max","maximum","maximumConfig","maxPoolConfig","MaxPool","maxPoolProgram","maxPool3DConfig","MaxPool3D","MaxPool2DBackpropProgram","MaxPool3DBackpropProgram","maxPool3DGradConfig","MaxPool3DGrad","maxPool3dPositionsProgram","maxPool3dPositions","maxPoolBackpropProgram","maxPoolGradConfig","MaxPoolGrad","maxPoolPositionsProgram","maxPoolPositions","maxPoolBackPropProgram","maxPoolWithArgmaxConfig","MaxPoolWithArgmax","indexes","poolOutput","maxPoolWithArgmaxImpl","meanConfig","Mean","meanInputIsTransposed","meanInput","meanInputValues","meanOutShape","meanImpl","minConfig","Min","minimum","minimumConfig","MirrorPadProgram","paddings","mode","unpackedCoords","MirrorPadPackedProgram","cLimit","padSetup","mirrorPadConfig","MirrorPad","mod","modConfig","Mod","MultinomialProgram","numOutcomes","numSamples","realDiv","realDivConfig","RealDiv","SUB","sub","cpuSub","subConfig","softmax","logits","maxLogit","expandedShape","maxLogitsReshaped","sumExp","sumExpReshaped","softmaxConfig","Softmax","multinomialConfig","Multinomial","seed","normalized","probs","NEG","NEG_PACKED","negConfig","nonMaxSuppressionV3Impl","nonMaxSuppressionV3Config","NonMaxSuppressionV3","scores","maxOutputSize","iouThreshold","scoreThreshold","boxesVals","scoresVals","selectedIndices","nonMaxSuppressionV4Impl","nonMaxSuppressionV4Config","NonMaxSuppressionV4","padToMaxOutputSize","validOutputs","nonMaxSuppressionV5Impl","nonMaxSuppressionV5Config","NonMaxSuppressionV5","softNmsSigma","maxOutputSizeVal","iouThresholdVal","scoreThresholdVal","softNmsSigmaVal","selectedScores","OneHotProgram","onValue","offValue","oneHotConfig","OneHot","zerosLike","zerosLikeConfig","ZerosLike","onesLikeConfig","OnesLike","onesLike","packConfig","Pack","expandedT","PadProgram","constantValue","PadPackedProgram","componentSetup","paddingArea","padV2","padV2Config","PadV2","pow","powConfig","Pow","prodConfig","raggedGatherConfig","RaggedGather","$paramsNestedSplits","$paramsNestedSplitsShapes","$paramsDenseValues","$indices","outputDenseValuesShape","outputNestedSplitsTensors","outputDenseValuesTensor","raggedRangeConfig","RaggedRange","$starts","$limits","$deltas","rtNestedSplitsData","rtDenseValuesData","raggedTensorToTensorConfig","RaggedTensorToTensor","rowPartitionTensors","$values","$defaultValue","$rowPartitionValues","range","rangeConfig","Range","reciprocal","reciprocalConfig","Reciprocal","relu","reluConfig","Relu","relu6","relu6Config","Relu6","ResizeBilinearProgram","newHeight","newWidth","alignCorners","halfPixelCenters","oldHeight","oldWidth","effectiveInSize","effectiveOutSize","sourceFracIndexRC","ResizeBilinearPackedProgram","resizeBilinearConfig","ResizeBilinear","images","ResizeBilinearBackpropProgram","dyShape","xHeight","xWidth","yHeight","yWidth","effectiveXSize","effectiveYSize","invHeightScale","invWidthScale","winHeight","winWidth","resizeBilinearGradConfig","ResizeBilinearGrad","ResizeNearestNeighborProgram","roundBase","ResizeNearestNeighborPackedProgram","resizeNearestNeighborConfig","ResizeNearestNeighbor","ResizeNearestNeigborBackpropProgram","resizeNearestNeighborGradConfig","ResizeNearestNeighborGrad","ReverseProgram","inCoords","getInCoord","ReversePackedProgram","nextRow","inCoordsArray","channels1","getR","getG","getB","getA","reverseConfig","Reverse","$dims","RotateProgram","fillValue","fillSnippet","rotateWithOffsetConfig","RotateWithOffset","radians","center","centerX","centerY","sin","roundConfig","Round","rsqrt","rsqrtConfig","ScatterProgram","updateSize","indicesRank","updatesRank","stridesType","indicesString","indicesSnippet","updatesString","updatesSnippet","strideString","scatterNdConfig","ScatterNd","SearchSortedProgram","numInputs","side","webGL1LoopHead","loopHead","boundComparator","searchSortedConfig","SearchSorted","sortedSequence","SelectProgram","cRank","cCoords","abCoords","cCoordVars","abCoordVars","selectConfig","Select","selu","seluConfig","Selu","sigmoid","sigmoidConfig","signConfig","Sign","sinConfig","Sin","sinh","sinhConfig","Sinh","softplus","softplusConfig","Softplus","spaceToBatchNDConfig","SpaceToBatchND","completePaddings","paddedX","reshapedPaddedShape","permutedReshapedPaddedPermutation","reshapedPaddedX","paddedXT","sparseFillEmptyRowsConfig","SparseFillEmptyRows","$denseShape","outputIndicesShape","sparseReshapeConfig","SparseReshape","$inputShape","$inputIndices","sparseSegmentMeanConfig","SparseSegmentMean","$data","$segmentIds","outputDataShape","sparseSegmentSumConfig","SparseSegmentSum","sparseToDenseConfig","SparseToDense","sparseIndices","sparseValues","updatesBuf","splitVConfig","SplitV","numOrSizeSplits","splitSizes","sliceT","SQRT","sqrtConfig","square","squareConfig","Square","SQUARED_DIFFERENCE","squaredDifference","squaredDifferenceConfig","stepConfig","Step","StridedSliceProgram","inputDtype","newCoords","outputAxis","stridedSliceConfig","StridedSlice","beginMask","endMask","ellipsisMask","newAxisMask","shrinkAxisMask","finalShapeSparse","finalShape","isIdentity","sliceDim0","isSimpleSlice","$end","$strides","resultReshaped","stringNGramsConfig","StringNGrams","$dataSplits","stringSplitConfig","StringSplit","$input","$delimiter","stringToHashBucketFastConfig","StringToHashBucketFast","tan","tanConfig","Tan","tanh","tanhConfig","Tanh","TileProgram","tile","buf","tileConfig","Tile","SwapProgram","MergeProgram","disposeIntermediateTensorInfoOrNull","roundUpToPow2","pow2","topKConfig","TopK","TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD","TOPK_K_CPU_HANDOFF_THRESHOLD","xIsPacked","x2D","kPow2","lastDimPow2","getInputs","runSwap","dir","inc","NEGATIVE_INFINITY","prevIndices","len","mergeProgram","prevValues","TransformProgram","interpolation","fillMode","interpolationModeId","fillModeId","transformConfig","Transform","transforms","uniqueConfig","Unique","unpackConfig","Unpack","SegmentOpProgram","segOpInfo","segOpType","numSegments","checkValueOutOfBounds","checkSegmentIdOutOfBounds","kernelConfigs","UnsortedSegmentSum","outputDType","segOpCompute","rangeInfo","tileInfo","kernelConfig","registerKernel"],"sourceRoot":""}