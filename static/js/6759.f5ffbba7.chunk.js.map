{"version":3,"file":"static/js/6759.f5ffbba7.chunk.js","mappings":"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","sources":["njslab/Project/Project_03_SlowZone/01_JSAPI/Tint/FilterGLViewDarkForDarken.ts","njslab/Project/Project_03_SlowZone/PolygonInteraction/index.ts"],"sourcesContent":["import { NVector3, GLShaderCommon } from '../../../../../lib/NJSCore';\n\n// import { Mat3 } from '../../AppCore/GLUtility/Mat3';\n\nexport class FilterGLViewDarkForDarken {\n\n    gl: WebGLRenderingContext;\n    program: WebGLProgram;\n    fragmentShader: WebGLShader;\n    vertexShader: WebGLShader;\n    matrixLocation: WebGLProgram;\n    posBuffer: WebGLBuffer;\n    colBuffer: WebGLBuffer;\n    vertexs: Float32Array;\n\n    posLocAtt: number;\n    colLocAtt: number;\n    matLoc: WebGLUniformLocation;\n    colLoc: WebGLUniformLocation;\n    cVecLoc: WebGLUniformLocation;\n    mouseLoc: WebGLUniformLocation;\n    timeGL: WebGLUniformLocation;\n    // startTime: number;\n    // randomSeed: number;\n\n    vShader: WebGLShader;\n    fShader: WebGLShader;\n\n    v = `\n    attribute vec2 a_position;\n    attribute vec4 a_color;\n    \n    varying vec4 f_color;\n\n    void main() {\n\n        vec2 mouse_distance = vec2(0,0) - (a_position.xy /vec2(2,2));\n        float red = 1.0 - length(mouse_distance);\n        f_color = vec4(a_position, 0, 1.0);\n    \n        // float dis = distance(vec2(a_position.xy), vec2(0,0));\n\n        // f_color = vec4(dis * 0.6, 0,0,1);\n        gl_Position = vec4( a_position, 0, 1);\n    }\n    `;\n\n    f = `\n    precision highp float;\n\n    varying vec4 f_color;\n    \n    void main() {\n        vec2 mouse_distance = vec2(0,0) - (f_color.xy /vec2(5,5));\n\n        float col =  length(mouse_distance*5.);\n        float val = 1.0 - length(mouse_distance*8.);\n        \n        gl_FragColor = vec4(0.19,0.19,0.19, col);\n\n    }\n    `;\n\n    positionAttribLocation: WebGLProgram;\n    colorAttribLocation: WebGLProgram;\n    translation: NVector3;\n    color: number[];\n    colArray: Float32Array;\n\n    constructor(gl: WebGLRenderingContext, xt: number = 100, yt: number = 100, zt: number = 0, xs: number = 1, ys: number = 1, zs: number = 1) {\n        this.gl = gl;\n        // this.translation = new NVector3(xt, yt, zt);\n        // this.angleInRadians = 0;\n        // this.scale = new NVector3(xs, ys, zs);\n        this.color = [Math.random(), Math.random(), Math.random(), 1];\n        this.InitShader();\n    }\n    InitShader() {\n        // let vShader = GLUtility.CreateShaderFromPath(this.gl, this.gl.VERTEX_SHADER,'/shader/vsCanvas.glsl');\n        // let fShader = GLUtility.CreateShaderFromPath(this.gl, this.gl.FRAGMENT_SHADER, '/shader/fsColor.glsl');\n\n        let vShader = GLShaderCommon.CreateShader(this.gl, this.gl.VERTEX_SHADER, this.v); // '/shader/vsCanvas.glsl');\n        let fShader = GLShaderCommon.CreateShader(this.gl, this.gl.FRAGMENT_SHADER, this.f); // '/shader/fsColor.glsl');\n\n        if (vShader && fShader) {\n            this.vShader = vShader;\n            this.fShader = fShader;\n            let program = GLShaderCommon.CreateProgram(this.gl, vShader, fShader);\n            if (program) { this.program = program; }\n        }\n\n        // this.InitVerext();\n    }\n    Render(gl: WebGLRenderingContext) {\n\n        let col = [0.1, 0, 0, 1];\n\n        this.vertexs = new Float32Array([\n            // left column\n            -1, -1, 1, 1, 1, 1,\n            - 1, 1, col[0], col[1], col[2], col[3],\n            1, -1, col[0], col[1], col[2], col[3],\n\n            -1, 1, 1, 1, 1, 1,\n            1, -1, col[0], col[1], col[2], col[3],\n            1, 1, col[0], col[1], col[2], col[3],\n\n        ]);\n\n        this.posBuffer = this.gl.createBuffer() as WebGLBuffer;\n        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.posBuffer);\n        this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(this.vertexs), gl.STATIC_DRAW);\n\n        this.posLocAtt = this.gl.getAttribLocation(this.program, 'a_position');\n        // Tell the attribute how to get data out of posBuffer (ARRAY_BUFFER)\n        let size = 2;          // 2 components per iteration\n        let type = gl.FLOAT;   // the data is 32bit floats\n        let normalize = false; // don't normalize the data\n        let stride = 6 * Float32Array.BYTES_PER_ELEMENT; // 0 = move forward size * sizeof(type) each iteration to get the next position\n        let offset = 0;        // start at the beginning of the buffer\n        gl.vertexAttribPointer(this.posLocAtt, size, type, normalize, stride, offset);\n        gl.enableVertexAttribArray(this.posLocAtt);\n\n        // this.colLocAtt = this.gl.getAttribLocation(this.program, 'a_color');\n        // size = 4;          // 2 components per iteration\n        // type = gl.FLOAT;   // the data is 32bit floats\n        // normalize = false; // don't normalize the data\n        // stride = 6 * Float32Array.BYTES_PER_ELEMENT; // 0 = move forward size * sizeof(type) each iteration to get the next position\n        // offset = 2 * Float32Array.BYTES_PER_ELEMENT;        // start at the beginning of the buffer\n        // gl.vertexAttribPointer(this.colLocAtt, size, type, normalize, stride, offset);\n        // gl.enableVertexAttribArray(this.colLocAtt);\n\n        gl.useProgram(this.program);\n        let primitiveType = gl.TRIANGLES; // LINE_LOOP; // gl.TRIANGLE_STRIP;\n        offset = 0;\n        let count = 6; // this.vertexs.length * 0.5;\n        gl.drawArrays(primitiveType, offset, count);\n\n    }\n}","import * as THREE from 'three';\r\nimport { RendererThree, MercatorProjection, } from '../../../../lib';\r\nimport { getJSONFromURL, } from 'njscore';\r\n\r\nimport { FilterGLViewDarkForDarken } from '../01_JSAPI/Tint/FilterGLViewDarkForDarken';\r\nimport { meshgrid } from '@tensorflow/tfjs-core';\r\n\r\nexport class Solution extends RendererThree {\r\n\r\n    streetOSM: any = [];\r\n    routesTreated: any = [];\r\n    routesControl: any = [];\r\n    zones30: any = [];\r\n\r\n    meshArea: THREE.Mesh[];\r\n\r\n    raycaster = new THREE.Raycaster();\r\n    pointer = new THREE.Vector2();\r\n    sphere: THREE.Mesh;\r\n\r\n    constructor(id: string = 'main') {\r\n        super(id)\r\n\r\n        const light = new THREE.PointLight(0xffffff, 0.8);\r\n        this.camera.add(light);\r\n        this.scene.add(light);\r\n\r\n        this.raycaster = new THREE.Raycaster();\r\n        this.raycaster.params.Mesh.threshold = 3;\r\n        this.raycaster.far = 1000;\r\n\r\n        const sphereGeometry = new THREE.SphereGeometry(0.2, 32, 32);\r\n        const sphereMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff });\r\n        const sphere = new THREE.Mesh(sphereGeometry, sphereMaterial);\r\n        this.sphere = sphere;\r\n        this.scene.add(sphere);\r\n\r\n        const canvasGL = document.createElement('canvas');\r\n        canvasGL.style.position = 'absolute';\r\n        canvasGL.style.pointerEvents = 'none';\r\n        canvasGL.style.mixBlendMode = 'darken';\r\n        canvasGL.width = this.hostDiv.clientWidth;\r\n        canvasGL.height = this.hostDiv.clientHeight;\r\n        this.hostDiv.appendChild(canvasGL);\r\n        const glCtx = canvasGL.getContext('webgl');\r\n        const d = new FilterGLViewDarkForDarken(glCtx, 0.5, 5)\r\n        d.Render(glCtx);\r\n\r\n\r\n        this.camera.position.set(0, 40, 48);\r\n\r\n        const path = '/static/research/slow-zone/';\r\n        getJSONFromURL(process.env.PUBLIC_URL + path + 'street_osm.geojson').then((data) => {\r\n            for (let i = 0; i < data['features'].length; ++i) {\r\n                this.streetOSM.push(data['features'][i]['geometry']['coordinates']);\r\n            }\r\n            // renderLines(this.scene, this.streetOSM, [0, 1, 1]);\r\n            renderPoints(this.scene, this.streetOSM, [0, 1, 1]);\r\n\r\n\r\n            getJSONFromURL(process.env.PUBLIC_URL + path + 'treated-st.geojson').then((data) => {\r\n                for (let i = 0; i < data['features'].length; ++i) {\r\n                    this.routesTreated.push(data['features'][i]['geometry']['coordinates']);\r\n                }\r\n                // renderLines(this.scene, this.routesTreated, [1, 0, 0]);\r\n            });\r\n\r\n            getJSONFromURL(process.env.PUBLIC_URL + path + 'control-st.geojson').then((data) => {\r\n                for (let i = 0; i < data['features'].length; ++i) {\r\n                    this.routesControl.push(data['features'][i]['geometry']['coordinates']);\r\n                }\r\n                // renderLines(this.scene, this.routesControl, [0, 1, 0]);\r\n            });\r\n\r\n            getJSONFromURL(process.env.PUBLIC_URL + path + 'zones-30.geojson').then((data) => {\r\n                for (let i = 0; i < data['features'].length; ++i) {\r\n                    this.zones30.push(data['features'][i]['geometry']['coordinates']);\r\n                }\r\n                this.meshArea = renderMultiPolygon(this.scene, this.zones30, [0, 1, 0]);\r\n\r\n                this.start();\r\n            });\r\n\r\n\r\n    \r\n        });\r\n    }\r\n\r\n    public update(scene: THREE.Scene) {\r\n        this.raycaster.setFromCamera(this.pointer, this.camera);\r\n        const intersects = this.raycaster.intersectObjects(this.meshArea, true);\r\n\r\n        if (intersects.length > 0) {\r\n            this.sphere.visible = true;\r\n            this.sphere.position.copy(intersects[0].point);\r\n        } else {\r\n\r\n            this.sphere.visible = false;\r\n        }\r\n\r\n    }\r\n    public mouseMove(e: MouseEvent): void {\r\n        // console.log(e)\r\n        this.pointer.x = ((e.offsetX) / this.hostDiv.clientWidth) * 2 - 1;\r\n        this.pointer.y = - ((e.offsetY) / this.hostDiv.clientHeight) * 2 + 1;\r\n    }\r\n    public mouseDown(e: MouseEvent): void {\r\n        this.raycaster.setFromCamera(this.pointer, this.camera);\r\n        const intersects = this.raycaster.intersectObjects(this.meshArea, false);\r\n        \r\n        console.log(intersects);\r\n\r\n        if (intersects.length > 0) {\r\n            this.sphere.visible = true;\r\n\r\n            const captured = this.scene.getObjectById(intersects[0].object.id) as THREE.Mesh;\r\n\r\n            const dd = captured.material as THREE.MeshBasicMaterial;\r\n            // console.log(dd);\r\n            dd.color.r += 0.2;\r\n            // console.log(col)\r\n            // const INTERSECTED = intersects[ 0 ].object;\r\n\r\n        } else {\r\n\r\n            this.sphere.visible = false;\r\n        }\r\n    }\r\n}\r\n\r\nconst renderMultiPolygon = (scene: THREE.Scene, paths: any, colorArray: number[]) => {\r\n    // if (multiPolygons === undefined) return;\r\n\r\n    const xOFf = -15478803.88731685;\r\n    const yOFf = -4766681.448690384;\r\n    const scale = 0.01;\r\n\r\n    // const geometry = new THREE.BufferGeometry();\r\n    // const material = new THREE.MeshBasicMaterial( { vertexColors: true } );\r\n    const meshes = []\r\n\r\n    const positions = [];\r\n\r\n\r\n    for (let multi = 0; multi < paths.length; ++multi) {\r\n        const multiPolygon = paths[multi];\r\n\r\n        for (let polyI = 0; polyI < multiPolygon.length; ++polyI) {\r\n            const polygon = multiPolygon[polyI];\r\n\r\n\r\n\r\n            if (polygon.length === 1) {\r\n                const thePolygon = polygon[0];\r\n\r\n                const shape = [];\r\n\r\n                for (let i = 0; i < thePolygon.length; ++i) {\r\n\r\n                    const [xPro, yPro] = MercatorProjection(thePolygon[i][0], thePolygon[i][1]);\r\n\r\n                    const x = (xPro + xOFf) * scale\r\n                    const y = (yPro + yOFf) * scale\r\n                    // console.log(x, y)\r\n                    positions.push(x, 0, y)\r\n\r\n                    shape.push(new THREE.Vector2(x, y));\r\n                }\r\n\r\n\r\n                let geometry = new THREE.ShapeGeometry(new THREE.Shape(shape));\r\n                let mat = new THREE.MeshBasicMaterial({\r\n                    side: THREE.DoubleSide, color: 0x00ff00,\r\n                    transparent: true,\r\n                    opacity: 0.3\r\n                });\r\n                let mesh = new THREE.Mesh(geometry, mat);\r\n                scene.add(mesh);\r\n                meshes.push(mesh);\r\n                mesh.rotateOnAxis(new THREE.Vector3(1, 0, 0), Math.PI * 0.5);\r\n\r\n\r\n            }\r\n        }\r\n    }\r\n    return meshes;\r\n};\r\n\r\nconst renderPoints = (scene: THREE.Scene, paths: any, color: number[]) => {\r\n    const geometry = new THREE.BufferGeometry();\r\n    const material = new THREE.PointsMaterial({ vertexColors: true, size: 0.5 });\r\n\r\n    const positions = [];\r\n    const colors = [];\r\n\r\n\r\n    const xOFf = -15478803.88731685;\r\n    const yOFf = -4766681.448690384;\r\n    const scale = 0.01;\r\n\r\n\r\n    for (let i = 0; i < paths.length; ++i) {\r\n        const route = paths[i]\r\n\r\n        for (let j = 0; j < route.length; ++j) {\r\n            for (let k = 0; k < route[j].length; ++k) {\r\n\r\n                const [xPro, yPro] = MercatorProjection(route[j][k][0], route[j][k][1]);\r\n\r\n                const x = (xPro + xOFf) * scale\r\n                const y = (yPro + yOFf) * scale\r\n\r\n                positions.push(x, 0, y)\r\n\r\n                colors.push(color[0], color[1], color[2]);\r\n\r\n\r\n            }\r\n        }\r\n    }\r\n\r\n    geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));\r\n    geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));\r\n    // generateMorphTargets( geometry );\r\n\r\n    geometry.computeBoundingSphere();\r\n\r\n    const line = new THREE.Points(geometry, material);\r\n    scene.add(line);\r\n\r\n\r\n}\r\n\r\nconst renderLines = (scene: THREE.Scene, paths: any, color: number[]) => {\r\n\r\n    const geometry = new THREE.BufferGeometry();\r\n    // const material = new THREE.PointsMaterial( { vertexColors: true, size: 0.1 } );\r\n    const material = new THREE.LineBasicMaterial({ vertexColors: true });\r\n\r\n    const positions = [];\r\n    const colors = [];\r\n    const indices = [];\r\n\r\n    const xOFf = -15478803.88731685;\r\n    const yOFf = -4766681.448690384;\r\n    const scale = 0.01;\r\n\r\n\r\n    let xC = 0\r\n    let yC = 0\r\n    let Count = 0\r\n\r\n    for (let i = 0; i < paths.length; ++i) {\r\n        const route = paths[i]\r\n\r\n        for (let j = 0; j < route.length; ++j) {\r\n            for (let k = 0; k < route[j].length; ++k) {\r\n\r\n                const [xPro, yPro] = MercatorProjection(route[j][k][0], route[j][k][1]);\r\n                xC += xPro;\r\n                yC += yPro;\r\n                Count += 1;\r\n\r\n                const x = (xPro + xOFf) * scale\r\n                const y = (yPro + yOFf) * scale\r\n                // console.log(x, y)\r\n                positions.push(x, 0, y)\r\n\r\n                colors.push(color[0], color[1], color[2]);\r\n\r\n                if (k < route[j].length - 1) {\r\n                    indices.push(Math.floor(positions.length / 3) - 1, Math.floor(positions.length / 3));\r\n                }\r\n            }\r\n        }\r\n    }\r\n    console.log(xC / Count, yC / Count, Count)\r\n    geometry.setIndex(indices);\r\n    geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));\r\n    geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));\r\n    // generateMorphTargets( geometry );\r\n\r\n    geometry.computeBoundingSphere();\r\n\r\n    const line = new THREE.LineSegments(geometry, material);\r\n    scene.add(line);\r\n};"],"names":["FilterGLViewDarkForDarken","gl","program","fragmentShader","vertexShader","matrixLocation","posBuffer","colBuffer","vertexs","posLocAtt","colLocAtt","matLoc","colLoc","cVecLoc","mouseLoc","timeGL","vShader","fShader","v","f","positionAttribLocation","colorAttribLocation","translation","color","colArray","this","Math","random","InitShader","GLShaderCommon","VERTEX_SHADER","FRAGMENT_SHADER","col","Float32Array","createBuffer","bindBuffer","ARRAY_BUFFER","bufferData","STATIC_DRAW","getAttribLocation","type","FLOAT","stride","BYTES_PER_ELEMENT","offset","vertexAttribPointer","enableVertexAttribArray","useProgram","primitiveType","TRIANGLES","drawArrays","Solution","id","streetOSM","routesTreated","routesControl","zones30","meshArea","raycaster","THREE","pointer","sphere","light","camera","add","scene","params","Mesh","threshold","far","sphereGeometry","sphereMaterial","canvasGL","document","createElement","style","position","pointerEvents","mixBlendMode","width","hostDiv","clientWidth","height","clientHeight","appendChild","glCtx","getContext","d","Render","set","path","getJSONFromURL","process","then","data","i","length","push","renderPoints","renderMultiPolygon","start","setFromCamera","intersects","intersectObjects","visible","copy","point","e","x","offsetX","y","offsetY","console","log","getObjectById","object","material","r","RendererThree","paths","colorArray","meshes","positions","multi","multiPolygon","polyI","polygon","thePolygon","shape","MercatorProjection","geometry","mat","side","transparent","opacity","mesh","rotateOnAxis","PI","vertexColors","size","colors","route","j","k","setAttribute","computeBoundingSphere","line"],"sourceRoot":""}