{"version":3,"file":"static/js/9413.8d6a8f27.chunk.js","mappings":"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","sources":["njslab/Project/Project_03_SlowZone/01_JSAPI/Tint/FilterGLViewDarkForDarken.ts","njslab/Project/Project_03_SlowZone/PointInteraction/index.ts"],"sourcesContent":["import { NVector3, GLShaderCommon } from '../../../../../lib/NJSCore';\n\n// import { Mat3 } from '../../AppCore/GLUtility/Mat3';\n\nexport class FilterGLViewDarkForDarken {\n\n    gl: WebGLRenderingContext;\n    program: WebGLProgram;\n    fragmentShader: WebGLShader;\n    vertexShader: WebGLShader;\n    matrixLocation: WebGLProgram;\n    posBuffer: WebGLBuffer;\n    colBuffer: WebGLBuffer;\n    vertexs: Float32Array;\n\n    posLocAtt: number;\n    colLocAtt: number;\n    matLoc: WebGLUniformLocation;\n    colLoc: WebGLUniformLocation;\n    cVecLoc: WebGLUniformLocation;\n    mouseLoc: WebGLUniformLocation;\n    timeGL: WebGLUniformLocation;\n    // startTime: number;\n    // randomSeed: number;\n\n    vShader: WebGLShader;\n    fShader: WebGLShader;\n\n    v = `\n    attribute vec2 a_position;\n    attribute vec4 a_color;\n    \n    varying vec4 f_color;\n\n    void main() {\n\n        vec2 mouse_distance = vec2(0,0) - (a_position.xy /vec2(2,2));\n        float red = 1.0 - length(mouse_distance);\n        f_color = vec4(a_position, 0, 1.0);\n    \n        // float dis = distance(vec2(a_position.xy), vec2(0,0));\n\n        // f_color = vec4(dis * 0.6, 0,0,1);\n        gl_Position = vec4( a_position, 0, 1);\n    }\n    `;\n\n    f = `\n    precision highp float;\n\n    varying vec4 f_color;\n    \n    void main() {\n        vec2 mouse_distance = vec2(0,0) - (f_color.xy /vec2(5,5));\n\n        float col =  length(mouse_distance*5.);\n        float val = 1.0 - length(mouse_distance*8.);\n        \n        gl_FragColor = vec4(0.19,0.19,0.19, col);\n\n    }\n    `;\n\n    positionAttribLocation: WebGLProgram;\n    colorAttribLocation: WebGLProgram;\n    translation: NVector3;\n    color: number[];\n    colArray: Float32Array;\n\n    constructor(gl: WebGLRenderingContext, xt: number = 100, yt: number = 100, zt: number = 0, xs: number = 1, ys: number = 1, zs: number = 1) {\n        this.gl = gl;\n        // this.translation = new NVector3(xt, yt, zt);\n        // this.angleInRadians = 0;\n        // this.scale = new NVector3(xs, ys, zs);\n        this.color = [Math.random(), Math.random(), Math.random(), 1];\n        this.InitShader();\n    }\n    InitShader() {\n        // let vShader = GLUtility.CreateShaderFromPath(this.gl, this.gl.VERTEX_SHADER,'/shader/vsCanvas.glsl');\n        // let fShader = GLUtility.CreateShaderFromPath(this.gl, this.gl.FRAGMENT_SHADER, '/shader/fsColor.glsl');\n\n        let vShader = GLShaderCommon.CreateShader(this.gl, this.gl.VERTEX_SHADER, this.v); // '/shader/vsCanvas.glsl');\n        let fShader = GLShaderCommon.CreateShader(this.gl, this.gl.FRAGMENT_SHADER, this.f); // '/shader/fsColor.glsl');\n\n        if (vShader && fShader) {\n            this.vShader = vShader;\n            this.fShader = fShader;\n            let program = GLShaderCommon.CreateProgram(this.gl, vShader, fShader);\n            if (program) { this.program = program; }\n        }\n\n        // this.InitVerext();\n    }\n    Render(gl: WebGLRenderingContext) {\n\n        let col = [0.1, 0, 0, 1];\n\n        this.vertexs = new Float32Array([\n            // left column\n            -1, -1, 1, 1, 1, 1,\n            - 1, 1, col[0], col[1], col[2], col[3],\n            1, -1, col[0], col[1], col[2], col[3],\n\n            -1, 1, 1, 1, 1, 1,\n            1, -1, col[0], col[1], col[2], col[3],\n            1, 1, col[0], col[1], col[2], col[3],\n\n        ]);\n\n        this.posBuffer = this.gl.createBuffer() as WebGLBuffer;\n        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.posBuffer);\n        this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(this.vertexs), gl.STATIC_DRAW);\n\n        this.posLocAtt = this.gl.getAttribLocation(this.program, 'a_position');\n        // Tell the attribute how to get data out of posBuffer (ARRAY_BUFFER)\n        let size = 2;          // 2 components per iteration\n        let type = gl.FLOAT;   // the data is 32bit floats\n        let normalize = false; // don't normalize the data\n        let stride = 6 * Float32Array.BYTES_PER_ELEMENT; // 0 = move forward size * sizeof(type) each iteration to get the next position\n        let offset = 0;        // start at the beginning of the buffer\n        gl.vertexAttribPointer(this.posLocAtt, size, type, normalize, stride, offset);\n        gl.enableVertexAttribArray(this.posLocAtt);\n\n        // this.colLocAtt = this.gl.getAttribLocation(this.program, 'a_color');\n        // size = 4;          // 2 components per iteration\n        // type = gl.FLOAT;   // the data is 32bit floats\n        // normalize = false; // don't normalize the data\n        // stride = 6 * Float32Array.BYTES_PER_ELEMENT; // 0 = move forward size * sizeof(type) each iteration to get the next position\n        // offset = 2 * Float32Array.BYTES_PER_ELEMENT;        // start at the beginning of the buffer\n        // gl.vertexAttribPointer(this.colLocAtt, size, type, normalize, stride, offset);\n        // gl.enableVertexAttribArray(this.colLocAtt);\n\n        gl.useProgram(this.program);\n        let primitiveType = gl.TRIANGLES; // LINE_LOOP; // gl.TRIANGLE_STRIP;\n        offset = 0;\n        let count = 6; // this.vertexs.length * 0.5;\n        gl.drawArrays(primitiveType, offset, count);\n\n    }\n}","import * as THREE from 'three';\r\nimport { RendererThree, MercatorProjection, } from '../../../../lib';\r\nimport { getJSONFromURL, distanceTo } from 'njscore';\r\n\r\nimport { FilterGLViewDarkForDarken } from '../01_JSAPI/Tint/FilterGLViewDarkForDarken';\r\n\r\nexport class Solution extends RendererThree {\r\n\r\n    streetOSM: any = [];\r\n    routesTreated: any = [];\r\n    routesControl: any = [];\r\n    zones30: any = [];\r\n\r\n    positions;\r\n    geometry;\r\n\r\n    raycaster = new THREE.Raycaster();\r\n    pointer = new THREE.Vector2();\r\n\r\n    mesh: THREE.Points;\r\n\r\n    sphere: THREE.Mesh;\r\n\r\n    constructor(id: string = 'main') {\r\n        super(id)\r\n\r\n        const light = new THREE.PointLight(0xffffff, 0.8);\r\n        this.camera.add(light);\r\n        this.scene.add(light);\r\n\r\n        this.raycaster = new THREE.Raycaster();\r\n        this.raycaster.params.Points.threshold = 0.8;\r\n        this.raycaster.far = 1000;\r\n\r\n        const sphereGeometry = new THREE.SphereGeometry(0.1, 32, 32);\r\n        const sphereMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff });\r\n        const sphere = new THREE.Mesh(sphereGeometry, sphereMaterial);\r\n        this.sphere = sphere;\r\n        this.scene.add(sphere);\r\n\r\n\r\n        const canvasGL = document.createElement('canvas');\r\n        canvasGL.style.position = 'absolute';\r\n        canvasGL.style.pointerEvents = 'none';\r\n        canvasGL.style.mixBlendMode = 'darken';\r\n        canvasGL.width = this.hostDiv.clientWidth;\r\n        canvasGL.height = this.hostDiv.clientHeight;\r\n        this.hostDiv.appendChild(canvasGL);\r\n        const glCtx = canvasGL.getContext('webgl');\r\n        const d = new FilterGLViewDarkForDarken(glCtx, 0.5, 5)\r\n        d.Render(glCtx);\r\n\r\n        this.camera.position.set(0, 40, 48);\r\n\r\n        const path = '/static/research/slow-zone/';\r\n        getJSONFromURL(process.env.PUBLIC_URL + path + 'street_osm.geojson').then((data) => {\r\n            for (let i = 0; i < data['features'].length; ++i) {\r\n                this.streetOSM.push(data['features'][i]['geometry']['coordinates']);\r\n            }\r\n            renderLines(this.scene, this.streetOSM, [0, 0.8, 0.7]);\r\n            this.renderPoints(this.scene, this.streetOSM, [0, 1, 1]);\r\n\r\n            this.start();\r\n        });\r\n\r\n\r\n    }\r\n    public mouseMove(e: MouseEvent): void {\r\n\r\n        this.pointer.x = (e.offsetX / this.hostDiv.clientWidth) * 2 - 1;\r\n        this.pointer.y = - (e.offsetY / this.hostDiv.clientHeight) * 2 + 1;\r\n    }\r\n    public update(scene: THREE.Scene) {\r\n        // console.log(this.pointer)\r\n\r\n        this.raycaster.setFromCamera(this.pointer, this.camera);\r\n        const intersections = this.raycaster.intersectObjects([this.mesh], false);\r\n        const intersection = (intersections.length) > 0 ? intersections[0] : null;\r\n\r\n        if (intersection !== null) {\r\n            // console.log(intersection.point.x, intersection.point.y, intersection.point.z);\r\n            this.sphere.position.set(intersection.point.x, intersection.point.y, intersection.point.z);\r\n        }\r\n\r\n\r\n\r\n        let numVertices = this.mesh.geometry.attributes.position.count;\r\n        for (let i = 0; i < numVertices; i++) {\r\n            let o = this.mesh.geometry.attributes.position;\r\n\r\n            let x = o.getX(i);\r\n            let y = o.getY(i);\r\n            let z = o.getZ(i)\r\n\r\n            y = Math.sin(5 * x * z + this.t * 5) * 9\r\n\r\n\r\n            y = y < 0 ? 0 : y;\r\n\r\n            let p = new THREE.Vector3(x, y, z);\r\n\r\n            this.mesh.geometry.attributes.position.setXYZ(i, p.x, p.y, p.z);\r\n\r\n            if (intersection !== null) {\r\n                y = distanceTo(x, y, z, intersection.point.x, intersection.point.y, intersection.point.z) / 30\r\n            }\r\n\r\n\r\n            this.mesh.geometry.attributes.color.setXYZ(i, y, 1 - y, 0);\r\n            // console.log(y)\r\n        }\r\n\r\n        // set to true each time you modify the positions:\r\n        this.mesh.geometry.attributes.position.needsUpdate = true;\r\n        this.mesh.geometry.attributes.color.needsUpdate = true;\r\n        this.mesh.geometry.computeVertexNormals();\r\n\r\n    }\r\n\r\n    renderPoints = (scene: THREE.Scene, paths: any, color: number[]) => {\r\n        const geometry = new THREE.BufferGeometry();\r\n        const material = new THREE.PointsMaterial({ vertexColors: true, size: 0.75 });\r\n\r\n        const positions = [];\r\n        const colors = [];\r\n\r\n\r\n        const xOFf = -15478803.88731685;\r\n        const yOFf = -4766681.448690384;\r\n        const scale = 0.01;\r\n\r\n\r\n        for (let i = 0; i < paths.length; ++i) {\r\n            const route = paths[i]\r\n\r\n            for (let j = 0; j < route.length; ++j) {\r\n                for (let k = 0; k < route[j].length; ++k) {\r\n\r\n                    const [xPro, yPro] = MercatorProjection(route[j][k][0], route[j][k][1]);\r\n\r\n                    const x = (xPro + xOFf) * scale\r\n                    const y = (yPro + yOFf) * scale\r\n\r\n                    positions.push(x, 0, y)\r\n\r\n                    colors.push(color[0], color[1], color[2]);\r\n\r\n\r\n                }\r\n            }\r\n        }\r\n\r\n        geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));\r\n        geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));\r\n        // generateMorphTargets( geometry );\r\n\r\n        geometry.computeBoundingSphere();\r\n        this.positions = positions;\r\n        this.geometry = geometry;\r\n        this.mesh = new THREE.Points(geometry, material);\r\n        scene.add(this.mesh);\r\n\r\n    }\r\n}\r\n\r\nconst renderLines = (scene: THREE.Scene, paths: any, color: number[]) => {\r\n\r\n    const geometry = new THREE.BufferGeometry();\r\n    const material = new THREE.LineBasicMaterial(\r\n        { vertexColors: true, linewidth: 0.01 }\r\n    );\r\n\r\n    const positions = [];\r\n    const colors = [];\r\n    const indices = [];\r\n\r\n    const xOFf = -15478803.88731685;\r\n    const yOFf = -4766681.448690384;\r\n    const scale = 0.01;\r\n\r\n\r\n    let xC = 0\r\n    let yC = 0\r\n    let Count = 0\r\n\r\n    for (let i = 0; i < paths.length; ++i) {\r\n        const route = paths[i]\r\n\r\n        for (let j = 0; j < route.length; ++j) {\r\n            for (let k = 0; k < route[j].length; ++k) {\r\n\r\n                const [xPro, yPro] = MercatorProjection(route[j][k][0], route[j][k][1]);\r\n                xC += xPro;\r\n                yC += yPro;\r\n                Count += 1;\r\n\r\n                const x = (xPro + xOFf) * scale\r\n                const y = (yPro + yOFf) * scale\r\n                // console.log(x, y)\r\n                positions.push(x, 0, y)\r\n\r\n                colors.push(color[0], color[1], color[2]);\r\n\r\n                if (k < route[j].length - 1) {\r\n                    indices.push(Math.floor(positions.length / 3) - 1, Math.floor(positions.length / 3));\r\n                }\r\n            }\r\n        }\r\n    }\r\n    console.log(xC / Count, yC / Count, Count)\r\n\r\n    geometry.setIndex(indices);\r\n    geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));\r\n    geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));\r\n    geometry.computeBoundingSphere();\r\n\r\n    const mesh = new THREE.LineSegments(geometry, material);\r\n    scene.add(mesh);\r\n    return mesh;\r\n};"],"names":["FilterGLViewDarkForDarken","gl","program","fragmentShader","vertexShader","matrixLocation","posBuffer","colBuffer","vertexs","posLocAtt","colLocAtt","matLoc","colLoc","cVecLoc","mouseLoc","timeGL","vShader","fShader","v","f","positionAttribLocation","colorAttribLocation","translation","color","colArray","this","Math","random","InitShader","GLShaderCommon","VERTEX_SHADER","FRAGMENT_SHADER","col","Float32Array","createBuffer","bindBuffer","ARRAY_BUFFER","bufferData","STATIC_DRAW","getAttribLocation","type","FLOAT","stride","BYTES_PER_ELEMENT","offset","vertexAttribPointer","enableVertexAttribArray","useProgram","primitiveType","TRIANGLES","drawArrays","Solution","id","streetOSM","routesTreated","routesControl","zones30","positions","geometry","raycaster","THREE","pointer","mesh","sphere","renderPoints","scene","paths","material","vertexColors","size","colors","i","length","route","j","k","MercatorProjection","x","y","push","setAttribute","computeBoundingSphere","add","light","camera","params","Points","threshold","far","sphereGeometry","sphereMaterial","canvasGL","document","createElement","style","position","pointerEvents","mixBlendMode","width","hostDiv","clientWidth","height","clientHeight","appendChild","glCtx","getContext","d","Render","set","path","getJSONFromURL","process","then","data","renderLines","start","e","offsetX","offsetY","setFromCamera","intersections","intersectObjects","intersection","point","z","numVertices","attributes","count","o","getX","getY","getZ","sin","t","p","setXYZ","distanceTo","needsUpdate","computeVertexNormals","RendererThree","linewidth","indices","xC","yC","Count","xPro","yPro","floor","console","log","setIndex"],"sourceRoot":""}