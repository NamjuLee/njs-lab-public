{"version":3,"file":"static/js/6781.9f2fdf58.chunk.js","mappings":"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","sources":["njslab/Workshop/workshop-ml/08_MPGPrediction/index.ts"],"sourcesContent":["import * as tf from '@tensorflow/tfjs';\r\nimport * as tfvis from '@tensorflow/tfjs-vis';\r\nimport '@tensorflow/tfjs-backend-webgl';\r\n\r\nexport class Solution {\r\n    public destroy() {\r\n        \r\n    }\r\n    constructor(id: string) {\r\n    //  https://js.tensorflow.org/api/latest/\r\n        console.log(\"Let's learn TF JS !!\");\r\n        console.log(\"==============================\");\r\n\r\n      // const data  = await getData()\r\n\r\n      //   const model = createModel();\r\n      //   tfvis.show.modelSummary({name: 'Model Summary'}, model);\r\n\r\n      execute();\r\n\r\n        console.log('Playground done!');\r\n    }\r\n};\r\nconst execute = async () => {\r\n  const data = await getData();\r\n  console.log(data);\r\n  visData(data);\r\n\r\n  const tensor = await convertToTensor(data);\r\n  console.log(tensor)\r\n\r\n  const model = createModel()\r\n\r\n  await trainModel(model, tensor.inputs, tensor.labels);\r\n\r\n  testModel(model, data, tensor);\r\n\r\n}\r\nconst getData = async () => {\r\n    const carsDataResponse = await fetch('https://storage.googleapis.com/tfjs-tutorials/carsData.json');\r\n    const carsData = await carsDataResponse.json();\r\n    const cleaned = carsData.map(car => ({\r\n      mpg: car.Miles_per_Gallon,\r\n      horsepower: car.Horsepower,\r\n    }))\r\n    .filter(car => (car.mpg != null && car.horsepower != null));\r\n  \r\n    return cleaned;\r\n};\r\n\r\nconst visData = async (data) => {\r\n    const values = data.map(d => ({\r\n      x: d.horsepower,\r\n      y: d.mpg,\r\n    }));\r\n  \r\n    tfvis.render.scatterplot(\r\n      {name: 'Horsepower v MPG'},\r\n      {values},\r\n      {\r\n        xLabel: 'Horsepower',\r\n        yLabel: 'MPG',\r\n        height: 300\r\n      }\r\n    );\r\n  \r\n  }\r\n\r\nconst createModel = () => {\r\n    // Create a sequential model\r\n    const model = tf.sequential();\r\n  \r\n    // Add a single input layer\r\n    model.add(tf.layers.dense({inputShape: [1], units: 1, useBias: true}));\r\n  \r\n    // Add an output layer\r\n    model.add(tf.layers.dense({units: 1, useBias: true}));\r\n  \r\n    return model;\r\n  }\r\n\r\n\r\nconst convertToTensor = async (data) => {\r\n  // Wrapping these calculations in a tidy will dispose any\r\n  // intermediate tensors.\r\n\r\n  return tf.tidy(() => {\r\n    // Step 1. Shuffle the data\r\n    tf.util.shuffle(data);\r\n\r\n    // Step 2. Convert data to Tensor\r\n    const inputs = data.map(d => d.horsepower)\r\n    const labels = data.map(d => d.mpg);\r\n\r\n    const inputTensor = tf.tensor2d(inputs, [inputs.length, 1]);\r\n    const labelTensor = tf.tensor2d(labels, [labels.length, 1]);\r\n\r\n    //Step 3. Normalize the data to the range 0 - 1 using min-max scaling\r\n    const inputMax = inputTensor.max();\r\n    const inputMin = inputTensor.min();\r\n    const labelMax = labelTensor.max();\r\n    const labelMin = labelTensor.min();\r\n\r\n    const normalizedInputs = inputTensor.sub(inputMin).div(inputMax.sub(inputMin));\r\n    const normalizedLabels = labelTensor.sub(labelMin).div(labelMax.sub(labelMin));\r\n\r\n    return {\r\n      inputs: normalizedInputs,\r\n      labels: normalizedLabels,\r\n      // Return the min/max bounds so we can use them later.\r\n      inputMax,\r\n      inputMin,\r\n      labelMax,\r\n      labelMin,\r\n    }\r\n  });\r\n}\r\n\r\n const trainModel = async (model, inputs, labels) => {\r\n  // Prepare the model for training.\r\n  model.compile({\r\n    optimizer: tf.train.adam(),\r\n    loss: tf.losses.meanSquaredError,\r\n    metrics: ['mse'],\r\n  });\r\n\r\n  const batchSize = 32;\r\n  const epochs = 0;\r\n\r\n  return await model.fit(inputs, labels, {\r\n    batchSize,\r\n    epochs,\r\n    shuffle: true,\r\n    callbacks: tfvis.show.fitCallbacks(\r\n      { name: 'Training Performance' },\r\n      ['loss', 'mse'],\r\n      { height: 200, callbacks: ['onEpochEnd'] }\r\n    )\r\n  });\r\n}\r\n\r\nconst testModel = (model, inputData, normalizationData) => {\r\n  const {inputMax, inputMin, labelMin, labelMax} = normalizationData;\r\n\r\n  // Generate predictions for a uniform range of numbers between 0 and 1;\r\n  // We un-normalize the data by doing the inverse of the min-max scaling\r\n  // that we did earlier.\r\n  const [xs, preds] = tf.tidy(() => {\r\n\r\n    const xs = tf.linspace(0, 1, 100);\r\n    const preds = model.predict(xs.reshape([100, 1]));\r\n\r\n    const unNormXs = xs.mul(inputMax.sub(inputMin)).add(inputMin);\r\n\r\n    const unNormPreds = preds.mul(labelMax.sub(labelMin)).add(labelMin);\r\n\r\n    // Un-normalize the data\r\n    return [unNormXs.dataSync(), unNormPreds.dataSync()];\r\n  });\r\n\r\n\r\n  const predictedPoints = Array.from(xs).map((val, i) => {\r\n    return {x: val, y: preds[i]}\r\n  });\r\n\r\n  const originalPoints = inputData.map(d => ({\r\n    x: d.horsepower, y: d.mpg,\r\n  }));\r\n\r\n\r\n  tfvis.render.scatterplot(\r\n    {name: 'Model Predictions vs Original Data'},\r\n    {values: [originalPoints, predictedPoints], series: ['original', 'predicted']},\r\n    {\r\n      xLabel: 'Horsepower',\r\n      yLabel: 'MPG',\r\n      height: 300\r\n    }\r\n  );\r\n}"],"names":["Solution","id","console","log","execute","getData","data","visData","convertToTensor","tensor","model","createModel","trainModel","inputs","labels","testModel","fetch","carsDataResponse","json","carsData","cleaned","map","car","mpg","Miles_per_Gallon","horsepower","Horsepower","filter","values","d","x","y","tfvis","name","xLabel","yLabel","height","tf","add","inputShape","units","useBias","inputTensor","length","labelTensor","inputMax","max","inputMin","min","labelMax","labelMin","sub","div","compile","optimizer","loss","metrics","fit","batchSize","epochs","shuffle","callbacks","inputData","normalizationData","xs","preds","predict","reshape","unNormXs","mul","unNormPreds","dataSync","predictedPoints","Array","from","val","i","originalPoints","series"],"sourceRoot":""}