"use strict";(self.webpackChunkNJS_Lab=self.webpackChunkNJS_Lab||[]).push([[6376],{84638:function(t,i,s){s.d(i,{MO:function(){return o},TE:function(){return h},Y4:function(){return e},h9:function(){return n}});const e=(t,i)=>{const s=t[0].x,e=t[1].x,h=i[0].x,n=i[1].x,o=t[0].y,r=t[1].y,l=i[0].y,c=i[1].y;return s<=n&&e>=h&&o<=c&&r>=l},h=(t,i)=>Math.sqrt((t.x-i.x)*(t.x-i.x)+(t.y-i.y)*(t.y-i.y)+(t.z-i.z)*(t.z-i.z));class n{static getMidVec(t,i){return new n(t.x+.5*(i.x-t.x),t.y+.5*(i.y-t.y),t.z+.5*(i.z-t.z))}static distanceTo(t,i){return Math.sqrt((t.x-i.x)*(t.x-i.x)+(t.y-i.y)*(t.y-i.y)+(t.z-i.z)*(t.z-i.z))}static Clone(t){return n.DeepCopy(t)}static DeepCopy(t){const i=new n(t.x,t.y,t.z);return i.long=t.long,i.lat=t.lat,i}static Dot(t,i){return t.x*i.x+t.y*i.y+t.z*i.z}static ZAxis(){return new n(0,0,1)}static YAxis(){return new n(0,1,0)}static Zero(){return new n(0,0,0)}static Origin(){return new n(0,0,0)}constructor(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,i=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,s=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;this.x=0,this.y=0,this.z=0,this.long=0,this.lat=0,this.elevation=0,this.d=!0,this.isRenderable=!0,this.x=t,this.y=i,this.z=s}Set(t,i,s){return this.x=t,this.y=i,this.z=s,new n(this.x,this.y,this.z)}scale(t){return this.x*=t,this.y*=t,this.z*=t,new n(this.x,this.y,this.z)}Mult(t){return this.x*=t,this.y*=t,this.z*=t,new n(this.x,this.y,this.z)}DivByVal(t){return this.x/=t,this.y/=t,this.z/=t,new n(this.x,this.y,this.z)}DivByVec(t){return this.x/=t.x,this.y/=t.y,this.z/=t.z,new n(this.x,this.y,this.z)}Add(t){return this.x+=t.x,this.y+=t.y,this.z+=t.z,new n(this.x,this.y,this.z)}Sub(t){return this.x-=t.x,this.y-=t.y,this.z-=t.z,new n(this.x,this.y,this.z)}Negate(){return this.x*=-1,this.y*=-1,this.z*=-1,new n(this.x,this.y,this.z)}Equals(t){return this.x===t.x&&this.y===t.y&&this.z===t.z}distanceTo(t){return n.distanceTo(this,t)}normalize(){let t=Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z);return t<1e-4||(this.x=this.x/t,this.y=this.y/t,this.z=this.z/t),this}Clone(){const t=new n(this.x,this.y,this.z);return t.long=this.long,t.lat=this.lat,t.elevation=this.elevation,t}Length(){const t=Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z);return t<1e-5?1e-5:t}Unitize(){return this.normalize()}GetAngle(){return Math.atan2(this.y,this.x)}GetAngleDegree(){return 180*this.GetAngle()/Math.PI}ToJSON(){}ToString(){return"x: "+this.x.toFixed(3).toString()+" , y: "+this.y.toFixed(3).toString()+", z: "+this.z.toFixed(3).toString()}ToFloat32Array(){return new Float32Array([this.x,this.y,this.z])}}class o{constructor(t,i){this.vec=void 0,this.id="",this.numVisit=0,this.isCollapse=!1,this.isHidden=!1,this.isRenderable=!0,this.isSelected=!1,this.isHover=!1,this.collision=void 0,this.vec=new n(t,i,0),this.collision=new r(this)}}class r{constructor(t){this.base=void 0,this.isCollided=!1,this.neighborShapes=[],this.minVec=void 0,this.maxVec=void 0,this.isVisited=!1,this.numOrder=-1,this.base=t;this.minVec=new n(this.base.vec.x-5,this.base.vec.y-5,0),this.maxVec=new n(this.base.vec.x+5,this.base.vec.y+5,0)}Reset(){this.neighborShapes=[],this.numOrder=-1,this.base.numVisit=0,this.base.isCollapse=!1,this.isCollided=!1,this.isVisited=!1}}},26376:function(t,i,s){s.r(i),s.d(i,{Renderer:function(){return x},Solution:function(){return p}});var e=s(84638);class h{constructor(t,i){this.renderer=void 0,this.points=void 0,this.r0=16,this.r1=24,this.isHover=!1,this.isVisited=!1,this.boundingBoxMin=new e.h9(Number.MAX_SAFE_INTEGER,Number.MAX_SAFE_INTEGER,Number.MAX_SAFE_INTEGER),this.boundingBoxMax=new e.h9(Number.MIN_SAFE_INTEGER,Number.MIN_SAFE_INTEGER,Number.MIN_SAFE_INTEGER),this.minVec=void 0,this.maxVec=void 0,this.vec=new e.h9(0,0,0),this.t=1,this.GridResolution=85,this.tempVecGridList=[],this.tempGeoGridList=[],this.renderer=t,this.points=i;for(let s=0;s<this.points.length;++s)this.vec.x+=this.points[s].vec.x,this.vec.y+=this.points[s].vec.y,this.UpdateBoundingBox(this.points[s].vec);this.vec.x/=this.points.length,this.vec.y/=this.points.length,this.minVec=new e.h9(this.vec.x-this.r1,this.vec.y-this.r1,0),this.maxVec=new e.h9(this.vec.x+this.r1,this.vec.y+this.r1,0)}IsInside(t){return(0,e.TE)(this.vec,t)<this.r1?(this.isHover=!0,!0):(this.isHover=!1,!1)}AddPost(t){if(!this.points.includes(t)){this.points.push(t),this.vec=new e.h9(0,0,0);for(let t=0;t<this.points.length;++t)this.vec.x+=this.points[t].vec.x,this.vec.y+=this.points[t].vec.y,this.UpdateBoundingBox(this.points[t].vec);this.vec.x/=this.points.length,this.vec.y/=this.points.length,this.minVec=new e.h9(this.vec.x-this.r1,this.vec.y-this.r1,0),this.maxVec=new e.h9(this.vec.x+this.r1,this.vec.y+this.r1,0)}}NeedDecompose(){return this.boundingBoxMax.x-this.boundingBoxMin.x>this.GridResolution||this.boundingBoxMax.y-this.boundingBoxMin.y>this.GridResolution}Split(){this.DeepRemove();const t=(this.boundingBoxMax.x-this.boundingBoxMin.x)/this.GridResolution<1?1:(this.boundingBoxMax.x-this.boundingBoxMin.x)/this.GridResolution,i=(this.boundingBoxMax.y-this.boundingBoxMin.y)/this.GridResolution<1?1:(this.boundingBoxMax.y-this.boundingBoxMin.y)/this.GridResolution,s=this.buildGrid(t,i);this.BuildSubCluster(s,t,i)}Merge(t){this.points.concat(t.points),this.vec=new e.h9(0,0,0);for(let i=0;i<this.points.length;++i)this.vec.x+=this.points[i].vec.x,this.vec.y+=this.points[i].vec.y,this.UpdateBoundingBox(this.points[i].vec);this.vec.x/=this.points.length,this.vec.y/=this.points.length,this.minVec=new e.h9(this.vec.x-this.r1,this.vec.y-this.r1,0),this.maxVec=new e.h9(this.vec.x+this.r1,this.vec.y+this.r1,0),t.DeepRemove()}DeepRemove(){this.renderer.RemoveCluster(this)}buildGrid(t,i){this.tempGeoGridList=[];let s=[];for(let h=0;h<i;++h){const i=this.boundingBoxMin.y+h*this.GridResolution,n=[];for(let h=0;h<t;++h){const t=this.boundingBoxMin.x+h*this.GridResolution;s.push(new e.h9(t,i));const o=[];n.push(o)}this.tempGeoGridList.push(n)}return this.tempVecGridList=s,s}BuildSubCluster(t,i,s){for(let e=0;e<this.points.length;++e)this.GetCellAtPoint(this.points[e].vec,i,s).push(this.points[e]);for(let e=0;e<this.tempGeoGridList.length;++e)for(let t=0;t<this.tempGeoGridList[e].length;++t)this.tempGeoGridList[e][t]&&(1===this.tempGeoGridList[e][t].length?this.tempGeoGridList[e][t][0].collision.Reset():this.tempGeoGridList[e][t].length>1&&this.renderer.clustersRPoint.push(new h(this.renderer,this.tempGeoGridList[e][t])))}GetCellAtPoint(t,i,s){let h=new e.h9(t.x-this.boundingBoxMin.x,t.y-this.boundingBoxMin.y),n=Math.round(h.x/this.GridResolution),o=Math.round(h.y/this.GridResolution);return n>=i&&(n=i-1),o>=s&&(o=s-1),n<0&&(n=0),o<0&&(o=0),n=Math.round(n),o=Math.round(o),this.tempGeoGridList[o][n]}Draw(t,i,s){if(this.UpdateTimeer(),s){this.vec=new e.h9(0,0,0),this.boundingBoxMin=new e.h9(Number.MAX_SAFE_INTEGER,Number.MAX_SAFE_INTEGER,Number.MAX_SAFE_INTEGER),this.boundingBoxMax=new e.h9(Number.MIN_SAFE_INTEGER,Number.MIN_SAFE_INTEGER,Number.MIN_SAFE_INTEGER);for(let t=0;t<this.points.length;++t)this.vec.x+=this.points[t].vec.x,this.vec.y+=this.points[t].vec.y,this.UpdateBoundingBox(this.points[t].vec);this.vec.x/=this.points.length,this.vec.y/=this.points.length,this.minVec=new e.h9(this.vec.x-this.r1,this.vec.y-this.r1,0),this.maxVec=new e.h9(this.vec.x+this.r1,this.vec.y+this.r1,0)}if(n(t,this.points,this.vec,this.r0,this.r1,this.isHover,this.t),i.optimizer.inspection&&(t.beginPath(),t.rect(this.minVec.x,this.minVec.y,this.maxVec.x-this.minVec.x,this.maxVec.y-this.minVec.y),t.closePath(),t.fillStyle="rgba(0, 0, 0, 0.3)",t.fill(),t.lineWidth=.5,t.beginPath(),t.rect(this.boundingBoxMin.x,this.boundingBoxMin.y,this.boundingBoxMax.x-this.boundingBoxMin.x,this.boundingBoxMax.y-this.boundingBoxMin.y),t.closePath(),t.stroke(),this.tempVecGridList.length>0))for(let e=0;e<this.tempVecGridList.length;++e)t.beginPath(),t.rect(this.tempVecGridList[e].x,this.tempVecGridList[e].y,this.GridResolution,this.GridResolution),t.closePath(),t.stroke()}UpdateTimeer(){this.t-=.1,this.t=this.t<.4?.4:this.t}UpdateBoundingBox(t){this.boundingBoxMin.x=t.x<this.boundingBoxMin.x?t.x:this.boundingBoxMin.x,this.boundingBoxMin.y=t.y<this.boundingBoxMin.y?t.y:this.boundingBoxMin.y,this.boundingBoxMax.x=t.x>this.boundingBoxMax.x?t.x:this.boundingBoxMax.x,this.boundingBoxMax.y=t.y>this.boundingBoxMax.y?t.y:this.boundingBoxMax.y}}const n=function(t,i,s,e,h,n){if(n)for(let o=0;o<i.length;++o)t.lineWidth=.6,t.strokeStyle="#f00",t.beginPath(),t.moveTo(s.x,s.y),t.lineTo(i[o].vec.x,i[o].vec.y),t.closePath(),t.stroke(),t.lineWidth=1,t.strokeStyle="rgba(255, 255, 255, 1)",t.fillStyle="#f00",t.beginPath(),t.arc(i[o].vec.x,i[o].vec.y,4,0,2*Math.PI),t.closePath(),t.fill(),t.stroke();n?(t.fillStyle="#f00",t.beginPath(),t.arc(s.x,s.y,1.5,0,2*Math.PI),t.closePath(),t.fill()):(t.beginPath(),t.arc(s.x,s.y,h,0,2*Math.PI),t.closePath(),t.fillStyle="#f00",t.fill(),t.beginPath(),t.arc(s.x,s.y,e,0,2*Math.PI),t.closePath(),t.fillStyle="#0f0",t.fill(),t.fillStyle="rgba(255, 255, 255, 1)",t.font="bold 11px Arial",t.textAlign="center",t.fillText("".concat(i.length),s.x,s.y+4))};class o{constructor(t){this.clustersRPoint=[],this.optimizer=void 0,this.optimizer=t}InitGeometry(){this.clustersRPoint=[]}addClusterByGeometries(t){for(let i=0;i<t.length;++i)this.clustersRPoint.push(new h(this,t[i]))}RemoveCluster(t){this.clustersRPoint.splice(this.clustersRPoint.indexOf(t),1)}Render(t,i){if(this.clustersRPoint.length>0)for(let s=0;s<this.clustersRPoint.length;++s)this.clustersRPoint[s].Draw(t,this,i)}}class r{constructor(t){this.optimizer=void 0,this.pointList=[],this.optimizer=t}update(){this.updatePoints(),this.pointList=this.BuildConnectivity(this.pointList),this.initGeometry();const t=this.buildGraph(this.pointList);if(void 0!==t){this.addClusterByGeometries(t),this.PostUpdateCollisionBasedonGraph();const i=this.NeedDecompose();i.length>0&&(this.SplitClusters(i),this.PostMergeCluster())}}initGeometry(){this.optimizer.renderer.InitGeometry()}addClusterByGeometries(t){this.optimizer.renderer.addClusterByGeometries(t)}updatePoints(){this.pointList=[];for(let t=0;t<this.optimizer.points.length;++t)if(!this.optimizer.points[t].isHidden&&this.optimizer.points[t].isRenderable){const i=this.optimizer.points[t];i.collision.Reset(),this.pointList.push(i)}}BuildConnectivity(t){for(let i=0;i<t.length;++i){const s=t[i];for(let h=i+1;h<t.length;++h){const i=t[h];!i.isCollapse&&i!==s&&(0,e.Y4)([s.collision.minVec,s.collision.maxVec],[i.collision.minVec,i.collision.maxVec])&&(s.collision.isCollided=!0,s.isCollapse=!0,s.numVisit=0,s.collision.neighborShapes.push(i),i.collision.isCollided=!0,i.isCollapse=!0,i.numVisit=0,i.collision.neighborShapes.push(s))}}return t}buildGraph(t){let i=[];for(let s=0;s<t.length;++s){let e=[],h=[t[s]];h[0].collision.isVisited=!0,e.push(h[0]);let n,o=0;for(;void 0!==(n=h.shift());){for(let t=0;t<n.collision.neighborShapes.length;++t)n.collision.neighborShapes[t].collision.isVisited||(n.collision.neighborShapes[t].collision.isVisited=!0,h.push(n.collision.neighborShapes[t]),e.push(n.collision.neighborShapes[t]));if(o++>1e3)return void console.debug("fail to optimize")}e.length>1&&i.push(e)}return i}PostUpdateCollisionBasedonGraph(){for(let t=0;t<this.optimizer.renderer.clustersRPoint.length;++t)this.UpdateByQueue(this.optimizer.renderer.clustersRPoint[t],this.pointList)}UpdateByQueue(t,i){let s=0;const h=[...i];for(;h.length;){const n=h.shift();if(n){if(n.numVisit>100){n.numVisit=0;break}if(0===h.length&&i.length<s++)break;n.collision.isCollided||((0,e.Y4)([n.collision.minVec,n.collision.maxVec],[t.minVec,t.maxVec])?(n.collision.isCollided=!0,n.isCollapse=!0,n.numVisit=0,t.AddPost(n)):(n.numVisit++,h.push(n)))}}}NeedDecompose(){const t=[];for(let i=0;i<this.optimizer.renderer.clustersRPoint.length;++i)this.optimizer.renderer.clustersRPoint[i].NeedDecompose()&&t.push(this.optimizer.renderer.clustersRPoint[i]);return t}SplitClusters(t){for(let i=0;i<t.length;++i)t[i].Split()}PostMergeCluster(){this.PostMergeClusterCompute(this.optimizer.renderer.clustersRPoint)}PostMergeClusterCompute(t){for(let i=0;i<t.length-1;++i){const s=t[i];for(let h=i+1;h<t.length;++h){const i=t[h];i.isVisited||(0,e.TE)(s.vec,i.vec)<s.r1+20&&(i.isVisited=!0,s.Merge(i))}}}}class l{constructor(){this.graphClustering=void 0,this.renderer=void 0,this.mv=new e.h9(0,0),this.inspection=!0,this.points=[],this.graphClustering=new r(this),this.renderer=new o(this)}push(t,i){this.points.push(new e.MO(t,i)),this.update()}mouseInteraction(t,i){}update(){this.graphClustering.update()}getCellAtPoint(t){}render(t,i){this.renderer.Render(t,i)}}var c=s(5483),u=s.n(c);class a{constructor(t){var i=this;this.map=void 0,this.center=function(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:-99.292649,s=arguments.length>1&&void 0!==arguments[1]?arguments[1]:39.043903;i.map.setCenter({lat:s,lng:t})},this.toMap=(t,i)=>{const s=this.map.unproject({x:t,y:i});return[s.lng,s.lat]},this.toScreen=(t,i)=>{const s=this.map.project([t,i]);return[s.x,s.y]},this.mouseDown=t=>{},this.mouseUp=t=>{},this.mouseMove=t=>{},this.mouseClick=t=>{},this.mouseDClick=t=>{},this.initMap(t)}initMap(t){u().accessToken="pk.eyJ1IjoiZGVzaWduanUiLCJhIjoiY2xhNGU0YWo4MDlhYzNwdHBwenVvang4eiJ9.P3sX4l_3KjdPeRRbVS1VVg",this.map=new(u().Map)({container:t,zoom:15,center:[-71.093161,42.358871],style:"mapbox://styles/mapbox/dark-v10"}),this.map.dragRotate.disable(),this.map.on("mousemove",(t=>{this.mouseMove(t)})),this.map.on("click",(t=>{this.mouseClick(t)})),this.map.on("mousedown",(t=>{this.mouseDown(t)})),this.map.on("dblclick",(t=>{this.mouseDClick(t)})),this.map.on("mouseup",(t=>{this.mouseUp(t)}));let i=document.getElementsByClassName("mapboxgl-canvas")[0];i.style.position="absolute",i=document.getElementsByClassName("mapboxgl-control-container")[0],i.style.display="none"}}var d=s(55913);class p{constructor(t){this.divHost=void 0,this.mapboxWrapper=void 0,this.renderer=void 0,this.mouseDown=t=>{},this.mouseUp=t=>{},this.mouseDrag=t=>{},this.mouseClick=t=>{this.renderer.pts.push([t.lngLat.lng,t.lngLat.lat]);const i=this.mapboxWrapper.toScreen(t.lngLat.lng,t.lngLat.lat);this.renderer.mouseClick(i[0],i[1])},this.mouseMove=t=>{},this.divHost=t,this.divHost.style.position="relative",this.mapboxWrapper=new a(this.divHost.id),this.mapboxWrapper.mouseDown=this.mouseDown,this.mapboxWrapper.mouseUp=this.mouseUp,this.mapboxWrapper.mouseClick=this.mouseClick,this.mapboxWrapper.mouseMove=this.mouseMove,setTimeout((()=>{this.renderer=new x(this.divHost,this)}),100)}keyDown(t){}destroy(){for(this.renderer.destroy();this.divHost.lastElementChild;)this.divHost.removeChild(this.divHost.lastElementChild)}}class x extends d.bb{constructor(t,i){super(t),this.app=void 0,this.time=0,this.pts=[],this.clustering=void 0,this.mouseClick=(t,i)=>{console.log(t,i),this.clustering.push(t,i)},this.mouseUp=(t,i)=>{},this.mouseDrag=(t,i)=>{},this.app=i,this.canvas.id="mapboxCustom",this.canvas.style.position="absolute",this.canvas.style.width="100%",this.canvas.style.height="100%",this.canvas.style.pointerEvents="none",this.pts.push([-71.093161,42.358871]),this.clustering=new l,this.start()}render(t){this.time+=.1,this.clustering.render(t,!1)}}}}]);
//# sourceMappingURL=6376.4335a95a.chunk.js.map