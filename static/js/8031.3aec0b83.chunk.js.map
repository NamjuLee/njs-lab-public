{"version":3,"file":"static/js/8031.3aec0b83.chunk.js","mappings":"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","sources":["njslab/LabStarter/Starter-WebGPU/triangle.ts","njslab/LabStarter/Starter-WebGPU/index.ts"],"sourcesContent":["const vertex = new Float32Array([\n    0.0, 0.5, 0.0,\n    -0.5, -0.5, 0.0,\n    0.5, -0.5, 0.0\n])\nconst vertexCount = 3\n\nexport {vertex, vertexCount}","// import positionVert from './shaders/position.vert.wgsl?raw';\r\n// import colorFrag from './shaders/color.frag.wgsl';\r\n\r\nimport * as triangle from './triangle';\r\n\r\nconst positionVert = `\r\n@vertex\r\nfn main(@location(0) position : vec3<f32>) -> @builtin(position) vec4<f32> {\r\n    return vec4<f32>(position, 1.0);\r\n}\r\n`\r\nconst colorFrag = `\r\n@group(0) @binding(0) var<uniform> color : vec4<f32>;\r\n\r\n@fragment\r\nfn main() -> @location(0) vec4<f32> {\r\n    return color;\r\n}\r\n`\r\n\r\nexport class Solution {\r\n    divHost: HTMLElement;\r\n    canvas: HTMLCanvasElement;\r\n    ctx: GPUCanvasContext;\r\n    device: GPUDevice;\r\n    format: GPUTextureFormat;\r\n    size: any;\r\n    pipelineObj: any;\r\n    constructor(id: string) {\r\n        this.divHost = document.getElementById(id);\r\n        \r\n        console.log(id, 'webGPU', navigator.gpu);\r\n        this.canvas = document.createElement('canvas');\r\n        this.divHost.appendChild(this.canvas);\r\n\r\n        this.initWebGPU();\r\n    }\r\n    async initWebGPU() {\r\n        if (!navigator.gpu) { throw new Error('Not Support WebGPU'); }\r\n\r\n        const adapter = await navigator.gpu.requestAdapter({\r\n            powerPreference: 'high-performance'\r\n            // powerPreference: 'low-power'\r\n        })\r\n\r\n        if (!adapter) { throw new Error('No Adapter Found'); }\r\n\r\n        const device = await adapter.requestDevice()\r\n        this.ctx = this.canvas.getContext('webgpu') as GPUCanvasContext\r\n        const format = navigator.gpu.getPreferredCanvasFormat ? navigator.gpu.getPreferredCanvasFormat() : this.ctx.getPreferredFormat(adapter)\r\n        const devicePixelRatio = window.devicePixelRatio || 1\r\n        this.canvas.width = this.divHost.clientWidth ;\r\n        this.canvas.height = this.divHost.clientHeight;\r\n        this.ctx.configure({\r\n            // json specific format when key and value are the same\r\n            device, format,\r\n            // prevent chrome warning\r\n            alphaMode: 'opaque'\r\n        })\r\n\r\n        this.size = { width: this.canvas.width, height: this.canvas.height }\r\n        this.device = device;\r\n        this.format = format;\r\n\r\n        this.initPipeline(this.device, this.format);\r\n    }\r\n    public destroy() {\r\n\r\n    }\r\n    async initPipeline(device: GPUDevice, format: GPUTextureFormat) {\r\n        const pipeline = await device.createRenderPipelineAsync({\r\n            label: 'Basic Pipline',\r\n            layout: 'auto',\r\n            vertex: {\r\n                module: device.createShaderModule({\r\n                    code: positionVert,\r\n                }),\r\n                entryPoint: 'main',\r\n                buffers: [{\r\n                    arrayStride: 3 * 4, // 3 float32,\r\n                    attributes: [\r\n                        {\r\n                            // position xyz\r\n                            shaderLocation: 0,\r\n                            offset: 0,\r\n                            format: 'float32x3',\r\n                        }\r\n                    ]\r\n                }]\r\n            },\r\n            fragment: {\r\n                module: device.createShaderModule({\r\n                    code: colorFrag,\r\n                }),\r\n                entryPoint: 'main',\r\n                targets: [\r\n                    {\r\n                        format: format\r\n                    }\r\n                ]\r\n            },\r\n            primitive: {\r\n                topology: 'triangle-list' // try point-list, line-list, line-strip, triangle-strip?\r\n            }\r\n        } as GPURenderPipelineDescriptor)\r\n        // create vertex buffer\r\n        const vertexBuffer = device.createBuffer({\r\n            label: 'GPUBuffer store vertex',\r\n            size: triangle.vertex.byteLength,\r\n            usage: GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST,\r\n            //mappedAtCreation: true\r\n        })\r\n        device.queue.writeBuffer(vertexBuffer, 0, triangle.vertex)\r\n        // create color buffer\r\n        const colorBuffer = device.createBuffer({\r\n            label: 'GPUBuffer store rgba color',\r\n            size: 4 * 4, // 4 * float32\r\n            usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,\r\n        })\r\n        device.queue.writeBuffer(colorBuffer, 0, new Float32Array([1, 1, 0, 1]))\r\n\r\n        // create a uniform group for color\r\n        const uniformGroup = device.createBindGroup({\r\n            label: 'Uniform Group with colorBuffer',\r\n            layout: pipeline.getBindGroupLayout(0),\r\n            entries: [\r\n                {\r\n                    binding: 0,\r\n                    resource: {\r\n                        buffer: colorBuffer\r\n                    }\r\n                }\r\n            ]\r\n        })\r\n        // return all vars\r\n        console.log('working');\r\n        this.pipelineObj = { pipeline, vertexBuffer, colorBuffer, uniformGroup }\r\n        this.run();\r\n    }\r\n    draw(device: GPUDevice, context: GPUCanvasContext, pipelineObj: {\r\n        pipeline: GPURenderPipeline,\r\n        vertexBuffer: GPUBuffer,\r\n        colorBuffer: GPUBuffer,\r\n        uniformGroup: GPUBindGroup\r\n    }) {\r\n        const commandEncoder = device.createCommandEncoder()\r\n        const view = context.getCurrentTexture().createView()\r\n        const renderPassDescriptor: GPURenderPassDescriptor = {\r\n            //@ts-ignore\r\n            colorAttachments: [\r\n                {\r\n                    view: view,\r\n                    clearValue: { r: 0, g: 0, b: 0, a: 1.0 },\r\n                    loadOp: 'clear',\r\n                    storeOp: 'store'\r\n                }\r\n            ]\r\n        }\r\n        const passEncoder = commandEncoder.beginRenderPass(renderPassDescriptor)\r\n        passEncoder.setPipeline(pipelineObj.pipeline)\r\n        // set uniformGroup\r\n        passEncoder.setBindGroup(0, pipelineObj.uniformGroup)\r\n        // set vertex\r\n        passEncoder.setVertexBuffer(0, pipelineObj.vertexBuffer)\r\n        // 3 vertex form a triangle\r\n        passEncoder.draw(triangle.vertexCount)\r\n        passEncoder.end()\r\n        // webgpu run in a separate process, all the commands will be executed after submit\r\n        device.queue.submit([commandEncoder.finish()])\r\n    }\r\n    public run(){\r\n        // const canvas = document.querySelector('canvas')\r\n        // if (!canvas)\r\n        //     throw new Error('No Canvas')\r\n        // const {device, context, format} = await initWebGPU(canvas)\r\n        // const pipelineObj = await initPipeline(device, format)\r\n        \r\n        // first draw\r\n        this.draw(this.device, this.ctx, this.pipelineObj)\r\n    \r\n        // update colorBuffer if color changed\r\n        document.querySelector('input[type=\"color\"]')?.addEventListener('input', (e:Event) => {\r\n            // get hex color string\r\n            const color = (e.target as HTMLInputElement).value\r\n            console.log(color)\r\n            // parse hex color into rgb\r\n            const r = +('0x' + color.slice(1, 3)) / 255\r\n            const g = +('0x' + color.slice(3, 5)) / 255\r\n            const b = +('0x' + color.slice(5, 7)) / 255\r\n            // write colorBuffer with new color\r\n            this.device.queue.writeBuffer(this.pipelineObj.colorBuffer, 0, new Float32Array([r, g, b, 1]))\r\n            this.draw(this.device, this.ctx, this.pipelineObj)\r\n        })\r\n        \r\n        // update vertexBuffer\r\n        document.querySelector('input[type=\"range\"]')?.addEventListener('input', (e:Event) => {\r\n            // get input value\r\n            const value = +(e.target as HTMLInputElement).value\r\n            console.log(value)\r\n            // chagne vertex 0/3/6\r\n            triangle.vertex[0] = 0 + value\r\n            triangle.vertex[3] = -0.5 + value\r\n            triangle.vertex[6] = 0.5 + value\r\n            // write vertexBuffer with new vertex\r\n            this.device.queue.writeBuffer(this.pipelineObj.vertexBuffer, 0, triangle.vertex)\r\n            this.draw(this.device, this.ctx, this.pipelineObj)\r\n        })\r\n        // re-configure context on resize\r\n        window.addEventListener('resize', ()=>{\r\n            this.canvas.width = this.divHost.clientWidth;\r\n            this.canvas.height = this.divHost.clientHeight;\r\n            // don't need to recall context.configure() after v104\r\n            this.draw(this.device, this.ctx, this.pipelineObj);\r\n        })\r\n    }\r\n}"],"names":["vertex","Float32Array","Solution","id","divHost","canvas","ctx","device","format","size","pipelineObj","this","document","getElementById","console","log","navigator","gpu","createElement","appendChild","initWebGPU","Error","requestAdapter","powerPreference","adapter","requestDevice","getContext","getPreferredCanvasFormat","getPreferredFormat","window","devicePixelRatio","width","clientWidth","height","clientHeight","configure","alphaMode","initPipeline","createRenderPipelineAsync","label","layout","module","createShaderModule","code","entryPoint","buffers","arrayStride","attributes","shaderLocation","offset","fragment","targets","primitive","topology","pipeline","vertexBuffer","createBuffer","triangle","usage","GPUBufferUsage","VERTEX","COPY_DST","queue","writeBuffer","colorBuffer","UNIFORM","uniformGroup","createBindGroup","getBindGroupLayout","entries","binding","resource","buffer","run","context","commandEncoder","createCommandEncoder","renderPassDescriptor","colorAttachments","view","getCurrentTexture","createView","clearValue","r","g","b","a","loadOp","storeOp","passEncoder","beginRenderPass","setPipeline","setBindGroup","setVertexBuffer","draw","end","submit","finish","querySelector","addEventListener","e","color","target","value","slice"],"sourceRoot":""}