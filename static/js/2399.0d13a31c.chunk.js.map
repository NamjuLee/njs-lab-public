{"version":3,"file":"static/js/2399.0d13a31c.chunk.js","mappings":"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","sources":["njslab/Infrastructure/WebGPU/WebGPU_NJS_Sandbox_01/Controller/index.ts","../node_modules/gl-matrix/esm/vec2.js","njslab/Infrastructure/WebGPU/WebGPU_NJS_Sandbox_01/Renderer/CameraController.ts","njslab/Infrastructure/WebGPU/WebGPU_NJS_Sandbox_01/Renderer/WebGPU.ts","njslab/Infrastructure/WebGPU/WebGPU_NJS_Sandbox_01/Renderer/index.ts","njslab/Infrastructure/WebGPU/WebGPU_NJS_Sandbox_01/Geometry/Base/index.ts","njslab/Infrastructure/WebGPU/WebGPU_NJS_Sandbox_01/Object/TriMeshUniform/index.ts","njslab/Infrastructure/WebGPU/WebGPU_NJS_Sandbox_01/lib/index.ts","njslab/Infrastructure/WebGPU/WebGPU_NJS_Sandbox_01/Scene/index.ts","njslab/Infrastructure/WebGPU/WebGPU_NJS_Sandbox_01/index.ts","../node_modules/gl-matrix/esm/vec3.js"],"sourcesContent":["import { App } from \"..\";\nexport class Controller {\n    app: App;\n    pos = [0, 0]\n    isDown = false\n    constructor(app: App) {\n        this.app = app;\n    }\n    public init() {\n        this.appendEvent();\n    }\n    public appendEvent() {\n        this.app.renderer.canvas.addEventListener('ondrag', (e: MouseEvent) => {\n            // console.log('click', e);\n        }, false);\n        this.app.renderer.canvas.addEventListener('click', (e: MouseEvent) => {\n            // console.log('click', e);\n        }, false);\n        this.app.renderer.canvas.addEventListener('dblclick', (e: MouseEvent) => {\n            // console.log('d-click', e);\n        }, false);\n        this.app.renderer.canvas.addEventListener('drag', (e: MouseEvent) => {\n            // console.log('drag', e);\n        }, true);\n        this.app.renderer.canvas.addEventListener('mouseup', (e: MouseEvent) => {\n            // console.log('mouse up', e);\n        }, false);\n        this.app.renderer.canvas.addEventListener('mousedown', (e: MouseEvent) => {\n            this.isDown = true;\n            this.pos[0] = e.offsetX;\n            this.pos[1] = e.offsetY;\n            // this.app.renderer.camera.translateX(0.25)\n            // this.app.renderer.cameraController.translateX();\n            // this.app.renderer.cameraController.rotateZ();\n            // console.log('pointer down', e);\n        }, false);\n        this.app.renderer.canvas.addEventListener('mouseup', (e: MouseEvent) => {\n            // console.log('pointer up', e);\n            this.isDown = false;\n        }, false);\n        this.app.renderer.canvas.addEventListener('mousemove', (e: MouseEvent) => {\n            if (this.isDown) {\n                // console.log('move dragging')\n                const xOff = this.pos[0] - e.offsetX;\n                const yOff = this.pos[1] - e.offsetY;\n\n                this.app.renderer.cameraController.arcRotation(xOff, yOff)\n                this.pos[0] = e.offsetX;\n                this.pos[1] = e.offsetY;\n\n            } else {\n                // console.log('move')\n            }\n\n            // console.log('mousemove', e);\n        }, false);\n        this.app.renderer.canvas.addEventListener('wheel', (e:  WheelEvent) => {\n            // console.log('wheel', e.deltaY);\n            this.app.renderer.cameraController.zoomWheel(e.deltaY)\n        }, false);\n    }\n}","import * as glMatrix from \"./common.js\";\n/**\n * 2 Dimensional Vector\n * @module vec2\n */\n\n/**\n * Creates a new, empty vec2\n *\n * @returns {vec2} a new 2D vector\n */\n\nexport function create() {\n  var out = new glMatrix.ARRAY_TYPE(2);\n\n  if (glMatrix.ARRAY_TYPE != Float32Array) {\n    out[0] = 0;\n    out[1] = 0;\n  }\n\n  return out;\n}\n/**\n * Creates a new vec2 initialized with values from an existing vector\n *\n * @param {ReadonlyVec2} a vector to clone\n * @returns {vec2} a new 2D vector\n */\n\nexport function clone(a) {\n  var out = new glMatrix.ARRAY_TYPE(2);\n  out[0] = a[0];\n  out[1] = a[1];\n  return out;\n}\n/**\n * Creates a new vec2 initialized with the given values\n *\n * @param {Number} x X component\n * @param {Number} y Y component\n * @returns {vec2} a new 2D vector\n */\n\nexport function fromValues(x, y) {\n  var out = new glMatrix.ARRAY_TYPE(2);\n  out[0] = x;\n  out[1] = y;\n  return out;\n}\n/**\n * Copy the values from one vec2 to another\n *\n * @param {vec2} out the receiving vector\n * @param {ReadonlyVec2} a the source vector\n * @returns {vec2} out\n */\n\nexport function copy(out, a) {\n  out[0] = a[0];\n  out[1] = a[1];\n  return out;\n}\n/**\n * Set the components of a vec2 to the given values\n *\n * @param {vec2} out the receiving vector\n * @param {Number} x X component\n * @param {Number} y Y component\n * @returns {vec2} out\n */\n\nexport function set(out, x, y) {\n  out[0] = x;\n  out[1] = y;\n  return out;\n}\n/**\n * Adds two vec2's\n *\n * @param {vec2} out the receiving vector\n * @param {ReadonlyVec2} a the first operand\n * @param {ReadonlyVec2} b the second operand\n * @returns {vec2} out\n */\n\nexport function add(out, a, b) {\n  out[0] = a[0] + b[0];\n  out[1] = a[1] + b[1];\n  return out;\n}\n/**\n * Subtracts vector b from vector a\n *\n * @param {vec2} out the receiving vector\n * @param {ReadonlyVec2} a the first operand\n * @param {ReadonlyVec2} b the second operand\n * @returns {vec2} out\n */\n\nexport function subtract(out, a, b) {\n  out[0] = a[0] - b[0];\n  out[1] = a[1] - b[1];\n  return out;\n}\n/**\n * Multiplies two vec2's\n *\n * @param {vec2} out the receiving vector\n * @param {ReadonlyVec2} a the first operand\n * @param {ReadonlyVec2} b the second operand\n * @returns {vec2} out\n */\n\nexport function multiply(out, a, b) {\n  out[0] = a[0] * b[0];\n  out[1] = a[1] * b[1];\n  return out;\n}\n/**\n * Divides two vec2's\n *\n * @param {vec2} out the receiving vector\n * @param {ReadonlyVec2} a the first operand\n * @param {ReadonlyVec2} b the second operand\n * @returns {vec2} out\n */\n\nexport function divide(out, a, b) {\n  out[0] = a[0] / b[0];\n  out[1] = a[1] / b[1];\n  return out;\n}\n/**\n * Math.ceil the components of a vec2\n *\n * @param {vec2} out the receiving vector\n * @param {ReadonlyVec2} a vector to ceil\n * @returns {vec2} out\n */\n\nexport function ceil(out, a) {\n  out[0] = Math.ceil(a[0]);\n  out[1] = Math.ceil(a[1]);\n  return out;\n}\n/**\n * Math.floor the components of a vec2\n *\n * @param {vec2} out the receiving vector\n * @param {ReadonlyVec2} a vector to floor\n * @returns {vec2} out\n */\n\nexport function floor(out, a) {\n  out[0] = Math.floor(a[0]);\n  out[1] = Math.floor(a[1]);\n  return out;\n}\n/**\n * Returns the minimum of two vec2's\n *\n * @param {vec2} out the receiving vector\n * @param {ReadonlyVec2} a the first operand\n * @param {ReadonlyVec2} b the second operand\n * @returns {vec2} out\n */\n\nexport function min(out, a, b) {\n  out[0] = Math.min(a[0], b[0]);\n  out[1] = Math.min(a[1], b[1]);\n  return out;\n}\n/**\n * Returns the maximum of two vec2's\n *\n * @param {vec2} out the receiving vector\n * @param {ReadonlyVec2} a the first operand\n * @param {ReadonlyVec2} b the second operand\n * @returns {vec2} out\n */\n\nexport function max(out, a, b) {\n  out[0] = Math.max(a[0], b[0]);\n  out[1] = Math.max(a[1], b[1]);\n  return out;\n}\n/**\n * Math.round the components of a vec2\n *\n * @param {vec2} out the receiving vector\n * @param {ReadonlyVec2} a vector to round\n * @returns {vec2} out\n */\n\nexport function round(out, a) {\n  out[0] = Math.round(a[0]);\n  out[1] = Math.round(a[1]);\n  return out;\n}\n/**\n * Scales a vec2 by a scalar number\n *\n * @param {vec2} out the receiving vector\n * @param {ReadonlyVec2} a the vector to scale\n * @param {Number} b amount to scale the vector by\n * @returns {vec2} out\n */\n\nexport function scale(out, a, b) {\n  out[0] = a[0] * b;\n  out[1] = a[1] * b;\n  return out;\n}\n/**\n * Adds two vec2's after scaling the second operand by a scalar value\n *\n * @param {vec2} out the receiving vector\n * @param {ReadonlyVec2} a the first operand\n * @param {ReadonlyVec2} b the second operand\n * @param {Number} scale the amount to scale b by before adding\n * @returns {vec2} out\n */\n\nexport function scaleAndAdd(out, a, b, scale) {\n  out[0] = a[0] + b[0] * scale;\n  out[1] = a[1] + b[1] * scale;\n  return out;\n}\n/**\n * Calculates the euclidian distance between two vec2's\n *\n * @param {ReadonlyVec2} a the first operand\n * @param {ReadonlyVec2} b the second operand\n * @returns {Number} distance between a and b\n */\n\nexport function distance(a, b) {\n  var x = b[0] - a[0],\n      y = b[1] - a[1];\n  return Math.hypot(x, y);\n}\n/**\n * Calculates the squared euclidian distance between two vec2's\n *\n * @param {ReadonlyVec2} a the first operand\n * @param {ReadonlyVec2} b the second operand\n * @returns {Number} squared distance between a and b\n */\n\nexport function squaredDistance(a, b) {\n  var x = b[0] - a[0],\n      y = b[1] - a[1];\n  return x * x + y * y;\n}\n/**\n * Calculates the length of a vec2\n *\n * @param {ReadonlyVec2} a vector to calculate length of\n * @returns {Number} length of a\n */\n\nexport function length(a) {\n  var x = a[0],\n      y = a[1];\n  return Math.hypot(x, y);\n}\n/**\n * Calculates the squared length of a vec2\n *\n * @param {ReadonlyVec2} a vector to calculate squared length of\n * @returns {Number} squared length of a\n */\n\nexport function squaredLength(a) {\n  var x = a[0],\n      y = a[1];\n  return x * x + y * y;\n}\n/**\n * Negates the components of a vec2\n *\n * @param {vec2} out the receiving vector\n * @param {ReadonlyVec2} a vector to negate\n * @returns {vec2} out\n */\n\nexport function negate(out, a) {\n  out[0] = -a[0];\n  out[1] = -a[1];\n  return out;\n}\n/**\n * Returns the inverse of the components of a vec2\n *\n * @param {vec2} out the receiving vector\n * @param {ReadonlyVec2} a vector to invert\n * @returns {vec2} out\n */\n\nexport function inverse(out, a) {\n  out[0] = 1.0 / a[0];\n  out[1] = 1.0 / a[1];\n  return out;\n}\n/**\n * Normalize a vec2\n *\n * @param {vec2} out the receiving vector\n * @param {ReadonlyVec2} a vector to normalize\n * @returns {vec2} out\n */\n\nexport function normalize(out, a) {\n  var x = a[0],\n      y = a[1];\n  var len = x * x + y * y;\n\n  if (len > 0) {\n    //TODO: evaluate use of glm_invsqrt here?\n    len = 1 / Math.sqrt(len);\n  }\n\n  out[0] = a[0] * len;\n  out[1] = a[1] * len;\n  return out;\n}\n/**\n * Calculates the dot product of two vec2's\n *\n * @param {ReadonlyVec2} a the first operand\n * @param {ReadonlyVec2} b the second operand\n * @returns {Number} dot product of a and b\n */\n\nexport function dot(a, b) {\n  return a[0] * b[0] + a[1] * b[1];\n}\n/**\n * Computes the cross product of two vec2's\n * Note that the cross product must by definition produce a 3D vector\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec2} a the first operand\n * @param {ReadonlyVec2} b the second operand\n * @returns {vec3} out\n */\n\nexport function cross(out, a, b) {\n  var z = a[0] * b[1] - a[1] * b[0];\n  out[0] = out[1] = 0;\n  out[2] = z;\n  return out;\n}\n/**\n * Performs a linear interpolation between two vec2's\n *\n * @param {vec2} out the receiving vector\n * @param {ReadonlyVec2} a the first operand\n * @param {ReadonlyVec2} b the second operand\n * @param {Number} t interpolation amount, in the range [0-1], between the two inputs\n * @returns {vec2} out\n */\n\nexport function lerp(out, a, b, t) {\n  var ax = a[0],\n      ay = a[1];\n  out[0] = ax + t * (b[0] - ax);\n  out[1] = ay + t * (b[1] - ay);\n  return out;\n}\n/**\n * Generates a random vector with the given scale\n *\n * @param {vec2} out the receiving vector\n * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned\n * @returns {vec2} out\n */\n\nexport function random(out, scale) {\n  scale = scale || 1.0;\n  var r = glMatrix.RANDOM() * 2.0 * Math.PI;\n  out[0] = Math.cos(r) * scale;\n  out[1] = Math.sin(r) * scale;\n  return out;\n}\n/**\n * Transforms the vec2 with a mat2\n *\n * @param {vec2} out the receiving vector\n * @param {ReadonlyVec2} a the vector to transform\n * @param {ReadonlyMat2} m matrix to transform with\n * @returns {vec2} out\n */\n\nexport function transformMat2(out, a, m) {\n  var x = a[0],\n      y = a[1];\n  out[0] = m[0] * x + m[2] * y;\n  out[1] = m[1] * x + m[3] * y;\n  return out;\n}\n/**\n * Transforms the vec2 with a mat2d\n *\n * @param {vec2} out the receiving vector\n * @param {ReadonlyVec2} a the vector to transform\n * @param {ReadonlyMat2d} m matrix to transform with\n * @returns {vec2} out\n */\n\nexport function transformMat2d(out, a, m) {\n  var x = a[0],\n      y = a[1];\n  out[0] = m[0] * x + m[2] * y + m[4];\n  out[1] = m[1] * x + m[3] * y + m[5];\n  return out;\n}\n/**\n * Transforms the vec2 with a mat3\n * 3rd vector component is implicitly '1'\n *\n * @param {vec2} out the receiving vector\n * @param {ReadonlyVec2} a the vector to transform\n * @param {ReadonlyMat3} m matrix to transform with\n * @returns {vec2} out\n */\n\nexport function transformMat3(out, a, m) {\n  var x = a[0],\n      y = a[1];\n  out[0] = m[0] * x + m[3] * y + m[6];\n  out[1] = m[1] * x + m[4] * y + m[7];\n  return out;\n}\n/**\n * Transforms the vec2 with a mat4\n * 3rd vector component is implicitly '0'\n * 4th vector component is implicitly '1'\n *\n * @param {vec2} out the receiving vector\n * @param {ReadonlyVec2} a the vector to transform\n * @param {ReadonlyMat4} m matrix to transform with\n * @returns {vec2} out\n */\n\nexport function transformMat4(out, a, m) {\n  var x = a[0];\n  var y = a[1];\n  out[0] = m[0] * x + m[4] * y + m[12];\n  out[1] = m[1] * x + m[5] * y + m[13];\n  return out;\n}\n/**\n * Rotate a 2D vector\n * @param {vec2} out The receiving vec2\n * @param {ReadonlyVec2} a The vec2 point to rotate\n * @param {ReadonlyVec2} b The origin of the rotation\n * @param {Number} rad The angle of rotation in radians\n * @returns {vec2} out\n */\n\nexport function rotate(out, a, b, rad) {\n  //Translate point to the origin\n  var p0 = a[0] - b[0],\n      p1 = a[1] - b[1],\n      sinC = Math.sin(rad),\n      cosC = Math.cos(rad); //perform rotation and translate to correct position\n\n  out[0] = p0 * cosC - p1 * sinC + b[0];\n  out[1] = p0 * sinC + p1 * cosC + b[1];\n  return out;\n}\n/**\n * Get the angle between two 2D vectors\n * @param {ReadonlyVec2} a The first operand\n * @param {ReadonlyVec2} b The second operand\n * @returns {Number} The angle in radians\n */\n\nexport function angle(a, b) {\n  var x1 = a[0],\n      y1 = a[1],\n      x2 = b[0],\n      y2 = b[1],\n      // mag is the product of the magnitudes of a and b\n  mag = Math.sqrt(x1 * x1 + y1 * y1) * Math.sqrt(x2 * x2 + y2 * y2),\n      // mag &&.. short circuits if mag == 0\n  cosine = mag && (x1 * x2 + y1 * y2) / mag; // Math.min(Math.max(cosine, -1), 1) clamps the cosine between -1 and 1\n\n  return Math.acos(Math.min(Math.max(cosine, -1), 1));\n}\n/**\n * Set the components of a vec2 to zero\n *\n * @param {vec2} out the receiving vector\n * @returns {vec2} out\n */\n\nexport function zero(out) {\n  out[0] = 0.0;\n  out[1] = 0.0;\n  return out;\n}\n/**\n * Returns a string representation of a vector\n *\n * @param {ReadonlyVec2} a vector to represent as a string\n * @returns {String} string representation of the vector\n */\n\nexport function str(a) {\n  return \"vec2(\" + a[0] + \", \" + a[1] + \")\";\n}\n/**\n * Returns whether or not the vectors exactly have the same elements in the same position (when compared with ===)\n *\n * @param {ReadonlyVec2} a The first vector.\n * @param {ReadonlyVec2} b The second vector.\n * @returns {Boolean} True if the vectors are equal, false otherwise.\n */\n\nexport function exactEquals(a, b) {\n  return a[0] === b[0] && a[1] === b[1];\n}\n/**\n * Returns whether or not the vectors have approximately the same elements in the same position.\n *\n * @param {ReadonlyVec2} a The first vector.\n * @param {ReadonlyVec2} b The second vector.\n * @returns {Boolean} True if the vectors are equal, false otherwise.\n */\n\nexport function equals(a, b) {\n  var a0 = a[0],\n      a1 = a[1];\n  var b0 = b[0],\n      b1 = b[1];\n  return Math.abs(a0 - b0) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1));\n}\n/**\n * Alias for {@link vec2.length}\n * @function\n */\n\nexport var len = length;\n/**\n * Alias for {@link vec2.subtract}\n * @function\n */\n\nexport var sub = subtract;\n/**\n * Alias for {@link vec2.multiply}\n * @function\n */\n\nexport var mul = multiply;\n/**\n * Alias for {@link vec2.divide}\n * @function\n */\n\nexport var div = divide;\n/**\n * Alias for {@link vec2.distance}\n * @function\n */\n\nexport var dist = distance;\n/**\n * Alias for {@link vec2.squaredDistance}\n * @function\n */\n\nexport var sqrDist = squaredDistance;\n/**\n * Alias for {@link vec2.squaredLength}\n * @function\n */\n\nexport var sqrLen = squaredLength;\n/**\n * Perform some operation over an array of vec2s.\n *\n * @param {Array} a the array of vectors to iterate over\n * @param {Number} stride Number of elements between the start of each vec2. If 0 assumes tightly packed\n * @param {Number} offset Number of elements to skip at the beginning of the array\n * @param {Number} count Number of vec2s to iterate over. If 0 iterates over entire array\n * @param {Function} fn Function to call for each vector in the array\n * @param {Object} [arg] additional argument to pass to fn\n * @returns {Array} a\n * @function\n */\n\nexport var forEach = function () {\n  var vec = create();\n  return function (a, stride, offset, count, fn, arg) {\n    var i, l;\n\n    if (!stride) {\n      stride = 2;\n    }\n\n    if (!offset) {\n      offset = 0;\n    }\n\n    if (count) {\n      l = Math.min(count * stride + offset, a.length);\n    } else {\n      l = a.length;\n    }\n\n    for (i = offset; i < l; i += stride) {\n      vec[0] = a[i];\n      vec[1] = a[i + 1];\n      fn(vec, vec, arg);\n      a[i] = vec[0];\n      a[i + 1] = vec[1];\n    }\n\n    return a;\n  };\n}();","import { vec2, vec3, mat4 } from 'gl-matrix';\nimport { } from '../lib';\n\nimport { Renderer } from '.';\n\nexport class CameraController {\n    public solution: Renderer;\n    public canvas: HTMLCanvasElement\n\n    public camera: Camera;\n\n    private modelMatrix: mat4 = mat4.create();\n    private mvpMatrix: mat4 = mat4.create();\n\n    // public vMatrix: mat4;\n    // public vpMatrix: mat4;\n    public rotation =vec3.fromValues(0, 0, 0); \n    public translation =vec3.fromValues(0, 0, 0); \n\n\n    // public projectionMatrix = mat4.create();\n\n    // public eye = vec3.fromValues(0,10,0);\n\n    public screen2 = vec2.fromValues(0, 0);\n\n    angleXY = 2.5;\n    angleZ = 0.6;\n    distance = 5;\n\n    constructor(solution: Renderer) {\n        this.solution = solution;\n        this.canvas = solution.canvas;\n\n        const eye = vec3.fromValues(2.6451475620269775, -3.130298137664795, 2.864337205886841);\n        const center = vec3.fromValues(0, 0, 0);\n        const up = vec3.fromValues(0, 0, 1);\n\n        this.camera = new Camera(this.canvas.width / this.canvas.height, eye, center, up);\n        this.update();\n    }\n    public zoomWheel(v: number) {\n        this.distance += v * 0.01;\n        this.arcRotation(0, 0);\n    }\n    public update() {\n        // mat4.lookAt(this.vMatrix, this.eye, this.center, this.up);\n        this.camera.update();\n\n        // mat4.multiply(this.camera.viewProjectionMatrix, this.camera.projectionMatrix, this.camera.viewMatrix);\n        createTransforms(this.modelMatrix, this.translation, this.rotation);\n        mat4.multiply(this.mvpMatrix, this.camera.viewProjectionMatrix, this.modelMatrix);\n        // console.log('camera updated...');\n    }\n    public rotateZ(val = 0.1) {\n        this.rotation[2] += val;\n        this.update();\n    }\n    public translateX(val = 0.1) {\n        this.translation[0] += val;\n        this.update();\n    }\n    public get getMatrix() {\n        return this.mvpMatrix;\n    }\n    public arcRotation(x: number, y: number) {\n        x = x * 0.01;\n        y = y * 0.01;\n        this.angleXY -= x;\n        this.angleZ -= y;\n        this.camera.eye[0] = this.camera.center[0] + (Math.sin(this.angleXY) * Math.cos(this.angleZ)) * this.distance;\n        this.camera.eye[1] = this.camera.center[1] + (Math.cos(this.angleXY) * Math.cos(this.angleZ)) * this.distance;\n        this.camera.eye[2] = this.camera.center[2] + (Math.sin(this.angleZ) * this.distance);\n        this.update();\n    }\n}\n\n\nexport class Camera {\n    public viewMatrix = mat4.create();\n    public projectionMatrix = mat4.create(); \n    public viewProjectionMatrix = mat4.create();\n\n    public zoomMax = 100;\n    public zoomSpeed = 2;\n\n    public near = 0.01;\n    public far = 10000;\n\n    public mvpMatrix = mat4.create();\n\n    public eye = vec3.fromValues(2.6451475620269775, -3.130298137664795, 2.864337205886841);\n    public center = vec3.fromValues(0, 0, 0);\n    public up = vec3.fromValues(0, 1, 0);\n\n    constructor(respectRatio = 1.0, cameraPosition:vec3 = [2, 2, 4], lookDirection:vec3 = [0, 0, 0],  upDirection:vec3 = [0, 1, 0]){\n        this.eye = cameraPosition;\n        this.center = lookDirection;\n        this.up = upDirection;\n\n        mat4.perspective(this.projectionMatrix, 2 * Math.PI / 5, respectRatio, this.near, this.far);\n        // mat4.ortho(this.projectionMatrix, 0, 0, 800, 800, -400 , 400);\n        // mat4.frustum(projectionMatrix, 0, 800, 800, 0, -400, 400);\n\n        this.update();\n    }\n    public update() {\n        mat4.lookAt(this.viewMatrix, this.eye, this.center, this.up);\n        mat4.multiply(this.viewProjectionMatrix, this.projectionMatrix, this.viewMatrix);\n\n        // createTransforms(this.modelMatrix, this.translation, this.rotation);\n        // mat4.multiply(this.mvpMatrix, this.viewProjectionMatrix, this.viewMatrix);\n    }\n}\n\nexport const createTransforms = (modelMat:mat4, translation:vec3 = [0,0,0], rotation:vec3 = [0,0,0], scaling:vec3 = [1,1,1]) => {\n    const rotateXMat = mat4.create();\n    const rotateYMat = mat4.create();\n    const rotateZMat = mat4.create();   \n    const translateMat = mat4.create();\n    const scaleMat = mat4.create();\n\n    //perform individual transformations\n    mat4.fromTranslation(translateMat, translation);\n    mat4.fromXRotation(rotateXMat, rotation[0]);\n    mat4.fromYRotation(rotateYMat, rotation[1]);\n    mat4.fromZRotation(rotateZMat, rotation[2]);\n    mat4.fromScaling(scaleMat, scaling);\n\n    //combine all transformation matrices together to form a final transform matrix: modelMat\n    mat4.multiply(modelMat, rotateXMat, scaleMat);\n    mat4.multiply(modelMat, rotateYMat, modelMat);        \n    mat4.multiply(modelMat, rotateZMat, modelMat);\n    mat4.multiply(modelMat, translateMat, modelMat);\n};","import { Renderer } from './';\n\nexport enum PrimitiveTopology {\n    PointList = 'point-list',\n    LineList = 'line-list',\n    LineStrip = 'line-strip',\n    TriangleList = 'triangle-list',\n    TriangleStrip = 'triangle-strip',\n}\n\nexport class WebGPU {\n    public renderer: Renderer;\n\n    ctx: GPUCanvasContext;\n    device: GPUDevice;\n    format: GPUTextureFormat;\n\n    commandEncoder: GPUCommandEncoder;\n\n    PrimitiveTopology = PrimitiveTopology;\n\n\n    constructor(renderer: Renderer) {\n        this.renderer = renderer;\n    }\n    public async initWebGPU() {\n        if (!navigator.gpu) { throw new Error('Not Support WebGPU'); }\n        const adapter = await navigator.gpu.requestAdapter({\n            powerPreference: 'high-performance'\n            // powerPreference: 'low-power'\n        })\n        if (!adapter) { throw new Error('No Adapter Found'); }\n\n        const device = await adapter.requestDevice()\n        this.ctx = this.renderer.canvas.getContext('webgpu') as GPUCanvasContext\n        // this.format = navigator.gpu.getPreferredCanvasFormat ? navigator.gpu.getPreferredCanvasFormat() : this.ctx.getPreferredFormat(adapter)\n        this.format = \"bgra8unorm\";\n\n        this.ctx.configure({\n            device: device, \n            format: this.format,\n            // prevent chrome warning\n            alphaMode: 'opaque'\n        });\n\n        // this.size = { width: this.canvas.width, height: this.canvas.height }\n        this.device = device;\n\n    }\n    public destroy() {\n        this.device.destroy();\n    }\n}","import { App } from '../';\nimport { CameraController } from './CameraController';\nimport { WebGPU } from './WebGPU';\n\nexport class Renderer {\n    public app: App;\n    public canvas: HTMLCanvasElement;\n\n    public cameraController: CameraController;\n    public webGPU: WebGPU;\n\n    public isAnimation: boolean = true;\n    private requestAni: any;\n\n    constructor(app: App) {\n        this.app = app;\n\n        this.canvas = document.createElement('canvas');\n        this.canvas.width = this.app.divHost.clientWidth;\n        this.canvas.height = this.app.divHost.clientHeight;\n        this.app.divHost.appendChild(this.canvas);\n\n        this.webGPU = new WebGPU(this);\n    }\n    async init() {\n        await this.webGPU.initWebGPU();\n\n        this.cameraController = new CameraController(this);\n        this.requestAni = requestAnimationFrame(this.loop);\n    }\n\n    public loop = () => {\n        if (this.isAnimation) {\n            this.requestAni = requestAnimationFrame(this.loop);\n        }\n        // this.cameraController.update();\n        this.drawing();\n    }\n    public drawing() {\n        this.app.scene.render();\n    }\n    public destroy() {\n        this.webGPU.destroy();\n        // this.isAnimation = false;\n        cancelAnimationFrame(this.requestAni);\n        // this.requestAni = undefined;\n        while (this.app.divHost.lastElementChild) {\n            this.app.divHost.removeChild(this.app.divHost.lastElementChild);\n        }\n    }\n}\n\n","import { Scene } from '../../Scene';\nimport { WebGPU } from '../../Renderer/WebGPU';\nexport class ObjectBase {\n    public scene: Scene;\n    public webGPU: WebGPU;\n    constructor(scene: Scene) {\n        this.scene = scene;\n        this.webGPU = scene.app.renderer.webGPU;\n        this.scene.objects.push(this);\n\n    }\n    public async initPipeline() {\n\n    }\n    public update() {\n\n    }\n    public render() {\n\n    }\n}","import { loadWGSL } from '../../lib';\r\nimport { mat4, vec3 } from \"gl-matrix\";\r\n\r\nimport { Scene } from '../../Scene';\r\nimport { ObjectBase } from '../../Geometry/Base';\r\n\r\nconst shaderPath = require('./shaders.wgsl');\r\n\r\nexport class TriMeshUniform extends ObjectBase {\r\n\r\n\r\n    buffer: GPUBuffer\r\n    bufferLayout: GPUVertexBufferLayout\r\n    uniformBuffer;\r\n\r\n    pipeline;\r\n    bindGroup;\r\n\r\n    t = 0.0;\r\n\r\n    isRenderable= false;\r\n\r\n    constructor(scene: Scene) {\r\n        super(scene)\r\n\r\n        // x y r g b\r\n        const vertices: Float32Array = new Float32Array(\r\n            [\r\n                0.0,  0.0,  1.5, 1.0, 0.0, 0.0,\r\n                0.0, -1.5, -1.5, 0.0, 1.0, 0.0,\r\n                0.0,  1.5, -1.5, 0.0, 0.0, 1.0\r\n            ]\r\n        );\r\n\r\n        const usage: GPUBufferUsageFlags = GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST;\r\n        //VERTEX: the buffer can be used as a vertex buffer\r\n        //COPY_DST: data can be copied to the buffer\r\n\r\n        const descriptor: GPUBufferDescriptor = {\r\n            size: vertices.byteLength,\r\n            usage: usage,\r\n            mappedAtCreation: true // similar to HOST_VISIBLE, allows buffer to be written by the CPU\r\n        };\r\n\r\n        this.buffer = this.webGPU.device.createBuffer(descriptor);\r\n\r\n        //Buffer has been created, now load in the vertices\r\n        new Float32Array(this.buffer.getMappedRange()).set(vertices);\r\n        this.buffer.unmap();\r\n\r\n        //now define the buffer layout\r\n        this.bufferLayout = {\r\n            arrayStride: 24,\r\n            attributes: [\r\n                {\r\n                    shaderLocation: 0,\r\n                    format: \"float32x3\",\r\n                    offset: 0\r\n                },\r\n                {\r\n                    shaderLocation: 1,\r\n                    format: \"float32x3\",\r\n                    offset: 12\r\n                }\r\n            ]\r\n        }\r\n        this.initPipeline();\r\n    }\r\n    async initPipeline () {\r\n\r\n        this.uniformBuffer = this.webGPU.device.createBuffer({\r\n            size: 64 * 3,\r\n            usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST\r\n        });\r\n\r\n        // const bindGroupLayout = this.webGPU.device.createBindGroupLayout({\r\n        //     entries: [],\r\n        // });\r\n\r\n        const bindGroupLayout = this.webGPU.device.createBindGroupLayout({\r\n            entries: [\r\n                {\r\n                    binding: 0,\r\n                    visibility: GPUShaderStage.VERTEX,\r\n                    buffer: {}\r\n                }\r\n            ]\r\n\r\n        });\r\n    \r\n        // this.bindGroup = this.webGPU.device.createBindGroup({\r\n        //     layout: bindGroupLayout,\r\n        //     entries: []\r\n        // });\r\n\r\n        this.bindGroup = this.webGPU.device.createBindGroup({\r\n            layout: bindGroupLayout,\r\n            entries: [\r\n                {\r\n                    binding: 0,\r\n                    resource: {\r\n                        buffer: this.uniformBuffer\r\n                    }\r\n                }\r\n            ]\r\n        });\r\n        \r\n        const pipelineLayout = this.webGPU.device.createPipelineLayout({\r\n            bindGroupLayouts: [bindGroupLayout]\r\n        });\r\n    \r\n        const shader = await loadWGSL(shaderPath);\r\n\r\n        this.pipeline = this.webGPU.device.createRenderPipeline({\r\n            vertex : {\r\n                module : this.webGPU.device.createShaderModule({\r\n                    code : shader\r\n                }),\r\n                entryPoint : \"vs_main\",\r\n                buffers: [this.bufferLayout,]\r\n            },\r\n    \r\n            fragment : {\r\n                module : this.webGPU.device.createShaderModule({\r\n                    code : shader\r\n                }),\r\n                entryPoint : \"fs_main\",\r\n                targets : [{\r\n                    format : this.webGPU.format\r\n                }]\r\n            },\r\n    \r\n            primitive : {\r\n                topology : \"triangle-list\"\r\n            },\r\n    \r\n            layout: pipelineLayout\r\n        });\r\n        this.isRenderable = true;\r\n    }\r\n    render() {\r\n        if (!this.isRenderable) { return; }\r\n\r\n        this.t += 0.01;\r\n        if (this.t > 2.0 * Math.PI) {\r\n            // this.t -= 2.0 * Math.PI;\r\n        }\r\n        \r\n\r\n        //make transforms\r\n        let projection = mat4.create();\r\n        // load perspective projection into the projection matrix,\r\n        // Field of view = 45 degrees (pi/4)\r\n        // Aspect ratio = 800/600\r\n        // near = 0.1, far = 10 \r\n        const fovy = Math.PI/4;\r\n        const aspect = this.webGPU.renderer.canvas.width/this.webGPU.renderer.canvas.height\r\n        const near = 0.1\r\n        const far = 10\r\n        mat4.perspective(projection, fovy, aspect, near,far );\r\n\r\n\r\n        let view = mat4.create();\r\n        // console.log(view)\r\n        //load lookat matrix into the view matrix,\r\n        //looking from [-2, 0, 2]\r\n        //looking at [0, 0, 0]\r\n        //up vector is [0, 0, 1]\r\n        const eye = vec3.fromValues(-2, 0, 2);\r\n        const center = vec3.fromValues(0, 0, 0);\r\n        const up = vec3.fromValues(0, 0, 1)\r\n        mat4.lookAt(view, eye, center, up);\r\n\r\n\r\n\r\n        \r\n        const model = mat4.create();\r\n        //Store, in the model matrix, the model matrix after rotating it by t radians around the z axis.\r\n        //(yeah, I know, kinda weird.)\r\n\r\n        // mat4.rotate(model, model, this.t, [0,1,0]);\r\n        mat4.translate(model, model, [Math.sin(this.t ),0,0]);\r\n\r\n        let hasCamera = true;\r\n        if (hasCamera){\r\n            projection = this.webGPU.renderer.cameraController.camera.projectionMatrix;\r\n            view = this.webGPU.renderer.cameraController.camera.viewMatrix;\r\n        } \r\n        \r\n\r\n        this.webGPU.device.queue.writeBuffer(this.uniformBuffer, 0, <ArrayBuffer>model); \r\n        this.webGPU.device.queue.writeBuffer(this.uniformBuffer, 64, <ArrayBuffer>view); \r\n        this.webGPU.device.queue.writeBuffer(this.uniformBuffer, 128, <ArrayBuffer>projection); \r\n\r\n\r\n        //command encoder: records draw commands for submission\r\n        const commandEncoder : GPUCommandEncoder = this.webGPU.device.createCommandEncoder();\r\n        //texture view: image view to the color buffer in this case\r\n        const textureView : GPUTextureView = this.webGPU.ctx.getCurrentTexture().createView();\r\n        //renderpass: holds draw commands, allocated from command encoder\r\n        const renderpass : GPURenderPassEncoder = commandEncoder.beginRenderPass({\r\n            colorAttachments: [{\r\n                view: textureView,\r\n                clearValue: {r: 0.0, g: 0.0, b: 0.0, a: 1.0},\r\n                loadOp: \"clear\",\r\n                storeOp: \"store\"\r\n            }]\r\n        });\r\n        // renderpass.setPipeline(this.pipeline);\r\n        // renderpass.setVertexBuffer(0, this.buffer);\r\n        // renderpass.setBindGroup(0, this.bindGroup)\r\n        // renderpass.draw(3, 1, 0, 0);\r\n        // renderpass.end();\r\n    \r\n        // this.webGPU.device.queue.submit([commandEncoder.finish()]);\r\n\r\n\r\n\r\n        renderpass.setPipeline(this.pipeline);\r\n        renderpass.setVertexBuffer(0, this.buffer);\r\n        renderpass.setBindGroup(0, this.bindGroup);\r\n        renderpass.draw(3, 1, 0, 0);\r\n        renderpass.end();\r\n    \r\n        this.webGPU.device.queue.submit([commandEncoder.finish()]);\r\n    }\r\n}","import { vec3, mat4 } from 'gl-matrix';\n\nexport const loadWGSL = async (path: string) => {\n    return fetch(`${path}`)\n        .then((response: Response) => {\n            return response.text();\n        }).catch((err: Error) => {\n            console.debug(err);\n        });\n\n}\n\nexport const createViewProjection = (respectRatio = 1.0, cameraPosition:vec3 = [2, 2, 4], lookDirection:vec3 = [0, 0, 0], \n    upDirection:vec3 = [0, 1, 0]) => {\n\n    const viewMatrix = mat4.create();\n    const projectionMatrix = mat4.create();       \n    const viewProjectionMatrix = mat4.create();\n\n    // mat4.perspective(projectionMatrix, 2 * Math.PI / 5, respectRatio, 0.1, 100.0);\n    mat4.ortho(projectionMatrix, 0, 0, 800, 800, -400 , 400);\n    // mat4.frustum(projectionMatrix, 0, 800, 800, 0, -400, 400);\n\n    mat4.lookAt(viewMatrix, cameraPosition, lookDirection, upDirection);\n    mat4.multiply(viewProjectionMatrix, projectionMatrix, viewMatrix);\n\n    const cameraOption = {\n        eye: cameraPosition,\n        center: lookDirection,\n        zoomMax: 100,\n        zoomSpeed: 2\n    };\n\n    return {\n        viewMatrix,\n        projectionMatrix,\n        viewProjectionMatrix,\n        cameraOption\n    }\n};\n\nexport const createTransforms = (modelMat:mat4, translation:vec3 = [0,0,0], rotation:vec3 = [0,0,0], scaling:vec3 = [1,1,1]) => {\n    const rotateXMat = mat4.create();\n    const rotateYMat = mat4.create();\n    const rotateZMat = mat4.create();   \n    const translateMat = mat4.create();\n    const scaleMat = mat4.create();\n\n    //perform individual transformations\n    mat4.fromTranslation(translateMat, translation);\n    mat4.fromXRotation(rotateXMat, rotation[0]);\n    mat4.fromYRotation(rotateYMat, rotation[1]);\n    mat4.fromZRotation(rotateZMat, rotation[2]);\n    mat4.fromScaling(scaleMat, scaling);\n\n    //combine all transformation matrices together to form a final transform matrix: modelMat\n    mat4.multiply(modelMat, rotateXMat, scaleMat);\n    mat4.multiply(modelMat, rotateYMat, modelMat);        \n    mat4.multiply(modelMat, rotateZMat, modelMat);\n    mat4.multiply(modelMat, translateMat, modelMat);\n};\n\nexport const createGPUBuffer = (device:GPUDevice, data:Float32Array, \n    usageFlag:GPUBufferUsageFlags = GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST) => {\n    const buffer = device.createBuffer({\n        size: data.byteLength,\n        usage: usageFlag,\n        mappedAtCreation: true\n    });\n    new Float32Array(buffer.getMappedRange()).set(data);\n    buffer.unmap();\n    return buffer;\n};","import { App } from \"..\";\n\nimport { ObjectBase } from '../Geometry/Base';\n\n\nimport { Line } from '../Geometry/Line';\nimport { Tri } from '../Geometry/Tri';\nimport { TriangleMesh } from \"../Geometry/TriMesh\";\n\nimport { TriMeshUniform } from \"../Object/TriMeshUniform\";\nimport { SphereWire } from '../Object/SphereWire';\nimport { Box } from \"../Object/Box\";\nimport { BoxF } from \"../Object/BoxF\";\nimport { PolylineRandom } from \"../Object/PolylineRandom\";\n\nexport class Scene {\n    public app: App;\n    public objects: ObjectBase[] = [];\n    \n    public t = 0.0;\n    constructor(app: App) {\n        this.app = app;\n    }\n    async init() {\n        new TriMeshUniform(this);\n\n        // new Box(this);\n        // new BoxF(this);\n\n        // new SphereWire(this);\n\n        // new PolylineRandom(this);\n    }\n    public render() {\n\n        for (let i = 0 ; i < this.objects.length; ++i) {\n            this.objects[i].update();\n            this.objects[i].render();\n        }\n\n\n\n        if (this.t % 300 === 0) {\n            // new TriMeshUniform(this);\n        }\n\n        this.t+= 0.1;\n    }\n}","import { Controller } from './Controller';\r\nimport { Renderer } from './Renderer';\r\nimport { Scene } from './Scene';\r\n\r\n// https://www.youtube.com/playlist?list=PLn3eTxaOtL2Ns3wkxdyS3CiqkJuwQdZzn\r\n// https://www.youtube.com/playlist?list=PL_UrKDEhALdKh0118flOjuAnVIGKFUJXN\r\n\r\n// https://webgpufundamentals.org/\r\n// https://webgpu.github.io/webgpu-samples/\r\n\r\n// https://antongerdelan.net/opengl/raycasting.html\r\n\r\nexport class App {\r\n    public divHost: HTMLElement;\r\n\r\n    public controller: Controller;\r\n    public renderer: Renderer;\r\n    public scene: Scene;\r\n\r\n    constructor(id: string) {\r\n        this.divHost = document.getElementById(id);\r\n\r\n        this.renderer = new Renderer(this)\r\n        this.controller = new Controller(this);\r\n        this.scene = new Scene(this);\r\n\r\n        this.init();\r\n    }\r\n    public async init() {\r\n        this.controller.init();\r\n        await this.renderer.init();\r\n        await this.scene.init();\r\n    };\r\n    public destroy() {\r\n        this.renderer.destroy();\r\n        while (this.divHost.lastElementChild) {\r\n            this.divHost.removeChild(this.divHost.lastElementChild);\r\n        }\r\n    }\r\n}\r\n\r\n\r\nexport class Solution {\r\n    public app: App\r\n    constructor(id: string) {\r\n        this.app = new App(id)\r\n    }\r\n    public destroy() {\r\n        this.app.destroy();\r\n    }\r\n}","import * as glMatrix from \"./common.js\";\n/**\n * 3 Dimensional Vector\n * @module vec3\n */\n\n/**\n * Creates a new, empty vec3\n *\n * @returns {vec3} a new 3D vector\n */\n\nexport function create() {\n  var out = new glMatrix.ARRAY_TYPE(3);\n\n  if (glMatrix.ARRAY_TYPE != Float32Array) {\n    out[0] = 0;\n    out[1] = 0;\n    out[2] = 0;\n  }\n\n  return out;\n}\n/**\n * Creates a new vec3 initialized with values from an existing vector\n *\n * @param {ReadonlyVec3} a vector to clone\n * @returns {vec3} a new 3D vector\n */\n\nexport function clone(a) {\n  var out = new glMatrix.ARRAY_TYPE(3);\n  out[0] = a[0];\n  out[1] = a[1];\n  out[2] = a[2];\n  return out;\n}\n/**\n * Calculates the length of a vec3\n *\n * @param {ReadonlyVec3} a vector to calculate length of\n * @returns {Number} length of a\n */\n\nexport function length(a) {\n  var x = a[0];\n  var y = a[1];\n  var z = a[2];\n  return Math.hypot(x, y, z);\n}\n/**\n * Creates a new vec3 initialized with the given values\n *\n * @param {Number} x X component\n * @param {Number} y Y component\n * @param {Number} z Z component\n * @returns {vec3} a new 3D vector\n */\n\nexport function fromValues(x, y, z) {\n  var out = new glMatrix.ARRAY_TYPE(3);\n  out[0] = x;\n  out[1] = y;\n  out[2] = z;\n  return out;\n}\n/**\n * Copy the values from one vec3 to another\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the source vector\n * @returns {vec3} out\n */\n\nexport function copy(out, a) {\n  out[0] = a[0];\n  out[1] = a[1];\n  out[2] = a[2];\n  return out;\n}\n/**\n * Set the components of a vec3 to the given values\n *\n * @param {vec3} out the receiving vector\n * @param {Number} x X component\n * @param {Number} y Y component\n * @param {Number} z Z component\n * @returns {vec3} out\n */\n\nexport function set(out, x, y, z) {\n  out[0] = x;\n  out[1] = y;\n  out[2] = z;\n  return out;\n}\n/**\n * Adds two vec3's\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the first operand\n * @param {ReadonlyVec3} b the second operand\n * @returns {vec3} out\n */\n\nexport function add(out, a, b) {\n  out[0] = a[0] + b[0];\n  out[1] = a[1] + b[1];\n  out[2] = a[2] + b[2];\n  return out;\n}\n/**\n * Subtracts vector b from vector a\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the first operand\n * @param {ReadonlyVec3} b the second operand\n * @returns {vec3} out\n */\n\nexport function subtract(out, a, b) {\n  out[0] = a[0] - b[0];\n  out[1] = a[1] - b[1];\n  out[2] = a[2] - b[2];\n  return out;\n}\n/**\n * Multiplies two vec3's\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the first operand\n * @param {ReadonlyVec3} b the second operand\n * @returns {vec3} out\n */\n\nexport function multiply(out, a, b) {\n  out[0] = a[0] * b[0];\n  out[1] = a[1] * b[1];\n  out[2] = a[2] * b[2];\n  return out;\n}\n/**\n * Divides two vec3's\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the first operand\n * @param {ReadonlyVec3} b the second operand\n * @returns {vec3} out\n */\n\nexport function divide(out, a, b) {\n  out[0] = a[0] / b[0];\n  out[1] = a[1] / b[1];\n  out[2] = a[2] / b[2];\n  return out;\n}\n/**\n * Math.ceil the components of a vec3\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a vector to ceil\n * @returns {vec3} out\n */\n\nexport function ceil(out, a) {\n  out[0] = Math.ceil(a[0]);\n  out[1] = Math.ceil(a[1]);\n  out[2] = Math.ceil(a[2]);\n  return out;\n}\n/**\n * Math.floor the components of a vec3\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a vector to floor\n * @returns {vec3} out\n */\n\nexport function floor(out, a) {\n  out[0] = Math.floor(a[0]);\n  out[1] = Math.floor(a[1]);\n  out[2] = Math.floor(a[2]);\n  return out;\n}\n/**\n * Returns the minimum of two vec3's\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the first operand\n * @param {ReadonlyVec3} b the second operand\n * @returns {vec3} out\n */\n\nexport function min(out, a, b) {\n  out[0] = Math.min(a[0], b[0]);\n  out[1] = Math.min(a[1], b[1]);\n  out[2] = Math.min(a[2], b[2]);\n  return out;\n}\n/**\n * Returns the maximum of two vec3's\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the first operand\n * @param {ReadonlyVec3} b the second operand\n * @returns {vec3} out\n */\n\nexport function max(out, a, b) {\n  out[0] = Math.max(a[0], b[0]);\n  out[1] = Math.max(a[1], b[1]);\n  out[2] = Math.max(a[2], b[2]);\n  return out;\n}\n/**\n * Math.round the components of a vec3\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a vector to round\n * @returns {vec3} out\n */\n\nexport function round(out, a) {\n  out[0] = Math.round(a[0]);\n  out[1] = Math.round(a[1]);\n  out[2] = Math.round(a[2]);\n  return out;\n}\n/**\n * Scales a vec3 by a scalar number\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the vector to scale\n * @param {Number} b amount to scale the vector by\n * @returns {vec3} out\n */\n\nexport function scale(out, a, b) {\n  out[0] = a[0] * b;\n  out[1] = a[1] * b;\n  out[2] = a[2] * b;\n  return out;\n}\n/**\n * Adds two vec3's after scaling the second operand by a scalar value\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the first operand\n * @param {ReadonlyVec3} b the second operand\n * @param {Number} scale the amount to scale b by before adding\n * @returns {vec3} out\n */\n\nexport function scaleAndAdd(out, a, b, scale) {\n  out[0] = a[0] + b[0] * scale;\n  out[1] = a[1] + b[1] * scale;\n  out[2] = a[2] + b[2] * scale;\n  return out;\n}\n/**\n * Calculates the euclidian distance between two vec3's\n *\n * @param {ReadonlyVec3} a the first operand\n * @param {ReadonlyVec3} b the second operand\n * @returns {Number} distance between a and b\n */\n\nexport function distance(a, b) {\n  var x = b[0] - a[0];\n  var y = b[1] - a[1];\n  var z = b[2] - a[2];\n  return Math.hypot(x, y, z);\n}\n/**\n * Calculates the squared euclidian distance between two vec3's\n *\n * @param {ReadonlyVec3} a the first operand\n * @param {ReadonlyVec3} b the second operand\n * @returns {Number} squared distance between a and b\n */\n\nexport function squaredDistance(a, b) {\n  var x = b[0] - a[0];\n  var y = b[1] - a[1];\n  var z = b[2] - a[2];\n  return x * x + y * y + z * z;\n}\n/**\n * Calculates the squared length of a vec3\n *\n * @param {ReadonlyVec3} a vector to calculate squared length of\n * @returns {Number} squared length of a\n */\n\nexport function squaredLength(a) {\n  var x = a[0];\n  var y = a[1];\n  var z = a[2];\n  return x * x + y * y + z * z;\n}\n/**\n * Negates the components of a vec3\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a vector to negate\n * @returns {vec3} out\n */\n\nexport function negate(out, a) {\n  out[0] = -a[0];\n  out[1] = -a[1];\n  out[2] = -a[2];\n  return out;\n}\n/**\n * Returns the inverse of the components of a vec3\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a vector to invert\n * @returns {vec3} out\n */\n\nexport function inverse(out, a) {\n  out[0] = 1.0 / a[0];\n  out[1] = 1.0 / a[1];\n  out[2] = 1.0 / a[2];\n  return out;\n}\n/**\n * Normalize a vec3\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a vector to normalize\n * @returns {vec3} out\n */\n\nexport function normalize(out, a) {\n  var x = a[0];\n  var y = a[1];\n  var z = a[2];\n  var len = x * x + y * y + z * z;\n\n  if (len > 0) {\n    //TODO: evaluate use of glm_invsqrt here?\n    len = 1 / Math.sqrt(len);\n  }\n\n  out[0] = a[0] * len;\n  out[1] = a[1] * len;\n  out[2] = a[2] * len;\n  return out;\n}\n/**\n * Calculates the dot product of two vec3's\n *\n * @param {ReadonlyVec3} a the first operand\n * @param {ReadonlyVec3} b the second operand\n * @returns {Number} dot product of a and b\n */\n\nexport function dot(a, b) {\n  return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];\n}\n/**\n * Computes the cross product of two vec3's\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the first operand\n * @param {ReadonlyVec3} b the second operand\n * @returns {vec3} out\n */\n\nexport function cross(out, a, b) {\n  var ax = a[0],\n      ay = a[1],\n      az = a[2];\n  var bx = b[0],\n      by = b[1],\n      bz = b[2];\n  out[0] = ay * bz - az * by;\n  out[1] = az * bx - ax * bz;\n  out[2] = ax * by - ay * bx;\n  return out;\n}\n/**\n * Performs a linear interpolation between two vec3's\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the first operand\n * @param {ReadonlyVec3} b the second operand\n * @param {Number} t interpolation amount, in the range [0-1], between the two inputs\n * @returns {vec3} out\n */\n\nexport function lerp(out, a, b, t) {\n  var ax = a[0];\n  var ay = a[1];\n  var az = a[2];\n  out[0] = ax + t * (b[0] - ax);\n  out[1] = ay + t * (b[1] - ay);\n  out[2] = az + t * (b[2] - az);\n  return out;\n}\n/**\n * Performs a hermite interpolation with two control points\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the first operand\n * @param {ReadonlyVec3} b the second operand\n * @param {ReadonlyVec3} c the third operand\n * @param {ReadonlyVec3} d the fourth operand\n * @param {Number} t interpolation amount, in the range [0-1], between the two inputs\n * @returns {vec3} out\n */\n\nexport function hermite(out, a, b, c, d, t) {\n  var factorTimes2 = t * t;\n  var factor1 = factorTimes2 * (2 * t - 3) + 1;\n  var factor2 = factorTimes2 * (t - 2) + t;\n  var factor3 = factorTimes2 * (t - 1);\n  var factor4 = factorTimes2 * (3 - 2 * t);\n  out[0] = a[0] * factor1 + b[0] * factor2 + c[0] * factor3 + d[0] * factor4;\n  out[1] = a[1] * factor1 + b[1] * factor2 + c[1] * factor3 + d[1] * factor4;\n  out[2] = a[2] * factor1 + b[2] * factor2 + c[2] * factor3 + d[2] * factor4;\n  return out;\n}\n/**\n * Performs a bezier interpolation with two control points\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the first operand\n * @param {ReadonlyVec3} b the second operand\n * @param {ReadonlyVec3} c the third operand\n * @param {ReadonlyVec3} d the fourth operand\n * @param {Number} t interpolation amount, in the range [0-1], between the two inputs\n * @returns {vec3} out\n */\n\nexport function bezier(out, a, b, c, d, t) {\n  var inverseFactor = 1 - t;\n  var inverseFactorTimesTwo = inverseFactor * inverseFactor;\n  var factorTimes2 = t * t;\n  var factor1 = inverseFactorTimesTwo * inverseFactor;\n  var factor2 = 3 * t * inverseFactorTimesTwo;\n  var factor3 = 3 * factorTimes2 * inverseFactor;\n  var factor4 = factorTimes2 * t;\n  out[0] = a[0] * factor1 + b[0] * factor2 + c[0] * factor3 + d[0] * factor4;\n  out[1] = a[1] * factor1 + b[1] * factor2 + c[1] * factor3 + d[1] * factor4;\n  out[2] = a[2] * factor1 + b[2] * factor2 + c[2] * factor3 + d[2] * factor4;\n  return out;\n}\n/**\n * Generates a random vector with the given scale\n *\n * @param {vec3} out the receiving vector\n * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned\n * @returns {vec3} out\n */\n\nexport function random(out, scale) {\n  scale = scale || 1.0;\n  var r = glMatrix.RANDOM() * 2.0 * Math.PI;\n  var z = glMatrix.RANDOM() * 2.0 - 1.0;\n  var zScale = Math.sqrt(1.0 - z * z) * scale;\n  out[0] = Math.cos(r) * zScale;\n  out[1] = Math.sin(r) * zScale;\n  out[2] = z * scale;\n  return out;\n}\n/**\n * Transforms the vec3 with a mat4.\n * 4th vector component is implicitly '1'\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the vector to transform\n * @param {ReadonlyMat4} m matrix to transform with\n * @returns {vec3} out\n */\n\nexport function transformMat4(out, a, m) {\n  var x = a[0],\n      y = a[1],\n      z = a[2];\n  var w = m[3] * x + m[7] * y + m[11] * z + m[15];\n  w = w || 1.0;\n  out[0] = (m[0] * x + m[4] * y + m[8] * z + m[12]) / w;\n  out[1] = (m[1] * x + m[5] * y + m[9] * z + m[13]) / w;\n  out[2] = (m[2] * x + m[6] * y + m[10] * z + m[14]) / w;\n  return out;\n}\n/**\n * Transforms the vec3 with a mat3.\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the vector to transform\n * @param {ReadonlyMat3} m the 3x3 matrix to transform with\n * @returns {vec3} out\n */\n\nexport function transformMat3(out, a, m) {\n  var x = a[0],\n      y = a[1],\n      z = a[2];\n  out[0] = x * m[0] + y * m[3] + z * m[6];\n  out[1] = x * m[1] + y * m[4] + z * m[7];\n  out[2] = x * m[2] + y * m[5] + z * m[8];\n  return out;\n}\n/**\n * Transforms the vec3 with a quat\n * Can also be used for dual quaternions. (Multiply it with the real part)\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the vector to transform\n * @param {ReadonlyQuat} q quaternion to transform with\n * @returns {vec3} out\n */\n\nexport function transformQuat(out, a, q) {\n  // benchmarks: https://jsperf.com/quaternion-transform-vec3-implementations-fixed\n  var qx = q[0],\n      qy = q[1],\n      qz = q[2],\n      qw = q[3];\n  var x = a[0],\n      y = a[1],\n      z = a[2]; // var qvec = [qx, qy, qz];\n  // var uv = vec3.cross([], qvec, a);\n\n  var uvx = qy * z - qz * y,\n      uvy = qz * x - qx * z,\n      uvz = qx * y - qy * x; // var uuv = vec3.cross([], qvec, uv);\n\n  var uuvx = qy * uvz - qz * uvy,\n      uuvy = qz * uvx - qx * uvz,\n      uuvz = qx * uvy - qy * uvx; // vec3.scale(uv, uv, 2 * w);\n\n  var w2 = qw * 2;\n  uvx *= w2;\n  uvy *= w2;\n  uvz *= w2; // vec3.scale(uuv, uuv, 2);\n\n  uuvx *= 2;\n  uuvy *= 2;\n  uuvz *= 2; // return vec3.add(out, a, vec3.add(out, uv, uuv));\n\n  out[0] = x + uvx + uuvx;\n  out[1] = y + uvy + uuvy;\n  out[2] = z + uvz + uuvz;\n  return out;\n}\n/**\n * Rotate a 3D vector around the x-axis\n * @param {vec3} out The receiving vec3\n * @param {ReadonlyVec3} a The vec3 point to rotate\n * @param {ReadonlyVec3} b The origin of the rotation\n * @param {Number} rad The angle of rotation in radians\n * @returns {vec3} out\n */\n\nexport function rotateX(out, a, b, rad) {\n  var p = [],\n      r = []; //Translate point to the origin\n\n  p[0] = a[0] - b[0];\n  p[1] = a[1] - b[1];\n  p[2] = a[2] - b[2]; //perform rotation\n\n  r[0] = p[0];\n  r[1] = p[1] * Math.cos(rad) - p[2] * Math.sin(rad);\n  r[2] = p[1] * Math.sin(rad) + p[2] * Math.cos(rad); //translate to correct position\n\n  out[0] = r[0] + b[0];\n  out[1] = r[1] + b[1];\n  out[2] = r[2] + b[2];\n  return out;\n}\n/**\n * Rotate a 3D vector around the y-axis\n * @param {vec3} out The receiving vec3\n * @param {ReadonlyVec3} a The vec3 point to rotate\n * @param {ReadonlyVec3} b The origin of the rotation\n * @param {Number} rad The angle of rotation in radians\n * @returns {vec3} out\n */\n\nexport function rotateY(out, a, b, rad) {\n  var p = [],\n      r = []; //Translate point to the origin\n\n  p[0] = a[0] - b[0];\n  p[1] = a[1] - b[1];\n  p[2] = a[2] - b[2]; //perform rotation\n\n  r[0] = p[2] * Math.sin(rad) + p[0] * Math.cos(rad);\n  r[1] = p[1];\n  r[2] = p[2] * Math.cos(rad) - p[0] * Math.sin(rad); //translate to correct position\n\n  out[0] = r[0] + b[0];\n  out[1] = r[1] + b[1];\n  out[2] = r[2] + b[2];\n  return out;\n}\n/**\n * Rotate a 3D vector around the z-axis\n * @param {vec3} out The receiving vec3\n * @param {ReadonlyVec3} a The vec3 point to rotate\n * @param {ReadonlyVec3} b The origin of the rotation\n * @param {Number} rad The angle of rotation in radians\n * @returns {vec3} out\n */\n\nexport function rotateZ(out, a, b, rad) {\n  var p = [],\n      r = []; //Translate point to the origin\n\n  p[0] = a[0] - b[0];\n  p[1] = a[1] - b[1];\n  p[2] = a[2] - b[2]; //perform rotation\n\n  r[0] = p[0] * Math.cos(rad) - p[1] * Math.sin(rad);\n  r[1] = p[0] * Math.sin(rad) + p[1] * Math.cos(rad);\n  r[2] = p[2]; //translate to correct position\n\n  out[0] = r[0] + b[0];\n  out[1] = r[1] + b[1];\n  out[2] = r[2] + b[2];\n  return out;\n}\n/**\n * Get the angle between two 3D vectors\n * @param {ReadonlyVec3} a The first operand\n * @param {ReadonlyVec3} b The second operand\n * @returns {Number} The angle in radians\n */\n\nexport function angle(a, b) {\n  var ax = a[0],\n      ay = a[1],\n      az = a[2],\n      bx = b[0],\n      by = b[1],\n      bz = b[2],\n      mag1 = Math.sqrt(ax * ax + ay * ay + az * az),\n      mag2 = Math.sqrt(bx * bx + by * by + bz * bz),\n      mag = mag1 * mag2,\n      cosine = mag && dot(a, b) / mag;\n  return Math.acos(Math.min(Math.max(cosine, -1), 1));\n}\n/**\n * Set the components of a vec3 to zero\n *\n * @param {vec3} out the receiving vector\n * @returns {vec3} out\n */\n\nexport function zero(out) {\n  out[0] = 0.0;\n  out[1] = 0.0;\n  out[2] = 0.0;\n  return out;\n}\n/**\n * Returns a string representation of a vector\n *\n * @param {ReadonlyVec3} a vector to represent as a string\n * @returns {String} string representation of the vector\n */\n\nexport function str(a) {\n  return \"vec3(\" + a[0] + \", \" + a[1] + \", \" + a[2] + \")\";\n}\n/**\n * Returns whether or not the vectors have exactly the same elements in the same position (when compared with ===)\n *\n * @param {ReadonlyVec3} a The first vector.\n * @param {ReadonlyVec3} b The second vector.\n * @returns {Boolean} True if the vectors are equal, false otherwise.\n */\n\nexport function exactEquals(a, b) {\n  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2];\n}\n/**\n * Returns whether or not the vectors have approximately the same elements in the same position.\n *\n * @param {ReadonlyVec3} a The first vector.\n * @param {ReadonlyVec3} b The second vector.\n * @returns {Boolean} True if the vectors are equal, false otherwise.\n */\n\nexport function equals(a, b) {\n  var a0 = a[0],\n      a1 = a[1],\n      a2 = a[2];\n  var b0 = b[0],\n      b1 = b[1],\n      b2 = b[2];\n  return Math.abs(a0 - b0) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a2), Math.abs(b2));\n}\n/**\n * Alias for {@link vec3.subtract}\n * @function\n */\n\nexport var sub = subtract;\n/**\n * Alias for {@link vec3.multiply}\n * @function\n */\n\nexport var mul = multiply;\n/**\n * Alias for {@link vec3.divide}\n * @function\n */\n\nexport var div = divide;\n/**\n * Alias for {@link vec3.distance}\n * @function\n */\n\nexport var dist = distance;\n/**\n * Alias for {@link vec3.squaredDistance}\n * @function\n */\n\nexport var sqrDist = squaredDistance;\n/**\n * Alias for {@link vec3.length}\n * @function\n */\n\nexport var len = length;\n/**\n * Alias for {@link vec3.squaredLength}\n * @function\n */\n\nexport var sqrLen = squaredLength;\n/**\n * Perform some operation over an array of vec3s.\n *\n * @param {Array} a the array of vectors to iterate over\n * @param {Number} stride Number of elements between the start of each vec3. If 0 assumes tightly packed\n * @param {Number} offset Number of elements to skip at the beginning of the array\n * @param {Number} count Number of vec3s to iterate over. If 0 iterates over entire array\n * @param {Function} fn Function to call for each vector in the array\n * @param {Object} [arg] additional argument to pass to fn\n * @returns {Array} a\n * @function\n */\n\nexport var forEach = function () {\n  var vec = create();\n  return function (a, stride, offset, count, fn, arg) {\n    var i, l;\n\n    if (!stride) {\n      stride = 3;\n    }\n\n    if (!offset) {\n      offset = 0;\n    }\n\n    if (count) {\n      l = Math.min(count * stride + offset, a.length);\n    } else {\n      l = a.length;\n    }\n\n    for (i = offset; i < l; i += stride) {\n      vec[0] = a[i];\n      vec[1] = a[i + 1];\n      vec[2] = a[i + 2];\n      fn(vec, vec, arg);\n      a[i] = vec[0];\n      a[i + 1] = vec[1];\n      a[i + 2] = vec[2];\n    }\n\n    return a;\n  };\n}();"],"names":["Controller","constructor","app","pos","isDown","this","init","appendEvent","renderer","canvas","addEventListener","e","offsetX","offsetY","xOff","yOff","cameraController","arcRotation","zoomWheel","deltaY","vec","out","glMatrix","Float32Array","create","CameraController","solution","camera","modelMatrix","mat4","mvpMatrix","rotation","vec3","translation","screen2","x","y","vec2","angleXY","angleZ","distance","eye","center","up","Camera","width","height","update","v","createTransforms","viewProjectionMatrix","rotateZ","val","translateX","getMatrix","Math","sin","cos","respectRatio","cameraPosition","lookDirection","upDirection","viewMatrix","projectionMatrix","zoomMax","zoomSpeed","near","far","PI","modelMat","scaling","rotateXMat","rotateYMat","rotateZMat","translateMat","scaleMat","PrimitiveTopology","WebGPU","ctx","device","format","commandEncoder","navigator","gpu","Error","adapter","requestAdapter","powerPreference","requestDevice","getContext","configure","alphaMode","destroy","Renderer","webGPU","isAnimation","requestAni","loop","requestAnimationFrame","drawing","document","createElement","divHost","clientWidth","clientHeight","appendChild","async","initWebGPU","scene","render","cancelAnimationFrame","lastElementChild","removeChild","ObjectBase","objects","push","shaderPath","require","TriMeshUniform","super","buffer","bufferLayout","uniformBuffer","pipeline","bindGroup","t","isRenderable","vertices","usage","GPUBufferUsage","VERTEX","COPY_DST","descriptor","size","byteLength","mappedAtCreation","createBuffer","getMappedRange","set","unmap","arrayStride","attributes","shaderLocation","offset","initPipeline","UNIFORM","bindGroupLayout","createBindGroupLayout","entries","binding","visibility","GPUShaderStage","createBindGroup","layout","resource","pipelineLayout","createPipelineLayout","bindGroupLayouts","shader","fetch","path","then","response","text","catch","err","console","debug","loadWGSL","createRenderPipeline","vertex","module","createShaderModule","code","entryPoint","buffers","fragment","targets","primitive","topology","projection","fovy","aspect","view","model","queue","writeBuffer","createCommandEncoder","textureView","getCurrentTexture","createView","renderpass","beginRenderPass","colorAttachments","clearValue","r","g","b","a","loadOp","storeOp","setPipeline","setVertexBuffer","setBindGroup","draw","end","submit","finish","Scene","i","length","App","id","controller","getElementById","Solution","fromValues","z","add","subtract","scaleAndAdd","scale","cross","ax","ay","az","bx","by","bz"],"sourceRoot":""}