{"version":3,"file":"static/js/74957.f8e1d881.chunk.js","mappings":"8LAIO,MAAMA,EAGXC,YAAYC,GAAa,KAFlBC,aAAO,OACPC,cAAQ,EAEbC,KAAKF,QAAUG,SAASC,eAAeL,GAGvCG,KAAKF,QAAQK,MAAMC,QAAU,OAC7BJ,KAAKF,QAAQK,MAAME,WAAa,SAEhC,MAAMC,EAAML,SAASM,cAAc,OACnCD,EAAIH,MAAMK,WAAa,OACvBF,EAAIH,MAAMM,YAAc,OACxBH,EAAIH,MAAMO,gBAAkB,OAC5BJ,EAAIH,MAAMQ,MAAQ,SAClBL,EAAIH,MAAMS,OAAS,QAEnBZ,KAAKF,QAAQe,YAAYP,GAKzBN,KAAKD,SAAW,IAAIe,EAASR,EAK/B,CACOS,UAEL,IADAf,KAAKD,SAASgB,UACPf,KAAKF,QAAQkB,kBAClBhB,KAAKF,QAAQmB,YAAYjB,KAAKF,QAAQkB,iBAE1C,EAGK,MAAMF,UAAiBI,EAAAA,GAK5BtB,YAAYU,GACVa,MAAMb,GAAK,KALbc,cAAQ,OACRC,GAAc,GAAG,KACjBC,YAA4BC,EAAU,KACtCC,EAAI,IAGFxB,KAAKyB,OAAOtB,MAAMuB,SAAW,WAC7B1B,KAAKyB,OAAOtB,MAAMQ,MAAQ,OAC1BX,KAAKyB,OAAOtB,MAAMS,OAAS,OAM3B,MAAMe,EAASC,EAAU,QAAS,EAAG,KACrCD,EAAOA,OAAOE,aAAY,UAAM7B,KAAKwB,GACrCxB,KAAKF,QAAQe,YAAYc,EAAOrB,KAChCqB,EAAOA,OAAOG,QAAU,KACtB9B,KAAKwB,GAAKG,EAAOA,OAAOI,MAAQ,IAEhCJ,EAAOK,KAAKC,UAAY,UAAYjC,KAAKwB,CAAC,EAG5CxB,KAAKqB,GAAK,GACV,IAAK,IAAIa,EAAI,EAAGA,EAAI,KAAMA,EACxBlC,KAAKqB,GAAGc,KACN,IAAIC,EACFC,KAAKC,SAAWtC,KAAKyB,OAAOd,MAC5B0B,KAAKC,SAAWtC,KAAKyB,OAAOb,SAOlCZ,KAAKuC,UAGL,MAAMC,EAAI,IAAIC,EAEdD,EAAEE,UAAU,GACZF,EAAEE,UAAU,GACZF,EAAEE,UAAU,GACZF,EAAEE,UAAU,GACZF,EAAEE,UAAU,GAEZF,EAAEG,QAAQ,EAAG,EAAG,GAChBH,EAAEG,QAAQ,EAAG,EAAG,GAChBH,EAAEG,QAAQ,EAAG,EAAG,GAChBH,EAAEG,QAAQ,EAAG,EAAG,GAChBH,EAAEG,QAAQ,EAAG,EAAG,GAChBH,EAAEG,QAAQ,EAAG,EAAG,GAChBH,EAAEG,QAAQ,EAAG,EAAG,GAEJH,EAAEI,QAAQ,GAOtB5C,KAAK6C,OACP,CACOC,UAAUC,EAAWC,GAC1B,MAAMC,EAAK,IAAIC,EAAAA,GAASH,EAAGC,GAE3B,IAAK,IAAId,EAAI,EAAGA,EAAIlC,KAAKqB,GAAG8B,SAAUjB,EAAG,CAGvC,GAFYlC,KAAKqB,GAAGa,GAAGkB,IAAIC,SAASJ,GAE1B,EAER,YADAjD,KAAKsB,OAAStB,KAAKqB,GAAGa,GAG1B,CAGF,CACOoB,UAAUP,EAAWC,GAEtBhD,KAAKsB,SACPtB,KAAKsB,OAAO8B,IAAIL,EAAIA,EACpB/C,KAAKsB,OAAO8B,IAAIJ,EAAIA,EACpBhD,KAAKuC,UAET,CACOgB,QAAQR,EAAWC,GACxBhD,KAAKsB,YAASC,CAChB,CACOiC,WAAWT,EAAWC,GAC3BhD,KAAKqB,GAAGc,KAAK,IAAIC,EAAMW,EAAGC,IAC1BhD,KAAKuC,SACP,CACOA,UACLvC,KAAKoB,SAAW,IAAIqC,EAAAA,GAASzD,KAAKqB,GAAGqC,KAAKC,GAAMA,EAAEP,MACpD,CACOQ,OAAOC,GAKZ7D,KAAKoB,SAAS0C,aAAaD,GAE3B7D,KAAKqB,GAAG0C,SAASJ,IACfA,EAAEC,OAAOC,EAAI,IAGf,IAAIG,EAAS,GACb,IAAK,IAAI9B,EAAI,EAAGA,EAAIlC,KAAKqB,GAAG8B,SAAUjB,EACpC8B,EAAO7B,KAAK,CAACnC,KAAKqB,GAAGa,GAAGkB,IAAIL,EAAG/C,KAAKqB,GAAGa,GAAGkB,IAAIJ,IAGhD,IAAIiB,EAAQC,IAAWlE,KAAKwB,EAAGwC,GAE/B,IAAK,IAAI9B,EAAI,EAAGA,EAAI+B,EAAMd,SAAUjB,EAAG,CACrC,MAAMiC,EAAMF,EAAM/B,GAAG,GACfkC,EAAMH,EAAM/B,GAAG,GAGrB2B,EAAIQ,YAEJR,EAAIS,OAAOtE,KAAKqB,GAAG8C,GAAKf,IAAIL,EAAG/C,KAAKqB,GAAG8C,GAAKf,IAAIJ,GAChDa,EAAIU,OAAOvE,KAAKqB,GAAG+C,GAAKhB,IAAIL,EAAG/C,KAAKqB,GAAG+C,GAAKhB,IAAIJ,GAChDa,EAAIW,YAAc,OAClBX,EAAIY,SAEJZ,EAAIa,UAAY,yBAChBb,EAAIc,MACN,CACF,EAGF,MAAMvC,EAEJxC,YAAYmD,EAAGC,GAAW,IAAR4B,EAAC,uDAAG,EAAC,KADhBxB,SAAG,EAERpD,KAAKoD,IAAM,IAAIF,EAAAA,GAASH,EAAGC,EAAG4B,EAChC,CACOhB,OAAOC,GACZA,EAAIa,UAAY,OAChBb,EAAIQ,YACJR,EAAIgB,IAAI7E,KAAKoD,IAAIL,EAAG/C,KAAKoD,IAAIJ,EAAG,EAAG,EAAa,EAAVX,KAAKyC,IAC3CjB,EAAIkB,YACJlB,EAAIc,MACN,EAGF,MAAMlC,EAGJ7C,cAAe,KAFfoF,cAAQ,OACRC,WAAK,EAEHjF,KAAKgF,SAAW,GAChBhF,KAAKiF,MAAQ,EACf,CACAvC,UAAUwC,GACRlF,KAAKgF,SAAS7C,KAAK+C,EACrB,CAEAvC,QAAQwC,EAASC,EAASC,GACxBrF,KAAKiF,MAAM9C,KAAK,CAAEgD,UAASC,UAASC,UACtC,CAEAzC,QAAQ0C,GACN,MAAMC,EAAU,CAAC,EACXC,EAAM,GAIZ,IAFAD,EAAQD,IAAe,EAEhBE,EAAIrC,OAASnD,KAAKgF,SAAS7B,OAAS,GAAG,CAC5C,IAAIsC,EAAU,KAad,GAXAzF,KAAKiF,MAAMlB,SAAS2B,KAEfH,EAAQG,EAAKP,WAAaI,EAAQG,EAAKN,WACtCG,EAAQG,EAAKP,UAAYI,EAAQG,EAAKN,aAEnCK,GAAWC,EAAKL,OAASI,EAAQJ,UACpCI,EAAUC,EAEd,KAGGD,EACH,MAGFD,EAAIrD,KAAKsD,GACTF,EAAQE,EAAQN,UAAW,EAC3BI,EAAQE,EAAQL,UAAW,CAC7B,CAEA,OAAOI,CACT,EAGF,MAAM5D,EAAY,CAAC+D,EAAeC,EAAaC,KAE7C,MAAMvF,EAAML,SAASM,cAAc,OACnCD,EAAIH,MAAMC,QAAU,OAEpB,MAAMuB,EAAS1B,SAASM,cAAc,SACtCoB,EAAOmE,KAAO,QACdnE,EAAOiE,IAAG,UAAMA,GAChBjE,EAAOkE,IAAG,UAAMA,GAEhB,MAAM7D,EAAO/B,SAASM,cAAc,OAMpC,OALAyB,EAAKC,UAAY0D,EACjB3D,EAAK7B,MAAM4F,MAAQ,OACnBzF,EAAIO,YAAYc,GAChBrB,EAAIO,YAAYmB,GAET,CACL1B,MACAqB,SACAK,OACD,C","sources":["njslab/Tools/AlphaShape/index.ts"],"sourcesContent":["import { Delaunay, NVector3 } from \"../../../lib/NJSCore\";\r\nimport { RendererCanvas } from \"../../../lib\";\r\nimport alphaShape from \"alpha-shape\";\r\n\r\nexport class Solution {\r\n  public divHost: HTMLElement;\r\n  public renderer: Renderer;\r\n  constructor(id: string) {\r\n    this.divHost = document.getElementById(id) as HTMLDivElement;\r\n\r\n    // Center align\r\n    this.divHost.style.display = \"flex\";\r\n    this.divHost.style.alignItems = \"center\";\r\n\r\n    const div = document.createElement(\"div\");\r\n    div.style.marginLeft = \"auto\";\r\n    div.style.marginRight = \"auto\";\r\n    div.style.backgroundColor = \"#555\";\r\n    div.style.width = \"1000px\";\r\n    div.style.height = \"600px\";\r\n\r\n    this.divHost.appendChild(div);\r\n\r\n    // TODO\r\n    // You code goes here for one time operation\r\n\r\n    this.renderer = new Renderer(div);\r\n\r\n    // console.log(this.renderer);\r\n    // !! you should execute it for rendering\r\n    // this.start();\r\n  }\r\n  public destroy() {\r\n    this.renderer.destroy();\r\n    while (this.divHost.lastElementChild) {\r\n      this.divHost.removeChild(this.divHost.lastElementChild);\r\n    }\r\n  }\r\n}\r\n\r\nexport class Renderer extends RendererCanvas {\r\n  delaunay: Delaunay;\r\n  vs: Point[] = [];\r\n  selVec: Point | undefined = undefined;\r\n  N = 0.01;\r\n  constructor(div: any) {\r\n    super(div);\r\n    this.canvas.style.position = \"relative\";\r\n    this.canvas.style.width = \"100%\";\r\n    this.canvas.style.height = \"100%\";\r\n\r\n    // TODO\r\n    // You code goes here for one time operation\r\n    //\r\n\r\n    const slider = getSlider(\"alpha\", 1, 1000);\r\n    slider.slider.defaultValue = `${this.N}`;\r\n    this.divHost.appendChild(slider.div);\r\n    slider.slider.oninput = () => {\r\n      this.N = +slider.slider.value / 100000;\r\n      // console.log(slider.slider.value)\r\n      slider.text.innerText = \"alpha: \" + this.N;\r\n    };\r\n\r\n    this.vs = [];\r\n    for (let i = 0; i < 15; ++i) {\r\n      this.vs.push(\r\n        new Point(\r\n          Math.random() * this.canvas.width,\r\n          Math.random() * this.canvas.height\r\n        )\r\n      );\r\n    }\r\n\r\n    // console.log(this.vs)\r\n\r\n    this.compute();\r\n\r\n    // Example Usage\r\n    const g = new Graph();\r\n\r\n    g.addVertex(0);\r\n    g.addVertex(1);\r\n    g.addVertex(2);\r\n    g.addVertex(3);\r\n    g.addVertex(4);\r\n\r\n    g.addEdge(0, 1, 2);\r\n    g.addEdge(0, 3, 6);\r\n    g.addEdge(1, 2, 3);\r\n    g.addEdge(1, 3, 8);\r\n    g.addEdge(1, 4, 5);\r\n    g.addEdge(2, 4, 7);\r\n    g.addEdge(3, 4, 9);\r\n\r\n    const MST = g.primMST(0);\r\n\r\n    // console.log(\"Minimum Spanning Tree:\");\r\n    // MST.forEach((edge) => {\r\n    //   console.log(`${edge.vertex1} - ${edge.vertex2} : ${edge.weight}`);\r\n    // });\r\n\r\n    this.start();\r\n  }\r\n  public mouseDown(x: number, y: number): void {\r\n    const mv = new NVector3(x, y);\r\n\r\n    for (let i = 0; i < this.vs.length; ++i) {\r\n      const dis = this.vs[i].vec.Distance(mv);\r\n      // console.log(dis)\r\n      if (dis < 6) {\r\n        this.selVec = this.vs[i];\r\n        return;\r\n      }\r\n    }\r\n\r\n    // this.selVec = undefined;\r\n  }\r\n  public mouseDrag(x: number, y: number): void {\r\n    // console.log(this.selVec)\r\n    if (this.selVec) {\r\n      this.selVec.vec.x = x;\r\n      this.selVec.vec.y = y;\r\n      this.compute();\r\n    }\r\n  }\r\n  public mouseUp(x: number, y: number): void {\r\n    this.selVec = undefined;\r\n  }\r\n  public mouseClick(x: number, y: number): void {\r\n    this.vs.push(new Point(x, y));\r\n    this.compute();\r\n  }\r\n  public compute() {\r\n    this.delaunay = new Delaunay(this.vs.map((v) => v.vec));\r\n  }\r\n  public render(ctx: CanvasRenderingContext2D): void {\r\n    // TODO\r\n    // You code goes here for the rending loop\r\n\r\n    // this.delaunay = new Delaunay(this.vs);\r\n    this.delaunay.DrawTriClass(ctx);\r\n\r\n    this.vs.forEach((v) => {\r\n      v.render(ctx);\r\n    });\r\n\r\n    let points = [];\r\n    for (let i = 0; i < this.vs.length; ++i) {\r\n      points.push([this.vs[i].vec.x, this.vs[i].vec.y]);\r\n    }\r\n\r\n    let cells = alphaShape(this.N, points);\r\n\r\n    for (let i = 0; i < cells.length; ++i) {\r\n      const idA = cells[i][0];\r\n      const idB = cells[i][1];\r\n      // console.log(idA, idB)\r\n\r\n      ctx.beginPath();\r\n\r\n      ctx.moveTo(this.vs[idA].vec.x, this.vs[idA].vec.y);\r\n      ctx.lineTo(this.vs[idB].vec.x, this.vs[idB].vec.y);\r\n      ctx.strokeStyle = \"#ff0\";\r\n      ctx.stroke();\r\n\r\n      ctx.fillStyle = \"rgba(255, 255, 0, 0.3)\";\r\n      ctx.fill();\r\n    }\r\n  }\r\n}\r\n\r\nclass Point {\r\n  public vec: NVector3;\r\n  constructor(x, y, z = 0) {\r\n    this.vec = new NVector3(x, y, z);\r\n  }\r\n  public render(ctx) {\r\n    ctx.fillStyle = \"#f00\";\r\n    ctx.beginPath();\r\n    ctx.arc(this.vec.x, this.vec.y, 6, 0, Math.PI * 2);\r\n    ctx.closePath();\r\n    ctx.fill();\r\n  }\r\n}\r\n\r\nclass Graph {\r\n  vertices;\r\n  edges;\r\n  constructor() {\r\n    this.vertices = [];\r\n    this.edges = [];\r\n  }\r\n  addVertex(vertex) {\r\n    this.vertices.push(vertex);\r\n  }\r\n\r\n  addEdge(vertex1, vertex2, weight) {\r\n    this.edges.push({ vertex1, vertex2, weight });\r\n  }\r\n\r\n  primMST(startVertex) {\r\n    const visited = {};\r\n    const MST = [];\r\n\r\n    visited[startVertex] = true;\r\n\r\n    while (MST.length < this.vertices.length - 1) {\r\n      let minEdge = null;\r\n\r\n      this.edges.forEach((edge) => {\r\n        if (\r\n          (visited[edge.vertex1] && !visited[edge.vertex2]) ||\r\n          (!visited[edge.vertex1] && visited[edge.vertex2])\r\n        ) {\r\n          if (!minEdge || edge.weight < minEdge.weight) {\r\n            minEdge = edge;\r\n          }\r\n        }\r\n      });\r\n\r\n      if (!minEdge) {\r\n        break;\r\n      }\r\n\r\n      MST.push(minEdge);\r\n      visited[minEdge.vertex1] = true;\r\n      visited[minEdge.vertex2] = true;\r\n    }\r\n\r\n    return MST;\r\n  }\r\n}\r\n\r\nconst getSlider = (title: string, min: number, max: number) => {\r\n  // <input type=\"range\" min=\"1\" max=\"100\" value=\"50\" class=\"slider\" id=\"myRange\">\r\n  const div = document.createElement(\"div\");\r\n  div.style.display = \"flex\";\r\n\r\n  const slider = document.createElement(\"input\");\r\n  slider.type = \"range\";\r\n  slider.min = `${min}`;\r\n  slider.max = `${max}`;\r\n\r\n  const text = document.createElement(\"div\");\r\n  text.innerText = title;\r\n  text.style.color = \"#aaa\";\r\n  div.appendChild(slider);\r\n  div.appendChild(text);\r\n\r\n  return {\r\n    div,\r\n    slider,\r\n    text,\r\n  };\r\n};\r\n\r\nfunction isClockwise(points) {\r\n  let sum = 0;\r\n  for (let i = 0; i < points.length; i++) {\r\n    const p1 = points[i];\r\n    const p2 = points[(i + 1) % points.length];\r\n    sum += (p2.x - p1.x) * (p2.y + p1.y);\r\n  }\r\n  return sum > 0; // 양수면 시계 방향\r\n}\r\n\r\nfunction fixPolygon(points) {\r\n  // 시계 방향이면 반대로 뒤집기\r\n  if (isClockwise(points)) {\r\n    return points.reverse();\r\n  }\r\n  return points;\r\n}\r\n\r\nfunction splitPolygons(points, maxDistance) {\r\n  const polygons = [];\r\n  let currentPolygon = [];\r\n\r\n  for (let i = 0; i < points.length; i++) {\r\n    const currentPoint = points[i];\r\n    const prevPoint = currentPolygon[currentPolygon.length - 1];\r\n\r\n    // 이전 점과 현재 점 사이의 거리가 충분히 크면 새로운 폴리곤 시작\r\n    if (\r\n      currentPolygon.length > 0 &&\r\n      calculateDistance(prevPoint, currentPoint) > maxDistance\r\n    ) {\r\n      polygons.push(currentPolygon);\r\n      currentPolygon = [];\r\n    }\r\n\r\n    currentPolygon.push(currentPoint);\r\n  }\r\n\r\n  // 마지막 폴리곤도 추가\r\n  if (currentPolygon.length > 0) {\r\n    polygons.push(currentPolygon);\r\n  }\r\n\r\n  return polygons;\r\n}\r\nfunction calculateDistance(pointA, pointB) {\r\n  return Math.sqrt(\r\n    Math.pow(pointA.x - pointB.x, 2) + Math.pow(pointA.y - pointB.y, 2)\r\n  );\r\n}\r\n\r\n// DFS(깊이 우선 탐색)으로 연결된 컴포넌트 찾기\r\nfunction findConnectedComponents(points, adjacencyMatrix) {\r\n  const visited = new Array(points.length).fill(false);\r\n  const components = [];\r\n\r\n  function dfs(index, currentComponent) {\r\n    visited[index] = true;\r\n    currentComponent.push(points[index]);\r\n\r\n    // 인접한 점을 탐색\r\n    for (let i = 0; i < points.length; i++) {\r\n      if (adjacencyMatrix[index][i] && !visited[i]) {\r\n        dfs(i, currentComponent);\r\n      }\r\n    }\r\n  }\r\n\r\n  for (let i = 0; i < points.length; i++) {\r\n    if (!visited[i]) {\r\n      const component = [];\r\n      dfs(i, component);\r\n      components.push(component);\r\n    }\r\n  }\r\n\r\n  return components;\r\n}\r\n"],"names":["Solution","constructor","id","divHost","renderer","this","document","getElementById","style","display","alignItems","div","createElement","marginLeft","marginRight","backgroundColor","width","height","appendChild","Renderer","destroy","lastElementChild","removeChild","RendererCanvas","super","delaunay","vs","selVec","undefined","N","canvas","position","slider","getSlider","defaultValue","oninput","value","text","innerText","i","push","Point","Math","random","compute","g","Graph","addVertex","addEdge","primMST","start","mouseDown","x","y","mv","NVector3","length","vec","Distance","mouseDrag","mouseUp","mouseClick","Delaunay","map","v","render","ctx","DrawTriClass","forEach","points","cells","alphaShape","idA","idB","beginPath","moveTo","lineTo","strokeStyle","stroke","fillStyle","fill","z","arc","PI","closePath","vertices","edges","vertex","vertex1","vertex2","weight","startVertex","visited","MST","minEdge","edge","title","min","max","type","color"],"sourceRoot":""}