{"version":3,"file":"static/js/3012.b01bb093.chunk.js","mappings":"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","sources":["njslab/Project/Project_03_SlowZone/LineStripeInteraction/index.ts"],"sourcesContent":["import * as THREE from 'three';\r\nimport { RendererThree, MercatorProjection, } from '../../../../lib';\r\nimport { getJSONFromURL, getColorByCelsius } from 'njscore';\r\n\r\nimport { FilterGLViewDarkForDarken } from '../01_JSAPI/Tint/FilterGLViewDarkForDarken';\r\n\r\nexport class Solution extends RendererThree {\r\n\r\n    streetOSM: any = [];\r\n    routesTreated: any = [];\r\n    routesControl: any = [];\r\n    zones30: any = [];\r\n\r\n    meshStreet: THREE.LineSegments;\r\n    meshSpike: THREE.LineSegments;\r\n\r\n    raycaster = new THREE.Raycaster();\r\n    pointer = new THREE.Vector2();\r\n    sphere: THREE.Mesh;\r\n\r\n    constructor(id: string = 'main') {\r\n        super(id)\r\n\r\n        const light = new THREE.PointLight(0xffffff, 0.8);\r\n        this.camera.add(light);\r\n        this.scene.add(light);\r\n\r\n        // const canvasGL = document.createElement('canvas');\r\n        // canvasGL.style.position = 'absolute';\r\n        // canvasGL.style.pointerEvents = 'none';\r\n        // canvasGL.style.mixBlendMode = 'darken';\r\n        // canvasGL.width = this.hostDiv.clientWidth;\r\n        // canvasGL.height = this.hostDiv.clientHeight;\r\n        // this.hostDiv.appendChild(canvasGL);\r\n        // const glCtx = canvasGL.getContext('webgl');\r\n        // const d = new FilterGLViewDarkForDarken(glCtx, 0.5, 5)\r\n        // d.Render(glCtx);\r\n\r\n\r\n        this.raycaster = new THREE.Raycaster();\r\n        this.raycaster.params.Line.threshold = 3;\r\n        this.raycaster.far = 1000;\r\n\r\n        const sphereGeometry = new THREE.SphereGeometry(0.2, 32, 32);\r\n        const sphereMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff });\r\n        const sphere = new THREE.Mesh(sphereGeometry, sphereMaterial);\r\n        this.sphere = sphere;\r\n        this.scene.add(sphere);\r\n\r\n        this.camera.position.set(0, 20, 20);\r\n\r\n        const path = '/static/research/slow-zone/';\r\n        getJSONFromURL(process.env.PUBLIC_URL + path + 'street_osm.geojson').then((data) => {\r\n            for (let i = 0; i < data['features'].length; ++i) {\r\n                this.streetOSM.push(data['features'][i]['geometry']['coordinates']);\r\n            }\r\n            this.meshStreet = renderLines(this.scene, this.streetOSM, [0, 1, 1]);\r\n            // renderPoints(this.scene, this.streetOSM, [0, 1, 1]);\r\n\r\n\r\n            getJSONFromURL(process.env.PUBLIC_URL + path + 'treated-st.geojson').then((data) => {\r\n                for (let i = 0; i < data['features'].length; ++i) {\r\n                    this.routesTreated.push(data['features'][i]['geometry']['coordinates']);\r\n                }\r\n                // renderLines(this.scene, this.routesTreated, [1, 0, 0]);\r\n                this.meshSpike = renderLinesSpike(this.scene, this.routesTreated, [1, 0, 0]);\r\n            });\r\n\r\n            getJSONFromURL(process.env.PUBLIC_URL + path + 'control-st.geojson').then((data) => {\r\n                for (let i = 0; i < data['features'].length; ++i) {\r\n                    this.routesControl.push(data['features'][i]['geometry']['coordinates']);\r\n                }\r\n                renderLines(this.scene, this.routesControl, [0, 1, 0]);\r\n            });\r\n\r\n\r\n\r\n            this.start();\r\n        });\r\n    }\r\n\r\n    public update(scene: THREE.Scene) {\r\n        // console.log('dddd');\r\n        this.raycaster.setFromCamera(this.pointer, this.camera);\r\n        const intersects = this.raycaster.intersectObjects([this.meshStreet, this.meshSpike], true);\r\n\r\n        if (intersects.length > 0) {\r\n            this.sphere.visible = true;\r\n            this.sphere.position.copy(intersects[0].point);\r\n        } else {\r\n\r\n            this.sphere.visible = false;\r\n        }\r\n\r\n\r\n        for (let i = 1; i < this.meshSpike.geometry.attributes.position.count; i += 2) {\r\n            let p = this.meshSpike.geometry.attributes.position;\r\n\r\n            let x = p.getX(i);\r\n            let y = p.getY(i);\r\n            let z = p.getZ(i)\r\n\r\n            y = Math.sin(5 * x * z + this.t * 5) * 9\r\n\r\n            y = y < 0 ? 0 : y;\r\n\r\n            let np = new THREE.Vector3(x, y, z);\r\n            this.meshSpike.geometry.attributes.position.setXYZ(i, np.x, np.y, np.z);\r\n\r\n\r\n            const col = getColorByCelsius(y * 40)\r\n            // console.log(col)\r\n\r\n            // this.meshSpike.geometry.attributes.color.setXYZ(i -1, col[0] /255, col[1] /255, col[2] /255);\r\n            // this.meshSpike.geometry.attributes.color.setXYZ(i,    col[0] /255, col[1] /255, col[2] /255);\r\n\r\n            this.meshSpike.geometry.attributes.color.setXYZ(i -1, 0, y, 0);\r\n            this.meshSpike.geometry.attributes.color.setXYZ(i,    y, 0, 0);\r\n        }\r\n\r\n        this.meshSpike.geometry.attributes.position.needsUpdate = true;\r\n        this.meshSpike.geometry.attributes.color.needsUpdate = true;\r\n        this.meshSpike.geometry.computeVertexNormals();\r\n\r\n\r\n    }\r\n    public mouseMove(e: MouseEvent): void {\r\n        // console.log(e)\r\n        this.pointer.x = ((e.offsetX + 2) / this.hostDiv.clientWidth) * 2 - 1;\r\n        this.pointer.y = - ((e.offsetY - 70) / this.hostDiv.clientHeight) * 2 + 1;\r\n    }\r\n}\r\n\r\n\r\nconst renderPoints = (scene: THREE.Scene, paths: any, color: number[]) => {\r\n    const geometry = new THREE.BufferGeometry();\r\n    const material = new THREE.PointsMaterial({ vertexColors: true, size: 0.5 });\r\n\r\n    const positions = [];\r\n    const colors = [];\r\n\r\n\r\n    const xOFf = -15478803.88731685;\r\n    const yOFf = -4766681.448690384;\r\n    const scale = 0.01;\r\n\r\n\r\n    for (let i = 0; i < paths.length; ++i) {\r\n        const route = paths[i]\r\n\r\n        for (let j = 0; j < route.length; ++j) {\r\n            for (let k = 0; k < route[j].length; ++k) {\r\n\r\n                const [xPro, yPro] = MercatorProjection(route[j][k][0], route[j][k][1]);\r\n\r\n                const x = (xPro + xOFf) * scale\r\n                const y = (yPro + yOFf) * scale\r\n\r\n                positions.push(x, 0, y)\r\n\r\n                colors.push(color[0], color[1], color[2]);\r\n\r\n\r\n            }\r\n        }\r\n    }\r\n\r\n    geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));\r\n    geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));\r\n    // generateMorphTargets( geometry );\r\n\r\n    geometry.computeBoundingSphere();\r\n\r\n    const line = new THREE.Points(geometry, material);\r\n    scene.add(line);\r\n\r\n\r\n}\r\nconst renderLinesSpike = (scene: THREE.Scene, paths: any, color: number[]) => {\r\n    const geometry = new THREE.BufferGeometry();\r\n    // const material = new THREE.PointsMaterial( { vertexColors: true, size: 0.1 } );\r\n    const material = new THREE.LineBasicMaterial({ vertexColors: true });\r\n\r\n    const positions = [];\r\n    const colors = [];\r\n    const indices = [];\r\n\r\n    const xOFf = -15478803.88731685;\r\n    const yOFf = -4766681.448690384;\r\n    const scale = 0.01;\r\n\r\n\r\n    let xC = 0\r\n    let yC = 0\r\n    let Count = 0\r\n\r\n    for (let i = 0; i < paths.length; ++i) {\r\n        const route = paths[i]\r\n\r\n        for (let j = 0; j < route.length; ++j) {\r\n            for (let k = 0; k < route[j].length; ++k) {\r\n\r\n                const [xPro, yPro] = MercatorProjection(route[j][k][0], route[j][k][1]);\r\n                xC += xPro;\r\n                yC += yPro;\r\n                Count += 1;\r\n\r\n                const x = (xPro + xOFf) * scale\r\n                const y = (yPro + yOFf) * scale\r\n                // console.log(x, y)\r\n                positions.push(x, 0, y)\r\n                positions.push(x, 10, y)\r\n\r\n                colors.push(color[0], color[1], color[2]);\r\n                colors.push(color[0], color[1], color[2]);\r\n\r\n                // if (k < route[j].length - 1) {\r\n                //     indices.push(Math.floor(positions.length / 3) - 1, Math.floor(positions.length / 3));\r\n                //     indices.push(Math.floor(positions.length / 3) - 1, Math.floor(positions.length / 3));\r\n                // }\r\n            }\r\n        }\r\n    }\r\n    console.log(xC / Count, yC / Count)\r\n    // geometry.setIndex(indices);\r\n    geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));\r\n    geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));\r\n    // generateMorphTargets( geometry );\r\n\r\n    geometry.computeBoundingSphere();\r\n\r\n    const line = new THREE.LineSegments(geometry, material);\r\n    scene.add(line);\r\n    return line\r\n};\r\n\r\n\r\nconst renderLines = (scene: THREE.Scene, paths: any, color: number[]) => {\r\n\r\n    const geometry = new THREE.BufferGeometry();\r\n    // const material = new THREE.PointsMaterial( { vertexColors: true, size: 0.1 } );\r\n    const material = new THREE.LineBasicMaterial({ vertexColors: true });\r\n\r\n    const positions = [];\r\n    const colors = [];\r\n    const indices = [];\r\n\r\n    const xOFf = -15478803.88731685;\r\n    const yOFf = -4766681.448690384;\r\n    const scale = 0.01;\r\n\r\n\r\n    let xC = 0\r\n    let yC = 0\r\n    let Count = 0\r\n\r\n    for (let i = 0; i < paths.length; ++i) {\r\n        const route = paths[i]\r\n\r\n        for (let j = 0; j < route.length; ++j) {\r\n            for (let k = 0; k < route[j].length; ++k) {\r\n\r\n                const [xPro, yPro] = MercatorProjection(route[j][k][0], route[j][k][1]);\r\n                xC += xPro;\r\n                yC += yPro;\r\n                Count += 1;\r\n\r\n                const x = (xPro + xOFf) * scale\r\n                const y = (yPro + yOFf) * scale\r\n                // console.log(x, y)\r\n                positions.push(x, 0, y)\r\n\r\n                colors.push(color[0], color[1], color[2]);\r\n\r\n                if (k < route[j].length - 1) {\r\n                    indices.push(Math.floor(positions.length / 3) - 1, Math.floor(positions.length / 3));\r\n                }\r\n            }\r\n        }\r\n    }\r\n    console.log(xC / Count, yC / Count)\r\n    geometry.setIndex(indices);\r\n    geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));\r\n    geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));\r\n    // generateMorphTargets( geometry );\r\n\r\n    geometry.computeBoundingSphere();\r\n\r\n    const line = new THREE.LineSegments(geometry, material);\r\n    scene.add(line);\r\n    return line\r\n};"],"names":["Solution","id","streetOSM","routesTreated","routesControl","zones30","meshStreet","meshSpike","raycaster","THREE","pointer","sphere","light","camera","add","scene","params","Line","threshold","far","sphereGeometry","sphereMaterial","color","position","set","path","getJSONFromURL","process","then","data","i","length","push","renderLines","renderLinesSpike","start","this","setFromCamera","intersects","intersectObjects","visible","copy","point","geometry","attributes","count","p","x","getX","y","getY","z","getZ","Math","sin","t","np","setXYZ","getColorByCelsius","needsUpdate","computeVertexNormals","e","offsetX","hostDiv","clientWidth","offsetY","clientHeight","RendererThree","paths","material","vertexColors","positions","colors","xC","yC","Count","route","j","k","MercatorProjection","xPro","yPro","console","log","setAttribute","computeBoundingSphere","line","indices","floor","setIndex"],"sourceRoot":""}