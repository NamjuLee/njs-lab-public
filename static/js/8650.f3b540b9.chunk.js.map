{"version":3,"file":"static/js/8650.f3b540b9.chunk.js","mappings":"kNAIaA,EAAQ,0CAYjB,aAAkC,IAAD,EAArBC,EAAU,uDAAG,QAAM,gBAC3B,cAAMA,IAXVC,gBAAU,IAEVC,QAAU,IAAIC,EAAAA,IAAgB,EAC9BC,UAAY,IAAID,EAAAA,IAAkB,EAClCE,YAAM,IAENC,UAAI,IAEJC,IAAuB,GAInB,IAAMC,EAAQ,EAAKA,MAEnB,EAAKJ,UAAY,IAAID,EAAAA,IACrB,EAAKC,UAAUK,OAAOC,OAAOC,UAAY,GACzC,EAAKP,UAAUQ,IAAM,IAErB,IAAMC,EAAiB,IAAIV,EAAAA,IAAqB,GAAK,GAAI,IACnDW,EAAiB,IAAIX,EAAAA,IAAwB,CAAEY,MAAO,WACtDV,EAAS,IAAIF,EAAAA,IAAWU,EAAgBC,GAC9C,EAAKT,OAASA,EACd,EAAKG,MAAMQ,IAAIX,GAGf,EAAKY,OAAOC,SAASC,IAAI,EAAG,GAAI,IAEhC,IAAMC,EAAe,IAAIjB,EAAAA,IAAmB,SAAU,KACtD,EAAKK,MAAMQ,IAAII,GAEf,EAAKnB,WAAa,IAAIE,EAAAA,IAAiB,SAAU,KACjD,EAAKF,WAAWiB,SAASG,EAAI,GAC7B,EAAKpB,WAAWiB,SAASI,EAAI,GAC7B,EAAKrB,WAAWsB,YAAa,EAC7B,EAAKf,MAAMQ,IAAI,EAAKf,YAGpB,IADA,IAAMuB,EAAW,GACRC,EAAI,EAAGA,EAAI,EAAGA,IAAO,CAC1B,IAAMJ,EAAII,EACJH,EAAI,EACJI,EAAI,EACVF,EAASG,KAAMN,EAAGC,EAAGI,GACrB,EAAKnB,IAAIoB,KAAK,IAAIxB,EAAAA,IAAckB,EAAGC,EAAGI,GAC1C,CAEA,IAAME,EAAW,IAAIzB,EAAAA,IACrByB,EAASC,aAAc,WAAY,IAAI1B,EAAAA,IAA8BqB,EAAU,IAE/E,IAAMM,EAAW,IAAI3B,EAAAA,IAAsB,CAAEY,MAAO,QAC9CgB,EAAS,IAAI5B,EAAAA,IAAcyB,EAAUE,GAK9B,OAJbtB,EAAMQ,IAAKe,GAEX,EAAKzB,KAAOyB,EAEZ,EAAKC,QAAQ,CACjB,CAqBC,OArBA,iCACD,SAAiBC,GACbC,KAAKhC,QAAQmB,EAAKY,EAAEE,QAAUD,KAAKE,QAAQC,YAAe,EAAI,EAC9DH,KAAKhC,QAAQoB,GAAOW,EAAEK,QAAUJ,KAAKE,QAAQG,aAAgB,EAAI,CACrE,GAAC,oBACD,SAAc/B,GACV,IAAIgC,EAAS,IAAIrC,EAAAA,IACjBqC,EAAOC,cAAwB,KAAVC,KAAKC,IAC1BT,KAAKjC,WAAWiB,SAAS0B,aAAaJ,GAEtCN,KAAK9B,UAAUyC,cAAcX,KAAKhC,QAASgC,KAAKjB,QAChD,IAAM6B,EAAgBZ,KAAK9B,UAAU2C,iBAAiB,CAACb,KAAK5B,OAAO,GAC7D0C,EAAgBF,EAAcG,OAAU,EAAIH,EAAc,GAAK,KAEhD,OAAjBE,GAGAd,KAAK7B,OAAOa,SAASC,IAAI6B,EAAaE,MAAM7B,EAAG2B,EAAaE,MAAM5B,EAAG0B,EAAaE,MAAMxB,EAIhG,KAAC,EA9EgB,C,SAASyB,G","sources":["njslab/Workshop/workshop-three/LAB_Web_03_PointIndex/index.ts"],"sourcesContent":["import * as THREE from 'three';\r\nimport { RendererThree, getCSVFromURL } from '../../../../lib';\r\n\r\n\r\nexport class Solution extends RendererThree {\r\n\r\n    pointLight: THREE.PointLight;\r\n\r\n    pointer = new THREE.Vector2();\r\n    raycaster = new THREE.Raycaster();\r\n    sphere: THREE.Mesh;\r\n\r\n    mesh: THREE.Points;\r\n\r\n    vex: THREE.Vector3[] = [];\r\n\r\n    constructor(id: string = 'main') {\r\n        super(id)\r\n        const scene = this.scene;\r\n\r\n        this.raycaster = new THREE.Raycaster();\r\n        this.raycaster.params.Points.threshold = 0.8;\r\n        this.raycaster.far = 1000;\r\n\r\n        const sphereGeometry = new THREE.SphereGeometry(0.1, 32, 32);\r\n        const sphereMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff });\r\n        const sphere = new THREE.Mesh(sphereGeometry, sphereMaterial);\r\n        this.sphere = sphere;\r\n        this.scene.add(sphere);\r\n\r\n\r\n        this.camera.position.set(0, 50, 50);\r\n\r\n        const ambientLight = new THREE.AmbientLight(0xcccccc, 0.25);\r\n        this.scene.add(ambientLight);\r\n\r\n        this.pointLight = new THREE.PointLight(0xffffff, 0.75);\r\n        this.pointLight.position.x = 10;\r\n        this.pointLight.position.y = 10;\r\n        this.pointLight.castShadow = true;\r\n        this.scene.add(this.pointLight);\r\n\r\n        const vertices = [];\r\n        for( let i = 0; i < 2; i ++ ) {\r\n            const x = i;\r\n            const y = 0;\r\n            const z = 0;\r\n            vertices.push( x, y, z );\r\n            this.vex.push(new THREE.Vector3(x, y, z))\r\n        }\r\n        \r\n        const geometry = new THREE.BufferGeometry();\r\n        geometry.setAttribute( 'position', new THREE.Float32BufferAttribute( vertices, 3 ) );\r\n        // geometry.setAttribute( '', new THREE.Float32BufferAttribute( vertices, 3 ) );\r\n        const material = new THREE.PointsMaterial( { color: 0x00fff0 } );\r\n        const points = new THREE.Points( geometry, material );\r\n        scene.add( points );\r\n\r\n        this.mesh = points;\r\n\r\n        this.start();\r\n    }\r\n    public mouseMove(e: MouseEvent): void {\r\n        this.pointer.x = (e.offsetX / this.hostDiv.clientWidth) * 2 - 1;\r\n        this.pointer.y = - (e.offsetY / this.hostDiv.clientHeight) * 2 + 1;\r\n    }\r\n    public update(scene: THREE.Scene) {\r\n        let matrix = new THREE.Matrix4();\r\n        matrix.makeRotationY(Math.PI * 0.011);\r\n        this.pointLight.position.applyMatrix4(matrix);\r\n\r\n        this.raycaster.setFromCamera(this.pointer, this.camera);\r\n        const intersections = this.raycaster.intersectObjects([this.mesh], false);\r\n        const intersection = (intersections.length) > 0 ? intersections[0] : null;\r\n\r\n        if (intersection !== null) {\r\n            // console.log(intersection);\r\n            // console.log( intersection.index, intersection.object.id);\r\n            this.sphere.position.set(intersection.point.x, intersection.point.y, intersection.point.z);\r\n\r\n            // console.log(this.vex[intersection.index]);\r\n        }\r\n    }\r\n}\r\n"],"names":["Solution","id","pointLight","pointer","THREE","raycaster","sphere","mesh","vex","scene","params","Points","threshold","far","sphereGeometry","sphereMaterial","color","add","camera","position","set","ambientLight","x","y","castShadow","vertices","i","z","push","geometry","setAttribute","material","points","start","e","this","offsetX","hostDiv","clientWidth","offsetY","clientHeight","matrix","makeRotationY","Math","PI","applyMatrix4","setFromCamera","intersections","intersectObjects","intersection","length","point","RendererThree"],"sourceRoot":""}