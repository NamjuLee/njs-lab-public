{"version":3,"file":"static/js/99056.ef4e2e96.chunk.js","mappings":"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","sources":["../node_modules/polygon-clipping/dist/polygon-clipping.umd.js"],"sourcesContent":["(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :\n  typeof define === 'function' && define.amd ? define(factory) :\n  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, global.polygonClipping = factory());\n}(this, (function () { 'use strict';\n\n  function _classCallCheck(instance, Constructor) {\n    if (!(instance instanceof Constructor)) {\n      throw new TypeError(\"Cannot call a class as a function\");\n    }\n  }\n\n  function _defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  function _createClass(Constructor, protoProps, staticProps) {\n    if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) _defineProperties(Constructor, staticProps);\n    return Constructor;\n  }\n\n  /**\n   * splaytree v3.1.0\n   * Fast Splay tree for Node and browser\n   *\n   * @author Alexander Milevski <info@w8r.name>\n   * @license MIT\n   * @preserve\n   */\n  var Node =\n  /** @class */\n  function () {\n    function Node(key, data) {\n      this.next = null;\n      this.key = key;\n      this.data = data;\n      this.left = null;\n      this.right = null;\n    }\n\n    return Node;\n  }();\n  /* follows \"An implementation of top-down splaying\"\r\n   * by D. Sleator <sleator@cs.cmu.edu> March 1992\r\n   */\n\n\n  function DEFAULT_COMPARE(a, b) {\n    return a > b ? 1 : a < b ? -1 : 0;\n  }\n  /**\r\n   * Simple top down splay, not requiring i to be in the tree t.\r\n   */\n\n\n  function splay(i, t, comparator) {\n    var N = new Node(null, null);\n    var l = N;\n    var r = N;\n\n    while (true) {\n      var cmp = comparator(i, t.key); //if (i < t.key) {\n\n      if (cmp < 0) {\n        if (t.left === null) break; //if (i < t.left.key) {\n\n        if (comparator(i, t.left.key) < 0) {\n          var y = t.left;\n          /* rotate right */\n\n          t.left = y.right;\n          y.right = t;\n          t = y;\n          if (t.left === null) break;\n        }\n\n        r.left = t;\n        /* link right */\n\n        r = t;\n        t = t.left; //} else if (i > t.key) {\n      } else if (cmp > 0) {\n        if (t.right === null) break; //if (i > t.right.key) {\n\n        if (comparator(i, t.right.key) > 0) {\n          var y = t.right;\n          /* rotate left */\n\n          t.right = y.left;\n          y.left = t;\n          t = y;\n          if (t.right === null) break;\n        }\n\n        l.right = t;\n        /* link left */\n\n        l = t;\n        t = t.right;\n      } else break;\n    }\n    /* assemble */\n\n\n    l.right = t.left;\n    r.left = t.right;\n    t.left = N.right;\n    t.right = N.left;\n    return t;\n  }\n\n  function insert(i, data, t, comparator) {\n    var node = new Node(i, data);\n\n    if (t === null) {\n      node.left = node.right = null;\n      return node;\n    }\n\n    t = splay(i, t, comparator);\n    var cmp = comparator(i, t.key);\n\n    if (cmp < 0) {\n      node.left = t.left;\n      node.right = t;\n      t.left = null;\n    } else if (cmp >= 0) {\n      node.right = t.right;\n      node.left = t;\n      t.right = null;\n    }\n\n    return node;\n  }\n\n  function split(key, v, comparator) {\n    var left = null;\n    var right = null;\n\n    if (v) {\n      v = splay(key, v, comparator);\n      var cmp = comparator(v.key, key);\n\n      if (cmp === 0) {\n        left = v.left;\n        right = v.right;\n      } else if (cmp < 0) {\n        right = v.right;\n        v.right = null;\n        left = v;\n      } else {\n        left = v.left;\n        v.left = null;\n        right = v;\n      }\n    }\n\n    return {\n      left: left,\n      right: right\n    };\n  }\n\n  function merge(left, right, comparator) {\n    if (right === null) return left;\n    if (left === null) return right;\n    right = splay(left.key, right, comparator);\n    right.left = left;\n    return right;\n  }\n  /**\r\n   * Prints level of the tree\r\n   */\n\n\n  function printRow(root, prefix, isTail, out, printNode) {\n    if (root) {\n      out(\"\" + prefix + (isTail ? '└── ' : '├── ') + printNode(root) + \"\\n\");\n      var indent = prefix + (isTail ? '    ' : '│   ');\n      if (root.left) printRow(root.left, indent, false, out, printNode);\n      if (root.right) printRow(root.right, indent, true, out, printNode);\n    }\n  }\n\n  var Tree =\n  /** @class */\n  function () {\n    function Tree(comparator) {\n      if (comparator === void 0) {\n        comparator = DEFAULT_COMPARE;\n      }\n\n      this._root = null;\n      this._size = 0;\n      this._comparator = comparator;\n    }\n    /**\r\n     * Inserts a key, allows duplicates\r\n     */\n\n\n    Tree.prototype.insert = function (key, data) {\n      this._size++;\n      return this._root = insert(key, data, this._root, this._comparator);\n    };\n    /**\r\n     * Adds a key, if it is not present in the tree\r\n     */\n\n\n    Tree.prototype.add = function (key, data) {\n      var node = new Node(key, data);\n\n      if (this._root === null) {\n        node.left = node.right = null;\n        this._size++;\n        this._root = node;\n      }\n\n      var comparator = this._comparator;\n      var t = splay(key, this._root, comparator);\n      var cmp = comparator(key, t.key);\n      if (cmp === 0) this._root = t;else {\n        if (cmp < 0) {\n          node.left = t.left;\n          node.right = t;\n          t.left = null;\n        } else if (cmp > 0) {\n          node.right = t.right;\n          node.left = t;\n          t.right = null;\n        }\n\n        this._size++;\n        this._root = node;\n      }\n      return this._root;\n    };\n    /**\r\n     * @param  {Key} key\r\n     * @return {Node|null}\r\n     */\n\n\n    Tree.prototype.remove = function (key) {\n      this._root = this._remove(key, this._root, this._comparator);\n    };\n    /**\r\n     * Deletes i from the tree if it's there\r\n     */\n\n\n    Tree.prototype._remove = function (i, t, comparator) {\n      var x;\n      if (t === null) return null;\n      t = splay(i, t, comparator);\n      var cmp = comparator(i, t.key);\n\n      if (cmp === 0) {\n        /* found it */\n        if (t.left === null) {\n          x = t.right;\n        } else {\n          x = splay(i, t.left, comparator);\n          x.right = t.right;\n        }\n\n        this._size--;\n        return x;\n      }\n\n      return t;\n      /* It wasn't there */\n    };\n    /**\r\n     * Removes and returns the node with smallest key\r\n     */\n\n\n    Tree.prototype.pop = function () {\n      var node = this._root;\n\n      if (node) {\n        while (node.left) {\n          node = node.left;\n        }\n\n        this._root = splay(node.key, this._root, this._comparator);\n        this._root = this._remove(node.key, this._root, this._comparator);\n        return {\n          key: node.key,\n          data: node.data\n        };\n      }\n\n      return null;\n    };\n    /**\r\n     * Find without splaying\r\n     */\n\n\n    Tree.prototype.findStatic = function (key) {\n      var current = this._root;\n      var compare = this._comparator;\n\n      while (current) {\n        var cmp = compare(key, current.key);\n        if (cmp === 0) return current;else if (cmp < 0) current = current.left;else current = current.right;\n      }\n\n      return null;\n    };\n\n    Tree.prototype.find = function (key) {\n      if (this._root) {\n        this._root = splay(key, this._root, this._comparator);\n        if (this._comparator(key, this._root.key) !== 0) return null;\n      }\n\n      return this._root;\n    };\n\n    Tree.prototype.contains = function (key) {\n      var current = this._root;\n      var compare = this._comparator;\n\n      while (current) {\n        var cmp = compare(key, current.key);\n        if (cmp === 0) return true;else if (cmp < 0) current = current.left;else current = current.right;\n      }\n\n      return false;\n    };\n\n    Tree.prototype.forEach = function (visitor, ctx) {\n      var current = this._root;\n      var Q = [];\n      /* Initialize stack s */\n\n      var done = false;\n\n      while (!done) {\n        if (current !== null) {\n          Q.push(current);\n          current = current.left;\n        } else {\n          if (Q.length !== 0) {\n            current = Q.pop();\n            visitor.call(ctx, current);\n            current = current.right;\n          } else done = true;\n        }\n      }\n\n      return this;\n    };\n    /**\r\n     * Walk key range from `low` to `high`. Stops if `fn` returns a value.\r\n     */\n\n\n    Tree.prototype.range = function (low, high, fn, ctx) {\n      var Q = [];\n      var compare = this._comparator;\n      var node = this._root;\n      var cmp;\n\n      while (Q.length !== 0 || node) {\n        if (node) {\n          Q.push(node);\n          node = node.left;\n        } else {\n          node = Q.pop();\n          cmp = compare(node.key, high);\n\n          if (cmp > 0) {\n            break;\n          } else if (compare(node.key, low) >= 0) {\n            if (fn.call(ctx, node)) return this; // stop if smth is returned\n          }\n\n          node = node.right;\n        }\n      }\n\n      return this;\n    };\n    /**\r\n     * Returns array of keys\r\n     */\n\n\n    Tree.prototype.keys = function () {\n      var keys = [];\n      this.forEach(function (_a) {\n        var key = _a.key;\n        return keys.push(key);\n      });\n      return keys;\n    };\n    /**\r\n     * Returns array of all the data in the nodes\r\n     */\n\n\n    Tree.prototype.values = function () {\n      var values = [];\n      this.forEach(function (_a) {\n        var data = _a.data;\n        return values.push(data);\n      });\n      return values;\n    };\n\n    Tree.prototype.min = function () {\n      if (this._root) return this.minNode(this._root).key;\n      return null;\n    };\n\n    Tree.prototype.max = function () {\n      if (this._root) return this.maxNode(this._root).key;\n      return null;\n    };\n\n    Tree.prototype.minNode = function (t) {\n      if (t === void 0) {\n        t = this._root;\n      }\n\n      if (t) while (t.left) {\n        t = t.left;\n      }\n      return t;\n    };\n\n    Tree.prototype.maxNode = function (t) {\n      if (t === void 0) {\n        t = this._root;\n      }\n\n      if (t) while (t.right) {\n        t = t.right;\n      }\n      return t;\n    };\n    /**\r\n     * Returns node at given index\r\n     */\n\n\n    Tree.prototype.at = function (index) {\n      var current = this._root;\n      var done = false;\n      var i = 0;\n      var Q = [];\n\n      while (!done) {\n        if (current) {\n          Q.push(current);\n          current = current.left;\n        } else {\n          if (Q.length > 0) {\n            current = Q.pop();\n            if (i === index) return current;\n            i++;\n            current = current.right;\n          } else done = true;\n        }\n      }\n\n      return null;\n    };\n\n    Tree.prototype.next = function (d) {\n      var root = this._root;\n      var successor = null;\n\n      if (d.right) {\n        successor = d.right;\n\n        while (successor.left) {\n          successor = successor.left;\n        }\n\n        return successor;\n      }\n\n      var comparator = this._comparator;\n\n      while (root) {\n        var cmp = comparator(d.key, root.key);\n        if (cmp === 0) break;else if (cmp < 0) {\n          successor = root;\n          root = root.left;\n        } else root = root.right;\n      }\n\n      return successor;\n    };\n\n    Tree.prototype.prev = function (d) {\n      var root = this._root;\n      var predecessor = null;\n\n      if (d.left !== null) {\n        predecessor = d.left;\n\n        while (predecessor.right) {\n          predecessor = predecessor.right;\n        }\n\n        return predecessor;\n      }\n\n      var comparator = this._comparator;\n\n      while (root) {\n        var cmp = comparator(d.key, root.key);\n        if (cmp === 0) break;else if (cmp < 0) root = root.left;else {\n          predecessor = root;\n          root = root.right;\n        }\n      }\n\n      return predecessor;\n    };\n\n    Tree.prototype.clear = function () {\n      this._root = null;\n      this._size = 0;\n      return this;\n    };\n\n    Tree.prototype.toList = function () {\n      return toList(this._root);\n    };\n    /**\r\n     * Bulk-load items. Both array have to be same size\r\n     */\n\n\n    Tree.prototype.load = function (keys, values, presort) {\n      if (values === void 0) {\n        values = [];\n      }\n\n      if (presort === void 0) {\n        presort = false;\n      }\n\n      var size = keys.length;\n      var comparator = this._comparator; // sort if needed\n\n      if (presort) sort(keys, values, 0, size - 1, comparator);\n\n      if (this._root === null) {\n        // empty tree\n        this._root = loadRecursive(keys, values, 0, size);\n        this._size = size;\n      } else {\n        // that re-builds the whole tree from two in-order traversals\n        var mergedList = mergeLists(this.toList(), createList(keys, values), comparator);\n        size = this._size + size;\n        this._root = sortedListToBST({\n          head: mergedList\n        }, 0, size);\n      }\n\n      return this;\n    };\n\n    Tree.prototype.isEmpty = function () {\n      return this._root === null;\n    };\n\n    Object.defineProperty(Tree.prototype, \"size\", {\n      get: function get() {\n        return this._size;\n      },\n      enumerable: true,\n      configurable: true\n    });\n    Object.defineProperty(Tree.prototype, \"root\", {\n      get: function get() {\n        return this._root;\n      },\n      enumerable: true,\n      configurable: true\n    });\n\n    Tree.prototype.toString = function (printNode) {\n      if (printNode === void 0) {\n        printNode = function printNode(n) {\n          return String(n.key);\n        };\n      }\n\n      var out = [];\n      printRow(this._root, '', true, function (v) {\n        return out.push(v);\n      }, printNode);\n      return out.join('');\n    };\n\n    Tree.prototype.update = function (key, newKey, newData) {\n      var comparator = this._comparator;\n\n      var _a = split(key, this._root, comparator),\n          left = _a.left,\n          right = _a.right;\n\n      if (comparator(key, newKey) < 0) {\n        right = insert(newKey, newData, right, comparator);\n      } else {\n        left = insert(newKey, newData, left, comparator);\n      }\n\n      this._root = merge(left, right, comparator);\n    };\n\n    Tree.prototype.split = function (key) {\n      return split(key, this._root, this._comparator);\n    };\n\n    return Tree;\n  }();\n\n  function loadRecursive(keys, values, start, end) {\n    var size = end - start;\n\n    if (size > 0) {\n      var middle = start + Math.floor(size / 2);\n      var key = keys[middle];\n      var data = values[middle];\n      var node = new Node(key, data);\n      node.left = loadRecursive(keys, values, start, middle);\n      node.right = loadRecursive(keys, values, middle + 1, end);\n      return node;\n    }\n\n    return null;\n  }\n\n  function createList(keys, values) {\n    var head = new Node(null, null);\n    var p = head;\n\n    for (var i = 0; i < keys.length; i++) {\n      p = p.next = new Node(keys[i], values[i]);\n    }\n\n    p.next = null;\n    return head.next;\n  }\n\n  function toList(root) {\n    var current = root;\n    var Q = [];\n    var done = false;\n    var head = new Node(null, null);\n    var p = head;\n\n    while (!done) {\n      if (current) {\n        Q.push(current);\n        current = current.left;\n      } else {\n        if (Q.length > 0) {\n          current = p = p.next = Q.pop();\n          current = current.right;\n        } else done = true;\n      }\n    }\n\n    p.next = null; // that'll work even if the tree was empty\n\n    return head.next;\n  }\n\n  function sortedListToBST(list, start, end) {\n    var size = end - start;\n\n    if (size > 0) {\n      var middle = start + Math.floor(size / 2);\n      var left = sortedListToBST(list, start, middle);\n      var root = list.head;\n      root.left = left;\n      list.head = list.head.next;\n      root.right = sortedListToBST(list, middle + 1, end);\n      return root;\n    }\n\n    return null;\n  }\n\n  function mergeLists(l1, l2, compare) {\n    var head = new Node(null, null); // dummy\n\n    var p = head;\n    var p1 = l1;\n    var p2 = l2;\n\n    while (p1 !== null && p2 !== null) {\n      if (compare(p1.key, p2.key) < 0) {\n        p.next = p1;\n        p1 = p1.next;\n      } else {\n        p.next = p2;\n        p2 = p2.next;\n      }\n\n      p = p.next;\n    }\n\n    if (p1 !== null) {\n      p.next = p1;\n    } else if (p2 !== null) {\n      p.next = p2;\n    }\n\n    return head.next;\n  }\n\n  function sort(keys, values, left, right, compare) {\n    if (left >= right) return;\n    var pivot = keys[left + right >> 1];\n    var i = left - 1;\n    var j = right + 1;\n\n    while (true) {\n      do {\n        i++;\n      } while (compare(keys[i], pivot) < 0);\n\n      do {\n        j--;\n      } while (compare(keys[j], pivot) > 0);\n\n      if (i >= j) break;\n      var tmp = keys[i];\n      keys[i] = keys[j];\n      keys[j] = tmp;\n      tmp = values[i];\n      values[i] = values[j];\n      values[j] = tmp;\n    }\n\n    sort(keys, values, left, j, compare);\n    sort(keys, values, j + 1, right, compare);\n  }\n\n  /**\n   * A bounding box has the format:\n   *\n   *  { ll: { x: xmin, y: ymin }, ur: { x: xmax, y: ymax } }\n   *\n   */\n  var isInBbox = function isInBbox(bbox, point) {\n    return bbox.ll.x <= point.x && point.x <= bbox.ur.x && bbox.ll.y <= point.y && point.y <= bbox.ur.y;\n  };\n  /* Returns either null, or a bbox (aka an ordered pair of points)\n   * If there is only one point of overlap, a bbox with identical points\n   * will be returned */\n\n  var getBboxOverlap = function getBboxOverlap(b1, b2) {\n    // check if the bboxes overlap at all\n    if (b2.ur.x < b1.ll.x || b1.ur.x < b2.ll.x || b2.ur.y < b1.ll.y || b1.ur.y < b2.ll.y) return null; // find the middle two X values\n\n    var lowerX = b1.ll.x < b2.ll.x ? b2.ll.x : b1.ll.x;\n    var upperX = b1.ur.x < b2.ur.x ? b1.ur.x : b2.ur.x; // find the middle two Y values\n\n    var lowerY = b1.ll.y < b2.ll.y ? b2.ll.y : b1.ll.y;\n    var upperY = b1.ur.y < b2.ur.y ? b1.ur.y : b2.ur.y; // put those middle values together to get the overlap\n\n    return {\n      ll: {\n        x: lowerX,\n        y: lowerY\n      },\n      ur: {\n        x: upperX,\n        y: upperY\n      }\n    };\n  };\n\n  /* Javascript doesn't do integer math. Everything is\n   * floating point with percision Number.EPSILON.\n   *\n   * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/EPSILON\n   */\n  var epsilon = Number.EPSILON; // IE Polyfill\n\n  if (epsilon === undefined) epsilon = Math.pow(2, -52);\n  var EPSILON_SQ = epsilon * epsilon;\n  /* FLP comparator */\n\n  var cmp = function cmp(a, b) {\n    // check if they're both 0\n    if (-epsilon < a && a < epsilon) {\n      if (-epsilon < b && b < epsilon) {\n        return 0;\n      }\n    } // check if they're flp equal\n\n\n    var ab = a - b;\n\n    if (ab * ab < EPSILON_SQ * a * b) {\n      return 0;\n    } // normal comparison\n\n\n    return a < b ? -1 : 1;\n  };\n\n  /**\n   * This class rounds incoming values sufficiently so that\n   * floating points problems are, for the most part, avoided.\n   *\n   * Incoming points are have their x & y values tested against\n   * all previously seen x & y values. If either is 'too close'\n   * to a previously seen value, it's value is 'snapped' to the\n   * previously seen value.\n   *\n   * All points should be rounded by this class before being\n   * stored in any data structures in the rest of this algorithm.\n   */\n\n  var PtRounder = /*#__PURE__*/function () {\n    function PtRounder() {\n      _classCallCheck(this, PtRounder);\n\n      this.reset();\n    }\n\n    _createClass(PtRounder, [{\n      key: \"reset\",\n      value: function reset() {\n        this.xRounder = new CoordRounder();\n        this.yRounder = new CoordRounder();\n      }\n    }, {\n      key: \"round\",\n      value: function round(x, y) {\n        return {\n          x: this.xRounder.round(x),\n          y: this.yRounder.round(y)\n        };\n      }\n    }]);\n\n    return PtRounder;\n  }();\n\n  var CoordRounder = /*#__PURE__*/function () {\n    function CoordRounder() {\n      _classCallCheck(this, CoordRounder);\n\n      this.tree = new Tree(); // preseed with 0 so we don't end up with values < Number.EPSILON\n\n      this.round(0);\n    } // Note: this can rounds input values backwards or forwards.\n    //       You might ask, why not restrict this to just rounding\n    //       forwards? Wouldn't that allow left endpoints to always\n    //       remain left endpoints during splitting (never change to\n    //       right). No - it wouldn't, because we snap intersections\n    //       to endpoints (to establish independence from the segment\n    //       angle for t-intersections).\n\n\n    _createClass(CoordRounder, [{\n      key: \"round\",\n      value: function round(coord) {\n        var node = this.tree.add(coord);\n        var prevNode = this.tree.prev(node);\n\n        if (prevNode !== null && cmp(node.key, prevNode.key) === 0) {\n          this.tree.remove(coord);\n          return prevNode.key;\n        }\n\n        var nextNode = this.tree.next(node);\n\n        if (nextNode !== null && cmp(node.key, nextNode.key) === 0) {\n          this.tree.remove(coord);\n          return nextNode.key;\n        }\n\n        return coord;\n      }\n    }]);\n\n    return CoordRounder;\n  }(); // singleton available by import\n\n\n  var rounder = new PtRounder();\n\n  /* Cross Product of two vectors with first point at origin */\n\n  var crossProduct = function crossProduct(a, b) {\n    return a.x * b.y - a.y * b.x;\n  };\n  /* Dot Product of two vectors with first point at origin */\n\n  var dotProduct = function dotProduct(a, b) {\n    return a.x * b.x + a.y * b.y;\n  };\n  /* Comparator for two vectors with same starting point */\n\n  var compareVectorAngles = function compareVectorAngles(basePt, endPt1, endPt2) {\n    var v1 = {\n      x: endPt1.x - basePt.x,\n      y: endPt1.y - basePt.y\n    };\n    var v2 = {\n      x: endPt2.x - basePt.x,\n      y: endPt2.y - basePt.y\n    };\n    var kross = crossProduct(v1, v2);\n    return cmp(kross, 0);\n  };\n  var length = function length(v) {\n    return Math.sqrt(dotProduct(v, v));\n  };\n  /* Get the sine of the angle from pShared -> pAngle to pShaed -> pBase */\n\n  var sineOfAngle = function sineOfAngle(pShared, pBase, pAngle) {\n    var vBase = {\n      x: pBase.x - pShared.x,\n      y: pBase.y - pShared.y\n    };\n    var vAngle = {\n      x: pAngle.x - pShared.x,\n      y: pAngle.y - pShared.y\n    };\n    return crossProduct(vAngle, vBase) / length(vAngle) / length(vBase);\n  };\n  /* Get the cosine of the angle from pShared -> pAngle to pShaed -> pBase */\n\n  var cosineOfAngle = function cosineOfAngle(pShared, pBase, pAngle) {\n    var vBase = {\n      x: pBase.x - pShared.x,\n      y: pBase.y - pShared.y\n    };\n    var vAngle = {\n      x: pAngle.x - pShared.x,\n      y: pAngle.y - pShared.y\n    };\n    return dotProduct(vAngle, vBase) / length(vAngle) / length(vBase);\n  };\n  /* Get the x coordinate where the given line (defined by a point and vector)\n   * crosses the horizontal line with the given y coordiante.\n   * In the case of parrallel lines (including overlapping ones) returns null. */\n\n  var horizontalIntersection = function horizontalIntersection(pt, v, y) {\n    if (v.y === 0) return null;\n    return {\n      x: pt.x + v.x / v.y * (y - pt.y),\n      y: y\n    };\n  };\n  /* Get the y coordinate where the given line (defined by a point and vector)\n   * crosses the vertical line with the given x coordiante.\n   * In the case of parrallel lines (including overlapping ones) returns null. */\n\n  var verticalIntersection = function verticalIntersection(pt, v, x) {\n    if (v.x === 0) return null;\n    return {\n      x: x,\n      y: pt.y + v.y / v.x * (x - pt.x)\n    };\n  };\n  /* Get the intersection of two lines, each defined by a base point and a vector.\n   * In the case of parrallel lines (including overlapping ones) returns null. */\n\n  var intersection = function intersection(pt1, v1, pt2, v2) {\n    // take some shortcuts for vertical and horizontal lines\n    // this also ensures we don't calculate an intersection and then discover\n    // it's actually outside the bounding box of the line\n    if (v1.x === 0) return verticalIntersection(pt2, v2, pt1.x);\n    if (v2.x === 0) return verticalIntersection(pt1, v1, pt2.x);\n    if (v1.y === 0) return horizontalIntersection(pt2, v2, pt1.y);\n    if (v2.y === 0) return horizontalIntersection(pt1, v1, pt2.y); // General case for non-overlapping segments.\n    // This algorithm is based on Schneider and Eberly.\n    // http://www.cimec.org.ar/~ncalvo/Schneider_Eberly.pdf - pg 244\n\n    var kross = crossProduct(v1, v2);\n    if (kross == 0) return null;\n    var ve = {\n      x: pt2.x - pt1.x,\n      y: pt2.y - pt1.y\n    };\n    var d1 = crossProduct(ve, v1) / kross;\n    var d2 = crossProduct(ve, v2) / kross; // take the average of the two calculations to minimize rounding error\n\n    var x1 = pt1.x + d2 * v1.x,\n        x2 = pt2.x + d1 * v2.x;\n    var y1 = pt1.y + d2 * v1.y,\n        y2 = pt2.y + d1 * v2.y;\n    var x = (x1 + x2) / 2;\n    var y = (y1 + y2) / 2;\n    return {\n      x: x,\n      y: y\n    };\n  };\n\n  var SweepEvent = /*#__PURE__*/function () {\n    _createClass(SweepEvent, null, [{\n      key: \"compare\",\n      // for ordering sweep events in the sweep event queue\n      value: function compare(a, b) {\n        // favor event with a point that the sweep line hits first\n        var ptCmp = SweepEvent.comparePoints(a.point, b.point);\n        if (ptCmp !== 0) return ptCmp; // the points are the same, so link them if needed\n\n        if (a.point !== b.point) a.link(b); // favor right events over left\n\n        if (a.isLeft !== b.isLeft) return a.isLeft ? 1 : -1; // we have two matching left or right endpoints\n        // ordering of this case is the same as for their segments\n\n        return Segment.compare(a.segment, b.segment);\n      } // for ordering points in sweep line order\n\n    }, {\n      key: \"comparePoints\",\n      value: function comparePoints(aPt, bPt) {\n        if (aPt.x < bPt.x) return -1;\n        if (aPt.x > bPt.x) return 1;\n        if (aPt.y < bPt.y) return -1;\n        if (aPt.y > bPt.y) return 1;\n        return 0;\n      } // Warning: 'point' input will be modified and re-used (for performance)\n\n    }]);\n\n    function SweepEvent(point, isLeft) {\n      _classCallCheck(this, SweepEvent);\n\n      if (point.events === undefined) point.events = [this];else point.events.push(this);\n      this.point = point;\n      this.isLeft = isLeft; // this.segment, this.otherSE set by factory\n    }\n\n    _createClass(SweepEvent, [{\n      key: \"link\",\n      value: function link(other) {\n        if (other.point === this.point) {\n          throw new Error('Tried to link already linked events');\n        }\n\n        var otherEvents = other.point.events;\n\n        for (var i = 0, iMax = otherEvents.length; i < iMax; i++) {\n          var evt = otherEvents[i];\n          this.point.events.push(evt);\n          evt.point = this.point;\n        }\n\n        this.checkForConsuming();\n      }\n      /* Do a pass over our linked events and check to see if any pair\n       * of segments match, and should be consumed. */\n\n    }, {\n      key: \"checkForConsuming\",\n      value: function checkForConsuming() {\n        // FIXME: The loops in this method run O(n^2) => no good.\n        //        Maintain little ordered sweep event trees?\n        //        Can we maintaining an ordering that avoids the need\n        //        for the re-sorting with getLeftmostComparator in geom-out?\n        // Compare each pair of events to see if other events also match\n        var numEvents = this.point.events.length;\n\n        for (var i = 0; i < numEvents; i++) {\n          var evt1 = this.point.events[i];\n          if (evt1.segment.consumedBy !== undefined) continue;\n\n          for (var j = i + 1; j < numEvents; j++) {\n            var evt2 = this.point.events[j];\n            if (evt2.consumedBy !== undefined) continue;\n            if (evt1.otherSE.point.events !== evt2.otherSE.point.events) continue;\n            evt1.segment.consume(evt2.segment);\n          }\n        }\n      }\n    }, {\n      key: \"getAvailableLinkedEvents\",\n      value: function getAvailableLinkedEvents() {\n        // point.events is always of length 2 or greater\n        var events = [];\n\n        for (var i = 0, iMax = this.point.events.length; i < iMax; i++) {\n          var evt = this.point.events[i];\n\n          if (evt !== this && !evt.segment.ringOut && evt.segment.isInResult()) {\n            events.push(evt);\n          }\n        }\n\n        return events;\n      }\n      /**\n       * Returns a comparator function for sorting linked events that will\n       * favor the event that will give us the smallest left-side angle.\n       * All ring construction starts as low as possible heading to the right,\n       * so by always turning left as sharp as possible we'll get polygons\n       * without uncessary loops & holes.\n       *\n       * The comparator function has a compute cache such that it avoids\n       * re-computing already-computed values.\n       */\n\n    }, {\n      key: \"getLeftmostComparator\",\n      value: function getLeftmostComparator(baseEvent) {\n        var _this = this;\n\n        var cache = new Map();\n\n        var fillCache = function fillCache(linkedEvent) {\n          var nextEvent = linkedEvent.otherSE;\n          cache.set(linkedEvent, {\n            sine: sineOfAngle(_this.point, baseEvent.point, nextEvent.point),\n            cosine: cosineOfAngle(_this.point, baseEvent.point, nextEvent.point)\n          });\n        };\n\n        return function (a, b) {\n          if (!cache.has(a)) fillCache(a);\n          if (!cache.has(b)) fillCache(b);\n\n          var _cache$get = cache.get(a),\n              asine = _cache$get.sine,\n              acosine = _cache$get.cosine;\n\n          var _cache$get2 = cache.get(b),\n              bsine = _cache$get2.sine,\n              bcosine = _cache$get2.cosine; // both on or above x-axis\n\n\n          if (asine >= 0 && bsine >= 0) {\n            if (acosine < bcosine) return 1;\n            if (acosine > bcosine) return -1;\n            return 0;\n          } // both below x-axis\n\n\n          if (asine < 0 && bsine < 0) {\n            if (acosine < bcosine) return -1;\n            if (acosine > bcosine) return 1;\n            return 0;\n          } // one above x-axis, one below\n\n\n          if (bsine < asine) return -1;\n          if (bsine > asine) return 1;\n          return 0;\n        };\n      }\n    }]);\n\n    return SweepEvent;\n  }();\n\n  // segments and sweep events when all else is identical\n\n  var segmentId = 0;\n\n  var Segment = /*#__PURE__*/function () {\n    _createClass(Segment, null, [{\n      key: \"compare\",\n\n      /* This compare() function is for ordering segments in the sweep\n       * line tree, and does so according to the following criteria:\n       *\n       * Consider the vertical line that lies an infinestimal step to the\n       * right of the right-more of the two left endpoints of the input\n       * segments. Imagine slowly moving a point up from negative infinity\n       * in the increasing y direction. Which of the two segments will that\n       * point intersect first? That segment comes 'before' the other one.\n       *\n       * If neither segment would be intersected by such a line, (if one\n       * or more of the segments are vertical) then the line to be considered\n       * is directly on the right-more of the two left inputs.\n       */\n      value: function compare(a, b) {\n        var alx = a.leftSE.point.x;\n        var blx = b.leftSE.point.x;\n        var arx = a.rightSE.point.x;\n        var brx = b.rightSE.point.x; // check if they're even in the same vertical plane\n\n        if (brx < alx) return 1;\n        if (arx < blx) return -1;\n        var aly = a.leftSE.point.y;\n        var bly = b.leftSE.point.y;\n        var ary = a.rightSE.point.y;\n        var bry = b.rightSE.point.y; // is left endpoint of segment B the right-more?\n\n        if (alx < blx) {\n          // are the two segments in the same horizontal plane?\n          if (bly < aly && bly < ary) return 1;\n          if (bly > aly && bly > ary) return -1; // is the B left endpoint colinear to segment A?\n\n          var aCmpBLeft = a.comparePoint(b.leftSE.point);\n          if (aCmpBLeft < 0) return 1;\n          if (aCmpBLeft > 0) return -1; // is the A right endpoint colinear to segment B ?\n\n          var bCmpARight = b.comparePoint(a.rightSE.point);\n          if (bCmpARight !== 0) return bCmpARight; // colinear segments, consider the one with left-more\n          // left endpoint to be first (arbitrary?)\n\n          return -1;\n        } // is left endpoint of segment A the right-more?\n\n\n        if (alx > blx) {\n          if (aly < bly && aly < bry) return -1;\n          if (aly > bly && aly > bry) return 1; // is the A left endpoint colinear to segment B?\n\n          var bCmpALeft = b.comparePoint(a.leftSE.point);\n          if (bCmpALeft !== 0) return bCmpALeft; // is the B right endpoint colinear to segment A?\n\n          var aCmpBRight = a.comparePoint(b.rightSE.point);\n          if (aCmpBRight < 0) return 1;\n          if (aCmpBRight > 0) return -1; // colinear segments, consider the one with left-more\n          // left endpoint to be first (arbitrary?)\n\n          return 1;\n        } // if we get here, the two left endpoints are in the same\n        // vertical plane, ie alx === blx\n        // consider the lower left-endpoint to come first\n\n\n        if (aly < bly) return -1;\n        if (aly > bly) return 1; // left endpoints are identical\n        // check for colinearity by using the left-more right endpoint\n        // is the A right endpoint more left-more?\n\n        if (arx < brx) {\n          var _bCmpARight = b.comparePoint(a.rightSE.point);\n\n          if (_bCmpARight !== 0) return _bCmpARight;\n        } // is the B right endpoint more left-more?\n\n\n        if (arx > brx) {\n          var _aCmpBRight = a.comparePoint(b.rightSE.point);\n\n          if (_aCmpBRight < 0) return 1;\n          if (_aCmpBRight > 0) return -1;\n        }\n\n        if (arx !== brx) {\n          // are these two [almost] vertical segments with opposite orientation?\n          // if so, the one with the lower right endpoint comes first\n          var ay = ary - aly;\n          var ax = arx - alx;\n          var by = bry - bly;\n          var bx = brx - blx;\n          if (ay > ax && by < bx) return 1;\n          if (ay < ax && by > bx) return -1;\n        } // we have colinear segments with matching orientation\n        // consider the one with more left-more right endpoint to be first\n\n\n        if (arx > brx) return 1;\n        if (arx < brx) return -1; // if we get here, two two right endpoints are in the same\n        // vertical plane, ie arx === brx\n        // consider the lower right-endpoint to come first\n\n        if (ary < bry) return -1;\n        if (ary > bry) return 1; // right endpoints identical as well, so the segments are idential\n        // fall back on creation order as consistent tie-breaker\n\n        if (a.id < b.id) return -1;\n        if (a.id > b.id) return 1; // identical segment, ie a === b\n\n        return 0;\n      }\n      /* Warning: a reference to ringWindings input will be stored,\n       *  and possibly will be later modified */\n\n    }]);\n\n    function Segment(leftSE, rightSE, rings, windings) {\n      _classCallCheck(this, Segment);\n\n      this.id = ++segmentId;\n      this.leftSE = leftSE;\n      leftSE.segment = this;\n      leftSE.otherSE = rightSE;\n      this.rightSE = rightSE;\n      rightSE.segment = this;\n      rightSE.otherSE = leftSE;\n      this.rings = rings;\n      this.windings = windings; // left unset for performance, set later in algorithm\n      // this.ringOut, this.consumedBy, this.prev\n    }\n\n    _createClass(Segment, [{\n      key: \"replaceRightSE\",\n\n      /* When a segment is split, the rightSE is replaced with a new sweep event */\n      value: function replaceRightSE(newRightSE) {\n        this.rightSE = newRightSE;\n        this.rightSE.segment = this;\n        this.rightSE.otherSE = this.leftSE;\n        this.leftSE.otherSE = this.rightSE;\n      }\n    }, {\n      key: \"bbox\",\n      value: function bbox() {\n        var y1 = this.leftSE.point.y;\n        var y2 = this.rightSE.point.y;\n        return {\n          ll: {\n            x: this.leftSE.point.x,\n            y: y1 < y2 ? y1 : y2\n          },\n          ur: {\n            x: this.rightSE.point.x,\n            y: y1 > y2 ? y1 : y2\n          }\n        };\n      }\n      /* A vector from the left point to the right */\n\n    }, {\n      key: \"vector\",\n      value: function vector() {\n        return {\n          x: this.rightSE.point.x - this.leftSE.point.x,\n          y: this.rightSE.point.y - this.leftSE.point.y\n        };\n      }\n    }, {\n      key: \"isAnEndpoint\",\n      value: function isAnEndpoint(pt) {\n        return pt.x === this.leftSE.point.x && pt.y === this.leftSE.point.y || pt.x === this.rightSE.point.x && pt.y === this.rightSE.point.y;\n      }\n      /* Compare this segment with a point.\n       *\n       * A point P is considered to be colinear to a segment if there\n       * exists a distance D such that if we travel along the segment\n       * from one * endpoint towards the other a distance D, we find\n       * ourselves at point P.\n       *\n       * Return value indicates:\n       *\n       *   1: point lies above the segment (to the left of vertical)\n       *   0: point is colinear to segment\n       *  -1: point lies below the segment (to the right of vertical)\n       */\n\n    }, {\n      key: \"comparePoint\",\n      value: function comparePoint(point) {\n        if (this.isAnEndpoint(point)) return 0;\n        var lPt = this.leftSE.point;\n        var rPt = this.rightSE.point;\n        var v = this.vector(); // Exactly vertical segments.\n\n        if (lPt.x === rPt.x) {\n          if (point.x === lPt.x) return 0;\n          return point.x < lPt.x ? 1 : -1;\n        } // Nearly vertical segments with an intersection.\n        // Check to see where a point on the line with matching Y coordinate is.\n\n\n        var yDist = (point.y - lPt.y) / v.y;\n        var xFromYDist = lPt.x + yDist * v.x;\n        if (point.x === xFromYDist) return 0; // General case.\n        // Check to see where a point on the line with matching X coordinate is.\n\n        var xDist = (point.x - lPt.x) / v.x;\n        var yFromXDist = lPt.y + xDist * v.y;\n        if (point.y === yFromXDist) return 0;\n        return point.y < yFromXDist ? -1 : 1;\n      }\n      /**\n       * Given another segment, returns the first non-trivial intersection\n       * between the two segments (in terms of sweep line ordering), if it exists.\n       *\n       * A 'non-trivial' intersection is one that will cause one or both of the\n       * segments to be split(). As such, 'trivial' vs. 'non-trivial' intersection:\n       *\n       *   * endpoint of segA with endpoint of segB --> trivial\n       *   * endpoint of segA with point along segB --> non-trivial\n       *   * endpoint of segB with point along segA --> non-trivial\n       *   * point along segA with point along segB --> non-trivial\n       *\n       * If no non-trivial intersection exists, return null\n       * Else, return null.\n       */\n\n    }, {\n      key: \"getIntersection\",\n      value: function getIntersection(other) {\n        // If bboxes don't overlap, there can't be any intersections\n        var tBbox = this.bbox();\n        var oBbox = other.bbox();\n        var bboxOverlap = getBboxOverlap(tBbox, oBbox);\n        if (bboxOverlap === null) return null; // We first check to see if the endpoints can be considered intersections.\n        // This will 'snap' intersections to endpoints if possible, and will\n        // handle cases of colinearity.\n\n        var tlp = this.leftSE.point;\n        var trp = this.rightSE.point;\n        var olp = other.leftSE.point;\n        var orp = other.rightSE.point; // does each endpoint touch the other segment?\n        // note that we restrict the 'touching' definition to only allow segments\n        // to touch endpoints that lie forward from where we are in the sweep line pass\n\n        var touchesOtherLSE = isInBbox(tBbox, olp) && this.comparePoint(olp) === 0;\n        var touchesThisLSE = isInBbox(oBbox, tlp) && other.comparePoint(tlp) === 0;\n        var touchesOtherRSE = isInBbox(tBbox, orp) && this.comparePoint(orp) === 0;\n        var touchesThisRSE = isInBbox(oBbox, trp) && other.comparePoint(trp) === 0; // do left endpoints match?\n\n        if (touchesThisLSE && touchesOtherLSE) {\n          // these two cases are for colinear segments with matching left\n          // endpoints, and one segment being longer than the other\n          if (touchesThisRSE && !touchesOtherRSE) return trp;\n          if (!touchesThisRSE && touchesOtherRSE) return orp; // either the two segments match exactly (two trival intersections)\n          // or just on their left endpoint (one trivial intersection\n\n          return null;\n        } // does this left endpoint matches (other doesn't)\n\n\n        if (touchesThisLSE) {\n          // check for segments that just intersect on opposing endpoints\n          if (touchesOtherRSE) {\n            if (tlp.x === orp.x && tlp.y === orp.y) return null;\n          } // t-intersection on left endpoint\n\n\n          return tlp;\n        } // does other left endpoint matches (this doesn't)\n\n\n        if (touchesOtherLSE) {\n          // check for segments that just intersect on opposing endpoints\n          if (touchesThisRSE) {\n            if (trp.x === olp.x && trp.y === olp.y) return null;\n          } // t-intersection on left endpoint\n\n\n          return olp;\n        } // trivial intersection on right endpoints\n\n\n        if (touchesThisRSE && touchesOtherRSE) return null; // t-intersections on just one right endpoint\n\n        if (touchesThisRSE) return trp;\n        if (touchesOtherRSE) return orp; // None of our endpoints intersect. Look for a general intersection between\n        // infinite lines laid over the segments\n\n        var pt = intersection(tlp, this.vector(), olp, other.vector()); // are the segments parrallel? Note that if they were colinear with overlap,\n        // they would have an endpoint intersection and that case was already handled above\n\n        if (pt === null) return null; // is the intersection found between the lines not on the segments?\n\n        if (!isInBbox(bboxOverlap, pt)) return null; // round the the computed point if needed\n\n        return rounder.round(pt.x, pt.y);\n      }\n      /**\n       * Split the given segment into multiple segments on the given points.\n       *  * Each existing segment will retain its leftSE and a new rightSE will be\n       *    generated for it.\n       *  * A new segment will be generated which will adopt the original segment's\n       *    rightSE, and a new leftSE will be generated for it.\n       *  * If there are more than two points given to split on, new segments\n       *    in the middle will be generated with new leftSE and rightSE's.\n       *  * An array of the newly generated SweepEvents will be returned.\n       *\n       * Warning: input array of points is modified\n       */\n\n    }, {\n      key: \"split\",\n      value: function split(point) {\n        var newEvents = [];\n        var alreadyLinked = point.events !== undefined;\n        var newLeftSE = new SweepEvent(point, true);\n        var newRightSE = new SweepEvent(point, false);\n        var oldRightSE = this.rightSE;\n        this.replaceRightSE(newRightSE);\n        newEvents.push(newRightSE);\n        newEvents.push(newLeftSE);\n        var newSeg = new Segment(newLeftSE, oldRightSE, this.rings.slice(), this.windings.slice()); // when splitting a nearly vertical downward-facing segment,\n        // sometimes one of the resulting new segments is vertical, in which\n        // case its left and right events may need to be swapped\n\n        if (SweepEvent.comparePoints(newSeg.leftSE.point, newSeg.rightSE.point) > 0) {\n          newSeg.swapEvents();\n        }\n\n        if (SweepEvent.comparePoints(this.leftSE.point, this.rightSE.point) > 0) {\n          this.swapEvents();\n        } // in the point we just used to create new sweep events with was already\n        // linked to other events, we need to check if either of the affected\n        // segments should be consumed\n\n\n        if (alreadyLinked) {\n          newLeftSE.checkForConsuming();\n          newRightSE.checkForConsuming();\n        }\n\n        return newEvents;\n      }\n      /* Swap which event is left and right */\n\n    }, {\n      key: \"swapEvents\",\n      value: function swapEvents() {\n        var tmpEvt = this.rightSE;\n        this.rightSE = this.leftSE;\n        this.leftSE = tmpEvt;\n        this.leftSE.isLeft = true;\n        this.rightSE.isLeft = false;\n\n        for (var i = 0, iMax = this.windings.length; i < iMax; i++) {\n          this.windings[i] *= -1;\n        }\n      }\n      /* Consume another segment. We take their rings under our wing\n       * and mark them as consumed. Use for perfectly overlapping segments */\n\n    }, {\n      key: \"consume\",\n      value: function consume(other) {\n        var consumer = this;\n        var consumee = other;\n\n        while (consumer.consumedBy) {\n          consumer = consumer.consumedBy;\n        }\n\n        while (consumee.consumedBy) {\n          consumee = consumee.consumedBy;\n        }\n\n        var cmp = Segment.compare(consumer, consumee);\n        if (cmp === 0) return; // already consumed\n        // the winner of the consumption is the earlier segment\n        // according to sweep line ordering\n\n        if (cmp > 0) {\n          var tmp = consumer;\n          consumer = consumee;\n          consumee = tmp;\n        } // make sure a segment doesn't consume it's prev\n\n\n        if (consumer.prev === consumee) {\n          var _tmp = consumer;\n          consumer = consumee;\n          consumee = _tmp;\n        }\n\n        for (var i = 0, iMax = consumee.rings.length; i < iMax; i++) {\n          var ring = consumee.rings[i];\n          var winding = consumee.windings[i];\n          var index = consumer.rings.indexOf(ring);\n\n          if (index === -1) {\n            consumer.rings.push(ring);\n            consumer.windings.push(winding);\n          } else consumer.windings[index] += winding;\n        }\n\n        consumee.rings = null;\n        consumee.windings = null;\n        consumee.consumedBy = consumer; // mark sweep events consumed as to maintain ordering in sweep event queue\n\n        consumee.leftSE.consumedBy = consumer.leftSE;\n        consumee.rightSE.consumedBy = consumer.rightSE;\n      }\n      /* The first segment previous segment chain that is in the result */\n\n    }, {\n      key: \"prevInResult\",\n      value: function prevInResult() {\n        if (this._prevInResult !== undefined) return this._prevInResult;\n        if (!this.prev) this._prevInResult = null;else if (this.prev.isInResult()) this._prevInResult = this.prev;else this._prevInResult = this.prev.prevInResult();\n        return this._prevInResult;\n      }\n    }, {\n      key: \"beforeState\",\n      value: function beforeState() {\n        if (this._beforeState !== undefined) return this._beforeState;\n        if (!this.prev) this._beforeState = {\n          rings: [],\n          windings: [],\n          multiPolys: []\n        };else {\n          var seg = this.prev.consumedBy || this.prev;\n          this._beforeState = seg.afterState();\n        }\n        return this._beforeState;\n      }\n    }, {\n      key: \"afterState\",\n      value: function afterState() {\n        if (this._afterState !== undefined) return this._afterState;\n        var beforeState = this.beforeState();\n        this._afterState = {\n          rings: beforeState.rings.slice(0),\n          windings: beforeState.windings.slice(0),\n          multiPolys: []\n        };\n        var ringsAfter = this._afterState.rings;\n        var windingsAfter = this._afterState.windings;\n        var mpsAfter = this._afterState.multiPolys; // calculate ringsAfter, windingsAfter\n\n        for (var i = 0, iMax = this.rings.length; i < iMax; i++) {\n          var ring = this.rings[i];\n          var winding = this.windings[i];\n          var index = ringsAfter.indexOf(ring);\n\n          if (index === -1) {\n            ringsAfter.push(ring);\n            windingsAfter.push(winding);\n          } else windingsAfter[index] += winding;\n        } // calcualte polysAfter\n\n\n        var polysAfter = [];\n        var polysExclude = [];\n\n        for (var _i = 0, _iMax = ringsAfter.length; _i < _iMax; _i++) {\n          if (windingsAfter[_i] === 0) continue; // non-zero rule\n\n          var _ring = ringsAfter[_i];\n          var poly = _ring.poly;\n          if (polysExclude.indexOf(poly) !== -1) continue;\n          if (_ring.isExterior) polysAfter.push(poly);else {\n            if (polysExclude.indexOf(poly) === -1) polysExclude.push(poly);\n\n            var _index = polysAfter.indexOf(_ring.poly);\n\n            if (_index !== -1) polysAfter.splice(_index, 1);\n          }\n        } // calculate multiPolysAfter\n\n\n        for (var _i2 = 0, _iMax2 = polysAfter.length; _i2 < _iMax2; _i2++) {\n          var mp = polysAfter[_i2].multiPoly;\n          if (mpsAfter.indexOf(mp) === -1) mpsAfter.push(mp);\n        }\n\n        return this._afterState;\n      }\n      /* Is this segment part of the final result? */\n\n    }, {\n      key: \"isInResult\",\n      value: function isInResult() {\n        // if we've been consumed, we're not in the result\n        if (this.consumedBy) return false;\n        if (this._isInResult !== undefined) return this._isInResult;\n        var mpsBefore = this.beforeState().multiPolys;\n        var mpsAfter = this.afterState().multiPolys;\n\n        switch (operation.type) {\n          case 'union':\n            {\n              // UNION - included iff:\n              //  * On one side of us there is 0 poly interiors AND\n              //  * On the other side there is 1 or more.\n              var noBefores = mpsBefore.length === 0;\n              var noAfters = mpsAfter.length === 0;\n              this._isInResult = noBefores !== noAfters;\n              break;\n            }\n\n          case 'intersection':\n            {\n              // INTERSECTION - included iff:\n              //  * on one side of us all multipolys are rep. with poly interiors AND\n              //  * on the other side of us, not all multipolys are repsented\n              //    with poly interiors\n              var least;\n              var most;\n\n              if (mpsBefore.length < mpsAfter.length) {\n                least = mpsBefore.length;\n                most = mpsAfter.length;\n              } else {\n                least = mpsAfter.length;\n                most = mpsBefore.length;\n              }\n\n              this._isInResult = most === operation.numMultiPolys && least < most;\n              break;\n            }\n\n          case 'xor':\n            {\n              // XOR - included iff:\n              //  * the difference between the number of multipolys represented\n              //    with poly interiors on our two sides is an odd number\n              var diff = Math.abs(mpsBefore.length - mpsAfter.length);\n              this._isInResult = diff % 2 === 1;\n              break;\n            }\n\n          case 'difference':\n            {\n              // DIFFERENCE included iff:\n              //  * on exactly one side, we have just the subject\n              var isJustSubject = function isJustSubject(mps) {\n                return mps.length === 1 && mps[0].isSubject;\n              };\n\n              this._isInResult = isJustSubject(mpsBefore) !== isJustSubject(mpsAfter);\n              break;\n            }\n\n          default:\n            throw new Error(\"Unrecognized operation type found \".concat(operation.type));\n        }\n\n        return this._isInResult;\n      }\n    }], [{\n      key: \"fromRing\",\n      value: function fromRing(pt1, pt2, ring) {\n        var leftPt, rightPt, winding; // ordering the two points according to sweep line ordering\n\n        var cmpPts = SweepEvent.comparePoints(pt1, pt2);\n\n        if (cmpPts < 0) {\n          leftPt = pt1;\n          rightPt = pt2;\n          winding = 1;\n        } else if (cmpPts > 0) {\n          leftPt = pt2;\n          rightPt = pt1;\n          winding = -1;\n        } else throw new Error(\"Tried to create degenerate segment at [\".concat(pt1.x, \", \").concat(pt1.y, \"]\"));\n\n        var leftSE = new SweepEvent(leftPt, true);\n        var rightSE = new SweepEvent(rightPt, false);\n        return new Segment(leftSE, rightSE, [ring], [winding]);\n      }\n    }]);\n\n    return Segment;\n  }();\n\n  var RingIn = /*#__PURE__*/function () {\n    function RingIn(geomRing, poly, isExterior) {\n      _classCallCheck(this, RingIn);\n\n      if (!Array.isArray(geomRing) || geomRing.length === 0) {\n        throw new Error('Input geometry is not a valid Polygon or MultiPolygon');\n      }\n\n      this.poly = poly;\n      this.isExterior = isExterior;\n      this.segments = [];\n\n      if (typeof geomRing[0][0] !== 'number' || typeof geomRing[0][1] !== 'number') {\n        throw new Error('Input geometry is not a valid Polygon or MultiPolygon');\n      }\n\n      var firstPoint = rounder.round(geomRing[0][0], geomRing[0][1]);\n      this.bbox = {\n        ll: {\n          x: firstPoint.x,\n          y: firstPoint.y\n        },\n        ur: {\n          x: firstPoint.x,\n          y: firstPoint.y\n        }\n      };\n      var prevPoint = firstPoint;\n\n      for (var i = 1, iMax = geomRing.length; i < iMax; i++) {\n        if (typeof geomRing[i][0] !== 'number' || typeof geomRing[i][1] !== 'number') {\n          throw new Error('Input geometry is not a valid Polygon or MultiPolygon');\n        }\n\n        var point = rounder.round(geomRing[i][0], geomRing[i][1]); // skip repeated points\n\n        if (point.x === prevPoint.x && point.y === prevPoint.y) continue;\n        this.segments.push(Segment.fromRing(prevPoint, point, this));\n        if (point.x < this.bbox.ll.x) this.bbox.ll.x = point.x;\n        if (point.y < this.bbox.ll.y) this.bbox.ll.y = point.y;\n        if (point.x > this.bbox.ur.x) this.bbox.ur.x = point.x;\n        if (point.y > this.bbox.ur.y) this.bbox.ur.y = point.y;\n        prevPoint = point;\n      } // add segment from last to first if last is not the same as first\n\n\n      if (firstPoint.x !== prevPoint.x || firstPoint.y !== prevPoint.y) {\n        this.segments.push(Segment.fromRing(prevPoint, firstPoint, this));\n      }\n    }\n\n    _createClass(RingIn, [{\n      key: \"getSweepEvents\",\n      value: function getSweepEvents() {\n        var sweepEvents = [];\n\n        for (var i = 0, iMax = this.segments.length; i < iMax; i++) {\n          var segment = this.segments[i];\n          sweepEvents.push(segment.leftSE);\n          sweepEvents.push(segment.rightSE);\n        }\n\n        return sweepEvents;\n      }\n    }]);\n\n    return RingIn;\n  }();\n  var PolyIn = /*#__PURE__*/function () {\n    function PolyIn(geomPoly, multiPoly) {\n      _classCallCheck(this, PolyIn);\n\n      if (!Array.isArray(geomPoly)) {\n        throw new Error('Input geometry is not a valid Polygon or MultiPolygon');\n      }\n\n      this.exteriorRing = new RingIn(geomPoly[0], this, true); // copy by value\n\n      this.bbox = {\n        ll: {\n          x: this.exteriorRing.bbox.ll.x,\n          y: this.exteriorRing.bbox.ll.y\n        },\n        ur: {\n          x: this.exteriorRing.bbox.ur.x,\n          y: this.exteriorRing.bbox.ur.y\n        }\n      };\n      this.interiorRings = [];\n\n      for (var i = 1, iMax = geomPoly.length; i < iMax; i++) {\n        var ring = new RingIn(geomPoly[i], this, false);\n        if (ring.bbox.ll.x < this.bbox.ll.x) this.bbox.ll.x = ring.bbox.ll.x;\n        if (ring.bbox.ll.y < this.bbox.ll.y) this.bbox.ll.y = ring.bbox.ll.y;\n        if (ring.bbox.ur.x > this.bbox.ur.x) this.bbox.ur.x = ring.bbox.ur.x;\n        if (ring.bbox.ur.y > this.bbox.ur.y) this.bbox.ur.y = ring.bbox.ur.y;\n        this.interiorRings.push(ring);\n      }\n\n      this.multiPoly = multiPoly;\n    }\n\n    _createClass(PolyIn, [{\n      key: \"getSweepEvents\",\n      value: function getSweepEvents() {\n        var sweepEvents = this.exteriorRing.getSweepEvents();\n\n        for (var i = 0, iMax = this.interiorRings.length; i < iMax; i++) {\n          var ringSweepEvents = this.interiorRings[i].getSweepEvents();\n\n          for (var j = 0, jMax = ringSweepEvents.length; j < jMax; j++) {\n            sweepEvents.push(ringSweepEvents[j]);\n          }\n        }\n\n        return sweepEvents;\n      }\n    }]);\n\n    return PolyIn;\n  }();\n  var MultiPolyIn = /*#__PURE__*/function () {\n    function MultiPolyIn(geom, isSubject) {\n      _classCallCheck(this, MultiPolyIn);\n\n      if (!Array.isArray(geom)) {\n        throw new Error('Input geometry is not a valid Polygon or MultiPolygon');\n      }\n\n      try {\n        // if the input looks like a polygon, convert it to a multipolygon\n        if (typeof geom[0][0][0] === 'number') geom = [geom];\n      } catch (ex) {// The input is either malformed or has empty arrays.\n        // In either case, it will be handled later on.\n      }\n\n      this.polys = [];\n      this.bbox = {\n        ll: {\n          x: Number.POSITIVE_INFINITY,\n          y: Number.POSITIVE_INFINITY\n        },\n        ur: {\n          x: Number.NEGATIVE_INFINITY,\n          y: Number.NEGATIVE_INFINITY\n        }\n      };\n\n      for (var i = 0, iMax = geom.length; i < iMax; i++) {\n        var poly = new PolyIn(geom[i], this);\n        if (poly.bbox.ll.x < this.bbox.ll.x) this.bbox.ll.x = poly.bbox.ll.x;\n        if (poly.bbox.ll.y < this.bbox.ll.y) this.bbox.ll.y = poly.bbox.ll.y;\n        if (poly.bbox.ur.x > this.bbox.ur.x) this.bbox.ur.x = poly.bbox.ur.x;\n        if (poly.bbox.ur.y > this.bbox.ur.y) this.bbox.ur.y = poly.bbox.ur.y;\n        this.polys.push(poly);\n      }\n\n      this.isSubject = isSubject;\n    }\n\n    _createClass(MultiPolyIn, [{\n      key: \"getSweepEvents\",\n      value: function getSweepEvents() {\n        var sweepEvents = [];\n\n        for (var i = 0, iMax = this.polys.length; i < iMax; i++) {\n          var polySweepEvents = this.polys[i].getSweepEvents();\n\n          for (var j = 0, jMax = polySweepEvents.length; j < jMax; j++) {\n            sweepEvents.push(polySweepEvents[j]);\n          }\n        }\n\n        return sweepEvents;\n      }\n    }]);\n\n    return MultiPolyIn;\n  }();\n\n  var RingOut = /*#__PURE__*/function () {\n    _createClass(RingOut, null, [{\n      key: \"factory\",\n\n      /* Given the segments from the sweep line pass, compute & return a series\n       * of closed rings from all the segments marked to be part of the result */\n      value: function factory(allSegments) {\n        var ringsOut = [];\n\n        for (var i = 0, iMax = allSegments.length; i < iMax; i++) {\n          var segment = allSegments[i];\n          if (!segment.isInResult() || segment.ringOut) continue;\n          var prevEvent = null;\n          var event = segment.leftSE;\n          var nextEvent = segment.rightSE;\n          var events = [event];\n          var startingPoint = event.point;\n          var intersectionLEs = [];\n          /* Walk the chain of linked events to form a closed ring */\n\n          while (true) {\n            prevEvent = event;\n            event = nextEvent;\n            events.push(event);\n            /* Is the ring complete? */\n\n            if (event.point === startingPoint) break;\n\n            while (true) {\n              var availableLEs = event.getAvailableLinkedEvents();\n              /* Did we hit a dead end? This shouldn't happen. Indicates some earlier\n               * part of the algorithm malfunctioned... please file a bug report. */\n\n              if (availableLEs.length === 0) {\n                var firstPt = events[0].point;\n                var lastPt = events[events.length - 1].point;\n                throw new Error(\"Unable to complete output ring starting at [\".concat(firstPt.x, \",\") + \" \".concat(firstPt.y, \"]. Last matching segment found ends at\") + \" [\".concat(lastPt.x, \", \").concat(lastPt.y, \"].\"));\n              }\n              /* Only one way to go, so cotinue on the path */\n\n\n              if (availableLEs.length === 1) {\n                nextEvent = availableLEs[0].otherSE;\n                break;\n              }\n              /* We must have an intersection. Check for a completed loop */\n\n\n              var indexLE = null;\n\n              for (var j = 0, jMax = intersectionLEs.length; j < jMax; j++) {\n                if (intersectionLEs[j].point === event.point) {\n                  indexLE = j;\n                  break;\n                }\n              }\n              /* Found a completed loop. Cut that off and make a ring */\n\n\n              if (indexLE !== null) {\n                var intersectionLE = intersectionLEs.splice(indexLE)[0];\n                var ringEvents = events.splice(intersectionLE.index);\n                ringEvents.unshift(ringEvents[0].otherSE);\n                ringsOut.push(new RingOut(ringEvents.reverse()));\n                continue;\n              }\n              /* register the intersection */\n\n\n              intersectionLEs.push({\n                index: events.length,\n                point: event.point\n              });\n              /* Choose the left-most option to continue the walk */\n\n              var comparator = event.getLeftmostComparator(prevEvent);\n              nextEvent = availableLEs.sort(comparator)[0].otherSE;\n              break;\n            }\n          }\n\n          ringsOut.push(new RingOut(events));\n        }\n\n        return ringsOut;\n      }\n    }]);\n\n    function RingOut(events) {\n      _classCallCheck(this, RingOut);\n\n      this.events = events;\n\n      for (var i = 0, iMax = events.length; i < iMax; i++) {\n        events[i].segment.ringOut = this;\n      }\n\n      this.poly = null;\n    }\n\n    _createClass(RingOut, [{\n      key: \"getGeom\",\n      value: function getGeom() {\n        // Remove superfluous points (ie extra points along a straight line),\n        var prevPt = this.events[0].point;\n        var points = [prevPt];\n\n        for (var i = 1, iMax = this.events.length - 1; i < iMax; i++) {\n          var _pt = this.events[i].point;\n          var _nextPt = this.events[i + 1].point;\n          if (compareVectorAngles(_pt, prevPt, _nextPt) === 0) continue;\n          points.push(_pt);\n          prevPt = _pt;\n        } // ring was all (within rounding error of angle calc) colinear points\n\n\n        if (points.length === 1) return null; // check if the starting point is necessary\n\n        var pt = points[0];\n        var nextPt = points[1];\n        if (compareVectorAngles(pt, prevPt, nextPt) === 0) points.shift();\n        points.push(points[0]);\n        var step = this.isExteriorRing() ? 1 : -1;\n        var iStart = this.isExteriorRing() ? 0 : points.length - 1;\n        var iEnd = this.isExteriorRing() ? points.length : -1;\n        var orderedPoints = [];\n\n        for (var _i = iStart; _i != iEnd; _i += step) {\n          orderedPoints.push([points[_i].x, points[_i].y]);\n        }\n\n        return orderedPoints;\n      }\n    }, {\n      key: \"isExteriorRing\",\n      value: function isExteriorRing() {\n        if (this._isExteriorRing === undefined) {\n          var enclosing = this.enclosingRing();\n          this._isExteriorRing = enclosing ? !enclosing.isExteriorRing() : true;\n        }\n\n        return this._isExteriorRing;\n      }\n    }, {\n      key: \"enclosingRing\",\n      value: function enclosingRing() {\n        if (this._enclosingRing === undefined) {\n          this._enclosingRing = this._calcEnclosingRing();\n        }\n\n        return this._enclosingRing;\n      }\n      /* Returns the ring that encloses this one, if any */\n\n    }, {\n      key: \"_calcEnclosingRing\",\n      value: function _calcEnclosingRing() {\n        // start with the ealier sweep line event so that the prevSeg\n        // chain doesn't lead us inside of a loop of ours\n        var leftMostEvt = this.events[0];\n\n        for (var i = 1, iMax = this.events.length; i < iMax; i++) {\n          var evt = this.events[i];\n          if (SweepEvent.compare(leftMostEvt, evt) > 0) leftMostEvt = evt;\n        }\n\n        var prevSeg = leftMostEvt.segment.prevInResult();\n        var prevPrevSeg = prevSeg ? prevSeg.prevInResult() : null;\n\n        while (true) {\n          // no segment found, thus no ring can enclose us\n          if (!prevSeg) return null; // no segments below prev segment found, thus the ring of the prev\n          // segment must loop back around and enclose us\n\n          if (!prevPrevSeg) return prevSeg.ringOut; // if the two segments are of different rings, the ring of the prev\n          // segment must either loop around us or the ring of the prev prev\n          // seg, which would make us and the ring of the prev peers\n\n          if (prevPrevSeg.ringOut !== prevSeg.ringOut) {\n            if (prevPrevSeg.ringOut.enclosingRing() !== prevSeg.ringOut) {\n              return prevSeg.ringOut;\n            } else return prevSeg.ringOut.enclosingRing();\n          } // two segments are from the same ring, so this was a penisula\n          // of that ring. iterate downward, keep searching\n\n\n          prevSeg = prevPrevSeg.prevInResult();\n          prevPrevSeg = prevSeg ? prevSeg.prevInResult() : null;\n        }\n      }\n    }]);\n\n    return RingOut;\n  }();\n  var PolyOut = /*#__PURE__*/function () {\n    function PolyOut(exteriorRing) {\n      _classCallCheck(this, PolyOut);\n\n      this.exteriorRing = exteriorRing;\n      exteriorRing.poly = this;\n      this.interiorRings = [];\n    }\n\n    _createClass(PolyOut, [{\n      key: \"addInterior\",\n      value: function addInterior(ring) {\n        this.interiorRings.push(ring);\n        ring.poly = this;\n      }\n    }, {\n      key: \"getGeom\",\n      value: function getGeom() {\n        var geom = [this.exteriorRing.getGeom()]; // exterior ring was all (within rounding error of angle calc) colinear points\n\n        if (geom[0] === null) return null;\n\n        for (var i = 0, iMax = this.interiorRings.length; i < iMax; i++) {\n          var ringGeom = this.interiorRings[i].getGeom(); // interior ring was all (within rounding error of angle calc) colinear points\n\n          if (ringGeom === null) continue;\n          geom.push(ringGeom);\n        }\n\n        return geom;\n      }\n    }]);\n\n    return PolyOut;\n  }();\n  var MultiPolyOut = /*#__PURE__*/function () {\n    function MultiPolyOut(rings) {\n      _classCallCheck(this, MultiPolyOut);\n\n      this.rings = rings;\n      this.polys = this._composePolys(rings);\n    }\n\n    _createClass(MultiPolyOut, [{\n      key: \"getGeom\",\n      value: function getGeom() {\n        var geom = [];\n\n        for (var i = 0, iMax = this.polys.length; i < iMax; i++) {\n          var polyGeom = this.polys[i].getGeom(); // exterior ring was all (within rounding error of angle calc) colinear points\n\n          if (polyGeom === null) continue;\n          geom.push(polyGeom);\n        }\n\n        return geom;\n      }\n    }, {\n      key: \"_composePolys\",\n      value: function _composePolys(rings) {\n        var polys = [];\n\n        for (var i = 0, iMax = rings.length; i < iMax; i++) {\n          var ring = rings[i];\n          if (ring.poly) continue;\n          if (ring.isExteriorRing()) polys.push(new PolyOut(ring));else {\n            var enclosingRing = ring.enclosingRing();\n            if (!enclosingRing.poly) polys.push(new PolyOut(enclosingRing));\n            enclosingRing.poly.addInterior(ring);\n          }\n        }\n\n        return polys;\n      }\n    }]);\n\n    return MultiPolyOut;\n  }();\n\n  /**\n   * NOTE:  We must be careful not to change any segments while\n   *        they are in the SplayTree. AFAIK, there's no way to tell\n   *        the tree to rebalance itself - thus before splitting\n   *        a segment that's in the tree, we remove it from the tree,\n   *        do the split, then re-insert it. (Even though splitting a\n   *        segment *shouldn't* change its correct position in the\n   *        sweep line tree, the reality is because of rounding errors,\n   *        it sometimes does.)\n   */\n\n  var SweepLine = /*#__PURE__*/function () {\n    function SweepLine(queue) {\n      var comparator = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Segment.compare;\n\n      _classCallCheck(this, SweepLine);\n\n      this.queue = queue;\n      this.tree = new Tree(comparator);\n      this.segments = [];\n    }\n\n    _createClass(SweepLine, [{\n      key: \"process\",\n      value: function process(event) {\n        var segment = event.segment;\n        var newEvents = []; // if we've already been consumed by another segment,\n        // clean up our body parts and get out\n\n        if (event.consumedBy) {\n          if (event.isLeft) this.queue.remove(event.otherSE);else this.tree.remove(segment);\n          return newEvents;\n        }\n\n        var node = event.isLeft ? this.tree.insert(segment) : this.tree.find(segment);\n        if (!node) throw new Error(\"Unable to find segment #\".concat(segment.id, \" \") + \"[\".concat(segment.leftSE.point.x, \", \").concat(segment.leftSE.point.y, \"] -> \") + \"[\".concat(segment.rightSE.point.x, \", \").concat(segment.rightSE.point.y, \"] \") + 'in SweepLine tree. Please submit a bug report.');\n        var prevNode = node;\n        var nextNode = node;\n        var prevSeg = undefined;\n        var nextSeg = undefined; // skip consumed segments still in tree\n\n        while (prevSeg === undefined) {\n          prevNode = this.tree.prev(prevNode);\n          if (prevNode === null) prevSeg = null;else if (prevNode.key.consumedBy === undefined) prevSeg = prevNode.key;\n        } // skip consumed segments still in tree\n\n\n        while (nextSeg === undefined) {\n          nextNode = this.tree.next(nextNode);\n          if (nextNode === null) nextSeg = null;else if (nextNode.key.consumedBy === undefined) nextSeg = nextNode.key;\n        }\n\n        if (event.isLeft) {\n          // Check for intersections against the previous segment in the sweep line\n          var prevMySplitter = null;\n\n          if (prevSeg) {\n            var prevInter = prevSeg.getIntersection(segment);\n\n            if (prevInter !== null) {\n              if (!segment.isAnEndpoint(prevInter)) prevMySplitter = prevInter;\n\n              if (!prevSeg.isAnEndpoint(prevInter)) {\n                var newEventsFromSplit = this._splitSafely(prevSeg, prevInter);\n\n                for (var i = 0, iMax = newEventsFromSplit.length; i < iMax; i++) {\n                  newEvents.push(newEventsFromSplit[i]);\n                }\n              }\n            }\n          } // Check for intersections against the next segment in the sweep line\n\n\n          var nextMySplitter = null;\n\n          if (nextSeg) {\n            var nextInter = nextSeg.getIntersection(segment);\n\n            if (nextInter !== null) {\n              if (!segment.isAnEndpoint(nextInter)) nextMySplitter = nextInter;\n\n              if (!nextSeg.isAnEndpoint(nextInter)) {\n                var _newEventsFromSplit = this._splitSafely(nextSeg, nextInter);\n\n                for (var _i = 0, _iMax = _newEventsFromSplit.length; _i < _iMax; _i++) {\n                  newEvents.push(_newEventsFromSplit[_i]);\n                }\n              }\n            }\n          } // For simplicity, even if we find more than one intersection we only\n          // spilt on the 'earliest' (sweep-line style) of the intersections.\n          // The other intersection will be handled in a future process().\n\n\n          if (prevMySplitter !== null || nextMySplitter !== null) {\n            var mySplitter = null;\n            if (prevMySplitter === null) mySplitter = nextMySplitter;else if (nextMySplitter === null) mySplitter = prevMySplitter;else {\n              var cmpSplitters = SweepEvent.comparePoints(prevMySplitter, nextMySplitter);\n              mySplitter = cmpSplitters <= 0 ? prevMySplitter : nextMySplitter;\n            } // Rounding errors can cause changes in ordering,\n            // so remove afected segments and right sweep events before splitting\n\n            this.queue.remove(segment.rightSE);\n            newEvents.push(segment.rightSE);\n\n            var _newEventsFromSplit2 = segment.split(mySplitter);\n\n            for (var _i2 = 0, _iMax2 = _newEventsFromSplit2.length; _i2 < _iMax2; _i2++) {\n              newEvents.push(_newEventsFromSplit2[_i2]);\n            }\n          }\n\n          if (newEvents.length > 0) {\n            // We found some intersections, so re-do the current event to\n            // make sure sweep line ordering is totally consistent for later\n            // use with the segment 'prev' pointers\n            this.tree.remove(segment);\n            newEvents.push(event);\n          } else {\n            // done with left event\n            this.segments.push(segment);\n            segment.prev = prevSeg;\n          }\n        } else {\n          // event.isRight\n          // since we're about to be removed from the sweep line, check for\n          // intersections between our previous and next segments\n          if (prevSeg && nextSeg) {\n            var inter = prevSeg.getIntersection(nextSeg);\n\n            if (inter !== null) {\n              if (!prevSeg.isAnEndpoint(inter)) {\n                var _newEventsFromSplit3 = this._splitSafely(prevSeg, inter);\n\n                for (var _i3 = 0, _iMax3 = _newEventsFromSplit3.length; _i3 < _iMax3; _i3++) {\n                  newEvents.push(_newEventsFromSplit3[_i3]);\n                }\n              }\n\n              if (!nextSeg.isAnEndpoint(inter)) {\n                var _newEventsFromSplit4 = this._splitSafely(nextSeg, inter);\n\n                for (var _i4 = 0, _iMax4 = _newEventsFromSplit4.length; _i4 < _iMax4; _i4++) {\n                  newEvents.push(_newEventsFromSplit4[_i4]);\n                }\n              }\n            }\n          }\n\n          this.tree.remove(segment);\n        }\n\n        return newEvents;\n      }\n      /* Safely split a segment that is currently in the datastructures\n       * IE - a segment other than the one that is currently being processed. */\n\n    }, {\n      key: \"_splitSafely\",\n      value: function _splitSafely(seg, pt) {\n        // Rounding errors can cause changes in ordering,\n        // so remove afected segments and right sweep events before splitting\n        // removeNode() doesn't work, so have re-find the seg\n        // https://github.com/w8r/splay-tree/pull/5\n        this.tree.remove(seg);\n        var rightSE = seg.rightSE;\n        this.queue.remove(rightSE);\n        var newEvents = seg.split(pt);\n        newEvents.push(rightSE); // splitting can trigger consumption\n\n        if (seg.consumedBy === undefined) this.tree.insert(seg);\n        return newEvents;\n      }\n    }]);\n\n    return SweepLine;\n  }();\n\n  var POLYGON_CLIPPING_MAX_QUEUE_SIZE = typeof process !== 'undefined' && process.env.POLYGON_CLIPPING_MAX_QUEUE_SIZE || 1000000;\n  var POLYGON_CLIPPING_MAX_SWEEPLINE_SEGMENTS = typeof process !== 'undefined' && process.env.POLYGON_CLIPPING_MAX_SWEEPLINE_SEGMENTS || 1000000;\n  var Operation = /*#__PURE__*/function () {\n    function Operation() {\n      _classCallCheck(this, Operation);\n    }\n\n    _createClass(Operation, [{\n      key: \"run\",\n      value: function run(type, geom, moreGeoms) {\n        operation.type = type;\n        rounder.reset();\n        /* Convert inputs to MultiPoly objects */\n\n        var multipolys = [new MultiPolyIn(geom, true)];\n\n        for (var i = 0, iMax = moreGeoms.length; i < iMax; i++) {\n          multipolys.push(new MultiPolyIn(moreGeoms[i], false));\n        }\n\n        operation.numMultiPolys = multipolys.length;\n        /* BBox optimization for difference operation\n         * If the bbox of a multipolygon that's part of the clipping doesn't\n         * intersect the bbox of the subject at all, we can just drop that\n         * multiploygon. */\n\n        if (operation.type === 'difference') {\n          // in place removal\n          var subject = multipolys[0];\n          var _i = 1;\n\n          while (_i < multipolys.length) {\n            if (getBboxOverlap(multipolys[_i].bbox, subject.bbox) !== null) _i++;else multipolys.splice(_i, 1);\n          }\n        }\n        /* BBox optimization for intersection operation\n         * If we can find any pair of multipolygons whose bbox does not overlap,\n         * then the result will be empty. */\n\n\n        if (operation.type === 'intersection') {\n          // TODO: this is O(n^2) in number of polygons. By sorting the bboxes,\n          //       it could be optimized to O(n * ln(n))\n          for (var _i2 = 0, _iMax = multipolys.length; _i2 < _iMax; _i2++) {\n            var mpA = multipolys[_i2];\n\n            for (var j = _i2 + 1, jMax = multipolys.length; j < jMax; j++) {\n              if (getBboxOverlap(mpA.bbox, multipolys[j].bbox) === null) return [];\n            }\n          }\n        }\n        /* Put segment endpoints in a priority queue */\n\n\n        var queue = new Tree(SweepEvent.compare);\n\n        for (var _i3 = 0, _iMax2 = multipolys.length; _i3 < _iMax2; _i3++) {\n          var sweepEvents = multipolys[_i3].getSweepEvents();\n\n          for (var _j = 0, _jMax = sweepEvents.length; _j < _jMax; _j++) {\n            queue.insert(sweepEvents[_j]);\n\n            if (queue.size > POLYGON_CLIPPING_MAX_QUEUE_SIZE) {\n              // prevents an infinite loop, an otherwise common manifestation of bugs\n              throw new Error('Infinite loop when putting segment endpoints in a priority queue ' + '(queue size too big). Please file a bug report.');\n            }\n          }\n        }\n        /* Pass the sweep line over those endpoints */\n\n\n        var sweepLine = new SweepLine(queue);\n        var prevQueueSize = queue.size;\n        var node = queue.pop();\n\n        while (node) {\n          var evt = node.key;\n\n          if (queue.size === prevQueueSize) {\n            // prevents an infinite loop, an otherwise common manifestation of bugs\n            var seg = evt.segment;\n            throw new Error(\"Unable to pop() \".concat(evt.isLeft ? 'left' : 'right', \" SweepEvent \") + \"[\".concat(evt.point.x, \", \").concat(evt.point.y, \"] from segment #\").concat(seg.id, \" \") + \"[\".concat(seg.leftSE.point.x, \", \").concat(seg.leftSE.point.y, \"] -> \") + \"[\".concat(seg.rightSE.point.x, \", \").concat(seg.rightSE.point.y, \"] from queue. \") + 'Please file a bug report.');\n          }\n\n          if (queue.size > POLYGON_CLIPPING_MAX_QUEUE_SIZE) {\n            // prevents an infinite loop, an otherwise common manifestation of bugs\n            throw new Error('Infinite loop when passing sweep line over endpoints ' + '(queue size too big). Please file a bug report.');\n          }\n\n          if (sweepLine.segments.length > POLYGON_CLIPPING_MAX_SWEEPLINE_SEGMENTS) {\n            // prevents an infinite loop, an otherwise common manifestation of bugs\n            throw new Error('Infinite loop when passing sweep line over endpoints ' + '(too many sweep line segments). Please file a bug report.');\n          }\n\n          var newEvents = sweepLine.process(evt);\n\n          for (var _i4 = 0, _iMax3 = newEvents.length; _i4 < _iMax3; _i4++) {\n            var _evt = newEvents[_i4];\n            if (_evt.consumedBy === undefined) queue.insert(_evt);\n          }\n\n          prevQueueSize = queue.size;\n          node = queue.pop();\n        } // free some memory we don't need anymore\n\n\n        rounder.reset();\n        /* Collect and compile segments we're keeping into a multipolygon */\n\n        var ringsOut = RingOut.factory(sweepLine.segments);\n        var result = new MultiPolyOut(ringsOut);\n        return result.getGeom();\n      }\n    }]);\n\n    return Operation;\n  }(); // singleton available by import\n\n  var operation = new Operation();\n\n  var union = function union(geom) {\n    for (var _len = arguments.length, moreGeoms = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      moreGeoms[_key - 1] = arguments[_key];\n    }\n\n    return operation.run('union', geom, moreGeoms);\n  };\n\n  var intersection$1 = function intersection(geom) {\n    for (var _len2 = arguments.length, moreGeoms = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n      moreGeoms[_key2 - 1] = arguments[_key2];\n    }\n\n    return operation.run('intersection', geom, moreGeoms);\n  };\n\n  var xor = function xor(geom) {\n    for (var _len3 = arguments.length, moreGeoms = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {\n      moreGeoms[_key3 - 1] = arguments[_key3];\n    }\n\n    return operation.run('xor', geom, moreGeoms);\n  };\n\n  var difference = function difference(subjectGeom) {\n    for (var _len4 = arguments.length, clippingGeoms = new Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {\n      clippingGeoms[_key4 - 1] = arguments[_key4];\n    }\n\n    return operation.run('difference', subjectGeom, clippingGeoms);\n  };\n\n  var index = {\n    union: union,\n    intersection: intersection$1,\n    xor: xor,\n    difference: difference\n  };\n\n  return index;\n\n})));\n"],"names":["module","exports","_classCallCheck","instance","Constructor","TypeError","_defineProperties","target","props","i","length","descriptor","enumerable","configurable","writable","Object","defineProperty","key","_createClass","protoProps","staticProps","prototype","Node","data","this","next","left","right","DEFAULT_COMPARE","a","b","splay","t","comparator","N","l","r","cmp","y","insert","node","split","v","merge","printRow","root","prefix","isTail","out","printNode","indent","Tree","_root","_size","_comparator","add","remove","_remove","x","pop","findStatic","current","compare","find","contains","forEach","visitor","ctx","Q","done","push","call","range","low","high","fn","keys","_a","values","min","minNode","max","maxNode","at","index","d","successor","prev","predecessor","clear","toList","load","presort","size","sort","loadRecursive","mergedList","mergeLists","createList","sortedListToBST","head","isEmpty","get","toString","n","String","join","update","newKey","newData","start","end","middle","Math","floor","p","list","l1","l2","p1","p2","pivot","j","tmp","isInBbox","bbox","point","ll","ur","getBboxOverlap","b1","b2","lowerX","upperX","epsilon","Number","EPSILON","undefined","pow","EPSILON_SQ","ab","PtRounder","reset","value","xRounder","CoordRounder","yRounder","round","tree","coord","prevNode","nextNode","rounder","crossProduct","dotProduct","compareVectorAngles","basePt","endPt1","endPt2","v1","v2","kross","sqrt","sineOfAngle","pShared","pBase","pAngle","vBase","vAngle","cosineOfAngle","horizontalIntersection","pt","verticalIntersection","intersection","pt1","pt2","ve","d1","d2","SweepEvent","isLeft","events","ptCmp","comparePoints","link","Segment","segment","aPt","bPt","other","Error","otherEvents","iMax","evt","checkForConsuming","numEvents","evt1","consumedBy","evt2","otherSE","consume","ringOut","isInResult","baseEvent","_this","cache","Map","fillCache","linkedEvent","nextEvent","set","sine","cosine","has","_cache$get","asine","acosine","_cache$get2","bsine","bcosine","segmentId","leftSE","rightSE","rings","windings","id","alx","blx","arx","brx","aly","bly","ary","bry","aCmpBLeft","comparePoint","bCmpARight","bCmpALeft","aCmpBRight","_bCmpARight","_aCmpBRight","ay","ax","by","bx","newRightSE","y1","y2","isAnEndpoint","lPt","rPt","vector","yDist","xFromYDist","xDist","yFromXDist","tBbox","oBbox","bboxOverlap","tlp","trp","olp","orp","touchesOtherLSE","touchesThisLSE","touchesOtherRSE","touchesThisRSE","newEvents","alreadyLinked","newLeftSE","oldRightSE","replaceRightSE","newSeg","slice","swapEvents","tmpEvt","consumer","consumee","_tmp","ring","winding","indexOf","_prevInResult","prevInResult","_beforeState","seg","afterState","multiPolys","_afterState","beforeState","ringsAfter","windingsAfter","mpsAfter","polysAfter","polysExclude","_i","_iMax","_ring","poly","isExterior","_index","splice","_i2","_iMax2","mp","multiPoly","_isInResult","mpsBefore","operation","type","noBefores","noAfters","least","most","numMultiPolys","diff","abs","isJustSubject","mps","isSubject","concat","leftPt","rightPt","cmpPts","RingIn","geomRing","Array","isArray","segments","firstPoint","prevPoint","fromRing","sweepEvents","PolyIn","geomPoly","exteriorRing","interiorRings","getSweepEvents","ringSweepEvents","jMax","MultiPolyIn","geom","ex","polys","POSITIVE_INFINITY","NEGATIVE_INFINITY","polySweepEvents","RingOut","allSegments","ringsOut","prevEvent","event","startingPoint","intersectionLEs","availableLEs","getAvailableLinkedEvents","firstPt","lastPt","indexLE","getLeftmostComparator","intersectionLE","ringEvents","unshift","reverse","prevPt","points","_pt","_nextPt","nextPt","shift","step","isExteriorRing","iStart","iEnd","orderedPoints","_isExteriorRing","enclosing","enclosingRing","_enclosingRing","_calcEnclosingRing","leftMostEvt","prevSeg","prevPrevSeg","PolyOut","getGeom","ringGeom","MultiPolyOut","_composePolys","polyGeom","addInterior","SweepLine","queue","arguments","nextSeg","prevMySplitter","prevInter","getIntersection","newEventsFromSplit","_splitSafely","nextMySplitter","nextInter","_newEventsFromSplit","mySplitter","_newEventsFromSplit2","inter","_newEventsFromSplit3","_i3","_iMax3","_newEventsFromSplit4","_i4","_iMax4","POLYGON_CLIPPING_MAX_QUEUE_SIZE","process","POLYGON_CLIPPING_MAX_SWEEPLINE_SEGMENTS","Operation","moreGeoms","multipolys","subject","mpA","_j","_jMax","sweepLine","prevQueueSize","_evt","factory","union","_len","_key","run","intersection$1","_len2","_key2","xor","_len3","_key3","difference","subjectGeom","_len4","clippingGeoms","_key4"],"sourceRoot":""}