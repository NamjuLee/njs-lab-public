{"version":3,"file":"static/js/7154.c73c1fa0.chunk.js","mappings":"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","sources":["njslab/Tools/GameOfLife/index.ts"],"sourcesContent":["import { PARAM } from 'App';\r\nimport { RendererCanvas } from '../../../lib'\r\n\r\n\r\nconst getSlider = (title: string, min: number, max: number) => {\r\n    // <input type=\"range\" min=\"1\" max=\"100\" value=\"50\" class=\"slider\" id=\"myRange\">\r\n    const div = document.createElement('div');\r\n    div.style.display = 'flex';\r\n\r\n    const slider = document.createElement('input');\r\n    slider.type = 'range';\r\n    slider.min = `${min}`;\r\n    slider.max = `${max}`;\r\n\r\n    const text = document.createElement('div');\r\n    text.textContent = title;\r\n    text.style.color = '#aaa';\r\n    div.appendChild(slider);\r\n    div.appendChild(text);\r\n\r\n    return {\r\n        div, slider\r\n    }\r\n};\r\nconst getCheckBox = (title: string) => {\r\n    const div = document.createElement('div');\r\n    div.style.display = 'flex';\r\n\r\n    const checkBox = document.createElement('input');\r\n    checkBox.type = 'checkbox';\r\n    checkBox.defaultChecked = false;\r\n    const text = document.createElement('div');\r\n    text.textContent = title;\r\n    text.style.color = '#aaa';\r\n    div.appendChild(checkBox);\r\n    div.appendChild(text);\r\n\r\n    return {\r\n        div, checkBox\r\n    }\r\n};\r\n\r\nexport class Solution {\r\n    public divHost: HTMLElement;\r\n    public renderer: Renderer;\r\n\r\n    constructor(divHost: any) {\r\n        this.divHost = divHost;\r\n\r\n        // Center align\r\n        this.divHost.style.display = 'flex';\r\n        this.divHost.style.alignItems = 'center';\r\n\r\n        const div = document.createElement('div');\r\n        div.style.marginLeft = 'auto';\r\n        div.style.marginRight = 'auto';\r\n        div.style.backgroundColor = '#555';\r\n        div.style.width = '1000px';\r\n        div.style.height = '600px';\r\n        this.divHost.appendChild(div);\r\n\r\n        // if (PARAM.demo) {\r\n            this.renderer = new Renderer(div);\r\n\r\n            let btn = document.createElement('div');\r\n            div.appendChild(btn);\r\n            btn.textContent = 'Reset';\r\n            btn.onclick = () => {\r\n                this.renderer.Build();\r\n            };\r\n       \r\n\r\n            btn = document.createElement('div');\r\n            div.appendChild(btn);\r\n            btn.textContent = 'Play and Stop toggle';\r\n            btn.onclick = () => {\r\n                this.renderer.playToggle = !this.renderer.playToggle;\r\n            };\r\n\r\n        // }\r\n    }\r\n    public destroy() {\r\n        this.renderer.destroy();\r\n        while (this.divHost.lastElementChild) {\r\n            this.divHost.removeChild(this.divHost.lastElementChild);\r\n        }\r\n    }\r\n}\r\n\r\nconst renderCell = (ctx: CanvasRenderingContext2D, node: Node, col: string, cellSize: number) => {\r\n    ctx.fillStyle = col;\r\n    ctx.beginPath();\r\n    ctx.rect(node.x * cellSize, node.y * cellSize, cellSize - 1, cellSize - 1);\r\n    ctx.closePath();\r\n    ctx.fill();\r\n};\r\n\r\nexport class Renderer extends RendererCanvas {\r\n    w: number = 0;\r\n    h: number = 0;\r\n    cols: number = 0;\r\n    rows: number = 0;\r\n    cellSize: number = 20;\r\n    gridWidth: number = 0;\r\n    gridHeight: number = 0;\r\n    chanceOfWalls: number = 0.15;\r\n    connectionDiagonal = true\r\n\r\n    graph: PixelMap;\r\n\r\n    playToggle = true;\r\n\r\n    frame = 0;\r\n    public divTextIteration: HTMLDivElement;\r\n\r\n    constructor(div: any) {\r\n        super(div);\r\n        this.canvas.style.position = 'relative';\r\n        this.canvas.style.width = '100%';\r\n        this.canvas.style.height = '100%';\r\n\r\n        // TODO\r\n        // You code goes here for one time operation\r\n        this.divTextIteration = document.createElement('div');\r\n        div.appendChild(this.divTextIteration);\r\n\r\n        this.Build();\r\n        this.start();\r\n    }\r\n    public update() {\r\n        for (let i = 0; i < this.cols; i++) {\r\n            for (let j = 0; j < this.rows; j++) {\r\n                const node = this.graph.grid[i][j];\r\n                node.count = 0\r\n                for (let k = 0; k < node.neighbors.length; k++) {\r\n                    if (node.neighbors[k].alive) {\r\n                        node.count++;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        for (let i = 0; i < this.cols; i++) {\r\n            for (let j = 0; j < this.rows; j++) {\r\n                const node = this.graph.grid[i][j];\r\n                if (!node.alive){\r\n                    if(node.count === 3) {\r\n                        node.alive = true; \r\n                    } \r\n                } else {\r\n                    if (node.count < 2) {\r\n                        node.alive = false\r\n                    } else if( 1 < node.count && node.count < 4) {\r\n                        node.alive = true; \r\n                    } else if (node.count > 3) {\r\n                        node.alive = false\r\n                    }\r\n\r\n                    \r\n                }\r\n            }\r\n        }\r\n    }\r\n    public render(ctx: CanvasRenderingContext2D): void {\r\n        if (this.playToggle) {\r\n            // const result = this.graph.propagation();\r\n            this.divTextIteration.textContent = `${this.frame++} iterations`;\r\n        }\r\n        // const result = this.graph.gePath();\r\n        if (this.graph.doneComputation) { this.Build(); }\r\n        // console.log(result)\r\n\r\n        if (this.frame % 10 === 0) {\r\n            this.update();\r\n        }\r\n\r\n        for (let i = 0; i < this.cols; i++) {\r\n            for (let j = 0; j < this.rows; j++) {\r\n                const node = this.graph.grid[i][j];\r\n                let color = 'rgb(255, 255, 255)';\r\n\r\n                if (node.blocked) { color = `rgba(0, 0, 0, 0.9)`; }\r\n                if (node === this.graph.endNode) { color = `rgba(255, 0, 255, 0.9)`; }\r\n                if (node.alive) { color = `rgba(0, 0, 0, 1)`; }\r\n\r\n                renderCell(ctx, node, color, this.cellSize);\r\n\r\n            }\r\n        }\r\n\r\n        for (let i = 0; i < this.graph.openNodes.length; i++) { // render open nodes\r\n            const node = this.graph.openNodes[i];\r\n            const color = 'rgb(0, 0, 255)';\r\n            renderCell(ctx, node, color, this.cellSize);\r\n        }\r\n\r\n        for (let i = 0; i < this.graph.closedNodes.length; i++) { // visited nodes\r\n            const node = this.graph.closedNodes[i];\r\n            const color = 'rgb(255, 0, 0)';\r\n            renderCell(ctx, node, color, this.cellSize);\r\n        }\r\n\r\n        for (let i = 0; i < this.graph.path.length; i++) { // path\r\n            const node = this.graph.path[i];\r\n            const color = 'rgb(0, 255, 0)';\r\n            renderCell(ctx, node, color, this.cellSize);\r\n        }\r\n\r\n        // for (let i = 0; i < this.cols; i++) { // connection\r\n        //     for (let j = 0; j < this.rows; j++) {\r\n        //         const node = this.graph.grid[i][j];\r\n        //         if (node.blocked) { continue; }\r\n        //         for (let k = 0; k < node.neighbors.length; ++k) {\r\n        //             ctx.strokeStyle = '#fff';\r\n        //             ctx.lineWidth = 0.58;\r\n        //             ctx.beginPath();\r\n        //             ctx.moveTo(this.cellSize * node.x + this.cellSize * 0.5, this.cellSize * node.y + this.cellSize * 0.5);\r\n        //             ctx.lineTo(this.cellSize * node.neighbors[k].x + this.cellSize * 0.5, this.cellSize * node.neighbors[k].y + this.cellSize * 0.5);\r\n        //             ctx.stroke();\r\n        //         }\r\n\r\n        //     }\r\n        // }\r\n    }\r\n    public Build() {\r\n        this.frame = 0;\r\n        this.w = this.canvas.width;\r\n        this.h = this.canvas.height;\r\n        this.cols = Math.floor(this.w / this.cellSize);\r\n        this.rows = Math.floor(this.h / this.cellSize);\r\n        this.gridWidth = this.w;\r\n        this.gridHeight = this.h;\r\n\r\n\r\n        this.graph = new PixelMap();\r\n        this.graph.connectionDiagonal = this.connectionDiagonal;\r\n\r\n        //Build navigation grid\r\n        for (let i = 0; i < this.cols; i++) {\r\n            for (let j = 0; j < this.rows; j++) {\r\n                if (this.graph.grid[i] === undefined)\r\n                    this.graph.grid[i] = [];\r\n\r\n                const node = new Node(i, j);\r\n                if (Math.random() < this.chanceOfWalls) { node.alive = true; }\r\n                this.graph.grid[i][j] = node;\r\n            }\r\n        }\r\n\r\n        // this.graph.startNode = this.getRandomCell();\r\n        // this.graph.startNode.blocked = false;\r\n\r\n        // this.graph.endNode = this.getRandomCell();\r\n        // this.graph.endNode.blocked = false;\r\n\r\n        //find neighbors\r\n        for (let i = 0; i < this.cols; i++) {\r\n            for (let j = 0; j < this.rows; j++) {\r\n                this.graph.buildConnection(this.graph.grid[i][j], this.cols, this.rows);\r\n            }\r\n        }\r\n\r\n        // this.graph.openNodes.push(this.graph.startNode);\r\n\r\n    }\r\n}\r\n\r\nclass PixelMap {\r\n    public grid: Node[][] = [];\r\n    public openNodes: Node[] = [];\r\n    public closedNodes: Node[] = [];\r\n    public startNode: Node;\r\n    public endNode: Node;\r\n    public path: Node[] = [];\r\n    public heuristicConst = 1;\r\n    public doneComputation: boolean = false;\r\n    public connectionDiagonal = true;\r\n    // constructor() {\r\n    //     // TODO\r\n    // }\r\n    public buildConnection = (node: Node, cols: number, rows: number) => {\r\n        if (node.blocked) { return; }\r\n\r\n        let x = node.x;\r\n        let y = node.y;\r\n\r\n        if (x < cols - 1) {\r\n            if (!this.grid[x + 1][y].blocked) {\r\n                node.neighbors.push(this.grid[x + 1][y]);\r\n            } // right\r\n        }\r\n\r\n        if (y < rows - 1) {\r\n            if (!this.grid[x][y + 1].blocked) {\r\n                node.neighbors.push(this.grid[x][y + 1]);\r\n            } // bottom\r\n        }\r\n\r\n        if (x > 0) {\r\n            if (!this.grid[x - 1][y].blocked) {\r\n                node.neighbors.push(this.grid[x - 1][y]);\r\n            } // left\r\n        }\r\n\r\n        if (y > 0) {\r\n            if (!this.grid[x][y - 1].blocked) {\r\n                node.neighbors.push(this.grid[x][y - 1]);\r\n            } // top\r\n        }\r\n        if (this.connectionDiagonal) {\r\n            // console.log(this.connectionDiagonal);\r\n            if (x > 0 && y > 0) {\r\n                if (!this.grid[x - 1][y - 1].blocked) {\r\n                    node.neighbors.push(this.grid[x - 1][y - 1]);\r\n                }\r\n            } // left up\r\n            if (x < cols - 1 && y < rows - 1) {\r\n                if (!this.grid[x + 1][y + 1].blocked) {\r\n                    node.neighbors.push(this.grid[x + 1][y + 1]);\r\n                }\r\n            } // right bottom\r\n            if (x > 0 && y < rows - 1) {\r\n                if (!this.grid[x - 1][y + 1].blocked) {\r\n                    node.neighbors.push(this.grid[x - 1][y + 1]);\r\n                }\r\n            } // left bottom\r\n            if (x < cols - 1 && y > 0) {\r\n                if (!this.grid[x + 1][y - 1].blocked) {\r\n                    node.neighbors.push(this.grid[x + 1][y - 1]);\r\n                }\r\n            } // right top\r\n        }\r\n    }\r\n}\r\nclass Node {\r\n    public f = 0;\r\n    public h = 0;\r\n    public g = 0;\r\n\r\n    public x = 0;\r\n    public y = 0;\r\n    public z = 0;\r\n    public neighbors: Node[] = [];\r\n    public count = 0;\r\n    public alive = false;\r\n    public blocked = false;\r\n    constructor(x: number, y: number) {\r\n        this.f = 0;\r\n        this.h = 0;\r\n        this.g = 0;\r\n        this.x = x;\r\n        this.y = y;\r\n        this.neighbors = [];\r\n    }\r\n}\r\n\r\n"],"names":["Solution","constructor","divHost","renderer","this","style","display","alignItems","div","document","createElement","marginLeft","marginRight","backgroundColor","width","height","appendChild","Renderer","btn","textContent","onclick","Build","playToggle","destroy","lastElementChild","removeChild","renderCell","ctx","node","col","cellSize","fillStyle","beginPath","rect","x","y","closePath","fill","RendererCanvas","super","w","h","cols","rows","gridWidth","gridHeight","chanceOfWalls","connectionDiagonal","graph","frame","divTextIteration","canvas","position","start","update","i","j","grid","count","k","neighbors","length","alive","render","doneComputation","color","blocked","endNode","openNodes","closedNodes","path","Math","floor","PixelMap","undefined","Node","random","buildConnection","startNode","heuristicConst","push","f","g","z"],"sourceRoot":""}