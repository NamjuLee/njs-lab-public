{"version":3,"file":"static/js/5780.a60e3b97.chunk.js","mappings":"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","sources":["njslab/Tools/A-Start-Graph/index.ts"],"sourcesContent":["import { PARAM } from 'App';\r\nimport { RendererCanvas } from '../../../lib'\r\n\r\nexport class Solution {\r\n    public divHost: HTMLElement;\r\n    public renderer: Renderer;\r\n    constructor(divHost: any) {\r\n        this.divHost = divHost;\r\n\r\n\r\n        // Center align\r\n        this.divHost.style.display = 'flex';\r\n        this.divHost.style.alignItems = 'center';\r\n\r\n        const div = document.createElement('div');\r\n        div.style.marginLeft = 'auto';\r\n        div.style.marginRight = 'auto';\r\n        div.style.backgroundColor = '#555';\r\n        div.style.width = '1000px';\r\n        div.style.height = '600px';\r\n\r\n        this.divHost.appendChild(div);\r\n\r\n        // TODO\r\n        // You code goes here for one time operation\r\n\r\n        if (PARAM.demo){\r\n            this.renderer = new Renderer(div);\r\n        }\r\n\r\n        // console.log(this.renderer);\r\n        // !! you should execute it for rendering\r\n        // this.start();\r\n    }\r\n    public destroy() {\r\n        this.renderer.destroy();\r\n        while (this.divHost.lastElementChild) {\r\n            this.divHost.removeChild(this.divHost.lastElementChild);\r\n        }\r\n    }\r\n}\r\n\r\nconst renderCell = (ctx: CanvasRenderingContext2D, node: Node, col: string, cellSize: number) => {\r\n    ctx.fillStyle = col;\r\n    ctx.beginPath();\r\n    ctx.rect(node.x * cellSize, node.y * cellSize, cellSize - 1, cellSize - 1);\r\n    ctx.closePath();\r\n    ctx.fill();\r\n};\r\n\r\nexport class Renderer extends RendererCanvas {\r\n    w: number = 0;\r\n    h: number = 0;\r\n    cols: number = 0;\r\n    rows: number = 0;\r\n    cellSize: number = 20;\r\n    gridWidth: number = 0;\r\n    gridHeight: number = 0;\r\n    chanceOfWalls: number = 0.35;\r\n\r\n    graph: PixelMap;\r\n\r\n    constructor(div: any) {\r\n        super(div);\r\n        this.canvas.style.position = 'relative';\r\n        this.canvas.style.width = '100%';\r\n        this.canvas.style.height = '100%';\r\n\r\n        // TODO\r\n        // You code goes here for one time operation\r\n        // \r\n\r\n\r\n        this.Build();\r\n        this.start();\r\n    }\r\n    public render(ctx: CanvasRenderingContext2D): void {\r\n        const result = this.graph.propagation();\r\n        if (this.graph.doneComputation) { this.Build(); }\r\n\r\n        //iterate grid\r\n        for (let i = 0; i < this.cols; i++) {\r\n            for (let j = 0; j < this.rows; j++) {\r\n                const node = this.graph.grid[i][j];\r\n                let color = 'rgb(190, 190, 190)';\r\n\r\n                if (node.wall) { color = `rgba(0, 0, 0, 0.9)`; }\r\n                if (node === this.graph.endNode) { color = `rgba(255, 0, 255, 0.9)`; }\r\n\r\n                renderCell(ctx, node, color, this.cellSize);\r\n\r\n            }\r\n        }\r\n\r\n        for (let i = 0; i < this.graph.openNodes.length; i++) { // render open nodes\r\n            const node = this.graph.openNodes[i];\r\n            const color = 'rgb(0, 0, 255)';\r\n            renderCell(ctx, node, color, this.cellSize);\r\n        }\r\n\r\n        for (let i = 0; i < this.graph.closedNodes.length; i++) { // visited nodes\r\n            const node = this.graph.closedNodes[i];\r\n            const color = 'rgb(255, 0, 0)';\r\n            renderCell(ctx, node, color, this.cellSize);\r\n        }\r\n\r\n        for (let i = 0; i < this.graph.path.length; i++) { // path\r\n            const node = this.graph.path[i];\r\n            const color = 'rgb(0, 255, 0)';\r\n            renderCell(ctx, node, color, this.cellSize);\r\n        }\r\n\r\n        for (let i = 0; i < this.cols; i++) { // connection\r\n            for (let j = 0; j < this.rows; j++) {\r\n                const node = this.graph.grid[i][j];\r\n                for (let k = 0; k < node.neighbors.length; ++k) {\r\n                    ctx.strokeStyle = '#fff';\r\n                    ctx.lineWidth = 0.58;\r\n                    ctx.beginPath();\r\n                    ctx.moveTo(this.cellSize * node.x + this.cellSize * 0.5, this.cellSize * node.y + this.cellSize * 0.5);\r\n                    ctx.lineTo(this.cellSize * node.neighbors[k].x + this.cellSize * 0.5, this.cellSize * node.neighbors[k].y + this.cellSize * 0.5);\r\n                    ctx.stroke();\r\n                }\r\n\r\n            }\r\n        }\r\n    }\r\n    public Build() {\r\n        this.w = this.canvas.width;\r\n        this.h = this.canvas.height;\r\n        this.cols = Math.floor(this.w / this.cellSize);\r\n        this.rows = Math.floor(this.h / this.cellSize);\r\n        this.gridWidth = this.w;\r\n        this.gridHeight = this.h;\r\n\r\n\r\n        this.graph = new PixelMap();\r\n\r\n        //Build navigation grid\r\n        for (let i = 0; i < this.cols; i++) {\r\n            for (let j = 0; j < this.rows; j++) {\r\n                if (this.graph.grid[i] == undefined)\r\n                    this.graph.grid[i] = [];\r\n\r\n                const node = new Node(i, j);\r\n                if (Math.random() < this.chanceOfWalls) {\r\n                    node.wall = true;\r\n                }\r\n                this.graph.grid[i][j] = node;\r\n            }\r\n        }\r\n\r\n        //find neighbors\r\n        for (let i = 0; i < this.cols; i++) {\r\n            for (let j = 0; j < this.rows; j++) {\r\n                this.graph.buildConnection(this.graph.grid[i][j], this.cols, this.rows);\r\n            }\r\n        }\r\n\r\n        this.graph.startNode = this.getRandomCell();\r\n        this.graph.startNode.wall = false;\r\n\r\n        this.graph.endNode = this.getRandomCell();\r\n        this.graph.endNode.wall = false;\r\n\r\n        this.graph.openNodes.push(this.graph.startNode);\r\n\r\n    }\r\n    getRandomCell() {\r\n        return this.graph.grid[Math.floor(Math.random() * this.cols)][Math.floor(Math.random() * this.rows)];\r\n    }\r\n}\r\n\r\nclass PixelMap {\r\n    grid: Node[][] = [];\r\n    openNodes: Node[] = [];\r\n    closedNodes: Node[] = [];\r\n    startNode: Node;\r\n    endNode: Node;\r\n    path: Node[] = [];\r\n\r\n    doneComputation: boolean = false;\r\n    constructor() {\r\n\r\n    }\r\n    public buildConnection = (node: Node, cols: number, rows: number) => {\r\n\r\n        let x = node.x;\r\n        let y = node.y;\r\n\r\n        if (x < cols - 1) { node.neighbors.push(this.grid[x + 1][y]); } // right\r\n\r\n        if (y < rows - 1) { node.neighbors.push(this.grid[x][y + 1]); } // bottom\r\n\r\n        if (x > 0) { node.neighbors.push(this.grid[x - 1][y]); } // left\r\n\r\n        if (y > 0) { node.neighbors.push(this.grid[x][y - 1]); } // top\r\n\r\n        // if (x > 0 && y > 0) { node.neighbors.push(this.grid[x - 1][y - 1]);} // left up\r\n\r\n        // if (x < cols - 1 && y < rows - 1) {node.neighbors.push(this.grid[x + 1][y + 1]);} // right bottom\r\n\r\n        // if (x > 0 && y < rows - 1) { node.neighbors.push(this.grid[x - 1][y + 1]);} // left bottom\r\n\r\n        // if (x < cols - 1 && y > 0) {node.neighbors.push(this.grid[x + 1][y - 1]);} // right top\r\n    }\r\n    public propagation() {\r\n\r\n        if (this.openNodes.length > 0) {\r\n            //find the lowest f in open nodes\r\n            let lowestF = 0;\r\n            for (let i = 0; i < this.openNodes.length; i++) {\r\n                if (this.openNodes[i].f < this.openNodes[lowestF].f) {\r\n                    lowestF = i;\r\n                }\r\n\r\n                if (this.openNodes[i].f == this.openNodes[lowestF].f) {\r\n                    if (this.openNodes[i].g > this.openNodes[lowestF].g) {\r\n                        lowestF = i;\r\n                    }\r\n                }\r\n            }\r\n            let current: Node = this.openNodes[lowestF];\r\n\r\n            if (current === this.endNode) {\r\n                //reached the end node so wait a sec and restart\r\n                this.doneComputation = true;\r\n                return this.path;\r\n            }\r\n\r\n            //calculate path\r\n            this.path = [];\r\n            let temp = current;\r\n            while (temp.previous) {\r\n                this.path.push(temp.previous);\r\n                temp = temp.previous;\r\n            }\r\n\r\n            this.openNodes.splice(this.openNodes.indexOf(current), 1);\r\n            this.closedNodes.push(current);\r\n\r\n            let neighbors = current.neighbors;\r\n            for (let i = 0; i < neighbors.length; i++) {\r\n                let neighbor = neighbors[i];\r\n\r\n                if (!this.closedNodes.includes(neighbor) && !neighbor.wall) {\r\n                    let tempG = current.g + heuristic(neighbor, current) * 0.01;\r\n\r\n                    if (!this.openNodes.includes(neighbor)) {\r\n                        this.openNodes.push(neighbor);\r\n                    }\r\n                    else {\r\n                        continue;\r\n                    }\r\n\r\n                    neighbor.g = tempG;\r\n                    neighbor.h = heuristic(neighbor, this.endNode);\r\n                    neighbor.f = neighbor.g + neighbor.h;\r\n                    neighbor.previous = current\r\n                }\r\n            }\r\n            return undefined;\r\n        } else {\r\n            this.doneComputation = true;\r\n            return this.path;\r\n        }\r\n    }\r\n}\r\nclass Node {\r\n    public f = 0;\r\n    public h = 0;\r\n    public g = 0;\r\n\r\n    public x = 0;\r\n    public y = 0;\r\n    public z = 0;\r\n    public neighbors: Node[] = [];\r\n    public previous = undefined;\r\n    public wall = false;\r\n    constructor(x: number, y: number) {\r\n        this.f = 0;\r\n        this.h = 0;\r\n        this.g = 0;\r\n        this.x = x;\r\n        this.y = y;\r\n        this.neighbors = [];\r\n        this.wall = false;\r\n\r\n    }\r\n}\r\n\r\nconst heuristic = (a: Node, b: Node) => {\r\n    let d = 0;\r\n    // d = distanceManhattan(a.x, a.y, a.z, b.x, b.y, b.z); // find the Manhattan distance (best for grids)\r\n    d = distanceEuclidean(a.x, a.y, a.z, b.x, b.y, b.z); // euclidean - find the direct distance\r\n    return d;\r\n}\r\nconst distanceManhattan = (x0: number, y0: number, z0: number, x1: number, y1: number, z1: number) => {\r\n    return Math.abs(x0 - x1) + Math.abs(y0 - y1) + Math.abs(z0 - z1);\r\n}\r\nconst distanceEuclidean = (x0: number, y0: number, z0: number, x1: number, y1: number, z1: number) => {\r\n    return Math.sqrt((x0 - x1) * (x0 - x1) + (y0 - y1) * (y0 - y1) + (z0 - z1) * (z0 - z1));\r\n}\r\n"],"names":["Solution","divHost","renderer","this","style","display","alignItems","div","document","createElement","marginLeft","marginRight","backgroundColor","width","height","appendChild","PARAM","Renderer","destroy","lastElementChild","removeChild","renderCell","ctx","node","col","cellSize","fillStyle","beginPath","rect","x","y","closePath","fill","w","h","cols","rows","gridWidth","gridHeight","chanceOfWalls","graph","canvas","position","Build","start","propagation","doneComputation","i","j","grid","color","wall","endNode","openNodes","length","closedNodes","path","k","neighbors","strokeStyle","lineWidth","moveTo","lineTo","stroke","Math","floor","PixelMap","undefined","Node","random","buildConnection","startNode","getRandomCell","push","RendererCanvas","lowestF","f","g","current","temp","previous","splice","indexOf","neighbor","includes","tempG","heuristic","z","a","b","distanceEuclidean","x0","y0","z0","x1","y1","z1","sqrt"],"sourceRoot":""}