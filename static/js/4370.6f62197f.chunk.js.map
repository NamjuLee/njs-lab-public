{"version":3,"file":"static/js/4370.6f62197f.chunk.js","mappings":"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","sources":["njslab/Infrastructure/WebGPU/Util/index.ts","njslab/Infrastructure/WebGPU/WebGPU_Sandbox/Geometry/triangle.ts","njslab/Infrastructure/WebGPU/WebGPU_Sandbox/Renderer/index.ts","njslab/Infrastructure/WebGPU/WebGPU_Sandbox/Geometry/Base/Geometry.ts","njslab/Infrastructure/WebGPU/WebGPU_Sandbox/Geometry/Tri.ts","njslab/Infrastructure/WebGPU/WebGPU_Sandbox/Renderer/shaders/index.ts","njslab/Infrastructure/WebGPU/WebGPU_Sandbox/Scene/index.ts","njslab/Infrastructure/WebGPU/WebGPU_Sandbox/EventListener/index.ts","njslab/Infrastructure/WebGPU/WebGPU_Sandbox/Controller/index.ts","njslab/Infrastructure/WebGPU/WebGPU_Sandbox/UI/index.ts","njslab/Infrastructure/WebGPU/WebGPU_Sandbox/index.ts"],"sourcesContent":["export const getSlider = (title: string, min: number, max: number) => {\n    // <input type=\"range\" min=\"1\" max=\"100\" value=\"50\" class=\"slider\" id=\"myRange\">\n    const div = document.createElement('div');\n    div.style.display = 'flex';\n\n    const slider = document.createElement('input');\n    slider.type = 'range';\n    slider.min = `${min}`;\n    slider.max = `${max}`;\n\n    const text = document.createElement('div');\n    text.textContent = title;\n    text.style.color = '#aaa';\n    div.appendChild(slider);\n    div.appendChild(text);\n    return {\n        div, slider, text\n    }\n};\n\nexport * from './MatUtil';","const vertex = new Float32Array([\n    0.0, 0.5, 0.0,\n    -0.5, -0.5, 0.0,\n    0.5, -0.5, 0.0\n])\nconst vertexCount = 3\n\nexport {vertex, vertexCount}","// import { positionVert, colorFrag } from './shaders';\nimport { Solution } from '..';\nimport * as triangle from '../Geometry/triangle';\n\ninterface SIZE{\n    width:number;\n    height:number;\n}\nexport interface pipeline {\n    pipeline: GPURenderPipeline,\n    vertexBuffer: GPUBuffer,\n    colorBuffer: GPUBuffer,\n    uniformGroup: GPUBindGroup\n}\n\nexport class Renderer {\n    solution: Solution;\n    canvas: HTMLCanvasElement;\n    ctx: GPUCanvasContext;\n\n    device: GPUDevice;\n    format: GPUTextureFormat;\n\n    size: SIZE;\n\n    // pipelineObj: pipeline;\n    commandEncoder: GPUCommandEncoder;\n    view: GPUTextureView\n    renderPassDescriptor: GPURenderPassDescriptor;\n    passEncoder: GPURenderPassEncoder;\n\n    requestAni;\n\n    constructor(solution: Solution) {\n        this.solution = solution;\n        this.canvas = solution.canvas;\n    }\n    async initWebGPU() {\n        if (!navigator.gpu) { throw new Error('Not Support WebGPU'); }\n\n        const adapter = await navigator.gpu.requestAdapter({\n            powerPreference: 'high-performance'\n            // powerPreference: 'low-power'\n        })\n\n        if (!adapter) { throw new Error('No Adapter Found'); }\n\n        const device = await adapter.requestDevice()\n        this.ctx = this.canvas.getContext('webgpu') as GPUCanvasContext\n        const format = navigator.gpu.getPreferredCanvasFormat ? navigator.gpu.getPreferredCanvasFormat() : this.ctx.getPreferredFormat(adapter)\n        // const format = 'bgra8unorm';\n        const devicePixelRatio = window.devicePixelRatio || 1\n        this.canvas.width = this.canvas.clientWidth ;\n        this.canvas.height = this.canvas.clientHeight;\n        this.ctx.configure({\n            // json specific format when key and value are the same\n            device, format,\n            // prevent chrome warning\n            alphaMode: 'opaque'\n        })\n\n        this.size = { width: this.canvas.width, height: this.canvas.height }\n        this.device = device;\n        this.format = format;\n\n        // await this.initPipeline(this.device, this.format);\n        // this.start();\n        this.loop();\n    }\n    public loop = () => {\n        // this.start();\n        this.solution.scene.render();\n        // this.draw(this.device, this.ctx, this.pipelineObj);\n        this.requestAni = requestAnimationFrame(this.loop);\n        \n    }\n    public draw (pipelineObj: pipeline) {\n        if (pipelineObj === undefined) { return;}\n        // const rotationAngle = Date.now() / 1000;\n        // console.log('run', rotationAngle);\n\n        this.commandEncoder = this.device.createCommandEncoder();\n        this.view = this.ctx.getCurrentTexture().createView();\n        this.renderPassDescriptor = {\n            //@ts-ignore\n            colorAttachments: [{\n                    view: this.view,\n                    clearValue: { r: 0, g: 0, b: 0, a: 1.0 },\n                    loadOp: 'clear',\n                    storeOp: 'store'\n                }]\n        };\n\n        // console.log(pipelineObj);\n        this.passEncoder = this.commandEncoder.beginRenderPass(this.renderPassDescriptor);\n        this.passEncoder.setPipeline(pipelineObj.pipeline);\n        this.passEncoder.setBindGroup(0, pipelineObj.uniformGroup); // set uniformGroup\n        this.passEncoder.setVertexBuffer(0, pipelineObj.vertexBuffer); // set vertex\n        this.passEncoder.draw(triangle.vertexCount); // 3 vertex form a triangle\n        this.passEncoder.end();\n        // webgpu run in a separate process, all the commands will be executed after submit\n        this.device.queue.submit([this.commandEncoder.finish()]);   \n    }\n    public destroy() {\n        this.device.destroy();\n        // this.isAnimation = false;\n        cancelAnimationFrame(this.requestAni);\n        // this.requestAni = undefined;\n    }\n}","import { pipeline } from '../../NWebGPU';\nexport class Geometry {\n    pipeline: pipeline;\n    constructor() {\n\n    }\n}","import { Scene } from '../Scene';\nimport { positionVert, colorFrag } from '../Renderer/shaders';\nimport { Geometry } from './Base/Geometry';\nexport class Tri extends Geometry {\n    scene: Scene;\n    vertex = new Float32Array([\n        0.0, 0.1, 0.0,\n        -0.5, -0.5, 0.0,\n        0.5, -0.5, 0.0\n    ]);\n    vertexCount: number = 3;\n\n    constructor(scene: Scene) {\n        super();\n        this.scene = scene;\n\n        const num = Math.random();\n        this.vertex[1]+= num;\n\n        this.initPipeline(this.scene.solution.renderer.device, this.scene.solution.renderer.format);\n\n    }\n    async initPipeline(device: GPUDevice, format: GPUTextureFormat) {\n        const pipeline = await device.createRenderPipelineAsync({\n            label: 'Basic Pipline',\n            layout: 'auto',\n            vertex: {\n                module: device.createShaderModule({\n                    code: positionVert,\n                }),\n                entryPoint: 'main',\n                buffers: [{\n                    arrayStride: 3 * 4, // 3 float32,\n                    attributes: [{\n                            // position xyz\n                            shaderLocation: 0,\n                            offset: 0,\n                            format: 'float32x3',\n                        }]\n                }]\n            },\n            fragment: {\n                module: device.createShaderModule({\n                    code: colorFrag,\n                }),\n                entryPoint: 'main',\n                targets: [{\n                        format: format\n                    }]\n            },\n            primitive: {\n                topology: 'triangle-list' // try point-list, line-list, line-strip, triangle-strip?\n            }\n        } as GPURenderPipelineDescriptor)\n        // create vertex buffer\n        const vertexBuffer = device.createBuffer({\n            label: 'GPUBuffer store vertex',\n            size: this.vertex.byteLength,\n            usage: GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST,\n            //mappedAtCreation: true\n        })\n        device.queue.writeBuffer(vertexBuffer, 0, this.vertex)\n        // create color buffer\n        const colorBuffer = device.createBuffer({\n            label: 'GPUBuffer store rgba color',\n            size: 4 * 4, // 4 * float32\n            usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,\n        })\n        device.queue.writeBuffer(colorBuffer, 0, new Float32Array([1, 0, 0, 1]))\n\n        // create a uniform group for color\n        const uniformGroup = device.createBindGroup({\n            label: 'Uniform Group with colorBuffer',\n            layout: pipeline.getBindGroupLayout(0),\n            entries: [\n                {\n                    binding: 0,\n                    resource: {\n                        buffer: colorBuffer\n                    }\n                }\n            ]\n        })\n        this.pipeline = { pipeline, vertexBuffer, colorBuffer, uniformGroup }\n        this.scene.geometries.push(this);\n    }\n}","export const positionVert = `\n@vertex\nfn main(@location(0) position : vec3<f32>) -> @builtin(position) vec4<f32> {\n    return vec4<f32>(position, 1.0);\n}\n`\nexport const colorFrag = `\n@group(0) @binding(0) var<uniform> color : vec4<f32>;\n\n@fragment\nfn main() -> @location(0) vec4<f32> {\n    return color;\n}`\n\n\nexport const Shaders = (color:string) => {\n    const vertex = `\n        @vertex\n        fn main(@builtin(vertex_index) VertexIndex: u32) -> @builtin(position) vec4<f32> {\n            var pos = array<vec2<f32>, 3>(\n                vec2<f32>(0.0, 0.5),\n                vec2<f32>(-0.5, -0.5),\n                vec2<f32>(0.5, -0.5));\n            return vec4<f32>(pos[VertexIndex], 0.0, 1.0);\n        }\n    `;\n\n    const fragment = `\n        @fragment\n        fn main() -> @location(0) vec4<f32> {\n            return vec4<f32>${color};\n        }\n    `;\n    return {vertex, fragment};\n}\n\nexport const Shaders1 = (color:string) => {\n    const vertex = `\n        var pos = array<vec2<f32>, 3>(\n            vec2<f32>(0.0, 0.5),\n            vec2<f32>(-0.5, -0.5),\n            vec2<f32>(0.5, -0.5));\n\n        [[stage(vertex)]]\n        fn main([[builtin(vertex_index)]] VertexIndex: u32) -> [[builtin(position)]] vec4<f32> {\n            return vec4<f32>(pos[VertexIndex], 0.0, 1.0);\n        }\n    `;\n\n    const fragment = `\n        [[stage(fragment)]]\n        fn main() -> [[location(0)]] vec4<f32> {\n            return vec4<f32>${color};\n        }\n    `;\n    return {vertex, fragment};\n}\n\nexport const ShadersOld = (color:string) => {\n    const vertex = `\n        const pos : array<vec2<f32>, 3> = array<vec2<f32>, 3>(\n            vec2<f32>(0.0, 0.5),\n            vec2<f32>(-0.5, -0.5),\n            vec2<f32>(0.5, -0.5));\n\n        [[builtin(position)]] var<out> Position : vec4<f32>;\n        [[builtin(vertex_idx)]] var<in> VertexIndex : i32;\n\n        [[stage(vertex)]]\n        fn main() -> void {\n            Position = vec4<f32>(pos[VertexIndex], 0.0, 1.0);\n            return;\n        }\n    `;\n\n    const fragment = `\n        [[location(0)]] var<out> outColor : vec4<f32>;\n\n        [[stage(fragment)]]\n        fn main() -> void {\n            outColor = vec4<f32>${color};\n            return;\n        }\n    `;\n    return {vertex, fragment};\n}","import { Solution } from '..';\nimport { Geometry } from '../Geometry/Base/Geometry';\n\nimport { Tri } from '../Geometry/Tri';\n\nexport class Scene {\n    public solution: Solution;\n    public geometries: Geometry[] = [];\n\n    private index = 0;\n    constructor(solution: Solution) {\n        this.solution = solution;\n\n\n\n\n    }\n    public init() {\n        this.geometries.push(new Tri(this));\n    }\n    public render() {\n        //\n\n        for(this.index = 0; this.index < this.geometries.length; ++this.index) {\n            this.solution.renderer.draw(this.geometries[this.index].pipeline);\n        }\n\n        console.log('rendering...', this.geometries.length);\n    }\n}","import { Solution } from '..';\nexport class EventListener {\n    solution: Solution;\n    constructor(solution: Solution) {\n        this.solution = solution;\n        this.appendEvent();\n    }\n    public appendEvent() {\n        this.solution.divHost.addEventListener('mousedown', (e: MouseEvent) => {\n            console.log(e);\n            this.solution.controller.addTri();\n        });\n    }\n}","import { Solution } from '..';\nimport { Tri  } from '../Geometry/Tri';\nexport class Controller {\n    public solution: Solution;\n    constructor(solution: Solution) {\n        this.solution = solution;\n\n    }\n    public addTri() {\n        new Tri(this.solution.scene);\n    }\n}","import * as triangle from '../Geometry/triangle';\nimport { getSlider } from '../../Util';\nimport { Solution } from '..';\n\nexport class UI {\n    public divHost: HTMLElement;\n    public solution: Solution;\n    public divColor: HTMLInputElement;\n    public divRange: any;\n\n    constructor(solution: Solution) {\n        this.solution = solution;\n        this.divHost = solution.divHost;\n\n        this.divColor = document.createElement('input');\n        this.divColor.type = 'color';\n        this.divColor.defaultValue = '#ff0000';\n        // this.divColor.style.position = 'absolute';\n        this.divHost.appendChild(this.divColor);\n\n        this.divRange = getSlider('size', 0, 100);\n        this.divHost.appendChild(this.divRange.div);\n\n        this.appendEvent();\n    }\n    public appendEvent() {\n        // update colorBuffer if color changed\n        this.divColor.addEventListener('input', (e: Event) => {\n            const color = (e.target as HTMLInputElement).value; // get hex color string\n            const r = +('0x' + color.slice(1, 3)) / 255; // parse hex color into rgb\n            const g = +('0x' + color.slice(3, 5)) / 255;\n            const b = +('0x' + color.slice(5, 7)) / 255;\n            // write colorBuffer with new color\n            // this.solution.nWebGPU.device.queue.writeBuffer(this.solution.nWebGPU.pipelineObj.colorBuffer, 0, new Float32Array([r, g, b, 1]));\n            // this.solution.nWebGPU.render();\n        });\n\n        // update vertexBuffer\n        this.divRange.slider.addEventListener('input', (e: Event) => {\n            // get input value\n            const value = +(e.target as HTMLInputElement).value;\n            console.log(value)\n            // chagne vertex 0/3/6\n            triangle.vertex[0] = 0;\n            triangle.vertex[3] = -0.5 + -(value * 0.01);\n            triangle.vertex[6] = 0.5 + (value * 0.01);\n            // write vertexBuffer with new vertex\n            // this.solution.nWebGPU.device.queue.writeBuffer(this.solution.nWebGPU.pipelineObj.vertexBuffer, 0, triangle.vertex);\n            // this.solution.nWebGPU.render();\n        });\n\n        // re-configure context on resize\n        window.addEventListener('resize', () => {\n            this.solution.canvas.width = this.solution.divHost.clientWidth;\n            this.solution.canvas.height = this.solution.divHost.clientHeight;\n            // don't need to recall context.configure() after v104\n            // this.solution.nWebGPU.render();\n        });\n    }\n}","import { Renderer } from './Renderer';\r\nimport { Scene } from './Scene';\r\nimport { EventListener } from './EventListener';\r\nimport { Controller } from './Controller';\r\nimport { UI } from './UI';\r\n\r\nimport { Tri } from './Geometry/Tri';\r\n\r\n// https://github.com/jack1232/WebGPU-Step-By-Step\r\n\r\nexport class Solution {\r\n    public divHost: HTMLElement;\r\n    public canvas: HTMLCanvasElement;\r\n\r\n    public scene: Scene;\r\n    public renderer: Renderer;\r\n    public ui: UI;\r\n    public eventListener: EventListener;\r\n    public controller: Controller;\r\n\r\n    constructor(id: string) {\r\n        this.divHost = document.getElementById(id);\r\n        this.divHost.style.position = 'relative';\r\n\r\n        this.canvas = document.createElement('canvas');\r\n        this.divHost.appendChild(this.canvas);\r\n        this.canvas.width = this.divHost.clientWidth;\r\n        this.canvas.height = this.divHost.clientHeight;\r\n        this.canvas.style.background = 'rgba(0,0,0,0)';\r\n        // this.canvas.style.position = 'absolute';\r\n\r\n        this.init();\r\n    }\r\n    public init = async () => {\r\n        this.scene = new Scene(this);\r\n        this.ui = new UI(this);\r\n        this.eventListener = new EventListener(this);\r\n        this.controller = new Controller(this);\r\n        this.renderer = new Renderer(this);\r\n        await this.initRenderer();\r\n        this.scene.init();\r\n        // this.renderer.render();\r\n\r\n\r\n        this.initPost();\r\n    }\r\n    public initPost() {\r\n        \r\n    }\r\n    private initRenderer = async () => {\r\n        return this.renderer.initWebGPU();\r\n    }\r\n    public destroy() {\r\n        this.renderer.destroy();\r\n\r\n        while (this.divHost.lastElementChild) {\r\n            this.divHost.removeChild(this.divHost.lastElementChild);\r\n        }\r\n    }\r\n}\r\n\r\n"],"names":["getSlider","title","min","max","div","document","createElement","style","display","slider","type","text","textContent","color","appendChild","vertex","Float32Array","Renderer","constructor","solution","canvas","ctx","device","format","size","commandEncoder","view","renderPassDescriptor","passEncoder","requestAni","loop","this","scene","render","requestAnimationFrame","async","navigator","gpu","Error","adapter","requestAdapter","powerPreference","requestDevice","getContext","getPreferredCanvasFormat","getPreferredFormat","window","devicePixelRatio","width","clientWidth","height","clientHeight","configure","alphaMode","draw","pipelineObj","undefined","createCommandEncoder","getCurrentTexture","createView","colorAttachments","clearValue","r","g","b","a","loadOp","storeOp","beginRenderPass","setPipeline","pipeline","setBindGroup","uniformGroup","setVertexBuffer","vertexBuffer","end","queue","submit","finish","destroy","cancelAnimationFrame","Geometry","Tri","super","vertexCount","num","Math","random","initPipeline","renderer","createRenderPipelineAsync","label","layout","module","createShaderModule","code","entryPoint","buffers","arrayStride","attributes","shaderLocation","offset","fragment","targets","primitive","topology","createBuffer","byteLength","usage","GPUBufferUsage","VERTEX","COPY_DST","writeBuffer","colorBuffer","UNIFORM","createBindGroup","getBindGroupLayout","entries","binding","resource","buffer","geometries","push","Scene","index","init","length","console","log","EventListener","appendEvent","divHost","addEventListener","e","controller","addTri","Controller","UI","divColor","divRange","defaultValue","target","value","slice","triangle","Solution","id","ui","eventListener","initRenderer","initPost","initWebGPU","getElementById","position","background","lastElementChild","removeChild"],"sourceRoot":""}