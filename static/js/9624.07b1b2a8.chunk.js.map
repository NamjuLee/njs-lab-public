{"version":3,"file":"static/js/9624.07b1b2a8.chunk.js","mappings":"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","sources":["../node_modules/@deck.gl/core/src/lib/composite-layer.ts","../node_modules/@luma.gl/shadertools/src/modules/lights/lights.glsl.js","../node_modules/@luma.gl/shadertools/src/modules/lights/lights.js","../node_modules/@luma.gl/shadertools/src/modules/phong-lighting/phong-lighting.glsl.js","../node_modules/@luma.gl/shadertools/src/modules/phong-lighting/phong-lighting.js","../node_modules/@math.gl/polygon/src/polygon-utils.ts","../node_modules/@math.gl/polygon/src/lineclip.ts","../node_modules/@math.gl/polygon/src/utils.ts","../node_modules/@math.gl/polygon/src/cut-by-grid.ts","../node_modules/@math.gl/polygon/src/cut-by-mercator-bounds.ts","../node_modules/@deck.gl/layers/src/solid-polygon-layer/polygon.ts","../node_modules/@deck.gl/core/src/utils/tesselator.ts","../node_modules/@deck.gl/layers/src/solid-polygon-layer/polygon-tesselator.ts","../node_modules/@deck.gl/layers/src/solid-polygon-layer/solid-polygon-layer-vertex-main.glsl.ts","../node_modules/@deck.gl/layers/src/solid-polygon-layer/solid-polygon-layer-vertex-top.glsl.ts","../node_modules/@deck.gl/layers/src/solid-polygon-layer/solid-polygon-layer-vertex-side.glsl.ts","../node_modules/@deck.gl/layers/src/solid-polygon-layer/solid-polygon-layer.ts","../node_modules/@deck.gl/layers/src/solid-polygon-layer/solid-polygon-layer-fragment.glsl.ts","../node_modules/@deck.gl/layers/src/path-layer/path.ts","../node_modules/@deck.gl/layers/src/path-layer/path-tesselator.ts","../node_modules/@deck.gl/layers/src/path-layer/path-layer.ts","../node_modules/@deck.gl/layers/src/path-layer/path-layer-vertex.glsl.ts","../node_modules/@deck.gl/layers/src/path-layer/path-layer-fragment.glsl.ts","../node_modules/@deck.gl/layers/src/polygon-layer/polygon-layer.ts","../node_modules/@deck.gl/layers/src/utils.ts"],"sourcesContent":["// Copyright (c) 2015 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\nimport Layer, {UpdateParameters} from './layer';\nimport debug from '../debug';\nimport {flatten} from '../utils/flatten';\n\nimport type AttributeManager from './attribute/attribute-manager';\nimport type {PickingInfo, GetPickingInfoParams} from './picking/pick-info';\nimport type {FilterContext} from '../passes/layers-pass';\nimport type {LayersList, LayerContext} from './layer-manager';\nimport type {CompositeLayerProps, Accessor, AccessorContext} from '../types/layer-props';\nimport {ConstructorOf} from '../types/types';\nimport {PROP_TYPES_SYMBOL} from '../lifecycle/constants';\n\nconst TRACE_RENDER_LAYERS = 'compositeLayer.renderLayers';\n\nexport default abstract class CompositeLayer<PropsT extends {} = {}> extends Layer<\n  PropsT & Required<CompositeLayerProps>\n> {\n  static layerName: string = 'CompositeLayer';\n\n  /** `true` if this layer renders other layers */\n  get isComposite(): boolean {\n    return true;\n  }\n\n  /** Returns true if all async resources are loaded */\n  get isLoaded(): boolean {\n    return super.isLoaded && this.getSubLayers().every(layer => layer.isLoaded);\n  }\n\n  /** Return last rendered sub layers */\n  getSubLayers(): Layer[] {\n    return (this.internalState && this.internalState.subLayers) || [];\n  }\n\n  // initializeState is usually not needed for composite layers\n  // Provide empty definition to disable check for missing definition\n  // eslint-disable-next-line @typescript-eslint/no-empty-function\n  initializeState(context: LayerContext): void {}\n\n  /** Updates selected state members and marks the composite layer to need rerender */\n  setState(updateObject: any): void {\n    super.setState(updateObject);\n    // Trigger a layer update\n    // Although conceptually layer.draw and compositeLayer.renderLayers are equivalent,\n    // they are executed during different lifecycles.\n    // draw can be called without calling updateState (e.g. most viewport changes),\n    // while renderLayers can only be called during a recursive layer update.\n    this.setNeedsUpdate();\n  }\n\n  /** called to augment the info object that is bubbled up from a sublayer\n      override Layer.getPickingInfo() because decoding / setting uniform do\n      not apply to a composite layer. */\n  getPickingInfo({info}: GetPickingInfoParams): PickingInfo {\n    const {object} = info;\n    const isDataWrapped =\n      object && object.__source && object.__source.parent && object.__source.parent.id === this.id;\n\n    if (!isDataWrapped) {\n      return info;\n    }\n\n    // override object with picked data\n    info.object = object.__source.object;\n    info.index = object.__source.index;\n\n    return info;\n  }\n\n  // Implement to generate subLayers\n  abstract renderLayers(): Layer | null | LayersList;\n\n  /**\n   * Filters sub layers at draw time. Return true if the sub layer should be drawn.\n   */\n  filterSubLayer(context: FilterContext): boolean {\n    return true;\n  }\n\n  /** Returns true if sub layer needs to be rendered */\n  protected shouldRenderSubLayer(subLayerId: string, data: any): boolean {\n    return data && data.length;\n  }\n\n  /** Returns sub layer class for a specific sublayer */\n  protected getSubLayerClass<T extends Layer>(\n    subLayerId: string,\n    DefaultLayerClass: ConstructorOf<T>\n  ): ConstructorOf<T> {\n    const {_subLayerProps: overridingProps} = this.props;\n\n    return (\n      (overridingProps &&\n        overridingProps[subLayerId] &&\n        (overridingProps[subLayerId].type as ConstructorOf<T>)) ||\n      DefaultLayerClass\n    );\n  }\n\n  /** When casting user data into another format to pass to sublayers,\n      add reference to the original object and object index */\n  protected getSubLayerRow<T>(row: T, sourceObject: any, sourceObjectIndex: number): T {\n    // @ts-ignore (TS2339) adding undefined property\n    row.__source = {\n      parent: this,\n      object: sourceObject,\n      index: sourceObjectIndex\n    };\n    return row;\n  }\n\n  /** Some composite layers cast user data into another format before passing to sublayers\n    We need to unwrap them before calling the accessor so that they see the original data\n    objects */\n  protected getSubLayerAccessor<In, Out>(accessor: Accessor<In, Out>): Accessor<In, Out> {\n    if (typeof accessor === 'function') {\n      const objectInfo: AccessorContext<In> = {\n        index: -1,\n        // @ts-ignore accessing resolved data\n        data: this.props.data,\n        target: []\n      };\n      return (x: any, i: AccessorContext<In>) => {\n        if (x && x.__source) {\n          objectInfo.index = x.__source.index;\n          // @ts-ignore (TS2349) Out is never a function\n          return accessor(x.__source.object as In, objectInfo);\n        }\n        // @ts-ignore (TS2349) Out is never a function\n        return accessor(x as In, i);\n      };\n    }\n    return accessor;\n  }\n\n  /** Returns sub layer props for a specific sublayer */\n  // eslint-disable-next-line complexity\n  protected getSubLayerProps(\n    sublayerProps: {\n      id?: string;\n      updateTriggers?: Record<string, any>;\n      [propName: string]: any;\n    } = {}\n  ): any {\n    const {\n      opacity,\n      pickable,\n      visible,\n      parameters,\n      getPolygonOffset,\n      highlightedObjectIndex,\n      autoHighlight,\n      highlightColor,\n      coordinateSystem,\n      coordinateOrigin,\n      wrapLongitude,\n      positionFormat,\n      modelMatrix,\n      extensions,\n      fetch,\n      operation,\n      _subLayerProps: overridingProps\n    } = this.props;\n    const newProps = {\n      id: '',\n      updateTriggers: {},\n      opacity,\n      pickable,\n      visible,\n      parameters,\n      getPolygonOffset,\n      highlightedObjectIndex,\n      autoHighlight,\n      highlightColor,\n      coordinateSystem,\n      coordinateOrigin,\n      wrapLongitude,\n      positionFormat,\n      modelMatrix,\n      extensions,\n      fetch,\n      operation\n    };\n\n    const overridingSublayerProps =\n      overridingProps && sublayerProps.id && overridingProps[sublayerProps.id];\n    const overridingSublayerTriggers =\n      overridingSublayerProps && overridingSublayerProps.updateTriggers;\n    const sublayerId = sublayerProps.id || 'sublayer';\n\n    if (overridingSublayerProps) {\n      const propTypes = this.props[PROP_TYPES_SYMBOL];\n      const subLayerPropTypes = sublayerProps.type ? sublayerProps.type._propTypes : {};\n      for (const key in overridingSublayerProps) {\n        const propType = subLayerPropTypes[key] || propTypes[key];\n        // eslint-disable-next-line\n        if (propType && propType.type === 'accessor') {\n          overridingSublayerProps[key] = this.getSubLayerAccessor(overridingSublayerProps[key]);\n        }\n      }\n    }\n\n    Object.assign(\n      newProps,\n      sublayerProps,\n      // experimental feature that allows users to override sublayer props via parent layer prop\n      overridingSublayerProps\n    );\n    newProps.id = `${this.props.id}-${sublayerId}`;\n    newProps.updateTriggers = {\n      all: this.props.updateTriggers?.all,\n      ...sublayerProps.updateTriggers,\n      ...overridingSublayerTriggers\n    };\n\n    // Pass through extension props\n    // @ts-ignore (TS2532) extensions is always defined after merging with default props\n    for (const extension of extensions) {\n      const passThroughProps = extension.getSubLayerProps.call(this, extension);\n      if (passThroughProps) {\n        Object.assign(newProps, passThroughProps, {\n          updateTriggers: Object.assign(newProps.updateTriggers, passThroughProps.updateTriggers)\n        });\n      }\n    }\n\n    return newProps;\n  }\n\n  /** Update sub layers to highlight the hovered object */\n  protected _updateAutoHighlight(info: PickingInfo): void {\n    for (const layer of this.getSubLayers()) {\n      layer.updateAutoHighlight(info);\n    }\n  }\n\n  /** Override base Layer method */\n  protected _getAttributeManager(): AttributeManager | null {\n    return null;\n  }\n\n  /** (Internal) Called after an update to rerender sub layers */\n  protected _postUpdate(updateParams: UpdateParameters<this>, forceUpdate: boolean) {\n    // @ts-ignore (TS2531) this method is only called internally when internalState is defined\n    let subLayers = this.internalState.subLayers as Layer[];\n    const shouldUpdate = !subLayers || this.needsUpdate();\n    if (shouldUpdate) {\n      const subLayersList = this.renderLayers();\n      // Flatten the returned array, removing any null, undefined or false\n      // this allows layers to render sublayers conditionally\n      // (see CompositeLayer.renderLayers docs)\n      subLayers = flatten(subLayersList, Boolean) as Layer[];\n      // @ts-ignore (TS2531) this method is only called internally when internalState is defined\n      this.internalState.subLayers = subLayers;\n    }\n    debug(TRACE_RENDER_LAYERS, this, shouldUpdate, subLayers);\n\n    // populate reference to parent layer (this layer)\n    // NOTE: needs to be done even when reusing layers as the parent may have changed\n    for (const layer of subLayers) {\n      layer.parent = this;\n    }\n  }\n}\n","export default `\\\n#if (defined(SHADER_TYPE_FRAGMENT) && defined(LIGHTING_FRAGMENT)) || (defined(SHADER_TYPE_VERTEX) && defined(LIGHTING_VERTEX))\n\nstruct AmbientLight {\n vec3 color;\n};\n\nstruct PointLight {\n vec3 color;\n vec3 position;\n\n // Constant-Linear-Exponential\n vec3 attenuation;\n};\n\nstruct DirectionalLight {\n  vec3 color;\n  vec3 direction;\n};\n\nuniform AmbientLight lighting_uAmbientLight;\nuniform PointLight lighting_uPointLight[MAX_LIGHTS];\nuniform DirectionalLight lighting_uDirectionalLight[MAX_LIGHTS];\nuniform int lighting_uPointLightCount;\nuniform int lighting_uDirectionalLightCount;\n\nuniform bool lighting_uEnabled;\n\nfloat getPointLightAttenuation(PointLight pointLight, float distance) {\n  return pointLight.attenuation.x\n       + pointLight.attenuation.y * distance\n       + pointLight.attenuation.z * distance * distance;\n}\n\n#endif\n`;\n","/** @typedef {import('../../types').ShaderModule} ShaderModule */\n\nimport lightingShader from './lights.glsl';\n\nconst INITIAL_MODULE_OPTIONS = {\n  lightSources: {}\n};\n\n// Take color 0-255 and intensity as input and output 0.0-1.0 range\nfunction convertColor({color = [0, 0, 0], intensity = 1.0} = {}) {\n  return color.map(component => (component * intensity) / 255.0);\n}\n\nfunction getLightSourceUniforms({ambientLight, pointLights = [], directionalLights = []}) {\n  const lightSourceUniforms = {};\n\n  if (ambientLight) {\n    lightSourceUniforms['lighting_uAmbientLight.color'] = convertColor(ambientLight);\n  } else {\n    lightSourceUniforms['lighting_uAmbientLight.color'] = [0, 0, 0];\n  }\n\n  pointLights.forEach((pointLight, index) => {\n    lightSourceUniforms[`lighting_uPointLight[${index}].color`] = convertColor(pointLight);\n    lightSourceUniforms[`lighting_uPointLight[${index}].position`] = pointLight.position;\n    lightSourceUniforms[`lighting_uPointLight[${index}].attenuation`] = pointLight.attenuation || [\n      1,\n      0,\n      0\n    ];\n  });\n  lightSourceUniforms.lighting_uPointLightCount = pointLights.length;\n\n  directionalLights.forEach((directionalLight, index) => {\n    lightSourceUniforms[`lighting_uDirectionalLight[${index}].color`] = convertColor(\n      directionalLight\n    );\n    lightSourceUniforms[`lighting_uDirectionalLight[${index}].direction`] =\n      directionalLight.direction;\n  });\n  lightSourceUniforms.lighting_uDirectionalLightCount = directionalLights.length;\n\n  return lightSourceUniforms;\n}\n\n// eslint-disable-next-line complexity\nfunction getUniforms(opts = INITIAL_MODULE_OPTIONS) {\n  // Specify lights separately\n  if ('lightSources' in opts) {\n    const {ambientLight, pointLights, directionalLights} = opts.lightSources || {};\n    const hasLights =\n      ambientLight ||\n      (pointLights && pointLights.length > 0) ||\n      (directionalLights && directionalLights.length > 0);\n\n    if (!hasLights) {\n      return {lighting_uEnabled: false};\n    }\n\n    return Object.assign(\n      {},\n      getLightSourceUniforms({ambientLight, pointLights, directionalLights}),\n      {\n        lighting_uEnabled: true\n      }\n    );\n  }\n\n  // Support for array of lights. Type of light is detected by type field\n  if ('lights' in opts) {\n    const lightSources = {pointLights: [], directionalLights: []};\n    // @ts-ignore\n    for (const light of opts.lights || []) {\n      switch (light.type) {\n        case 'ambient':\n          // Note: Only uses last ambient light\n          // TODO - add ambient light sources on CPU?\n          lightSources.ambientLight = light;\n          break;\n        case 'directional':\n          lightSources.directionalLights.push(light);\n          break;\n        case 'point':\n          lightSources.pointLights.push(light);\n          break;\n        default:\n        // eslint-disable-next-line\n        // console.warn(light.type);\n      }\n    }\n\n    // Call the `opts.lightSources`` version\n    return getUniforms({lightSources});\n  }\n\n  return {};\n}\n\n/** @type {ShaderModule} */\nexport const lights = {\n  name: 'lights',\n  vs: lightingShader,\n  fs: lightingShader,\n  getUniforms,\n  defines: {\n    MAX_LIGHTS: 3\n  }\n};\n","export default `\\\n\nuniform float lighting_uAmbient;\nuniform float lighting_uDiffuse;\nuniform float lighting_uShininess;\nuniform vec3  lighting_uSpecularColor;\n\nvec3 lighting_getLightColor(vec3 surfaceColor, vec3 light_direction, vec3 view_direction, vec3 normal_worldspace, vec3 color) {\n    vec3 halfway_direction = normalize(light_direction + view_direction);\n    float lambertian = dot(light_direction, normal_worldspace);\n    float specular = 0.0;\n    if (lambertian > 0.0) {\n      float specular_angle = max(dot(normal_worldspace, halfway_direction), 0.0);\n      specular = pow(specular_angle, lighting_uShininess);\n    }\n    lambertian = max(lambertian, 0.0);\n    return (lambertian * lighting_uDiffuse * surfaceColor + specular * lighting_uSpecularColor) * color;\n}\n\nvec3 lighting_getLightColor(vec3 surfaceColor, vec3 cameraPosition, vec3 position_worldspace, vec3 normal_worldspace) {\n  vec3 lightColor = surfaceColor;\n\n  if (lighting_uEnabled) {\n    vec3 view_direction = normalize(cameraPosition - position_worldspace);\n    lightColor = lighting_uAmbient * surfaceColor * lighting_uAmbientLight.color;\n\n    for (int i = 0; i < MAX_LIGHTS; i++) {\n      if (i >= lighting_uPointLightCount) {\n        break;\n      }\n      PointLight pointLight = lighting_uPointLight[i];\n      vec3 light_position_worldspace = pointLight.position;\n      vec3 light_direction = normalize(light_position_worldspace - position_worldspace);\n      lightColor += lighting_getLightColor(surfaceColor, light_direction, view_direction, normal_worldspace, pointLight.color);\n    }\n\n    for (int i = 0; i < MAX_LIGHTS; i++) {\n      if (i >= lighting_uDirectionalLightCount) {\n        break;\n      }\n      DirectionalLight directionalLight = lighting_uDirectionalLight[i];\n      lightColor += lighting_getLightColor(surfaceColor, -directionalLight.direction, view_direction, normal_worldspace, directionalLight.color);\n    }\n  }\n  return lightColor;\n}\n\nvec3 lighting_getSpecularLightColor(vec3 cameraPosition, vec3 position_worldspace, vec3 normal_worldspace) {\n  vec3 lightColor = vec3(0, 0, 0);\n  vec3 surfaceColor = vec3(0, 0, 0);\n\n  if (lighting_uEnabled) {\n    vec3 view_direction = normalize(cameraPosition - position_worldspace);\n\n    for (int i = 0; i < MAX_LIGHTS; i++) {\n      if (i >= lighting_uPointLightCount) {\n        break;\n      }\n      PointLight pointLight = lighting_uPointLight[i];\n      vec3 light_position_worldspace = pointLight.position;\n      vec3 light_direction = normalize(light_position_worldspace - position_worldspace);\n      lightColor += lighting_getLightColor(surfaceColor, light_direction, view_direction, normal_worldspace, pointLight.color);\n    }\n\n    for (int i = 0; i < MAX_LIGHTS; i++) {\n      if (i >= lighting_uDirectionalLightCount) {\n        break;\n      }\n      DirectionalLight directionalLight = lighting_uDirectionalLight[i];\n      lightColor += lighting_getLightColor(surfaceColor, -directionalLight.direction, view_direction, normal_worldspace, directionalLight.color);\n    }\n  }\n  return lightColor;\n}\n`;\n","/** @typedef {import('../../types').ShaderModule} ShaderModule */\n\nimport {lights} from '../lights/lights';\nimport lightingShader from './phong-lighting.glsl';\n\nconst INITIAL_MODULE_OPTIONS = {};\n\nfunction getMaterialUniforms(material) {\n  const {ambient = 0.35, diffuse = 0.6, shininess = 32, specularColor = [30, 30, 30]} = material;\n\n  return {\n    lighting_uAmbient: ambient,\n    lighting_uDiffuse: diffuse,\n    lighting_uShininess: shininess,\n    lighting_uSpecularColor: specularColor.map(x => x / 255)\n  };\n}\n\nfunction getUniforms(opts = INITIAL_MODULE_OPTIONS) {\n  if (!('material' in opts)) {\n    return {};\n  }\n\n  const {material} = opts;\n\n  if (!material) {\n    return {lighting_uEnabled: false};\n  }\n\n  return getMaterialUniforms(material);\n}\n\n/** @type {ShaderModule} */\nexport const gouraudLighting = {\n  name: 'gouraud-lighting',\n  dependencies: [lights],\n  vs: lightingShader,\n  defines: {\n    LIGHTING_VERTEX: 1\n  },\n  getUniforms\n};\n\n/** @type {ShaderModule} */\nexport const phongLighting = {\n  name: 'phong-lighting',\n  dependencies: [lights],\n  fs: lightingShader,\n  defines: {\n    LIGHTING_FRAGMENT: 1\n  },\n  getUniforms\n};\n","/* eslint-disable max-statements, max-depth, complexity, no-unused-expressions */\n\nimport {equals} from '@math.gl/core';\nimport type {NumericArray} from '@math.gl/core';\n\nexport const WINDING = {\n  CLOCKWISE: 1,\n  COUNTER_CLOCKWISE: -1\n} as const;\n\n/** Polygon representation where each point is represented as a separate array of positions. */\ntype PointsArray = NumericArray[];\n\n/** Segment visitor callback type for polygons defined with flat arrays, */\ntype SegmentVisitorFlat = (\n  p1x: number,\n  p1y: number,\n  p2x: number,\n  p2y: number,\n  i1: number,\n  i2: number\n) => void;\n\n/** Segment visitor callback type for polygons defined with array of points. */\nexport type SegmentVisitorPoints = (\n  p1: NumericArray,\n  p2: NumericArray,\n  i1: number,\n  i2: number\n) => void;\n\n/** Parameters of a polygon. */\ntype PolygonParams = {\n  start?: number; // Start index of the polygon in the array of positions. Defaults to 0.\n  end?: number; // End index of the polygon in the array of positions. Defaults to number of positions.\n  size?: number; // Size of a point, 2 (XZ) or 3 (XYZ). Defaults to 2. Affects only polygons stored in flat arrays.\n  isClosed?: boolean; // Indicates that the first point of the polygon is equal to the last point, and additional checks should be ommited.\n};\n\n/**\n * Checks winding direction of the polygon and reverses the polygon in case of opposite winding direction.\n * Note: points are modified in-place.\n * @param points An array that represents points of the polygon.\n * @param direction Requested winding direction. 1 is for clockwise, -1 for counterclockwise winding direction.\n * @param options Parameters of the polygon.\n * @return Returns true if the winding direction was changed.\n */\nexport function modifyPolygonWindingDirection(\n  points: NumericArray,\n  direction: number,\n  options: PolygonParams = {}\n): boolean {\n  const windingDirection = getPolygonWindingDirection(points, options);\n  if (windingDirection !== direction) {\n    reversePolygon(points, options);\n    return true;\n  }\n  return false;\n}\n\n/**\n * Returns winding direction of the polygon.\n * @param points An array that represents points of the polygon.\n * @param options Parameters of the polygon.\n * @returns Winding direction of the polygon.\n */\nexport function getPolygonWindingDirection(\n  points: NumericArray,\n  options: PolygonParams = {}\n): number {\n  return Math.sign(getPolygonSignedArea(points, options));\n}\n\n/**\n * Returns signed area of the polygon.\n * @param points An array that represents points of the polygon.\n * @param options Parameters of the polygon.\n * @returns Signed area of the polygon.\n * https://en.wikipedia.org/wiki/Shoelace_formula\n */\nexport function getPolygonSignedArea(points: NumericArray, options: PolygonParams = {}): number {\n  const {start = 0, end = points.length} = options;\n  const dim = options.size || 2;\n  let area = 0;\n  for (let i = start, j = end - dim; i < end; i += dim) {\n    area += (points[i] - points[j]) * (points[i + 1] + points[j + 1]);\n    j = i;\n  }\n  return area / 2;\n}\n\n/**\n * Calls the visitor callback for each segment in the polygon.\n * @param points An array that represents points of the polygon\n * @param visitor A callback to call for each segment.\n * @param options Parameters of the polygon.\n */\nexport function forEachSegmentInPolygon(\n  points: NumericArray,\n  visitor: SegmentVisitorFlat,\n  options: PolygonParams = {}\n): void {\n  const {start = 0, end = points.length, size = 2, isClosed} = options;\n\n  const numPoints = (end - start) / size;\n  for (let i = 0; i < numPoints - 1; ++i) {\n    visitor(\n      points[start + i * size],\n      points[start + i * size + 1],\n      points[start + (i + 1) * size],\n      points[start + (i + 1) * size + 1],\n      i,\n      i + 1\n    );\n  }\n\n  const endPointIndex = start + (numPoints - 1) * size;\n  const isClosedEx =\n    isClosed ||\n    (equals(points[start], points[endPointIndex]) &&\n      equals(points[start + 1], points[endPointIndex + 1]));\n\n  if (!isClosedEx) {\n    visitor(\n      points[endPointIndex],\n      points[endPointIndex + 1],\n      points[start],\n      points[start + 1],\n      numPoints - 1,\n      0\n    );\n  }\n}\n\nfunction reversePolygon(\n  points: NumericArray,\n  options: {start?: number; end?: number; size?: number}\n): void {\n  const {start = 0, end = points.length, size = 2} = options;\n\n  const numPoints = (end - start) / size;\n  const numSwaps = Math.floor(numPoints / 2);\n  for (let i = 0; i < numSwaps; ++i) {\n    const b1 = start + i * size;\n    const b2 = start + (numPoints - 1 - i) * size;\n    for (let j = 0; j < size; ++j) {\n      const tmp = points[b1 + j];\n      points[b1 + j] = points[b2 + j];\n      points[b2 + j] = tmp;\n    }\n  }\n}\n\n/**\n * Checks winding direction of the polygon and reverses the polygon in case of opposite winding direction.\n * Note: points are modified in-place.\n * @param points Array of points that represent the polygon.\n * @param direction Requested winding direction. 1 is for clockwise, -1 for counterclockwise winding direction.\n * @param options Parameters of the polygon.\n * @return Returns true if the winding direction was changed.\n */\nexport function modifyPolygonWindingDirectionPoints(\n  points: PointsArray,\n  direction: number,\n  options: PolygonParams = {}\n): boolean {\n  const currentDirection = getPolygonWindingDirectionPoints(points, options);\n  if (currentDirection !== direction) {\n    points.reverse();\n    return true;\n  }\n  return false;\n}\n\n/**\n * Returns winding direction of the polygon.\n * @param points Array of points that represent the polygon.\n * @param options Parameters of the polygon.\n * @returns Winding direction of the polygon.\n */\nexport function getPolygonWindingDirectionPoints(\n  points: PointsArray,\n  options: PolygonParams = {}\n): number {\n  return Math.sign(getPolygonSignedAreaPoints(points, options));\n}\n\n/**\n * Returns signed area of the polygon.\n * @param points Array of points that represent the polygon.\n * @param options Parameters of the polygon.\n * @returns Signed area of the polygon.\n */\nexport function getPolygonSignedAreaPoints(\n  points: PointsArray,\n  options: PolygonParams = {}\n): number {\n  // https://en.wikipedia.org/wiki/Shoelace_formula\n  const {start = 0, end = points.length} = options;\n  let area = 0;\n  for (let i = start, j = end - 1; i < end; ++i) {\n    area += (points[i][0] - points[j][0]) * (points[i][1] + points[j][1]);\n    j = i;\n  }\n  return area / 2;\n}\n\n/**\n * Calls visitor callback for each segment in the polygon.\n * @param points Array of points that represent the polygon.\n * @param visitor A callback to call for each segment.\n * @param options Parameters of the polygon.\n */\nexport function forEachSegmentInPolygonPoints(\n  points: PointsArray,\n  visitor: SegmentVisitorPoints,\n  options: PolygonParams = {}\n): void {\n  const {start = 0, end = points.length, isClosed} = options;\n  for (let i = start; i < end - 1; ++i) {\n    visitor(points[i], points[i + 1], i, i + 1);\n  }\n\n  const isClosedEx = isClosed || equals(points[end - 1], points[0]);\n  if (!isClosedEx) {\n    visitor(points[end - 1], points[0], end - 1, 0);\n  }\n}\n","/*\n  Adapted from https://github.com/mapbox/lineclip to work with flat arrays\n  and 3d positions\n\n  ISC License\n\n  Copyright (c) 2015, Mapbox\n\n  Permission to use, copy, modify, and/or distribute this software for any purpose\n  with or without fee is hereby granted, provided that the above copyright notice\n  and this permission notice appear in all copies.\n\n  THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\n  REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND\n  FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\n  INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS\n  OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER\n  TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF\n  THIS SOFTWARE.\n\n */\n\n/* eslint-disable max-statements, max-depth, complexity */\n\nimport {push, copy, getPointAtIndex} from './utils';\nimport type {NumericArray} from '@math.gl/core';\n\nexport type BoundingBox = [number, number, number, number];\n\n/**\n * Cohen-Sutherland line clipping algorithm, adapted to efficiently\n * handle polylines rather than just segments\n */\nexport function clipPolyline(\n  positions: Readonly<NumericArray>,\n  bbox: BoundingBox,\n  options?: {\n    size?: number;\n    startIndex?: number;\n    endIndex?: number;\n  }\n): number[][] {\n  const {size = 2, startIndex = 0, endIndex = positions.length} = options || {};\n  const numPoints = (endIndex - startIndex) / size;\n  const result: number[][] = [];\n  let part: number[] = [];\n  let a: number[];\n  let b: number[];\n  let codeA: number = -1;\n  let codeB: number;\n  let lastCode: number;\n\n  for (let i = 1; i < numPoints; i++) {\n    a = getPointAtIndex(positions, i - 1, size, startIndex, a);\n    b = getPointAtIndex(positions, i, size, startIndex, b);\n    if (codeA < 0) {\n      codeA = bitCode(a, bbox);\n    }\n    codeB = lastCode = bitCode(b, bbox);\n\n    // eslint-disable-next-line no-constant-condition\n    while (true) {\n      if (!(codeA | codeB)) {\n        // accept\n        push(part, a);\n\n        if (codeB !== lastCode) {\n          // segment went outside\n          push(part, b);\n\n          if (i < numPoints - 1) {\n            // start a new line\n            result.push(part);\n            part = [];\n          }\n        } else if (i === numPoints - 1) {\n          push(part, b);\n        }\n        break;\n      } else if (codeA & codeB) {\n        // trivial reject\n        break;\n      } else if (codeA) {\n        // a outside, intersect with clip edge\n        intersect(a, b, codeA, bbox, a);\n        codeA = bitCode(a, bbox);\n      } else {\n        // b outside\n        intersect(a, b, codeB, bbox, b);\n        codeB = bitCode(b, bbox);\n      }\n    }\n\n    codeA = lastCode;\n  }\n\n  if (part.length) result.push(part);\n\n  return result;\n}\n\n/**\n * Sutherland-Hodgeman polygon clipping algorithm\n * polygon must be closed (first vertex == last vertex)\n */\nexport function clipPolygon(\n  positions: Readonly<NumericArray>,\n  bbox: BoundingBox,\n  options?: {\n    size?: number;\n    startIndex?: number;\n    endIndex?: number;\n  }\n): number[] {\n  const {size = 2, endIndex = positions.length} = options || {};\n  let {startIndex = 0} = options || {};\n  let numPoints = (endIndex - startIndex) / size;\n  let result: number[];\n  let p: number[];\n  let prev: number[];\n  let inside: boolean;\n  let prevInside: boolean;\n\n  // clip against each side of the clip rectangle\n  for (let edge = 1; edge <= 8; edge *= 2) {\n    result = [];\n    prev = getPointAtIndex(positions, numPoints - 1, size, startIndex, prev);\n    prevInside = !(bitCode(prev, bbox) & edge);\n\n    for (let i = 0; i < numPoints; i++) {\n      p = getPointAtIndex(positions, i, size, startIndex, p);\n      inside = !(bitCode(p, bbox) & edge);\n\n      // if segment goes through the clip window, add an intersection\n      if (inside !== prevInside) push(result, intersect(prev, p, edge, bbox));\n\n      if (inside) push(result, p); // add a point if it's inside\n\n      copy(prev, p);\n      prevInside = inside;\n    }\n\n    // close loop\n    positions = result;\n    startIndex = 0;\n    numPoints = result.length / size;\n\n    if (!numPoints) break;\n  }\n\n  return result;\n}\n\n/** intersect a segment against one of the 4 lines that make up the bbox */\n\nexport function intersect(\n  a: number[],\n  b: number[],\n  edge: number,\n  bbox: BoundingBox,\n  out: number[] = []\n): number[] {\n  let t;\n  // Forces out[snapI] to be on the bbox edge\n  // Interpolation introduces precision issue which may cause lineclip to be\n  // stuck in an infinite loop\n  let snap: number;\n  if (edge & 8) {\n    // top\n    t = (bbox[3] - a[1]) / (b[1] - a[1]);\n    snap = 3;\n  } else if (edge & 4) {\n    // bottom\n    t = (bbox[1] - a[1]) / (b[1] - a[1]);\n    snap = 1;\n  } else if (edge & 2) {\n    // right\n    t = (bbox[2] - a[0]) / (b[0] - a[0]);\n    snap = 2;\n  } else if (edge & 1) {\n    // left\n    t = (bbox[0] - a[0]) / (b[0] - a[0]);\n    snap = 0;\n  } else {\n    return null;\n  }\n  for (let i = 0; i < a.length; i++) {\n    out[i] = (snap & 1) === i ? bbox[snap] : t * (b[i] - a[i]) + a[i];\n  }\n  return out;\n}\n\n/**\n * bit code reflects the point position relative to the bbox:\n *         left  mid  right\n *    top  1001  1000  1010\n *    mid  0001  0000  0010\n * bottom  0101  0100  0110\n */\nexport function bitCode(p: number[], bbox: BoundingBox): number {\n  let code = 0;\n\n  if (p[0] < bbox[0]) code |= 1;\n  // left\n  else if (p[0] > bbox[2]) code |= 2; // right\n\n  if (p[1] < bbox[1]) code |= 4;\n  // bottom\n  else if (p[1] > bbox[3]) code |= 8; // top\n\n  return code;\n}\n","import type {NumericArray} from '@math.gl/core';\n\nexport function push(target: number[], source: number[]): boolean {\n  const size = source.length;\n  const startIndex = target.length;\n\n  // dedupe, if source is the same point as the last vertex\n  if (startIndex > 0) {\n    let isDuplicate = true;\n    for (let i = 0; i < size; i++) {\n      if (target[startIndex - size + i] !== source[i]) {\n        isDuplicate = false;\n        break;\n      }\n    }\n    if (isDuplicate) {\n      return false;\n    }\n  }\n\n  for (let i = 0; i < size; i++) {\n    target[startIndex + i] = source[i];\n  }\n  return true;\n}\n\nexport function copy(target: number[], source: Readonly<NumericArray>): void {\n  const size = source.length;\n  for (let i = 0; i < size; i++) {\n    target[i] = source[i];\n  }\n}\n\nexport function getPointAtIndex(\n  positions: Readonly<NumericArray>,\n  index: number,\n  size: number,\n  offset: number,\n  out: number[] = []\n): number[] {\n  const startI = offset + index * size;\n  for (let i = 0; i < size; i++) {\n    out[i] = positions[startI + i];\n  }\n  return out;\n}\n","/* eslint-disable max-statements, max-depth, complexity, no-unused-expressions */\nimport {bitCode, intersect, BoundingBox} from './lineclip';\nimport {getPointAtIndex, copy, push} from './utils';\n\nimport type {NumericArray} from '@math.gl/core';\n\nexport type Polygon = {\n  positions: Readonly<NumericArray>;\n  holeIndices?: Readonly<NumericArray>;\n  edgeTypes?: Readonly<NumericArray>;\n};\n\nexport function cutPolylineByGrid(\n  positions: NumericArray,\n  options?: {\n    size?: number;\n    broken?: boolean;\n    gridResolution?: number;\n    gridOffset?: [number, number];\n    startIndex?: number;\n    endIndex?: number;\n  }\n): number[] | number[][] {\n  const {\n    size = 2,\n    broken = false,\n    gridResolution = 10,\n    gridOffset = [0, 0],\n    startIndex = 0,\n    endIndex = positions.length\n  } = options || {};\n  const numPoints = (endIndex - startIndex) / size;\n  let part: number[] = [];\n  const result: number[][] = [part];\n  const a: number[] = getPointAtIndex(positions, 0, size, startIndex);\n  let b: number[];\n  let codeB: number;\n  const cell: BoundingBox = getGridCell(a, gridResolution, gridOffset, []);\n  const scratchPoint: number[] = [];\n  push(part, a);\n\n  for (let i = 1; i < numPoints; i++) {\n    b = getPointAtIndex(positions, i, size, startIndex, b);\n    codeB = bitCode(b, cell);\n\n    while (codeB) {\n      // find the intersection with the current cell\n      intersect(a, b, codeB, cell, scratchPoint);\n      const codeAlt = bitCode(scratchPoint, cell);\n      if (codeAlt) {\n        intersect(a, scratchPoint, codeAlt, cell, scratchPoint);\n        codeB = codeAlt;\n      }\n      push(part, scratchPoint);\n      // move to the next cell\n      copy(a, scratchPoint);\n\n      moveToNeighborCell(cell, gridResolution, codeB);\n      if (broken && part.length > size) {\n        part = [];\n        result.push(part);\n        push(part, a);\n      }\n\n      codeB = bitCode(b, cell);\n    }\n\n    push(part, b);\n    copy(a, b);\n  }\n\n  return broken ? result : result[0];\n}\n\nconst TYPE_INSIDE = 0;\nconst TYPE_BORDER = 1;\n\nfunction concatInPlace(arr1: number[], arr2: number[]): number[] {\n  for (let i = 0; i < arr2.length; i++) {\n    arr1.push(arr2[i]);\n  }\n  return arr1;\n}\n\nexport function cutPolygonByGrid(\n  positions: Readonly<NumericArray>,\n  holeIndices: Readonly<NumericArray> | null = null,\n  options?: {\n    size?: number;\n    gridResolution?: number;\n    gridOffset?: [number, number];\n    edgeTypes?: boolean;\n  }\n): Polygon[] {\n  if (!positions.length) {\n    // input is empty\n    return [];\n  }\n  const {size = 2, gridResolution = 10, gridOffset = [0, 0], edgeTypes = false} = options || {};\n  const result: Polygon[] = [];\n  const queue: {pos: Readonly<NumericArray>; types: number[]; holes: Readonly<NumericArray>}[] = [\n    {\n      pos: positions,\n      types: edgeTypes ? (new Array(positions.length / size).fill(TYPE_BORDER) as number[]) : null,\n      holes: holeIndices || []\n    }\n  ];\n  const bbox: number[][] = [[], []];\n  // @ts-ignore\n  let cell: BoundingBox = [];\n\n  // Recursively bisect polygon until every part fit in a single grid cell\n  while (queue.length) {\n    const {pos, types, holes} = queue.shift();\n\n    // Get the bounding box of the outer polygon\n    getBoundingBox(pos, size, holes[0] || pos.length, bbox);\n    cell = getGridCell(bbox[0], gridResolution, gridOffset, cell);\n    const code = bitCode(bbox[1], cell);\n\n    if (code) {\n      // Split the outer ring at the boundary\n      let parts = bisectPolygon(pos, types, size, 0, holes[0] || pos.length, cell, code);\n      const polygonLow = {pos: parts[0].pos, types: parts[0].types, holes: []};\n      const polygonHigh = {pos: parts[1].pos, types: parts[1].types, holes: []};\n      queue.push(polygonLow, polygonHigh);\n\n      // Split each hole at the boundary\n      for (let i = 0; i < holes.length; i++) {\n        parts = bisectPolygon(pos, types, size, holes[i], holes[i + 1] || pos.length, cell, code);\n\n        if (parts[0]) {\n          polygonLow.holes.push(polygonLow.pos.length);\n          polygonLow.pos = concatInPlace(polygonLow.pos, parts[0].pos);\n          if (edgeTypes) {\n            polygonLow.types = concatInPlace(polygonLow.types, parts[0].types);\n          }\n        }\n        if (parts[1]) {\n          polygonHigh.holes.push(polygonHigh.pos.length);\n          polygonHigh.pos = concatInPlace(polygonHigh.pos, parts[1].pos);\n          if (edgeTypes) {\n            polygonHigh.types = concatInPlace(polygonHigh.types, parts[1].types);\n          }\n        }\n      }\n    } else {\n      // Polygon fits in a single cell, no more processing required\n      const polygon: Polygon = {positions: pos};\n      if (edgeTypes) {\n        polygon.edgeTypes = types;\n      }\n      if (holes.length) {\n        polygon.holeIndices = holes;\n      }\n\n      result.push(polygon);\n    }\n  }\n  return result;\n}\n\n// edgeTypes:\n// TYPE_BORDER - edge from the original polygon\n// TYPE_INSIDE - inside the original polygon\n// eslint-disable-next-line max-params\nfunction bisectPolygon(\n  positions: Readonly<NumericArray>,\n  edgeTypes: number[] | undefined,\n  size: number,\n  startIndex: number,\n  endIndex: number,\n  bbox: BoundingBox,\n  edge: number\n): {\n  pos: number[];\n  types?: number[];\n}[] {\n  const numPoints = (endIndex - startIndex) / size;\n  const resultLow: number[] = [];\n  const resultHigh: number[] = [];\n  const typesLow: number[] = [];\n  const typesHigh: number[] = [];\n  const scratchPoint: number[] = [];\n\n  let p: number[];\n  let side: number;\n  let type: number;\n  const prev = getPointAtIndex(positions, numPoints - 1, size, startIndex);\n  let prevSide = Math.sign(edge & 8 ? prev[1] - bbox[3] : prev[0] - bbox[2]);\n  let prevType = edgeTypes && edgeTypes[numPoints - 1];\n  let lowPointCount = 0;\n  let highPointCount = 0;\n\n  for (let i = 0; i < numPoints; i++) {\n    p = getPointAtIndex(positions, i, size, startIndex, p);\n    side = Math.sign(edge & 8 ? p[1] - bbox[3] : p[0] - bbox[2]);\n    type = edgeTypes && edgeTypes[startIndex / size + i];\n\n    // if segment goes through the boundary, add an intersection\n    if (side && prevSide && prevSide !== side) {\n      intersect(prev, p, edge, bbox, scratchPoint);\n      push(resultLow, scratchPoint) && typesLow.push(prevType);\n      push(resultHigh, scratchPoint) && typesHigh.push(prevType);\n    }\n\n    if (side <= 0) {\n      push(resultLow, p) && typesLow.push(type);\n      lowPointCount -= side;\n    } else if (typesLow.length) {\n      typesLow[typesLow.length - 1] = TYPE_INSIDE;\n    }\n    if (side >= 0) {\n      push(resultHigh, p) && typesHigh.push(type);\n      highPointCount += side;\n    } else if (typesHigh.length) {\n      typesHigh[typesHigh.length - 1] = TYPE_INSIDE;\n    }\n\n    copy(prev, p);\n    prevSide = side;\n    prevType = type;\n  }\n\n  return [\n    lowPointCount ? {pos: resultLow, types: edgeTypes && typesLow} : null,\n    highPointCount ? {pos: resultHigh, types: edgeTypes && typesHigh} : null\n  ];\n}\n\nfunction getGridCell(\n  p: number[],\n  gridResolution: number,\n  gridOffset: [number, number],\n  out: number[]\n): BoundingBox {\n  const left = Math.floor((p[0] - gridOffset[0]) / gridResolution) * gridResolution + gridOffset[0];\n  const bottom =\n    Math.floor((p[1] - gridOffset[1]) / gridResolution) * gridResolution + gridOffset[1];\n  out[0] = left;\n  out[1] = bottom;\n  out[2] = left + gridResolution;\n  out[3] = bottom + gridResolution;\n  return out as BoundingBox;\n}\n\nfunction moveToNeighborCell(cell: number[], gridResolution: number, edge: number): void {\n  if (edge & 8) {\n    // top\n    cell[1] += gridResolution;\n    cell[3] += gridResolution;\n  } else if (edge & 4) {\n    // bottom\n    cell[1] -= gridResolution;\n    cell[3] -= gridResolution;\n  } else if (edge & 2) {\n    // right\n    cell[0] += gridResolution;\n    cell[2] += gridResolution;\n  } else if (edge & 1) {\n    // left\n    cell[0] -= gridResolution;\n    cell[2] -= gridResolution;\n  }\n}\n\nfunction getBoundingBox(\n  positions: Readonly<NumericArray>,\n  size: number,\n  endIndex: number,\n  out: number[][]\n): number[][] {\n  let minX = Infinity;\n  let maxX = -Infinity;\n  let minY = Infinity;\n  let maxY = -Infinity;\n\n  for (let i = 0; i < endIndex; i += size) {\n    const x = positions[i];\n    const y = positions[i + 1];\n    minX = x < minX ? x : minX;\n    maxX = x > maxX ? x : maxX;\n    minY = y < minY ? y : minY;\n    maxY = y > maxY ? y : maxY;\n  }\n\n  out[0][0] = minX;\n  out[0][1] = minY;\n  out[1][0] = maxX;\n  out[1][1] = maxY;\n  return out;\n}\n","import {cutPolylineByGrid, cutPolygonByGrid} from './cut-by-grid';\nimport {getPointAtIndex, push} from './utils';\nimport type {Polygon} from './cut-by-grid';\nimport type {NumericArray} from '@math.gl/core';\n\n// https://en.wikipedia.org/wiki/Web_Mercator_projection\nconst DEFAULT_MAX_LATITUDE = 85.051129;\n\n/** https://user-images.githubusercontent.com/2059298/78465769-938b7a00-76ae-11ea-9b95-1f4c26425ab9.png */\nexport function cutPolylineByMercatorBounds(\n  positions: Readonly<NumericArray>,\n  options?: {\n    size?: number;\n    startIndex?: number;\n    endIndex?: number;\n    normalize?: boolean;\n  }\n): number[][] {\n  const {size = 2, startIndex = 0, endIndex = positions.length, normalize = true} = options || {};\n\n  // Remap longitudes so that each segment takes the shorter path\n  const newPositions = positions.slice(startIndex, endIndex);\n  wrapLongitudesForShortestPath(newPositions, size, 0, endIndex - startIndex);\n\n  const parts = cutPolylineByGrid(newPositions, {\n    size,\n    broken: true,\n    gridResolution: 360,\n    gridOffset: [-180, -180]\n  }) as number[][];\n\n  if (normalize) {\n    // Each part is guaranteed to be in a single copy of the world\n    // Map longitudes back to [-180, 180]\n    for (const part of parts) {\n      shiftLongitudesIntoRange(part, size);\n    }\n  }\n  return parts;\n}\n\n/** https://user-images.githubusercontent.com/2059298/78465770-94241080-76ae-11ea-809a-6a8534dac1d9.png */\nexport function cutPolygonByMercatorBounds(\n  positions: Readonly<NumericArray>,\n  holeIndices: Readonly<NumericArray> | null = null,\n  options?: {\n    size?: number;\n    normalize?: boolean;\n    maxLatitude?: number;\n    edgeTypes?: boolean;\n  }\n): Polygon[] {\n  const {size = 2, normalize = true, edgeTypes = false} = options || {};\n  holeIndices = holeIndices || [];\n  const newPositions: number[] = [];\n  const newHoleIndices: number[] = [];\n  let srcStartIndex = 0;\n  let targetIndex = 0;\n\n  for (let ringIndex = 0; ringIndex <= holeIndices.length; ringIndex++) {\n    // srcStartIndex/srcEndIndex define the ring in the original positions\n    const srcEndIndex = holeIndices[ringIndex] || positions.length;\n    // targetStartIndex/targetIndex define the ring in newPositions\n    const targetStartIndex = targetIndex;\n\n    // In case the ring contains a pole (e.g. Antarctica), we'll have to insert vertices\n    // The insertion point is defined by the vertex closest to the pole\n    // Split the the ring by the insertion point when copying to newPositions\n    const splitIndex = findSplitIndex(positions, size, srcStartIndex, srcEndIndex);\n    for (let i = splitIndex; i < srcEndIndex; i++) {\n      newPositions[targetIndex++] = positions[i];\n    }\n    for (let i = srcStartIndex; i < splitIndex; i++) {\n      newPositions[targetIndex++] = positions[i];\n    }\n\n    // Remap longitudes so that each segment takes the shorter path\n    wrapLongitudesForShortestPath(newPositions, size, targetStartIndex, targetIndex);\n\n    // Handle the case when the ring contains a pole\n    insertPoleVertices(newPositions, size, targetStartIndex, targetIndex, options?.maxLatitude);\n\n    srcStartIndex = srcEndIndex;\n    newHoleIndices[ringIndex] = targetIndex;\n  }\n  newHoleIndices.pop();\n\n  const parts = cutPolygonByGrid(newPositions, newHoleIndices, {\n    size,\n    gridResolution: 360,\n    gridOffset: [-180, -180],\n    edgeTypes\n  });\n\n  if (normalize) {\n    // Each part is guaranteed to be in a single copy of the world\n    // Map longitudes back to [-180, 180]\n    for (const part of parts) {\n      // @ts-expect-error (mutates readonly array) May mutate newPositions, which is created by us\n      shiftLongitudesIntoRange(part.positions, size);\n    }\n  }\n  return parts;\n}\n\n/* Helpers */\n\n// See comments for insertPoleVertices\nfunction findSplitIndex(\n  positions: Readonly<NumericArray>,\n  size: number,\n  startIndex: number,\n  endIndex: number\n): number {\n  let maxLat = -1;\n  let pointIndex = -1;\n  for (let i = startIndex + 1; i < endIndex; i += size) {\n    const lat = Math.abs(positions[i]);\n    if (lat > maxLat) {\n      maxLat = lat;\n      pointIndex = i - 1;\n    }\n  }\n  return pointIndex;\n}\n\n// https://user-images.githubusercontent.com/2059298/78857483-5987e400-79de-11ea-98fc-0631287a8431.png\n//\n// If the polygon contains a pole, to tesselate it correctly, we need to insert the edge\n// of map into the polygon. This requires adding two vertices that represent the pole, by\n// drawing a perpendicular line to the Mercator map edge from a selected vertex on the ring.\n//\n// We select the insertion position carefully so that the inserted line segments do not\n// intersect with the ring itself. This is ensured by findSplitIndex, which returns the\n// vertex closest to the pole.\nfunction insertPoleVertices(\n  positions: number[],\n  size: number,\n  startIndex: number,\n  endIndex: number,\n  maxLatitude: number = DEFAULT_MAX_LATITUDE\n): void {\n  // Check if the ring contains a pole\n  const firstLng = positions[startIndex];\n  const lastLng = positions[endIndex - size];\n  if (Math.abs(firstLng - lastLng) > 180) {\n    // The ring does not make a round trip\n    // Add the nearest pole to the vertices so that the polygon tesselates correctly\n    const p = getPointAtIndex(positions, 0, size, startIndex);\n    // Copy the first vertex to the world of the last vertex\n    p[0] += Math.round((lastLng - firstLng) / 360) * 360;\n    push(positions, p);\n    // Project the copied vertex to the edge of the map\n    p[1] = Math.sign(p[1]) * maxLatitude;\n    push(positions, p);\n    // Project the first vertex to the edge of the map\n    p[0] = firstLng;\n    push(positions, p);\n  }\n}\n\nfunction wrapLongitudesForShortestPath(\n  positions: NumericArray,\n  size: number,\n  startIndex: number,\n  endIndex: number\n): void {\n  let prevLng: number = positions[0];\n  let lng: number;\n  for (let i = startIndex; i < endIndex; i += size) {\n    lng = positions[i];\n    const delta = lng - prevLng;\n    if (delta > 180 || delta < -180) {\n      lng -= Math.round(delta / 360) * 360;\n    }\n    positions[i] = prevLng = lng;\n  }\n}\n\nfunction shiftLongitudesIntoRange(positions: NumericArray, size: number): void {\n  let refLng: number;\n  const pointCount = positions.length / size;\n\n  // Find a longitude that is not on the edge of a world\n  // Which we will use to determine which world copy it is\n  for (let i = 0; i < pointCount; i++) {\n    refLng = positions[i * size];\n    if ((refLng + 180) % 360 !== 0) {\n      break;\n    }\n  }\n\n  const delta = -Math.round(refLng / 360) * 360;\n  if (delta === 0) {\n    return;\n  }\n  for (let i = 0; i < pointCount; i++) {\n    positions[i * size] += delta;\n  }\n}\n","// Copyright (c) 2015 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n/* eslint-disable max-params */\nimport earcut from 'earcut';\nimport {modifyPolygonWindingDirection, WINDING} from '@math.gl/polygon';\n\nimport type {Position} from '@deck.gl/core';\nimport type {NumericArray} from '@math.gl/core';\n\nconst OUTER_POLYGON_WINDING = WINDING.CLOCKWISE;\nconst HOLE_POLYGON_WINDING = WINDING.COUNTER_CLOCKWISE;\n\ntype WindingOptions = {\n  start?: number;\n  end?: number;\n  size?: number;\n  isClosed?: boolean;\n};\n\n/** A scratch object for sending winding options */\nconst windingOptions: WindingOptions = {\n  isClosed: true\n};\n\n// 4 data formats are supported:\n\n/** Simple Polygon: an array of points */\nexport type NestedSimplePolygonGeometry = Position[];\n/** Complex Polygon: an array of array of points (array of rings)\n * with the first ring representing the outer hull and other rings representing holes\n */\nexport type NestedComplexPolygonGeometry = Position[][];\n/** An array of numbers (flattened \"simple polygon\") */\nexport type FlatSimplePolygonGeometry = NumericArray;\n/** Flattened \"complex polygon\" */\nexport type FlatComplexPolygonGeometry = {positions: NumericArray; holeIndices: NumericArray};\n\nexport type PolygonGeometry =\n  | NestedSimplePolygonGeometry\n  | NestedComplexPolygonGeometry\n  | FlatSimplePolygonGeometry\n  | FlatComplexPolygonGeometry;\n\nexport type NormalizedPolygonGeometry = FlatSimplePolygonGeometry | FlatComplexPolygonGeometry;\n\n/**\n * Ensure a polygon is valid format\n */\nfunction validate(polygon: PolygonGeometry): void {\n  polygon = (polygon && (polygon as FlatComplexPolygonGeometry).positions) || polygon;\n  if (!Array.isArray(polygon) && !ArrayBuffer.isView(polygon)) {\n    throw new Error('invalid polygon');\n  }\n}\n\n/** Get the positions from a normalized polygon */\nexport function getPositions(polygon: NormalizedPolygonGeometry): NumericArray {\n  return 'positions' in polygon ? polygon.positions : polygon;\n}\n\n/** Get the hole indices from a normalized polygon */\nexport function getHoleIndices(polygon: NormalizedPolygonGeometry): NumericArray | null {\n  return 'holeIndices' in polygon ? polygon.holeIndices : null;\n}\n\n/**\n * Check if a polygon is nested or flat\n * Returns true if the polygon is a flat polygon (i.e. not an array of polygons)\n */\nfunction isNested(\n  polygon: PolygonGeometry\n): polygon is NestedSimplePolygonGeometry | NestedComplexPolygonGeometry {\n  return Array.isArray(polygon[0]);\n}\n\n/**\n * Check if a polygon is simple or complex\n * Returns true if the polygon is a simple polygon (i.e. not an array of polygons)\n */\nfunction isSimple(\n  polygon: NestedSimplePolygonGeometry | NestedComplexPolygonGeometry\n): polygon is NestedSimplePolygonGeometry {\n  return polygon.length >= 1 && polygon[0].length >= 2 && Number.isFinite(polygon[0][0]);\n}\n\n/**\n * Check if a simple polygon is a closed ring\n * Returns true if the simple polygon is a closed ring\n */\nfunction isNestedRingClosed(simplePolygon: NestedSimplePolygonGeometry): boolean {\n  // check if first and last vertex are the same\n  const p0 = simplePolygon[0];\n  const p1 = simplePolygon[simplePolygon.length - 1];\n\n  return p0[0] === p1[0] && p0[1] === p1[1] && p0[2] === p1[2];\n}\n\n/**\n * Check if a simple flat array is a closed ring\n * Returns true if the simple flat array is a closed ring\n */\nfunction isFlatRingClosed(\n  positions: FlatSimplePolygonGeometry,\n  /** size of a position, 2 (xy) or 3 (xyz) */\n  size: number,\n  /** start index of the path in the positions array */\n  startIndex: number,\n  /** end index of the path in the positions array */\n  endIndex: number\n): boolean {\n  for (let i = 0; i < size; i++) {\n    if (positions[startIndex + i] !== positions[endIndex - size + i]) {\n      return false;\n    }\n  }\n  return true;\n}\n\n/**\n * Copy a simple polygon coordinates into a flat array, closes the ring if needed.\n * Returns the index of the write head in the destination\n */\nfunction copyNestedRing(\n  /** destination */\n  target: NumericArray,\n  /** index in the destination to start copying into */\n  targetStartIndex: number,\n  /** the source polygon */\n  simplePolygon: NestedSimplePolygonGeometry,\n  /** size of a position, 2 (xy) or 3 (xyz) */\n  size: number,\n  /** modify polygon to be of the specified winding direction */\n  windingDirection: number\n): number {\n  let targetIndex = targetStartIndex;\n  const len = simplePolygon.length;\n  for (let i = 0; i < len; i++) {\n    for (let j = 0; j < size; j++) {\n      target[targetIndex++] = simplePolygon[i][j] || 0;\n    }\n  }\n\n  if (!isNestedRingClosed(simplePolygon)) {\n    for (let j = 0; j < size; j++) {\n      target[targetIndex++] = simplePolygon[0][j] || 0;\n    }\n  }\n\n  windingOptions.start = targetStartIndex;\n  windingOptions.end = targetIndex;\n  windingOptions.size = size;\n  modifyPolygonWindingDirection(target, windingDirection, windingOptions);\n\n  return targetIndex;\n}\n\n/**\n * Copy a simple flat array into another flat array, closes the ring if needed.\n * Returns the index of the write head in the destination\n */\nfunction copyFlatRing(\n  /** destination */\n  target: NumericArray,\n  /** index in the destination to start copying into */\n  targetStartIndex: number,\n  /** the source polygon */\n  positions: FlatSimplePolygonGeometry,\n  /** size of a position, 2 (xy) or 3 (xyz) */\n  size: number,\n  /** start index of the path in the positions array */\n  srcStartIndex: number = 0,\n  /** end index of the path in the positions array */\n  srcEndIndex: number,\n  windingDirection: number\n): number {\n  srcEndIndex = srcEndIndex || positions.length;\n  const srcLength = srcEndIndex - srcStartIndex;\n  if (srcLength <= 0) {\n    return targetStartIndex;\n  }\n  let targetIndex = targetStartIndex;\n\n  for (let i = 0; i < srcLength; i++) {\n    target[targetIndex++] = positions[srcStartIndex + i];\n  }\n\n  if (!isFlatRingClosed(positions, size, srcStartIndex, srcEndIndex)) {\n    for (let i = 0; i < size; i++) {\n      target[targetIndex++] = positions[srcStartIndex + i];\n    }\n  }\n\n  windingOptions.start = targetStartIndex;\n  windingOptions.end = targetIndex;\n  windingOptions.size = size;\n  modifyPolygonWindingDirection(target, windingDirection, windingOptions);\n\n  return targetIndex;\n}\n\n/**\n * Normalize any polygon representation into the \"complex flat\" format\n */\n/* eslint-disable max-statements */\nexport function normalize(\n  polygon: PolygonGeometry,\n  positionSize: number\n): NormalizedPolygonGeometry {\n  validate(polygon);\n\n  const positions: number[] = [];\n  const holeIndices: number[] = [];\n\n  if ('positions' in polygon) {\n    // complex flat\n    const {positions: srcPositions, holeIndices: srcHoleIndices} = polygon;\n\n    if (srcHoleIndices) {\n      let targetIndex = 0;\n      // split the positions array into `holeIndices.length + 1` rings\n      // holeIndices[-1] falls back to 0\n      // holeIndices[holeIndices.length] falls back to positions.length\n      for (let i = 0; i <= srcHoleIndices.length; i++) {\n        targetIndex = copyFlatRing(\n          positions,\n          targetIndex,\n          srcPositions,\n          positionSize,\n          srcHoleIndices[i - 1],\n          srcHoleIndices[i],\n          i === 0 ? OUTER_POLYGON_WINDING : HOLE_POLYGON_WINDING\n        );\n        holeIndices.push(targetIndex);\n      }\n      // The last one is not a starting index of a hole, remove\n      holeIndices.pop();\n\n      return {positions, holeIndices};\n    }\n    polygon = srcPositions;\n  }\n  if (!isNested(polygon)) {\n    // simple flat\n    copyFlatRing(positions, 0, polygon, positionSize, 0, positions.length, OUTER_POLYGON_WINDING);\n    return positions;\n  }\n  if (!isSimple(polygon)) {\n    // complex polygon\n    let targetIndex = 0;\n\n    for (const [polygonIndex, simplePolygon] of polygon.entries()) {\n      targetIndex = copyNestedRing(\n        positions,\n        targetIndex,\n        simplePolygon,\n        positionSize,\n        polygonIndex === 0 ? OUTER_POLYGON_WINDING : HOLE_POLYGON_WINDING\n      );\n      holeIndices.push(targetIndex);\n    }\n    // The last one is not a starting index of a hole, remove\n    holeIndices.pop();\n    // last index points to the end of the array, remove it\n    return {positions, holeIndices};\n  }\n  // simple polygon\n  copyNestedRing(positions, 0, polygon, positionSize, OUTER_POLYGON_WINDING);\n  return positions;\n}\n/* eslint-enable max-statements */\n\n/*\n * Calculate the area of a single plane of the polygon\n */\nfunction getPlaneArea(positions: NumericArray, xIndex: number, yIndex: number): number {\n  const numVerts = positions.length / 3;\n  let area = 0;\n  for (let i = 0; i < numVerts; i++) {\n    const j = (i + 1) % numVerts;\n    area += positions[i * 3 + xIndex] * positions[j * 3 + yIndex];\n    area -= positions[j * 3 + xIndex] * positions[i * 3 + yIndex];\n  }\n  return Math.abs(area / 2);\n}\n\nfunction permutePositions(positions: NumericArray, xIndex: number, yIndex: number, zIndex: number) {\n  const numVerts = positions.length / 3;\n  for (let i = 0; i < numVerts; i++) {\n    const o = i * 3;\n\n    const x = positions[o + 0];\n    const y = positions[o + 1];\n    const z = positions[o + 2];\n\n    positions[o + xIndex] = x;\n    positions[o + yIndex] = y;\n    positions[o + zIndex] = z;\n  }\n}\n\n/*\n * Get vertex indices for drawing polygon mesh (triangulation)\n */\n// eslint-disable-next-line complexity, max-statements\nexport function getSurfaceIndices(\n  polygon: NormalizedPolygonGeometry,\n  positionSize: number,\n  preproject?: (xy: number[]) => number[],\n  full3d?: boolean\n): number[] {\n  let holeIndices = getHoleIndices(polygon);\n  if (holeIndices) {\n    holeIndices = holeIndices.map(positionIndex => positionIndex / positionSize);\n  }\n\n  let positions = getPositions(polygon);\n\n  const is3d = full3d && positionSize === 3;\n\n  if (preproject) {\n    // When tesselating lnglat coordinates, project them to the common space for accuracy\n    const n = positions.length;\n\n    // Clone the array\n    positions = positions.slice();\n\n    const p: number[] = [];\n    for (let i = 0; i < n; i += positionSize) {\n      p[0] = positions[i];\n      p[1] = positions[i + 1];\n\n      if (is3d) {\n        p[2] = positions[i + 2];\n      }\n\n      const xy = preproject(p);\n\n      positions[i] = xy[0];\n      positions[i + 1] = xy[1];\n\n      if (is3d) {\n        positions[i + 2] = xy[2];\n      }\n    }\n  }\n\n  if (is3d) {\n    // calculate plane with largest area\n    const xyArea = getPlaneArea(positions, 0, 1);\n    const xzArea = getPlaneArea(positions, 0, 2);\n    const yzArea = getPlaneArea(positions, 1, 2);\n\n    if (!xyArea && !xzArea && !yzArea) {\n      return []; // no planes have area, nothing we can do\n    }\n\n    // permute positions to make the largest plane xy for earcut\n    if (xyArea > xzArea && xyArea > yzArea) {\n      // xy plane largest, nothing to do\n    } else if (xzArea > yzArea) {\n      // xz plane largest, permute to make xyz -> xzy\n      if (!preproject) {\n        positions = positions.slice();\n      }\n      permutePositions(positions, 0, 2, 1);\n    } else {\n      // yz plane largest, permute to make xyz -> yzx\n      if (!preproject) {\n        positions = positions.slice();\n      }\n      permutePositions(positions, 2, 0, 1);\n    }\n  }\n\n  // Let earcut triangulate the polygon\n  return earcut(positions, holeIndices, positionSize);\n}\n","// Copyright (c) 2015 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\nimport {createIterable, getAccessorFromBuffer} from './iterable-utils';\nimport defaultTypedArrayManager from './typed-array-manager';\nimport assert from './assert';\n\nimport {Buffer} from '@luma.gl/webgl';\n\nimport type {BinaryAttribute} from '../lib/attribute/attribute';\nimport type {TypedArray} from '../types/types';\nimport type {AccessorFunction} from '../types/layer-props';\nimport type {TypedArrayManager} from './typed-array-manager';\n\ntype ExternalBuffer = TypedArray | Buffer | BinaryAttribute;\n\ntype TesselatorOptions<GeometryT, ExtraOptionsT> = ExtraOptionsT & {\n  attributes?: Record<string, any>;\n  getGeometry?: AccessorFunction<any, GeometryT>;\n  data?: any;\n  buffers?: Record<string, ExternalBuffer>;\n  geometryBuffer?: ExternalBuffer;\n  positionFormat?: 'XY' | 'XYZ';\n  dataChanged?: {startRow: number; endRow?: number}[] | string | false;\n  normalize?: boolean;\n};\n\nexport type GeometryUpdateContext = {\n  vertexStart: number;\n  indexStart: number;\n  geometrySize: number;\n  geometryIndex: number;\n};\n\nexport default abstract class Tesselator<GeometryT, NormalizedGeometryT, ExtraOptionsT> {\n  opts: TesselatorOptions<GeometryT, ExtraOptionsT>;\n  typedArrayManager: TypedArrayManager;\n  indexStarts: number[] = [0];\n  vertexStarts: number[] = [0];\n  vertexCount: number = 0;\n  instanceCount: number = 0;\n  attributes: Record<string, TypedArray | null>;\n\n  protected _attributeDefs: any;\n  protected data: any;\n  protected getGeometry?: AccessorFunction<any, GeometryT> | null;\n  protected geometryBuffer?: ExternalBuffer;\n  protected buffers!: Record<string, ExternalBuffer>;\n  protected positionSize!: number;\n  protected normalize!: boolean;\n\n  constructor(opts: TesselatorOptions<GeometryT, ExtraOptionsT>) {\n    const {attributes = {}} = opts;\n\n    this.typedArrayManager = defaultTypedArrayManager;\n    this.attributes = {};\n    this._attributeDefs = attributes;\n    this.opts = opts;\n\n    this.updateGeometry(opts);\n  }\n\n  /* Public methods */\n  updateGeometry(opts: TesselatorOptions<GeometryT, ExtraOptionsT>): void {\n    Object.assign(this.opts, opts);\n    const {\n      data,\n      buffers = {},\n      getGeometry,\n      geometryBuffer,\n      positionFormat,\n      dataChanged,\n      normalize = true\n    } = this.opts;\n    this.data = data;\n    this.getGeometry = getGeometry;\n    this.positionSize =\n      // @ts-ignore (2339) when geometryBuffer is a luma Buffer, size falls back to positionFormat\n      (geometryBuffer && geometryBuffer.size) || (positionFormat === 'XY' ? 2 : 3);\n    this.buffers = buffers;\n    this.normalize = normalize;\n\n    // Handle external logical value\n    if (geometryBuffer) {\n      assert(data.startIndices); // binary data missing startIndices\n      this.getGeometry = this.getGeometryFromBuffer(geometryBuffer);\n\n      if (!normalize) {\n        // skip packing and set attribute value directly\n        // TODO - avoid mutating user-provided object\n        buffers.positions = geometryBuffer;\n      }\n    }\n    this.geometryBuffer = buffers.positions;\n\n    if (Array.isArray(dataChanged)) {\n      // is partial update\n      for (const dataRange of dataChanged as {startRow: number; endRow?: number}[]) {\n        this._rebuildGeometry(dataRange);\n      }\n    } else {\n      this._rebuildGeometry();\n    }\n  }\n\n  updatePartialGeometry({startRow, endRow}: {startRow: number; endRow: number}): void {\n    this._rebuildGeometry({startRow, endRow});\n  }\n\n  // Subclass interface\n\n  /** Convert geometry to a uniform shape */\n  protected abstract normalizeGeometry(geometry: GeometryT): NormalizedGeometryT;\n\n  /** Update the positions buffer of a single geometry */\n  protected abstract updateGeometryAttributes(\n    geometry: NormalizedGeometryT | null,\n    context: GeometryUpdateContext\n  );\n\n  /** Get the number of vertices in a geometry */\n  protected abstract getGeometrySize(geometry: NormalizedGeometryT): number;\n\n  protected getGeometryFromBuffer(\n    geometryBuffer: ExternalBuffer\n  ): AccessorFunction<any, GeometryT> | null {\n    const value = (geometryBuffer as BinaryAttribute).value || geometryBuffer;\n    if (!ArrayBuffer.isView(value)) {\n      // Cannot read binary geometries\n      return null;\n    }\n\n    // @ts-ignore (2322) NumericArray not assignable to GeometryT\n    return getAccessorFromBuffer(value, {\n      size: this.positionSize,\n      offset: (geometryBuffer as BinaryAttribute).offset,\n      stride: (geometryBuffer as BinaryAttribute).stride,\n      startIndices: this.data.startIndices\n    });\n  }\n\n  /* Private utility methods */\n  private _allocate(instanceCount: number, copy: boolean): void {\n    // allocate attributes\n    const {attributes, buffers, _attributeDefs, typedArrayManager} = this;\n    for (const name in _attributeDefs) {\n      if (name in buffers) {\n        // Use external buffer\n        typedArrayManager.release(attributes[name]);\n        attributes[name] = null;\n      } else {\n        const def = _attributeDefs[name];\n        // If dataRange is supplied, this is a partial update.\n        // In case we need to reallocate the typed array, it will need the old values copied\n        // before performing partial update.\n        def.copy = copy;\n\n        attributes[name] = typedArrayManager.allocate(attributes[name], instanceCount, def);\n      }\n    }\n  }\n\n  /**\n   * Visit all objects\n   * `data` is expected to be an iterable consistent with the base Layer expectation\n   */\n  private _forEachGeometry(\n    visitor: (geometry: GeometryT | null, index: number) => void,\n    startRow: number,\n    endRow: number\n  ): void {\n    const {data, getGeometry} = this;\n    const {iterable, objectInfo} = createIterable(data, startRow, endRow);\n    for (const object of iterable) {\n      objectInfo.index++;\n      const geometry = getGeometry ? getGeometry(object, objectInfo) : null;\n      visitor(geometry, objectInfo.index);\n    }\n  }\n\n  /* eslint-disable complexity,max-statements */\n  private _rebuildGeometry(dataRange?: {startRow: number; endRow?: number}): void {\n    if (!this.data) {\n      return;\n    }\n\n    let {indexStarts, vertexStarts, instanceCount} = this;\n    const {data, geometryBuffer} = this;\n    const {startRow = 0, endRow = Infinity} = dataRange || {};\n\n    const normalizedData: Record<number, NormalizedGeometryT | null> = {};\n\n    if (!dataRange) {\n      // Full update - regenerate buffer layout from scratch\n      indexStarts = [0];\n      vertexStarts = [0];\n    }\n    if (this.normalize || !geometryBuffer) {\n      this._forEachGeometry(\n        (geometry: GeometryT | null, dataIndex: number) => {\n          const normalizedGeometry = geometry && this.normalizeGeometry(geometry);\n          normalizedData[dataIndex] = normalizedGeometry;\n          vertexStarts[dataIndex + 1] =\n            vertexStarts[dataIndex] +\n            (normalizedGeometry ? this.getGeometrySize(normalizedGeometry) : 0);\n        },\n        startRow,\n        endRow\n      );\n      // count instances\n      instanceCount = vertexStarts[vertexStarts.length - 1];\n    } else {\n      // assume user provided data is already normalized\n      vertexStarts = data.startIndices;\n      instanceCount = vertexStarts[data.length] || 0;\n\n      if (ArrayBuffer.isView(geometryBuffer)) {\n        instanceCount = instanceCount || geometryBuffer.length / this.positionSize;\n      } else if (geometryBuffer instanceof Buffer) {\n        // @ts-expect-error (2339) accessor is not typed\n        const byteStride = geometryBuffer.accessor.stride || this.positionSize * 4;\n        instanceCount = instanceCount || geometryBuffer.byteLength / byteStride;\n      } else if (geometryBuffer.buffer) {\n        const byteStride = geometryBuffer.stride || this.positionSize * 4;\n        instanceCount = instanceCount || geometryBuffer.buffer.byteLength / byteStride;\n      } else if (geometryBuffer.value) {\n        const bufferValue = geometryBuffer.value;\n        const elementStride =\n          // @ts-ignore (2339) if stride is not specified, will fall through to positionSize\n          geometryBuffer.stride / bufferValue.BYTES_PER_ELEMENT || this.positionSize;\n        instanceCount = instanceCount || bufferValue.length / elementStride;\n      }\n    }\n\n    // allocate attributes\n    this._allocate(instanceCount, Boolean(dataRange));\n\n    this.indexStarts = indexStarts;\n    this.vertexStarts = vertexStarts;\n    this.instanceCount = instanceCount;\n\n    // @ts-ignore (2739) context will be populated in the loop\n    const context: GeometryUpdateContext = {};\n\n    this._forEachGeometry(\n      (geometry: GeometryT | null, dataIndex: number) => {\n        const normalizedGeometry =\n          normalizedData[dataIndex] ||\n          // @ts-expect-error (2352) GeometryT cannot be casted to NormalizedGeometryT. We are assuming the user passed already normalized data if opts.normalize is set to false.\n          (geometry as NormalizedGeometryT);\n        context.vertexStart = vertexStarts[dataIndex];\n        context.indexStart = indexStarts[dataIndex];\n        const vertexEnd =\n          dataIndex < vertexStarts.length - 1 ? vertexStarts[dataIndex + 1] : instanceCount;\n        context.geometrySize = vertexEnd - vertexStarts[dataIndex];\n        context.geometryIndex = dataIndex;\n        this.updateGeometryAttributes(normalizedGeometry, context);\n      },\n      startRow,\n      endRow\n    );\n\n    this.vertexCount = indexStarts[indexStarts.length - 1];\n  }\n}\n","// Copyright (c) 2015 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n// Handles tesselation of polygons with holes\n// - 2D surfaces\n// - 2D outlines\n// - 3D surfaces (top and sides only)\n// - 3D wireframes (not yet)\nimport * as Polygon from './polygon';\nimport {Tesselator} from '@deck.gl/core';\nimport {cutPolygonByGrid, cutPolygonByMercatorBounds} from '@math.gl/polygon';\n\nimport type {\n  PolygonGeometry,\n  NormalizedPolygonGeometry,\n  FlatComplexPolygonGeometry\n} from './polygon';\nimport type {TypedArray} from '@math.gl/core';\n\ntype GeometryUpdateContext = {\n  vertexStart: number;\n  indexStart: number;\n  geometrySize: number;\n  geometryIndex: number;\n};\n\ntype CutPolygon = FlatComplexPolygonGeometry & {\n  edgeTypes: number[];\n};\n\n// This class is set up to allow querying one attribute at a time\n// the way the AttributeManager expects it\nexport default class PolygonTesselator extends Tesselator<\n  PolygonGeometry,\n  NormalizedPolygonGeometry | CutPolygon[],\n  {\n    fp64?: boolean;\n    IndexType?: Uint32ArrayConstructor | Uint16ArrayConstructor;\n    resolution?: number;\n    wrapLongitude?: boolean;\n    preproject?: (xy: number[]) => number[];\n    full3d?: boolean;\n  }\n> {\n  constructor(opts) {\n    const {fp64, IndexType = Uint32Array} = opts;\n    super({\n      ...opts,\n      attributes: {\n        positions: {size: 3, type: fp64 ? Float64Array : Float32Array},\n        vertexValid: {type: Uint8ClampedArray, size: 1},\n        indices: {type: IndexType, size: 1}\n      }\n    });\n  }\n\n  /** Get attribute by name */\n  get(attributeName: string): TypedArray | null {\n    const {attributes} = this;\n    if (attributeName === 'indices') {\n      return attributes.indices && attributes.indices.subarray(0, this.vertexCount);\n    }\n\n    return attributes[attributeName];\n  }\n\n  /** Override base Tesselator method */\n  updateGeometry(opts) {\n    super.updateGeometry(opts);\n\n    const externalIndices = this.buffers.indices;\n    if (externalIndices) {\n      // @ts-ignore (2339) value is not defined on TypedArray (fall through)\n      this.vertexCount = (externalIndices.value || externalIndices).length;\n    } else if (this.data && !this.getGeometry) {\n      throw new Error('missing indices buffer');\n    }\n  }\n\n  /** Implement base Tesselator interface */\n  protected normalizeGeometry(polygon: PolygonGeometry): NormalizedPolygonGeometry | CutPolygon[] {\n    if (this.normalize) {\n      const normalizedPolygon = Polygon.normalize(polygon, this.positionSize);\n      if (this.opts.resolution) {\n        return cutPolygonByGrid(\n          Polygon.getPositions(normalizedPolygon),\n          Polygon.getHoleIndices(normalizedPolygon),\n          {\n            size: this.positionSize,\n            gridResolution: this.opts.resolution,\n            edgeTypes: true\n          }\n        ) as CutPolygon[];\n      }\n      if (this.opts.wrapLongitude) {\n        return cutPolygonByMercatorBounds(\n          Polygon.getPositions(normalizedPolygon),\n          Polygon.getHoleIndices(normalizedPolygon),\n          {\n            size: this.positionSize,\n            maxLatitude: 86,\n            edgeTypes: true\n          }\n        ) as CutPolygon[];\n      }\n      return normalizedPolygon;\n    }\n    // normalize is explicitly set to false, assume that user passed in already normalized polygons\n    return polygon as NormalizedPolygonGeometry;\n  }\n\n  /** Implement base Tesselator interface */\n  protected getGeometrySize(polygon: NormalizedPolygonGeometry | CutPolygon[]): number {\n    if (isCut(polygon)) {\n      let size = 0;\n      for (const subPolygon of polygon) {\n        size += this.getGeometrySize(subPolygon);\n      }\n      return size;\n    }\n    return Polygon.getPositions(polygon).length / this.positionSize;\n  }\n\n  /** Override base Tesselator method */\n  protected getGeometryFromBuffer(buffer) {\n    if (this.normalize || !this.buffers.indices) {\n      return super.getGeometryFromBuffer(buffer);\n    }\n    // we don't need to read the positions if no normalization/tesselation\n    return null;\n  }\n\n  /** Implement base Tesselator interface */\n  protected updateGeometryAttributes(\n    polygon: NormalizedPolygonGeometry | CutPolygon[] | null,\n    context: GeometryUpdateContext\n  ) {\n    if (polygon && isCut(polygon)) {\n      for (const subPolygon of polygon) {\n        const geometrySize = this.getGeometrySize(subPolygon);\n        context.geometrySize = geometrySize;\n        this.updateGeometryAttributes(subPolygon, context);\n        context.vertexStart += geometrySize;\n        context.indexStart = this.indexStarts[context.geometryIndex + 1];\n      }\n    } else {\n      this._updateIndices(polygon, context);\n      this._updatePositions(polygon, context);\n      this._updateVertexValid(polygon, context);\n    }\n  }\n\n  // Flatten the indices array\n  private _updateIndices(\n    polygon: NormalizedPolygonGeometry | null,\n    {geometryIndex, vertexStart: offset, indexStart}: GeometryUpdateContext\n  ) {\n    const {attributes, indexStarts, typedArrayManager} = this;\n\n    let target = attributes.indices;\n    if (!target || !polygon) {\n      return;\n    }\n    let i = indexStart;\n\n    // 1. get triangulated indices for the internal areas\n    const indices = Polygon.getSurfaceIndices(\n      polygon,\n      this.positionSize,\n      this.opts.preproject,\n      this.opts.full3d\n    );\n\n    // make sure the buffer is large enough\n    target = typedArrayManager.allocate(target, indexStart + indices.length, {\n      copy: true\n    });\n\n    // 2. offset each index by the number of indices in previous polygons\n    for (let j = 0; j < indices.length; j++) {\n      target[i++] = indices[j] + offset;\n    }\n\n    indexStarts[geometryIndex + 1] = indexStart + indices.length;\n    attributes.indices = target;\n  }\n\n  // Flatten out all the vertices of all the sub subPolygons\n  private _updatePositions(\n    polygon: NormalizedPolygonGeometry | null,\n    {vertexStart, geometrySize}: GeometryUpdateContext\n  ) {\n    const {\n      attributes: {positions},\n      positionSize\n    } = this;\n    if (!positions || !polygon) {\n      return;\n    }\n    const polygonPositions = Polygon.getPositions(polygon);\n\n    for (let i = vertexStart, j = 0; j < geometrySize; i++, j++) {\n      const x = polygonPositions[j * positionSize];\n      const y = polygonPositions[j * positionSize + 1];\n      const z = positionSize > 2 ? polygonPositions[j * positionSize + 2] : 0;\n\n      positions[i * 3] = x;\n      positions[i * 3 + 1] = y;\n      positions[i * 3 + 2] = z;\n    }\n  }\n\n  private _updateVertexValid(\n    polygon: NormalizedPolygonGeometry | null,\n    {vertexStart, geometrySize}: GeometryUpdateContext\n  ) {\n    const {positionSize} = this;\n    const vertexValid = this.attributes.vertexValid as TypedArray;\n    const holeIndices = polygon && Polygon.getHoleIndices(polygon);\n    /* We are reusing the some buffer for `nextPositions` by offseting one vertex\n     * to the left. As a result,\n     * the last vertex of each ring overlaps with the first vertex of the next ring.\n     * `vertexValid` is used to mark the end of each ring so we don't draw these\n     * segments:\n      positions      A0 A1 A2 A3 A4 B0 B1 B2 C0 ...\n      nextPositions  A1 A2 A3 A4 B0 B1 B2 C0 C1 ...\n      vertexValid    1  1  1  1  0  1  1  0  1 ...\n     */\n    if (polygon && (polygon as CutPolygon).edgeTypes) {\n      vertexValid.set((polygon as CutPolygon).edgeTypes, vertexStart);\n    } else {\n      vertexValid.fill(1, vertexStart, vertexStart + geometrySize);\n    }\n    if (holeIndices) {\n      for (let j = 0; j < holeIndices.length; j++) {\n        vertexValid[vertexStart + holeIndices[j] / positionSize - 1] = 0;\n      }\n    }\n    vertexValid[vertexStart + geometrySize - 1] = 0;\n  }\n}\n\nfunction isCut(polygon: NormalizedPolygonGeometry | CutPolygon[]): polygon is CutPolygon[] {\n  return Array.isArray(polygon) && polygon.length > 0 && !Number.isFinite(polygon[0]);\n}\n","// Copyright (c) 2015 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\nexport default `\\\n\nattribute vec2 vertexPositions;\nattribute float vertexValid;\n\nuniform bool extruded;\nuniform bool isWireframe;\nuniform float elevationScale;\nuniform float opacity;\n\nvarying vec4 vColor;\n\nstruct PolygonProps {\n  vec4 fillColors;\n  vec4 lineColors;\n  vec3 positions;\n  vec3 nextPositions;\n  vec3 pickingColors;\n  vec3 positions64Low;\n  vec3 nextPositions64Low;\n  float elevations;\n};\n\nvec3 project_offset_normal(vec3 vector) {\n  if (project_uCoordinateSystem == COORDINATE_SYSTEM_LNGLAT ||\n    project_uCoordinateSystem == COORDINATE_SYSTEM_LNGLAT_OFFSETS) {\n    // normals generated by the polygon tesselator are in lnglat offsets instead of meters\n    return normalize(vector * project_uCommonUnitsPerWorldUnit);\n  }\n  return project_normal(vector);\n}\n\nvoid calculatePosition(PolygonProps props) {\n#ifdef IS_SIDE_VERTEX\n  if(vertexValid < 0.5){\n    gl_Position = vec4(0.);\n    return;\n  }\n#endif\n\n  vec3 pos;\n  vec3 pos64Low;\n  vec3 normal;\n  vec4 colors = isWireframe ? props.lineColors : props.fillColors;\n\n  geometry.worldPosition = props.positions;\n  geometry.worldPositionAlt = props.nextPositions;\n  geometry.pickingColor = props.pickingColors;\n\n#ifdef IS_SIDE_VERTEX\n  pos = mix(props.positions, props.nextPositions, vertexPositions.x);\n  pos64Low = mix(props.positions64Low, props.nextPositions64Low, vertexPositions.x);\n#else\n  pos = props.positions;\n  pos64Low = props.positions64Low;\n#endif\n\n  if (extruded) {\n    pos.z += props.elevations * vertexPositions.y * elevationScale;\n  }\n  gl_Position = project_position_to_clipspace(pos, pos64Low, vec3(0.), geometry.position);\n\n  DECKGL_FILTER_GL_POSITION(gl_Position, geometry);\n\n  if (extruded) {\n  #ifdef IS_SIDE_VERTEX\n    normal = vec3(\n      props.positions.y - props.nextPositions.y + (props.positions64Low.y - props.nextPositions64Low.y),\n      props.nextPositions.x - props.positions.x + (props.nextPositions64Low.x - props.positions64Low.x),\n      0.0);\n    normal = project_offset_normal(normal);\n  #else\n    normal = project_normal(vec3(0.0, 0.0, 1.0));\n  #endif\n    geometry.normal = normal;\n    vec3 lightColor = lighting_getLightColor(colors.rgb, project_uCameraPosition, geometry.position.xyz, normal);\n    vColor = vec4(lightColor, colors.a * opacity);\n  } else {\n    vColor = vec4(colors.rgb, colors.a * opacity);\n  }\n  DECKGL_FILTER_COLOR(vColor, geometry);\n}\n`;\n","// Copyright (c) 2015 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\nimport main from './solid-polygon-layer-vertex-main.glsl';\n\nexport default `\\\n#define SHADER_NAME solid-polygon-layer-vertex-shader\n\nattribute vec3 positions;\nattribute vec3 positions64Low;\nattribute float elevations;\nattribute vec4 fillColors;\nattribute vec4 lineColors;\nattribute vec3 pickingColors;\n\n${main}\n\nvoid main(void) {\n  PolygonProps props;\n\n  props.positions = positions;\n  props.positions64Low = positions64Low;\n  props.elevations = elevations;\n  props.fillColors = fillColors;\n  props.lineColors = lineColors;\n  props.pickingColors = pickingColors;\n\n  calculatePosition(props);\n}\n`;\n","// Copyright (c) 2015 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\nimport main from './solid-polygon-layer-vertex-main.glsl';\n\nexport default `\\\n#define SHADER_NAME solid-polygon-layer-vertex-shader-side\n#define IS_SIDE_VERTEX\n\n\nattribute vec3 instancePositions;\nattribute vec3 nextPositions;\nattribute vec3 instancePositions64Low;\nattribute vec3 nextPositions64Low;\nattribute float instanceElevations;\nattribute vec4 instanceFillColors;\nattribute vec4 instanceLineColors;\nattribute vec3 instancePickingColors;\n\n${main}\n\nvoid main(void) {\n  PolygonProps props;\n\n  #if RING_WINDING_ORDER_CW == 1\n    props.positions = instancePositions;\n    props.positions64Low = instancePositions64Low;\n    props.nextPositions = nextPositions;\n    props.nextPositions64Low = nextPositions64Low;\n  #else\n    props.positions = nextPositions;\n    props.positions64Low = nextPositions64Low;\n    props.nextPositions = instancePositions;\n    props.nextPositions64Low = instancePositions64Low;\n  #endif\n  props.elevations = instanceElevations;\n  props.fillColors = instanceFillColors;\n  props.lineColors = instanceLineColors;\n  props.pickingColors = instancePickingColors;\n\n  calculatePosition(props);\n}\n`;\n","// Copyright (c) 2015 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\nimport {Layer, project32, gouraudLighting, picking, COORDINATE_SYSTEM} from '@deck.gl/core';\nimport GL from '@luma.gl/constants';\nimport {Model, Geometry, hasFeatures, FEATURES} from '@luma.gl/core';\n\n// Polygon geometry generation is managed by the polygon tesselator\nimport PolygonTesselator from './polygon-tesselator';\n\nimport vsTop from './solid-polygon-layer-vertex-top.glsl';\nimport vsSide from './solid-polygon-layer-vertex-side.glsl';\nimport fs from './solid-polygon-layer-fragment.glsl';\n\nimport type {\n  LayerProps,\n  LayerDataSource,\n  Color,\n  Material,\n  Accessor,\n  AccessorFunction,\n  UpdateParameters,\n  GetPickingInfoParams,\n  PickingInfo,\n  DefaultProps\n} from '@deck.gl/core';\nimport type {PolygonGeometry} from './polygon';\n\ntype _SolidPolygonLayerProps<DataT> = {\n  data: LayerDataSource<DataT>;\n  /** Whether to fill the polygons\n   * @default true\n   */\n  filled?: boolean;\n  /** Whether to extrude the polygons\n   * @default false\n   */\n  extruded?: boolean;\n  /** Whether to generate a line wireframe of the polygon.\n   * @default false\n   */\n  wireframe?: boolean;\n  /**\n   * (Experimental) If `false`, will skip normalizing the coordinates returned by `getPolygon`.\n   * @default true\n   */\n  _normalize?: boolean;\n  /**\n   * (Experimental) This prop is only effective with `_normalize: false`.\n   * It specifies the winding order of rings in the polygon data, one of 'CW' (clockwise) and 'CCW' (counter-clockwise)\n   */\n  _windingOrder?: 'CW' | 'CCW';\n\n  /**\n   * (Experimental) This prop is only effective with `XYZ` data.\n   * When true, polygon tesselation will be performed on the plane with the largest area, instead of the xy plane.\n   * @default false\n   */\n  _full3d?: boolean;\n\n  /** Elevation multiplier.\n   * @default 1\n   */\n  elevationScale?: number;\n\n  /** Polygon geometry accessor. */\n  getPolygon?: AccessorFunction<DataT, PolygonGeometry>;\n  /** Extrusion height accessor.\n   * @default 1000\n   */\n  getElevation?: Accessor<DataT, number>;\n  /** Fill color accessor.\n   * @default [0, 0, 0, 255]\n   */\n  getFillColor?: Accessor<DataT, Color>;\n  /** Stroke color accessor.\n   * @default [0, 0, 0, 255]\n   */\n  getLineColor?: Accessor<DataT, Color>;\n\n  /**\n   * Material settings for lighting effect. Applies if `extruded: true`\n   *\n   * @default true\n   * @see https://deck.gl/docs/developer-guide/using-lighting\n   */\n  material?: Material;\n};\n\n/** Render filled and/or extruded polygons. */\nexport type SolidPolygonLayerProps<DataT = any> = _SolidPolygonLayerProps<DataT> & LayerProps;\n\nconst DEFAULT_COLOR: [number, number, number, number] = [0, 0, 0, 255];\n\nconst defaultProps: DefaultProps<SolidPolygonLayerProps> = {\n  filled: true,\n  extruded: false,\n  wireframe: false,\n  _normalize: true,\n  _windingOrder: 'CW',\n  _full3d: false,\n\n  elevationScale: {type: 'number', min: 0, value: 1},\n\n  getPolygon: {type: 'accessor', value: f => f.polygon},\n  getElevation: {type: 'accessor', value: 1000},\n  getFillColor: {type: 'accessor', value: DEFAULT_COLOR},\n  getLineColor: {type: 'accessor', value: DEFAULT_COLOR},\n\n  material: true\n};\n\nconst ATTRIBUTE_TRANSITION = {\n  enter: (value, chunk) => {\n    return chunk.length ? chunk.subarray(chunk.length - value.length) : value;\n  }\n};\n\nexport default class SolidPolygonLayer<DataT = any, ExtraPropsT extends {} = {}> extends Layer<\n  ExtraPropsT & Required<_SolidPolygonLayerProps<DataT>>\n> {\n  static defaultProps = defaultProps;\n  static layerName = 'SolidPolygonLayer';\n\n  state!: {\n    topModel?: Model;\n    sideModel?: Model;\n    models?: Model[];\n    numInstances: number;\n    polygonTesselator: PolygonTesselator;\n  };\n\n  getShaders(type) {\n    return super.getShaders({\n      vs: type === 'top' ? vsTop : vsSide,\n      fs,\n      defines: {\n        RING_WINDING_ORDER_CW: !this.props._normalize && this.props._windingOrder === 'CCW' ? 0 : 1\n      },\n      modules: [project32, gouraudLighting, picking]\n    });\n  }\n\n  get wrapLongitude(): boolean {\n    return false;\n  }\n\n  initializeState() {\n    const {gl, viewport} = this.context;\n    let {coordinateSystem} = this.props;\n    const {_full3d} = this.props;\n    if (viewport.isGeospatial && coordinateSystem === COORDINATE_SYSTEM.DEFAULT) {\n      coordinateSystem = COORDINATE_SYSTEM.LNGLAT;\n    }\n\n    let preproject: ((xy: number[]) => number[]) | undefined;\n\n    if (coordinateSystem === COORDINATE_SYSTEM.LNGLAT) {\n      if (_full3d) {\n        preproject = viewport.projectPosition.bind(viewport);\n      } else {\n        preproject = viewport.projectFlat.bind(viewport);\n      }\n    }\n\n    this.setState({\n      numInstances: 0,\n      polygonTesselator: new PolygonTesselator({\n        // Lnglat coordinates are usually projected non-linearly, which affects tesselation results\n        // Provide a preproject function if the coordinates are in lnglat\n        preproject,\n        fp64: this.use64bitPositions(),\n        IndexType: !gl || hasFeatures(gl, FEATURES.ELEMENT_INDEX_UINT32) ? Uint32Array : Uint16Array\n      })\n    });\n\n    const attributeManager = this.getAttributeManager()!;\n    const noAlloc = true;\n\n    attributeManager.remove(['instancePickingColors']);\n\n    /* eslint-disable max-len */\n    attributeManager.add({\n      indices: {\n        size: 1,\n        isIndexed: true,\n        // eslint-disable-next-line @typescript-eslint/unbound-method\n        update: this.calculateIndices,\n        noAlloc\n      },\n      positions: {\n        size: 3,\n        type: GL.DOUBLE,\n        fp64: this.use64bitPositions(),\n        transition: ATTRIBUTE_TRANSITION,\n        accessor: 'getPolygon',\n        // eslint-disable-next-line @typescript-eslint/unbound-method\n        update: this.calculatePositions,\n        noAlloc,\n        shaderAttributes: {\n          positions: {\n            vertexOffset: 0,\n            divisor: 0\n          },\n          instancePositions: {\n            vertexOffset: 0,\n            divisor: 1\n          },\n          nextPositions: {\n            vertexOffset: 1,\n            divisor: 1\n          }\n        }\n      },\n      vertexValid: {\n        size: 1,\n        divisor: 1,\n        type: GL.UNSIGNED_BYTE,\n        // eslint-disable-next-line @typescript-eslint/unbound-method\n        update: this.calculateVertexValid,\n        noAlloc\n      },\n      elevations: {\n        size: 1,\n        transition: ATTRIBUTE_TRANSITION,\n        accessor: 'getElevation',\n        shaderAttributes: {\n          elevations: {\n            divisor: 0\n          },\n          instanceElevations: {\n            divisor: 1\n          }\n        }\n      },\n      fillColors: {\n        size: this.props.colorFormat.length,\n        type: GL.UNSIGNED_BYTE,\n        normalized: true,\n        transition: ATTRIBUTE_TRANSITION,\n        accessor: 'getFillColor',\n        defaultValue: DEFAULT_COLOR,\n        shaderAttributes: {\n          fillColors: {\n            divisor: 0\n          },\n          instanceFillColors: {\n            divisor: 1\n          }\n        }\n      },\n      lineColors: {\n        size: this.props.colorFormat.length,\n        type: GL.UNSIGNED_BYTE,\n        normalized: true,\n        transition: ATTRIBUTE_TRANSITION,\n        accessor: 'getLineColor',\n        defaultValue: DEFAULT_COLOR,\n        shaderAttributes: {\n          lineColors: {\n            divisor: 0\n          },\n          instanceLineColors: {\n            divisor: 1\n          }\n        }\n      },\n      pickingColors: {\n        size: 3,\n        type: GL.UNSIGNED_BYTE,\n        accessor: (object, {index, target: value}) =>\n          this.encodePickingColor(object && object.__source ? object.__source.index : index, value),\n        shaderAttributes: {\n          pickingColors: {\n            divisor: 0\n          },\n          instancePickingColors: {\n            divisor: 1\n          }\n        }\n      }\n    });\n    /* eslint-enable max-len */\n  }\n\n  getPickingInfo(params: GetPickingInfoParams): PickingInfo {\n    const info = super.getPickingInfo(params);\n    const {index} = info;\n    const {data} = this.props;\n\n    // Check if data comes from a composite layer, wrapped with getSubLayerRow\n    if (data[0] && data[0].__source) {\n      // index decoded from picking color refers to the source index\n      info.object = (data as any[]).find(d => d.__source.index === index);\n    }\n    return info;\n  }\n\n  disablePickingIndex(objectIndex: number) {\n    const {data} = this.props;\n\n    // Check if data comes from a composite layer, wrapped with getSubLayerRow\n    if (data[0] && data[0].__source) {\n      // index decoded from picking color refers to the source index\n      for (let i = 0; i < (data as any[]).length; i++) {\n        if (data[i].__source.index === objectIndex) {\n          this._disablePickingIndex(i);\n        }\n      }\n    } else {\n      super.disablePickingIndex(objectIndex);\n    }\n  }\n\n  draw({uniforms}) {\n    const {extruded, filled, wireframe, elevationScale} = this.props;\n    const {topModel, sideModel, polygonTesselator} = this.state;\n\n    const renderUniforms = {\n      ...uniforms,\n      extruded: Boolean(extruded),\n      elevationScale\n    };\n\n    // Note: the order is important\n    if (sideModel) {\n      sideModel.setInstanceCount(polygonTesselator.instanceCount - 1);\n      sideModel.setUniforms(renderUniforms);\n      if (wireframe) {\n        sideModel.setDrawMode(GL.LINE_STRIP);\n        sideModel.setUniforms({isWireframe: true}).draw();\n      }\n      if (filled) {\n        sideModel.setDrawMode(GL.TRIANGLE_FAN);\n        sideModel.setUniforms({isWireframe: false}).draw();\n      }\n    }\n\n    if (topModel) {\n      topModel.setVertexCount(polygonTesselator.vertexCount);\n      topModel.setUniforms(renderUniforms).draw();\n    }\n  }\n\n  updateState(updateParams: UpdateParameters<this>) {\n    super.updateState(updateParams);\n\n    this.updateGeometry(updateParams);\n\n    const {props, oldProps, changeFlags} = updateParams;\n    const attributeManager = this.getAttributeManager();\n\n    const regenerateModels =\n      changeFlags.extensionsChanged ||\n      props.filled !== oldProps.filled ||\n      props.extruded !== oldProps.extruded;\n\n    if (regenerateModels) {\n      this.state.models?.forEach(model => model.delete());\n\n      this.setState(this._getModels(this.context.gl));\n      attributeManager!.invalidateAll();\n    }\n  }\n\n  protected updateGeometry({props, oldProps, changeFlags}: UpdateParameters<this>) {\n    const geometryConfigChanged =\n      changeFlags.dataChanged ||\n      (changeFlags.updateTriggersChanged &&\n        (changeFlags.updateTriggersChanged.all || changeFlags.updateTriggersChanged.getPolygon));\n\n    // When the geometry config  or the data is changed,\n    // tessellator needs to be invoked\n    if (geometryConfigChanged) {\n      const {polygonTesselator} = this.state;\n      const buffers = (props.data as any).attributes || {};\n      polygonTesselator.updateGeometry({\n        data: props.data,\n        normalize: props._normalize,\n        geometryBuffer: buffers.getPolygon,\n        buffers,\n        getGeometry: props.getPolygon,\n        positionFormat: props.positionFormat,\n        wrapLongitude: props.wrapLongitude,\n        // TODO - move the flag out of the viewport\n        resolution: this.context.viewport.resolution,\n        fp64: this.use64bitPositions(),\n        dataChanged: changeFlags.dataChanged,\n        full3d: props._full3d\n      });\n\n      this.setState({\n        numInstances: polygonTesselator.instanceCount,\n        startIndices: polygonTesselator.vertexStarts\n      });\n\n      if (!changeFlags.dataChanged) {\n        // Base `layer.updateState` only invalidates all attributes on data change\n        // Cover the rest of the scenarios here\n        this.getAttributeManager()!.invalidateAll();\n      }\n    }\n  }\n\n  protected _getModels(gl: WebGLRenderingContext): Model {\n    const {id, filled, extruded} = this.props;\n\n    let topModel;\n    let sideModel;\n\n    if (filled) {\n      const shaders = this.getShaders('top');\n      shaders.defines.NON_INSTANCED_MODEL = 1;\n\n      topModel = new Model(gl, {\n        ...shaders,\n        id: `${id}-top`,\n        drawMode: GL.TRIANGLES,\n        attributes: {\n          vertexPositions: new Float32Array([0, 1])\n        },\n        uniforms: {\n          isWireframe: false,\n          isSideVertex: false\n        },\n        vertexCount: 0,\n        isIndexed: true\n      });\n    }\n    if (extruded) {\n      sideModel = new Model(gl, {\n        ...this.getShaders('side'),\n        id: `${id}-side`,\n        geometry: new Geometry({\n          drawMode: GL.LINES,\n          vertexCount: 4,\n          attributes: {\n            // top right - top left - bootom left - bottom right\n            vertexPositions: {\n              size: 2,\n              value: new Float32Array([1, 0, 0, 0, 0, 1, 1, 1])\n            }\n          }\n        }),\n        instanceCount: 0,\n        isInstanced: 1\n      });\n\n      sideModel.userData.excludeAttributes = {indices: true};\n    }\n\n    return {\n      models: [sideModel, topModel].filter(Boolean),\n      topModel,\n      sideModel\n    };\n  }\n\n  protected calculateIndices(attribute) {\n    const {polygonTesselator} = this.state;\n    attribute.startIndices = polygonTesselator.indexStarts;\n    attribute.value = polygonTesselator.get('indices');\n  }\n\n  protected calculatePositions(attribute) {\n    const {polygonTesselator} = this.state;\n    attribute.startIndices = polygonTesselator.vertexStarts;\n    attribute.value = polygonTesselator.get('positions');\n  }\n\n  protected calculateVertexValid(attribute) {\n    attribute.value = this.state.polygonTesselator.get('vertexValid');\n  }\n}\n","// Copyright (c) 2015 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\nexport default `\\\n#define SHADER_NAME solid-polygon-layer-fragment-shader\n\nprecision highp float;\n\nvarying vec4 vColor;\n\nvoid main(void) {\n  gl_FragColor = vColor;\n\n  DECKGL_FILTER_COLOR(gl_FragColor, geometry);\n}\n`;\n","import {cutPolylineByGrid, cutPolylineByMercatorBounds} from '@math.gl/polygon';\n\nimport type {NumericArray} from '@math.gl/core';\nimport type {Position} from '@deck.gl/core';\n\nexport type NestedPathGeometry = Position[];\nexport type FlatPathGeometry = NumericArray;\nexport type PathGeometry = NestedPathGeometry | FlatPathGeometry;\nexport type NormalizedPathGeometry = FlatPathGeometry[] | FlatPathGeometry;\n\n/**\n * Flattens a nested path object\n * Cut the feature if needed (globe projection, wrap longitude, etc.)\n * Returns a flat array of path positions, or a list of flat arrays representing multiple paths\n */\nexport function normalizePath(\n  path: PathGeometry,\n  size: number,\n  gridResolution?: number,\n  wrapLongitude?: boolean\n): number[][] | NumericArray {\n  let flatPath: NumericArray;\n  if (Array.isArray(path[0])) {\n    const length = path.length * size;\n    flatPath = new Array(length);\n    for (let i = 0; i < path.length; i++) {\n      for (let j = 0; j < size; j++) {\n        flatPath[i * size + j] = path[i][j] || 0;\n      }\n    }\n  } else {\n    flatPath = path as NumericArray;\n  }\n  if (gridResolution) {\n    return cutPolylineByGrid(flatPath, {size, gridResolution});\n  }\n  if (wrapLongitude) {\n    return cutPolylineByMercatorBounds(flatPath, {size});\n  }\n  return flatPath;\n}\n","// Copyright (c) 2015 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\nimport {Tesselator} from '@deck.gl/core';\nimport {normalizePath} from './path';\n\nimport type {TypedArray} from '@math.gl/core';\nimport type {PathGeometry, FlatPathGeometry, NormalizedPathGeometry} from './path';\n\nconst START_CAP = 1;\nconst END_CAP = 2;\nconst INVALID = 4;\n\n// This class is set up to allow querying one attribute at a time\n// the way the AttributeManager expects it\nexport default class PathTesselator extends Tesselator<\n  PathGeometry,\n  NormalizedPathGeometry,\n  {\n    fp64?: boolean;\n    resolution?: number;\n    wrapLongitude?: boolean;\n    loop?: boolean;\n  }\n> {\n  constructor(opts) {\n    super({\n      ...opts,\n      attributes: {\n        // Padding covers shaderAttributes for last segment in largest case fp64\n        // additional vertex + hi & low parts, 3 * 6\n        positions: {\n          size: 3,\n          padding: 18,\n          initialize: true,\n          type: opts.fp64 ? Float64Array : Float32Array\n        },\n        segmentTypes: {size: 1, type: Uint8ClampedArray}\n      }\n    });\n  }\n\n  /** Get packed attribute by name */\n  get(attributeName: string): TypedArray | null {\n    return this.attributes[attributeName];\n  }\n\n  /* Implement base Tesselator interface */\n  protected getGeometryFromBuffer(buffer) {\n    if (this.normalize) {\n      return super.getGeometryFromBuffer(buffer);\n    }\n    // we don't need to read the positions if no normalization\n    return null;\n  }\n\n  /* Implement base Tesselator interface */\n  protected normalizeGeometry(path: PathGeometry): number[][] | PathGeometry {\n    if (this.normalize) {\n      return normalizePath(path, this.positionSize, this.opts.resolution, this.opts.wrapLongitude);\n    }\n    return path;\n  }\n\n  /* Implement base Tesselator interface */\n  protected getGeometrySize(path: NormalizedPathGeometry): number {\n    if (isCut(path)) {\n      let size = 0;\n      for (const subPath of path) {\n        size += this.getGeometrySize(subPath);\n      }\n      return size;\n    }\n    const numPoints = this.getPathLength(path);\n    if (numPoints < 2) {\n      // invalid path\n      return 0;\n    }\n    if (this.isClosed(path)) {\n      // minimum 3 vertices\n      return numPoints < 3 ? 0 : numPoints + 2;\n    }\n    return numPoints;\n  }\n\n  /* Implement base Tesselator interface */\n  protected updateGeometryAttributes(\n    path: NormalizedPathGeometry | null,\n    context: {\n      vertexStart: number;\n      geometrySize: number;\n    }\n  ): void {\n    if (context.geometrySize === 0) {\n      return;\n    }\n    if (path && isCut(path)) {\n      for (const subPath of path) {\n        const geometrySize = this.getGeometrySize(subPath);\n        context.geometrySize = geometrySize;\n        this.updateGeometryAttributes(subPath, context);\n        context.vertexStart += geometrySize;\n      }\n    } else {\n      this._updateSegmentTypes(path, context);\n      this._updatePositions(path, context);\n    }\n  }\n\n  private _updateSegmentTypes(\n    path: FlatPathGeometry | null,\n    context: {\n      vertexStart: number;\n      geometrySize: number;\n    }\n  ) {\n    const segmentTypes = this.attributes.segmentTypes as TypedArray;\n    const isPathClosed = path ? this.isClosed(path) : false;\n    const {vertexStart, geometrySize} = context;\n\n    // positions   --  A0 A1 B0 B1 B2 B3 B0 B1 B2 --\n    // segmentTypes     3  4  4  0  0  0  0  4  4\n    segmentTypes.fill(0, vertexStart, vertexStart + geometrySize);\n    if (isPathClosed) {\n      segmentTypes[vertexStart] = INVALID;\n      segmentTypes[vertexStart + geometrySize - 2] = INVALID;\n    } else {\n      segmentTypes[vertexStart] += START_CAP;\n      segmentTypes[vertexStart + geometrySize - 2] += END_CAP;\n    }\n    segmentTypes[vertexStart + geometrySize - 1] = INVALID;\n  }\n\n  private _updatePositions(\n    path: FlatPathGeometry | null,\n    context: {\n      vertexStart: number;\n      geometrySize: number;\n    }\n  ) {\n    const {positions} = this.attributes;\n    if (!positions || !path) {\n      return;\n    }\n    const {vertexStart, geometrySize} = context;\n    const p = new Array(3);\n\n    // positions   --  A0 A1 B0 B1 B2 B3 B0 B1 B2 --\n    // segmentTypes     3  4  4  0  0  0  0  4  4\n    for (let i = vertexStart, ptIndex = 0; ptIndex < geometrySize; i++, ptIndex++) {\n      this.getPointOnPath(path, ptIndex, p);\n      positions[i * 3] = p[0];\n      positions[i * 3 + 1] = p[1];\n      positions[i * 3 + 2] = p[2];\n    }\n  }\n\n  // Utilities\n  /** Returns the number of points in the path */\n  private getPathLength(path: FlatPathGeometry): number {\n    return path.length / this.positionSize;\n  }\n\n  /** Returns a point on the path at the specified index */\n  private getPointOnPath(path: FlatPathGeometry, index: number, target: number[] = []): number[] {\n    const {positionSize} = this;\n    if (index * positionSize >= path.length) {\n      // loop\n      index += 1 - path.length / positionSize;\n    }\n    const i = index * positionSize;\n    target[0] = path[i];\n    target[1] = path[i + 1];\n    target[2] = (positionSize === 3 && path[i + 2]) || 0;\n    return target;\n  }\n\n  // Returns true if the first and last points are identical\n  private isClosed(path: FlatPathGeometry): boolean {\n    if (!this.normalize) {\n      return Boolean(this.opts.loop);\n    }\n    const {positionSize} = this;\n    const lastPointIndex = path.length - positionSize;\n    return (\n      path[0] === path[lastPointIndex] &&\n      path[1] === path[lastPointIndex + 1] &&\n      (positionSize === 2 || path[2] === path[lastPointIndex + 2])\n    );\n  }\n}\n\nfunction isCut(path: NormalizedPathGeometry): path is FlatPathGeometry[] {\n  return Array.isArray(path[0]);\n}\n","// Copyright (c) 2015 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\nimport {Layer, project32, picking, UNIT} from '@deck.gl/core';\nimport GL from '@luma.gl/constants';\nimport {Model, Geometry} from '@luma.gl/core';\nimport PathTesselator from './path-tesselator';\n\nimport vs from './path-layer-vertex.glsl';\nimport fs from './path-layer-fragment.glsl';\n\nimport type {\n  LayerProps,\n  LayerDataSource,\n  Color,\n  Accessor,\n  AccessorFunction,\n  Unit,\n  UpdateParameters,\n  GetPickingInfoParams,\n  PickingInfo,\n  DefaultProps\n} from '@deck.gl/core';\nimport type {PathGeometry} from './path';\n\ntype _PathLayerProps<DataT> = {\n  data: LayerDataSource<DataT>;\n  /** The units of the line width, one of `'meters'`, `'common'`, and `'pixels'`\n   * @default 'meters'\n   */\n  widthUnits?: Unit;\n  /**\n   * Path width multiplier.\n   * @default 1\n   */\n  widthScale?: number;\n  /**\n   * The minimum path width in pixels. This prop can be used to prevent the path from getting too thin when zoomed out.\n   * @default 0\n   */\n  widthMinPixels?: number;\n  /**\n   * The maximum path width in pixels. This prop can be used to prevent the path from getting too thick when zoomed in.\n   * @default Number.MAX_SAFE_INTEGER\n   */\n  widthMaxPixels?: number;\n  /**\n   * Type of joint. If `true`, draw round joints. Otherwise draw miter joints.\n   * @default false\n   */\n  jointRounded?: boolean;\n  /**\n   * Type of caps. If `true`, draw round caps. Otherwise draw square caps.\n   * @default false\n   */\n  capRounded?: boolean;\n  /**\n   * The maximum extent of a joint in ratio to the stroke width. Only works if `jointRounded` is `false`.\n   * @default 4\n   */\n  miterLimit?: number;\n  /**\n   * If `true`, extrude the path in screen space (width always faces the camera).\n   * If `false`, the width always faces up (z).\n   * @default false\n   */\n  billboard?: boolean;\n  /**\n   * (Experimental) If `'loop'` or `'open'`, will skip normalizing the coordinates returned by `getPath` and instead assume all paths are to be loops or open paths.\n   * When normalization is disabled, paths must be specified in the format of flat array. Open paths must contain at least 2 vertices and closed paths must contain at least 3 vertices.\n   * @default null\n   */\n  _pathType?: null | 'loop' | 'open';\n  /**\n   * Path geometry accessor.\n   */\n  getPath?: AccessorFunction<DataT, PathGeometry>;\n  /**\n   * Path color accessor.\n   * @default [0, 0, 0, 255]\n   */\n  getColor?: Accessor<DataT, Color | Color[]>;\n  /**\n   * Path width accessor.\n   * @default 1\n   */\n  getWidth?: Accessor<DataT, number | number[]>;\n  /**\n   * @deprecated Use `jointRounded` and `capRounded` instead\n   */\n  rounded?: boolean;\n};\n\nexport type PathLayerProps<DataT = any> = _PathLayerProps<DataT> & LayerProps;\n\nconst DEFAULT_COLOR: [number, number, number, number] = [0, 0, 0, 255];\n\nconst defaultProps: DefaultProps<PathLayerProps> = {\n  widthUnits: 'meters',\n  widthScale: {type: 'number', min: 0, value: 1},\n  widthMinPixels: {type: 'number', min: 0, value: 0},\n  widthMaxPixels: {type: 'number', min: 0, value: Number.MAX_SAFE_INTEGER},\n  jointRounded: false,\n  capRounded: false,\n  miterLimit: {type: 'number', min: 0, value: 4},\n  billboard: false,\n  _pathType: null,\n\n  getPath: {type: 'accessor', value: object => object.path},\n  getColor: {type: 'accessor', value: DEFAULT_COLOR},\n  getWidth: {type: 'accessor', value: 1},\n\n  // deprecated props\n  rounded: {deprecatedFor: ['jointRounded', 'capRounded']}\n};\n\nconst ATTRIBUTE_TRANSITION = {\n  enter: (value, chunk) => {\n    return chunk.length ? chunk.subarray(chunk.length - value.length) : value;\n  }\n};\n\n/** Render lists of coordinate points as extruded polylines with mitering. */\nexport default class PathLayer<DataT = any, ExtraPropsT extends {} = {}> extends Layer<\n  ExtraPropsT & Required<_PathLayerProps<DataT>>\n> {\n  static defaultProps = defaultProps;\n  static layerName = 'PathLayer';\n\n  state!: {\n    model?: Model;\n    pathTesselator: PathTesselator;\n  };\n\n  getShaders() {\n    return super.getShaders({vs, fs, modules: [project32, picking]}); // 'project' module added by default.\n  }\n\n  get wrapLongitude(): boolean {\n    return false;\n  }\n\n  initializeState() {\n    const noAlloc = true;\n    const attributeManager = this.getAttributeManager();\n    /* eslint-disable max-len */\n    attributeManager!.addInstanced({\n      positions: {\n        size: 3,\n        // Start filling buffer from 1 vertex in\n        vertexOffset: 1,\n        type: GL.DOUBLE,\n        fp64: this.use64bitPositions(),\n        transition: ATTRIBUTE_TRANSITION,\n        accessor: 'getPath',\n        // eslint-disable-next-line @typescript-eslint/unbound-method\n        update: this.calculatePositions,\n        noAlloc,\n        shaderAttributes: {\n          instanceLeftPositions: {\n            vertexOffset: 0\n          },\n          instanceStartPositions: {\n            vertexOffset: 1\n          },\n          instanceEndPositions: {\n            vertexOffset: 2\n          },\n          instanceRightPositions: {\n            vertexOffset: 3\n          }\n        }\n      },\n      instanceTypes: {\n        size: 1,\n        type: GL.UNSIGNED_BYTE,\n        // eslint-disable-next-line @typescript-eslint/unbound-method\n        update: this.calculateSegmentTypes,\n        noAlloc\n      },\n      instanceStrokeWidths: {\n        size: 1,\n        accessor: 'getWidth',\n        transition: ATTRIBUTE_TRANSITION,\n        defaultValue: 1\n      },\n      instanceColors: {\n        size: this.props.colorFormat.length,\n        type: GL.UNSIGNED_BYTE,\n        normalized: true,\n        accessor: 'getColor',\n        transition: ATTRIBUTE_TRANSITION,\n        defaultValue: DEFAULT_COLOR\n      },\n      instancePickingColors: {\n        size: 3,\n        type: GL.UNSIGNED_BYTE,\n        accessor: (object, {index, target: value}) =>\n          this.encodePickingColor(object && object.__source ? object.__source.index : index, value)\n      }\n    });\n    /* eslint-enable max-len */\n\n    this.setState({\n      pathTesselator: new PathTesselator({\n        fp64: this.use64bitPositions()\n      })\n    });\n  }\n\n  updateState(params: UpdateParameters<this>) {\n    super.updateState(params);\n    const {props, changeFlags} = params;\n\n    const attributeManager = this.getAttributeManager();\n\n    const geometryChanged =\n      changeFlags.dataChanged ||\n      (changeFlags.updateTriggersChanged &&\n        (changeFlags.updateTriggersChanged.all || changeFlags.updateTriggersChanged.getPath));\n\n    if (geometryChanged) {\n      const {pathTesselator} = this.state;\n      const buffers = (props.data as any).attributes || {};\n\n      pathTesselator.updateGeometry({\n        data: props.data,\n        geometryBuffer: buffers.getPath,\n        buffers,\n        normalize: !props._pathType,\n        loop: props._pathType === 'loop',\n        getGeometry: props.getPath,\n        positionFormat: props.positionFormat,\n        wrapLongitude: props.wrapLongitude,\n        // TODO - move the flag out of the viewport\n        resolution: this.context.viewport.resolution,\n        dataChanged: changeFlags.dataChanged\n      });\n      this.setState({\n        numInstances: pathTesselator.instanceCount,\n        startIndices: pathTesselator.vertexStarts\n      });\n      if (!changeFlags.dataChanged) {\n        // Base `layer.updateState` only invalidates all attributes on data change\n        // Cover the rest of the scenarios here\n        attributeManager!.invalidateAll();\n      }\n    }\n\n    if (changeFlags.extensionsChanged) {\n      const {gl} = this.context;\n      this.state.model?.delete();\n      this.state.model = this._getModel(gl);\n      attributeManager!.invalidateAll();\n    }\n  }\n\n  getPickingInfo(params: GetPickingInfoParams): PickingInfo {\n    const info = super.getPickingInfo(params);\n    const {index} = info;\n    const {data} = this.props;\n\n    // Check if data comes from a composite layer, wrapped with getSubLayerRow\n    if (data[0] && data[0].__source) {\n      // index decoded from picking color refers to the source index\n      info.object = (data as any[]).find(d => d.__source.index === index);\n    }\n    return info;\n  }\n\n  /** Override base Layer method */\n  disablePickingIndex(objectIndex: number) {\n    const {data} = this.props;\n\n    // Check if data comes from a composite layer, wrapped with getSubLayerRow\n    if (data[0] && data[0].__source) {\n      // index decoded from picking color refers to the source index\n      for (let i = 0; i < (data as any[]).length; i++) {\n        if (data[i].__source.index === objectIndex) {\n          this._disablePickingIndex(i);\n        }\n      }\n    } else {\n      super.disablePickingIndex(objectIndex);\n    }\n  }\n\n  draw({uniforms}) {\n    const {\n      jointRounded,\n      capRounded,\n      billboard,\n      miterLimit,\n      widthUnits,\n      widthScale,\n      widthMinPixels,\n      widthMaxPixels\n    } = this.props;\n\n    this.state.model\n      .setUniforms(uniforms)\n      .setUniforms({\n        jointType: Number(jointRounded),\n        capType: Number(capRounded),\n        billboard,\n        widthUnits: UNIT[widthUnits],\n        widthScale,\n        miterLimit,\n        widthMinPixels,\n        widthMaxPixels\n      })\n      .draw();\n  }\n\n  protected _getModel(gl: WebGLRenderingContext): Model {\n    /*\n     *       _\n     *        \"-_ 1                   3                       5\n     *     _     \"o---------------------o-------------------_-o\n     *       -   / \"\"--..__              '.             _.-' /\n     *   _     \"@- - - - - \"\"--..__- - - - x - - - -_.@'    /\n     *    \"-_  /                   \"\"--..__ '.  _,-` :     /\n     *       \"o----------------------------\"\"-o'    :     /\n     *      0,2                            4 / '.  :     /\n     *                                      /   '.:     /\n     *                                     /     :'.   /\n     *                                    /     :  ', /\n     *                                   /     :     o\n     */\n\n    // prettier-ignore\n    const SEGMENT_INDICES = [\n      // start corner\n      0, 1, 2,\n      // body\n      1, 4, 2,\n      1, 3, 4,\n      // end corner\n      3, 5, 4\n    ];\n\n    // [0] position on segment - 0: start, 1: end\n    // [1] side of path - -1: left, 0: center (joint), 1: right\n    // prettier-ignore\n    const SEGMENT_POSITIONS = [\n      // bevel start corner\n      0, 0,\n      // start inner corner\n      0, -1,\n      // start outer corner\n      0, 1,\n      // end inner corner\n      1, -1,\n      // end outer corner\n      1, 1,\n      // bevel end corner\n      1, 0\n    ];\n\n    return new Model(gl, {\n      ...this.getShaders(),\n      id: this.props.id,\n      geometry: new Geometry({\n        drawMode: GL.TRIANGLES,\n        attributes: {\n          indices: new Uint16Array(SEGMENT_INDICES),\n          positions: {value: new Float32Array(SEGMENT_POSITIONS), size: 2}\n        }\n      }),\n      isInstanced: true\n    });\n  }\n\n  protected calculatePositions(attribute) {\n    const {pathTesselator} = this.state;\n\n    attribute.startIndices = pathTesselator.vertexStarts;\n    attribute.value = pathTesselator.get('positions');\n  }\n\n  protected calculateSegmentTypes(attribute) {\n    const {pathTesselator} = this.state;\n\n    attribute.startIndices = pathTesselator.vertexStarts;\n    attribute.value = pathTesselator.get('segmentTypes');\n  }\n}\n","// Copyright (c) 2015 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\nexport default `\\\n#define SHADER_NAME path-layer-vertex-shader\n\nattribute vec2 positions;\n\nattribute float instanceTypes;\nattribute vec3 instanceStartPositions;\nattribute vec3 instanceEndPositions;\nattribute vec3 instanceLeftPositions;\nattribute vec3 instanceRightPositions;\nattribute vec3 instanceLeftPositions64Low;\nattribute vec3 instanceStartPositions64Low;\nattribute vec3 instanceEndPositions64Low;\nattribute vec3 instanceRightPositions64Low;\nattribute float instanceStrokeWidths;\nattribute vec4 instanceColors;\nattribute vec3 instancePickingColors;\n\nuniform float widthScale;\nuniform float widthMinPixels;\nuniform float widthMaxPixels;\nuniform float jointType;\nuniform float capType;\nuniform float miterLimit;\nuniform bool billboard;\nuniform int widthUnits;\n\nuniform float opacity;\n\nvarying vec4 vColor;\nvarying vec2 vCornerOffset;\nvarying float vMiterLength;\nvarying vec2 vPathPosition;\nvarying float vPathLength;\nvarying float vJointType;\n\nconst float EPSILON = 0.001;\nconst vec3 ZERO_OFFSET = vec3(0.0);\n\nfloat flipIfTrue(bool flag) {\n  return -(float(flag) * 2. - 1.);\n}\n\n// calculate line join positions\nvec3 getLineJoinOffset(\n  vec3 prevPoint, vec3 currPoint, vec3 nextPoint,\n  vec2 width\n) {\n  bool isEnd = positions.x > 0.0;\n  // side of the segment - -1: left, 0: center, 1: right\n  float sideOfPath = positions.y;\n  float isJoint = float(sideOfPath == 0.0);\n\n  vec3 deltaA3 = (currPoint - prevPoint);\n  vec3 deltaB3 = (nextPoint - currPoint);\n\n  mat3 rotationMatrix;\n  bool needsRotation = !billboard && project_needs_rotation(currPoint, rotationMatrix);\n  if (needsRotation) {\n    deltaA3 = deltaA3 * rotationMatrix;\n    deltaB3 = deltaB3 * rotationMatrix;\n  }\n  vec2 deltaA = deltaA3.xy / width;\n  vec2 deltaB = deltaB3.xy / width;\n\n  float lenA = length(deltaA);\n  float lenB = length(deltaB);\n\n  vec2 dirA = lenA > 0. ? normalize(deltaA) : vec2(0.0, 0.0);\n  vec2 dirB = lenB > 0. ? normalize(deltaB) : vec2(0.0, 0.0);\n\n  vec2 perpA = vec2(-dirA.y, dirA.x);\n  vec2 perpB = vec2(-dirB.y, dirB.x);\n\n  // tangent of the corner\n  vec2 tangent = dirA + dirB;\n  tangent = length(tangent) > 0. ? normalize(tangent) : perpA;\n  // direction of the corner\n  vec2 miterVec = vec2(-tangent.y, tangent.x);\n  // direction of the segment\n  vec2 dir = isEnd ? dirA : dirB;\n  // direction of the extrusion\n  vec2 perp = isEnd ? perpA : perpB;\n  // length of the segment\n  float L = isEnd ? lenA : lenB;\n\n  // A = angle of the corner\n  float sinHalfA = abs(dot(miterVec, perp));\n  float cosHalfA = abs(dot(dirA, miterVec));\n\n  // -1: right, 1: left\n  float turnDirection = flipIfTrue(dirA.x * dirB.y >= dirA.y * dirB.x);\n\n  // relative position to the corner:\n  // -1: inside (smaller side of the angle)\n  // 0: center\n  // 1: outside (bigger side of the angle)\n  float cornerPosition = sideOfPath * turnDirection;\n\n  float miterSize = 1.0 / max(sinHalfA, EPSILON);\n  // trim if inside corner extends further than the line segment\n  miterSize = mix(\n    min(miterSize, max(lenA, lenB) / max(cosHalfA, EPSILON)),\n    miterSize,\n    step(0.0, cornerPosition)\n  );\n\n  vec2 offsetVec = mix(miterVec * miterSize, perp, step(0.5, cornerPosition))\n    * (sideOfPath + isJoint * turnDirection);\n\n  // special treatment for start cap and end cap\n  bool isStartCap = lenA == 0.0 || (!isEnd && (instanceTypes == 1.0 || instanceTypes == 3.0));\n  bool isEndCap = lenB == 0.0 || (isEnd && (instanceTypes == 2.0 || instanceTypes == 3.0));\n  bool isCap = isStartCap || isEndCap;\n\n  // extend out a triangle to envelope the round cap\n  if (isCap) {\n    offsetVec = mix(perp * sideOfPath, dir * capType * 4.0 * flipIfTrue(isStartCap), isJoint);\n    vJointType = capType;\n  } else {\n    vJointType = jointType;\n  }\n\n  // Generate variables for fragment shader\n  vPathLength = L;\n  vCornerOffset = offsetVec;\n  vMiterLength = dot(vCornerOffset, miterVec * turnDirection);\n  vMiterLength = isCap ? isJoint : vMiterLength;\n\n  vec2 offsetFromStartOfPath = vCornerOffset + deltaA * float(isEnd);\n  vPathPosition = vec2(\n    dot(offsetFromStartOfPath, perp),\n    dot(offsetFromStartOfPath, dir)\n  );\n  geometry.uv = vPathPosition;\n\n  float isValid = step(instanceTypes, 3.5);\n  vec3 offset = vec3(offsetVec * width * isValid, 0.0);\n\n  if (needsRotation) {\n    offset = rotationMatrix * offset;\n  }\n  return offset;\n}\n\n// In clipspace extrusion, if a line extends behind the camera, clip it to avoid visual artifacts\nvoid clipLine(inout vec4 position, vec4 refPosition) {\n  if (position.w < EPSILON) {\n    float r = (EPSILON - refPosition.w) / (position.w - refPosition.w);\n    position = refPosition + (position - refPosition) * r;\n  }\n}\n\nvoid main() {\n  geometry.pickingColor = instancePickingColors;\n\n  vColor = vec4(instanceColors.rgb, instanceColors.a * opacity);\n\n  float isEnd = positions.x;\n\n  vec3 prevPosition = mix(instanceLeftPositions, instanceStartPositions, isEnd);\n  vec3 prevPosition64Low = mix(instanceLeftPositions64Low, instanceStartPositions64Low, isEnd);\n\n  vec3 currPosition = mix(instanceStartPositions, instanceEndPositions, isEnd);\n  vec3 currPosition64Low = mix(instanceStartPositions64Low, instanceEndPositions64Low, isEnd);\n\n  vec3 nextPosition = mix(instanceEndPositions, instanceRightPositions, isEnd);\n  vec3 nextPosition64Low = mix(instanceEndPositions64Low, instanceRightPositions64Low, isEnd);\n\n  geometry.worldPosition = currPosition;\n  vec2 widthPixels = vec2(clamp(\n    project_size_to_pixel(instanceStrokeWidths * widthScale, widthUnits),\n    widthMinPixels, widthMaxPixels) / 2.0);\n  vec3 width;\n\n  if (billboard) {\n    // Extrude in clipspace\n    vec4 prevPositionScreen = project_position_to_clipspace(prevPosition, prevPosition64Low, ZERO_OFFSET);\n    vec4 currPositionScreen = project_position_to_clipspace(currPosition, currPosition64Low, ZERO_OFFSET, geometry.position);\n    vec4 nextPositionScreen = project_position_to_clipspace(nextPosition, nextPosition64Low, ZERO_OFFSET);\n\n    clipLine(prevPositionScreen, currPositionScreen);\n    clipLine(nextPositionScreen, currPositionScreen);\n    clipLine(currPositionScreen, mix(nextPositionScreen, prevPositionScreen, isEnd));\n\n    width = vec3(widthPixels, 0.0);\n    DECKGL_FILTER_SIZE(width, geometry);\n\n    vec3 offset = getLineJoinOffset(\n      prevPositionScreen.xyz / prevPositionScreen.w,\n      currPositionScreen.xyz / currPositionScreen.w,\n      nextPositionScreen.xyz / nextPositionScreen.w,\n      project_pixel_size_to_clipspace(width.xy)\n    );\n\n    DECKGL_FILTER_GL_POSITION(currPositionScreen, geometry);\n    gl_Position = vec4(currPositionScreen.xyz + offset * currPositionScreen.w, currPositionScreen.w);\n  } else {\n    // Extrude in commonspace\n    prevPosition = project_position(prevPosition, prevPosition64Low);\n    currPosition = project_position(currPosition, currPosition64Low);\n    nextPosition = project_position(nextPosition, nextPosition64Low);\n\n    width = vec3(project_pixel_size(widthPixels), 0.0);\n    DECKGL_FILTER_SIZE(width, geometry);\n\n    vec3 offset = getLineJoinOffset(prevPosition, currPosition, nextPosition, width.xy);\n    geometry.position = vec4(currPosition + offset, 1.0);\n    gl_Position = project_common_position_to_clipspace(geometry.position);\n    DECKGL_FILTER_GL_POSITION(gl_Position, geometry);\n  }\n  DECKGL_FILTER_COLOR(vColor, geometry);\n}\n`;\n","// Copyright (c) 2015 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\nexport default `\\\n#define SHADER_NAME path-layer-fragment-shader\n\nprecision highp float;\n\nuniform float miterLimit;\n\nvarying vec4 vColor;\nvarying vec2 vCornerOffset;\nvarying float vMiterLength;\n/*\n * vPathPosition represents the relative coordinates of the current fragment on the path segment.\n * vPathPosition.x - position along the width of the path, between [-1, 1]. 0 is the center line.\n * vPathPosition.y - position along the length of the path, between [0, L / width].\n */\nvarying vec2 vPathPosition;\nvarying float vPathLength;\nvarying float vJointType;\n\nvoid main(void) {\n  geometry.uv = vPathPosition;\n\n  if (vPathPosition.y < 0.0 || vPathPosition.y > vPathLength) {\n    // if joint is rounded, test distance from the corner\n    if (vJointType > 0.5 && length(vCornerOffset) > 1.0) {\n      discard;\n    }\n    // trim miter\n    if (vJointType < 0.5 && vMiterLength > miterLimit + 1.0) {\n      discard;\n    }\n  }\n  gl_FragColor = vColor;\n\n  DECKGL_FILTER_COLOR(gl_FragColor, geometry);\n}\n`;\n","// Copyright (c) 2015 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\nimport {\n  Accessor,\n  AccessorFunction,\n  Color,\n  CompositeLayer,\n  CompositeLayerProps,\n  createIterable,\n  Layer,\n  LayerDataSource,\n  LayersList,\n  log,\n  Unit,\n  Material,\n  UpdateParameters,\n  DefaultProps\n} from '@deck.gl/core';\nimport SolidPolygonLayer from '../solid-polygon-layer/solid-polygon-layer';\nimport PathLayer from '../path-layer/path-layer';\nimport * as Polygon from '../solid-polygon-layer/polygon';\nimport {replaceInRange} from '../utils';\n\n/**\n * All properties supported by `PolygonLayer`.\n */\nexport type PolygonLayerProps<DataT = any> = _PolygonLayerProps<DataT> & CompositeLayerProps;\n\n/**\n * Properties added by `PolygonLayer`.\n */\ntype _PolygonLayerProps<DataT = any> = {\n  data: LayerDataSource<DataT>;\n  /**\n   * Whether to draw an outline around the polygon (solid fill).\n   *\n   * Note that both the outer polygon as well the outlines of any holes will be drawn.\n   *\n   * @default true\n   */\n  stroked?: boolean;\n\n  /**\n   * Whether to draw a filled polygon (solid fill).\n   *\n   * Note that only the area between the outer polygon and any holes will be filled.\n   *\n   * @default true\n   */\n  filled?: boolean;\n\n  /**\n   * Whether to extrude the polygons.\n   *\n   * Based on the elevations provided by the `getElevation` accessor.\n   *\n   * If set to `false`, all polygons will be flat, this generates less geometry and is faster\n   * than simply returning 0 from getElevation.\n   *\n   * @default false\n   */\n  extruded?: boolean;\n\n  /**\n   * Elevation multiplier.\n   *\n   * The final elevation is calculated by `elevationScale * getElevation(d)`.\n   * `elevationScale` is a handy property to scale all elevation without updating the data.\n   *\n   * @default 1\n   */\n  elevationScale?: number;\n\n  /**\n   * Whether to generate a line wireframe of the hexagon.\n   *\n   * The outline will have \"horizontal\" lines closing the top and bottom polygons and a vertical\n   * line (a \"strut\") for each vertex on the polygon.\n   *\n   * @default false\n   */\n  wireframe?: boolean;\n\n  /**\n   * The units of the line width, one of `meters`, `common`, and `pixels`.\n   *\n   * @default 'meters'\n   * @see Unit.\n   */\n  lineWidthUnits?: Unit;\n\n  /**\n   * The line width multiplier that multiplied to all outlines of `Polygon` and `MultiPolygon`\n   * features if the stroked attribute is true.\n   *\n   * @default 1\n   */\n  lineWidthScale?: number;\n\n  /**\n   * The minimum line width in pixels.\n   *\n   * @default 0\n   */\n  lineWidthMinPixels?: number;\n\n  /**\n   * The maximum line width in pixels\n   *\n   * @default Number.MAX_SAFE_INTEGER\n   */\n  lineWidthMaxPixels?: number;\n\n  /**\n   * Type of joint. If `true`, draw round joints. Otherwise draw miter joints.\n   *\n   * @default false\n   */\n  lineJointRounded?: boolean;\n\n  /**\n   * The maximum extent of a joint in ratio to the stroke width.\n   *\n   * Only works if `lineJointRounded` is false.\n   *\n   * @default 4\n   */\n  lineMiterLimit?: number;\n\n  lineDashJustified?: boolean;\n\n  /** Called on each object in the data stream to retrieve its corresponding polygon. */\n  getPolygon?: AccessorFunction<DataT, any>;\n\n  /**\n   * Fill collor value or accessor.\n   *\n   * @default [0, 0, 0, 255]\n   */\n  getFillColor?: Accessor<DataT, Color>;\n\n  /**\n   * Line color value or accessor.\n   *\n   * @default [0, 0, 0, 255]\n   */\n  getLineColor?: Accessor<DataT, Color>;\n\n  /**\n   * Line width value or accessor.\n   *\n   * @default [0, 0, 0, 255]\n   */\n  getLineWidth?: Accessor<DataT, number>;\n\n  /**\n   * Elevation valur or accessor.\n   *\n   * Only used if `extruded: true`.\n   *\n   * @default 1000\n   */\n  getElevation?: Accessor<DataT, number>;\n\n  /**\n   * This property has been moved to `PathStyleExtension`.\n   *\n   * @deprecated\n   */\n  getLineDashArray?: Accessor<DataT, number> | null;\n\n  /**\n   * If `false`, will skip normalizing the coordinates returned by `getPolygon`.\n   *\n   * **Note**: This prop is experimental\n   *\n   * @default true\n   */\n  _normalize?: boolean;\n\n  /**\n   * Specifies the winding order of rings in the polygon data.\n   *\n   * **Note**: This prop is experimental\n   *\n   * @default 'CW'\n   */\n  _windingOrder?: 'CW' | 'CCW';\n\n  /**\n   * Material settings for lighting effect. Applies if `extruded: true`.\n   *\n   * @default true\n   * @see https://deck.gl/docs/developer-guide/using-lighting\n   */\n  material?: Material;\n};\n\nconst defaultLineColor: [number, number, number, number] = [0, 0, 0, 255];\nconst defaultFillColor: [number, number, number, number] = [0, 0, 0, 255];\n\nconst defaultProps: DefaultProps<PolygonLayerProps> = {\n  stroked: true,\n  filled: true,\n  extruded: false,\n  elevationScale: 1,\n  wireframe: false,\n  _normalize: true,\n  _windingOrder: 'CW',\n\n  lineWidthUnits: 'meters',\n  lineWidthScale: 1,\n  lineWidthMinPixels: 0,\n  lineWidthMaxPixels: Number.MAX_SAFE_INTEGER,\n  lineJointRounded: false,\n  lineMiterLimit: 4,\n\n  getPolygon: {type: 'accessor', value: f => f.polygon},\n  // Polygon fill color\n  getFillColor: {type: 'accessor', value: defaultFillColor},\n  // Point, line and polygon outline color\n  getLineColor: {type: 'accessor', value: defaultLineColor},\n  // Line and polygon outline accessors\n  getLineWidth: {type: 'accessor', value: 1},\n  // Polygon extrusion accessor\n  getElevation: {type: 'accessor', value: 1000},\n\n  // Optional material for 'lighting' shader module\n  material: true\n};\n\n/** A composite layer that renders filled, stroked and/or extruded polygons. */\nexport default class PolygonLayer<DataT = any, ExtraProps extends {} = {}> extends CompositeLayer<\n  Required<_PolygonLayerProps<DataT>> & ExtraProps\n> {\n  static layerName = 'PolygonLayer';\n  static defaultProps = defaultProps;\n\n  initializeState(): void {\n    this.state = {\n      paths: []\n    };\n\n    if (this.props.getLineDashArray) {\n      log.removed('getLineDashArray', 'PathStyleExtension')();\n    }\n  }\n\n  updateState({changeFlags}: UpdateParameters<this>) {\n    const geometryChanged =\n      changeFlags.dataChanged ||\n      (changeFlags.updateTriggersChanged &&\n        (changeFlags.updateTriggersChanged.all || changeFlags.updateTriggersChanged.getPolygon));\n\n    if (geometryChanged && Array.isArray(changeFlags.dataChanged)) {\n      const paths = this.state.paths.slice();\n      const pathsDiff = changeFlags.dataChanged.map(dataRange =>\n        replaceInRange({\n          data: paths,\n          getIndex: p => p.__source.index,\n          dataRange,\n          replace: this._getPaths(dataRange)\n        })\n      );\n      this.setState({paths, pathsDiff});\n    } else if (geometryChanged) {\n      this.setState({\n        paths: this._getPaths(),\n        pathsDiff: null\n      });\n    }\n  }\n\n  private _getPaths(dataRange: {startRow?: number; endRow?: number} = {}): {path: number[]}[] {\n    const {data, getPolygon, positionFormat, _normalize} = this.props;\n    const paths: {path: number[]}[] = [];\n    const positionSize = positionFormat === 'XY' ? 2 : 3;\n    const {startRow, endRow} = dataRange;\n\n    const {iterable, objectInfo} = createIterable(data, startRow, endRow);\n    for (const object of iterable) {\n      objectInfo.index++;\n      let polygon = getPolygon(object, objectInfo);\n      if (_normalize) {\n        polygon = Polygon.normalize(polygon, positionSize);\n      }\n      const {holeIndices} = polygon;\n      const positions = polygon.positions || polygon;\n\n      if (holeIndices) {\n        // split the positions array into `holeIndices.length + 1` rings\n        // holeIndices[-1] falls back to 0\n        // holeIndices[holeIndices.length] falls back to positions.length\n        for (let i = 0; i <= holeIndices.length; i++) {\n          const path = positions.slice(holeIndices[i - 1] || 0, holeIndices[i] || positions.length);\n          paths.push(this.getSubLayerRow({path}, object, objectInfo.index));\n        }\n      } else {\n        paths.push(this.getSubLayerRow({path: positions}, object, objectInfo.index));\n      }\n    }\n    return paths;\n  }\n\n  /* eslint-disable complexity */\n  renderLayers(): Layer | null | LayersList {\n    // Layer composition props\n    const {\n      data,\n      _dataDiff,\n      stroked,\n      filled,\n      extruded,\n      wireframe,\n      _normalize,\n      _windingOrder,\n      elevationScale,\n      transitions,\n      positionFormat\n    } = this.props;\n\n    // Rendering props underlying layer\n    const {\n      lineWidthUnits,\n      lineWidthScale,\n      lineWidthMinPixels,\n      lineWidthMaxPixels,\n      lineJointRounded,\n      lineMiterLimit,\n      lineDashJustified\n    } = this.props;\n\n    // Accessor props for underlying layers\n    const {\n      getFillColor,\n      getLineColor,\n      getLineWidth,\n      getLineDashArray,\n      getElevation,\n      getPolygon,\n      updateTriggers,\n      material\n    } = this.props;\n\n    const {paths, pathsDiff} = this.state;\n\n    const FillLayer = this.getSubLayerClass('fill', SolidPolygonLayer);\n    const StrokeLayer = this.getSubLayerClass('stroke', PathLayer);\n\n    // Filled Polygon Layer\n    const polygonLayer =\n      this.shouldRenderSubLayer('fill', paths) &&\n      new FillLayer(\n        {\n          _dataDiff,\n          extruded,\n          elevationScale,\n\n          filled,\n          wireframe,\n          _normalize,\n          _windingOrder,\n\n          getElevation,\n          getFillColor,\n          getLineColor: extruded && wireframe ? getLineColor : defaultLineColor,\n\n          material,\n          transitions\n        },\n        this.getSubLayerProps({\n          id: 'fill',\n          updateTriggers: updateTriggers && {\n            getPolygon: updateTriggers.getPolygon,\n            getElevation: updateTriggers.getElevation,\n            getFillColor: updateTriggers.getFillColor,\n            // using a legacy API to invalid lineColor attributes\n            // if (extruded && wireframe) has changed\n            lineColors: extruded && wireframe,\n            getLineColor: updateTriggers.getLineColor\n          }\n        }),\n        {\n          data,\n          positionFormat,\n          getPolygon\n        }\n      );\n\n    // Polygon line layer\n    const polygonLineLayer =\n      !extruded &&\n      stroked &&\n      this.shouldRenderSubLayer('stroke', paths) &&\n      new StrokeLayer(\n        {\n          _dataDiff: pathsDiff && (() => pathsDiff),\n          widthUnits: lineWidthUnits,\n          widthScale: lineWidthScale,\n          widthMinPixels: lineWidthMinPixels,\n          widthMaxPixels: lineWidthMaxPixels,\n          jointRounded: lineJointRounded,\n          miterLimit: lineMiterLimit,\n          dashJustified: lineDashJustified,\n\n          // Already normalized\n          _pathType: 'loop',\n\n          transitions: transitions && {\n            getWidth: transitions.getLineWidth,\n            getColor: transitions.getLineColor,\n            getPath: transitions.getPolygon\n          },\n\n          getColor: this.getSubLayerAccessor(getLineColor),\n          getWidth: this.getSubLayerAccessor(getLineWidth),\n          getDashArray: this.getSubLayerAccessor(getLineDashArray)\n        },\n        this.getSubLayerProps({\n          id: 'stroke',\n          updateTriggers: updateTriggers && {\n            getWidth: updateTriggers.getLineWidth,\n            getColor: updateTriggers.getLineColor,\n            getDashArray: updateTriggers.getLineDashArray\n          }\n        }),\n        {\n          data: paths,\n          positionFormat,\n          getPath: x => x.path\n        }\n      );\n\n    return [\n      // If not extruded: flat fill layer is drawn below outlines\n      !extruded && polygonLayer,\n      polygonLineLayer,\n      // If extruded: draw fill layer last for correct blending behavior\n      extruded && polygonLayer\n    ];\n  }\n  /* eslint-enable complexity */\n}\n","// Assume data array is sorted by <accessor>\n// Replaces the specified range with a new subarray\n// Mutates the data array\n// Returns {startRow, endRow} of the inserted items\nexport function replaceInRange({\n  data,\n  getIndex,\n  dataRange,\n  replace\n}: {\n  data: any[];\n  getIndex: (d: any) => number;\n  dataRange: {startRow?: number; endRow?: number};\n  replace: any[];\n}): {startRow: Number; endRow: number} {\n  const {startRow = 0, endRow = Infinity} = dataRange;\n  const count = data.length;\n  let replaceStart = count;\n  let replaceEnd = count;\n  for (let i = 0; i < count; i++) {\n    const row = getIndex(data[i]);\n    if (replaceStart > i && row >= startRow) {\n      replaceStart = i;\n    }\n    if (row >= endRow) {\n      replaceEnd = i;\n      break;\n    }\n  }\n  let index = replaceStart;\n  const dataLengthChanged = replaceEnd - replaceStart !== replace.length;\n  // Save the items after replaceEnd before we overwrite data\n  const endChunk = dataLengthChanged ? data.slice(replaceEnd) : undefined;\n  // Insert new items\n  for (let i = 0; i < replace.length; i++) {\n    data[index++] = replace[i];\n  }\n  if (endChunk) {\n    // Append items after replaceEnd\n    for (let i = 0; i < endChunk.length; i++) {\n      data[index++] = endChunk[i];\n    }\n    // Trim additional items\n    data.length = index;\n  }\n\n  return {\n    startRow: replaceStart,\n    endRow: replaceStart + replace.length\n  };\n}\n"],"names":["CompositeLayer","Layer","isComposite","isLoaded","super","this","getSubLayers","every","layer","internalState","subLayers","initializeState","context","setState","updateObject","setNeedsUpdate","getPickingInfo","info","object","__source","parent","id","index","filterSubLayer","shouldRenderSubLayer","subLayerId","data","length","getSubLayerClass","DefaultLayerClass","_subLayerProps","overridingProps","props","type","getSubLayerRow","row","sourceObject","sourceObjectIndex","getSubLayerAccessor","accessor","objectInfo","target","x","i","getSubLayerProps","sublayerProps","opacity","pickable","visible","parameters","getPolygonOffset","highlightedObjectIndex","autoHighlight","highlightColor","coordinateSystem","coordinateOrigin","wrapLongitude","positionFormat","modelMatrix","extensions","fetch","operation","newProps","updateTriggers","overridingSublayerProps","overridingSublayerTriggers","sublayerId","propTypes","PROP_TYPES_SYMBOL","subLayerPropTypes","_propTypes","key","propType","Object","assign","all","_this$props$updateTri","extension","passThroughProps","call","_updateAutoHighlight","updateAutoHighlight","_getAttributeManager","_postUpdate","updateParams","forceUpdate","shouldUpdate","needsUpdate","subLayersList","renderLayers","flatten","Boolean","debug","INITIAL_MODULE_OPTIONS","lightSources","convertColor","color","intensity","map","component","lights","name","vs","lightingShader","fs","getUniforms","opts","ambientLight","pointLights","directionalLights","lightSourceUniforms","forEach","pointLight","position","attenuation","lighting_uPointLightCount","directionalLight","direction","lighting_uDirectionalLightCount","getLightSourceUniforms","lighting_uEnabled","light","push","defines","MAX_LIGHTS","material","ambient","diffuse","shininess","specularColor","lighting_uAmbient","lighting_uDiffuse","lighting_uShininess","lighting_uSpecularColor","getMaterialUniforms","gouraudLighting","dependencies","LIGHTING_VERTEX","WINDING","modifyPolygonWindingDirection","points","options","windingDirection","Math","sign","start","end","dim","size","area","j","getPolygonSignedArea","getPolygonWindingDirection","numPoints","numSwaps","floor","b1","b2","tmp","reversePolygon","intersect","a","b","edge","bbox","t","snap","out","bitCode","p","code","source","startIndex","isDuplicate","copy","getPointAtIndex","positions","offset","startI","cutPolylineByGrid","broken","gridResolution","gridOffset","endIndex","part","result","codeB","cell","getGridCell","scratchPoint","codeAlt","moveToNeighborCell","TYPE_INSIDE","TYPE_BORDER","concatInPlace","arr1","arr2","cutPolygonByGrid","holeIndices","edgeTypes","queue","pos","types","Array","fill","holes","shift","getBoundingBox","parts","bisectPolygon","polygonLow","polygonHigh","polygon","resultLow","resultHigh","typesLow","typesHigh","side","prev","prevSide","prevType","lowPointCount","highPointCount","left","bottom","minX","Infinity","maxX","minY","maxY","y","DEFAULT_MAX_LATITUDE","findSplitIndex","maxLat","pointIndex","lat","abs","insertPoleVertices","maxLatitude","firstLng","lastLng","round","wrapLongitudesForShortestPath","lng","prevLng","delta","shiftLongitudesIntoRange","refLng","pointCount","OUTER_POLYGON_WINDING","HOLE_POLYGON_WINDING","windingOptions","isClosed","getPositions","getHoleIndices","copyNestedRing","targetStartIndex","simplePolygon","targetIndex","len","p0","p1","isNestedRingClosed","copyFlatRing","srcStartIndex","srcEndIndex","srcLength","isFlatRingClosed","normalize","positionSize","isArray","ArrayBuffer","isView","Error","validate","srcPositions","srcHoleIndices","pop","isNested","Number","isFinite","isSimple","polygonIndex","entries","getPlaneArea","xIndex","yIndex","numVerts","permutePositions","zIndex","o","z","Tesselator","constructor","_defineProperty","attributes","typedArrayManager","defaultTypedArrayManager","_attributeDefs","updateGeometry","buffers","getGeometry","geometryBuffer","dataChanged","assert","startIndices","getGeometryFromBuffer","dataRange","_rebuildGeometry","updatePartialGeometry","startRow","endRow","value","getAccessorFromBuffer","stride","_allocate","instanceCount","release","def","allocate","_forEachGeometry","visitor","iterable","createIterable","indexStarts","vertexStarts","normalizedData","geometry","dataIndex","normalizedGeometry","normalizeGeometry","getGeometrySize","Buffer","byteStride","byteLength","buffer","bufferValue","elementStride","BYTES_PER_ELEMENT","vertexStart","indexStart","vertexEnd","geometrySize","geometryIndex","updateGeometryAttributes","vertexCount","PolygonTesselator","fp64","IndexType","Uint32Array","Float64Array","Float32Array","vertexValid","Uint8ClampedArray","indices","get","attributeName","subarray","externalIndices","normalizedPolygon","Polygon","resolution","newPositions","newHoleIndices","ringIndex","splitIndex","cutPolygonByMercatorBounds","isCut","subPolygon","_updateIndices","_updatePositions","_updateVertexValid","preproject","full3d","positionIndex","is3d","n","slice","xy","xyArea","xzArea","yzArea","earcut","polygonPositions","set","main","DEFAULT_COLOR","defaultProps","filled","extruded","wireframe","_normalize","_windingOrder","_full3d","elevationScale","min","getPolygon","f","getElevation","getFillColor","getLineColor","ATTRIBUTE_TRANSITION","enter","chunk","SolidPolygonLayer","getShaders","vsTop","vsSide","RING_WINDING_ORDER_CW","modules","project32","picking","gl","viewport","isGeospatial","COORDINATE_SYSTEM","projectPosition","bind","projectFlat","numInstances","polygonTesselator","use64bitPositions","hasFeatures","FEATURES","Uint16Array","attributeManager","getAttributeManager","noAlloc","remove","add","isIndexed","update","calculateIndices","transition","calculatePositions","shaderAttributes","vertexOffset","divisor","instancePositions","nextPositions","calculateVertexValid","elevations","instanceElevations","fillColors","colorFormat","normalized","defaultValue","instanceFillColors","lineColors","instanceLineColors","pickingColors","encodePickingColor","instancePickingColors","params","find","d","disablePickingIndex","objectIndex","_disablePickingIndex","draw","uniforms","topModel","sideModel","state","renderUniforms","setInstanceCount","setUniforms","setDrawMode","isWireframe","setVertexCount","updateState","oldProps","changeFlags","extensionsChanged","models","model","delete","_getModels","invalidateAll","updateTriggersChanged","shaders","NON_INSTANCED_MODEL","Model","drawMode","vertexPositions","isSideVertex","Geometry","isInstanced","userData","excludeAttributes","filter","attribute","normalizePath","path","flatPath","cutPolylineByMercatorBounds","PathTesselator","padding","initialize","segmentTypes","subPath","getPathLength","_updateSegmentTypes","isPathClosed","ptIndex","getPointOnPath","loop","lastPointIndex","widthUnits","widthScale","widthMinPixels","widthMaxPixels","MAX_SAFE_INTEGER","jointRounded","capRounded","miterLimit","billboard","_pathType","getPath","getColor","getWidth","rounded","deprecatedFor","PathLayer","addInstanced","instanceLeftPositions","instanceStartPositions","instanceEndPositions","instanceRightPositions","instanceTypes","calculateSegmentTypes","instanceStrokeWidths","instanceColors","pathTesselator","_getModel","jointType","capType","UNIT","defaultLineColor","stroked","lineWidthUnits","lineWidthScale","lineWidthMinPixels","lineWidthMaxPixels","lineJointRounded","lineMiterLimit","getLineWidth","PolygonLayer","paths","getLineDashArray","log","geometryChanged","pathsDiff","getIndex","replace","count","replaceStart","replaceEnd","endChunk","undefined","replaceInRange","_getPaths","_dataDiff","transitions","lineDashJustified","FillLayer","StrokeLayer","polygonLayer","dashJustified","getDashArray"],"sourceRoot":""}